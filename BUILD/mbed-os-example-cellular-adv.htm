<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html><head>
<title>Static Call Graph - [.\BUILD\mbed-os-example-cellular-adv.axf]</title></head>
<body><HR>
<H1>Static Call Graph for image .\BUILD\mbed-os-example-cellular-adv.axf</H1><HR>
<BR><P>#&#060CALLGRAPH&#062# ARM Linker, 5060750: Last Updated: Tue May 15 11:46:58 2018
<BR><P>
<H3>Maximum Stack Usage =       2112 bytes + Unknown(Cycles, Untraceable Function Pointers)</H3><H3>
Call chain for Maximum Stack Depth:</H3>
mbed::CellularConnectionFSM::event() &rArr; mbed::CellularConnectionFSM::device_ready()
<P>
<H3>
Mutually Recursive functions
</H3> <LI><a href="#[30c]">core_util_critical_section_enter</a>&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;&nbsp;<a href="#[33a]">mbed_assert_internal</a><BR>
 <LI><a href="#[4b2]">exit</a>&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;&nbsp;<a href="#[4b3]">mbed_die</a><BR>
 <LI><a href="#[2fb]">__cxa_guard_release</a>&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;&nbsp;<a href="#[33a]">mbed_assert_internal</a><BR>
 <LI><a href="#[2f8]">__cxa_guard_acquire</a>&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;&nbsp;<a href="#[33a]">mbed_assert_internal</a><BR>
 <LI><a href="#[64a]">serial_leuart_baud</a>&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;&nbsp;<a href="#[33a]">mbed_assert_internal</a><BR>
 <LI><a href="#[64e]">serial_enable_pins</a>&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;&nbsp;<a href="#[4cb]">pin_mode</a><BR>
 <LI><a href="#[62b]">pinmap_peripheral</a>&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;&nbsp;<a href="#[3e6]">error</a><BR>
 <LI><a href="#[628]">pin_location</a>&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;&nbsp;<a href="#[3e6]">error</a><BR>
 <LI><a href="#[654]">serial_preinit</a>&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;&nbsp;<a href="#[33a]">mbed_assert_internal</a><BR>
 <LI><a href="#[62a]">pinmap_merge</a>&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;&nbsp;<a href="#[3e6]">error</a><BR>
 <LI><a href="#[442]">osRtxErrorNotify</a>&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;&nbsp;<a href="#[3e6]">error</a><BR>
 <LI><a href="#[477]">hal_critical_section_exit</a>&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;&nbsp;<a href="#[33a]">mbed_assert_internal</a><BR>
 <LI><a href="#[4ef]">initialize</a>&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;&nbsp;<a href="#[33a]">mbed_assert_internal</a><BR>
 <LI><a href="#[336]">gpio_init_out</a>&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;&nbsp;<a href="#[4ca]">gpio_init_out_ex</a><BR>
 <LI><a href="#[11]">NMI_Handler</a>&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;&nbsp;<a href="#[11]">NMI_Handler</a><BR>
 <LI><a href="#[17]">DebugMon_Handler</a>&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;&nbsp;<a href="#[17]">DebugMon_Handler</a><BR>
 <LI><a href="#[20]">ACMP0_IRQHandler</a>&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;&nbsp;<a href="#[20]">ACMP0_IRQHandler</a><BR>
 <LI><a href="#[46c]">ppp_slprintf</a>&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;&nbsp;<a href="#[632]">ppp_vslprintf</a><BR>
 <LI><a href="#[550]">netconn_drain</a>&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;&nbsp;<a href="#[550]">netconn_drain</a><BR>
 <LI><a href="#[20f]">__asm___13_rtx_mempool_c_7914b4c7__atomic_link_put</a>&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;&nbsp;<a href="#[20f]">__asm___13_rtx_mempool_c_7914b4c7__atomic_link_put</a><BR>
</UL>
<P>
<H3>
Function Pointers
</H3><UL>
 <LI><a href="#[51]">&lang;Func4&rang;</a> from .\build\serialbase.o(i.<Func4>) referenced from .\build\serialbase.o(i._ZN4mbed10SerialBaseC1E7PinNameS1_i)
 <LI><a href="#[20]">ACMP0_IRQHandler</a> from .\build\startup_efm32wg.o(.text) referenced from .\build\startup_efm32wg.o(RESET)
 <LI><a href="#[21]">ADC0_IRQHandler</a> from .\build\startup_efm32wg.o(.text) referenced from .\build\startup_efm32wg.o(RESET)
 <LI><a href="#[3e]">AES_IRQHandler</a> from .\build\startup_efm32wg.o(.text) referenced from .\build\startup_efm32wg.o(RESET)
 <LI><a href="#[39]">BURTC_IRQHandler</a> from .\build\startup_efm32wg.o(.text) referenced from .\build\startup_efm32wg.o(RESET)
 <LI><a href="#[14]">BusFault_Handler</a> from .\build\except.o(.text) referenced from .\build\startup_efm32wg.o(RESET)
 <LI><a href="#[3a]">CMU_IRQHandler</a> from .\build\startup_efm32wg.o(.text) referenced from .\build\startup_efm32wg.o(RESET)
 <LI><a href="#[22]">DAC0_IRQHandler</a> from .\build\startup_efm32wg.o(.text) referenced from .\build\startup_efm32wg.o(RESET)
 <LI><a href="#[1a]">DMA_IRQHandler</a> from .\build\em_dma.o(i.DMA_IRQHandler) referenced from .\build\startup_efm32wg.o(RESET)
 <LI><a href="#[17]">DebugMon_Handler</a> from .\build\startup_efm32wg.o(.text) referenced from .\build\startup_efm32wg.o(RESET)
 <LI><a href="#[3f]">EBI_IRQHandler</a> from .\build\startup_efm32wg.o(.text) referenced from .\build\startup_efm32wg.o(RESET)
 <LI><a href="#[40]">EMU_IRQHandler</a> from .\build\startup_efm32wg.o(.text) referenced from .\build\startup_efm32wg.o(RESET)
 <LI><a href="#[41]">FPUEH_IRQHandler</a> from .\build\startup_efm32wg.o(.text) referenced from .\build\startup_efm32wg.o(RESET)
 <LI><a href="#[1b]">GPIO_EVEN_IRQHandler</a> from .\build\gpio_irq_api.o(i.GPIO_EVEN_IRQHandler) referenced from .\build\startup_efm32wg.o(RESET)
 <LI><a href="#[25]">GPIO_ODD_IRQHandler</a> from .\build\gpio_irq_api.o(i.GPIO_ODD_IRQHandler) referenced from .\build\startup_efm32wg.o(RESET)
 <LI><a href="#[12]">HardFault_Handler</a> from .\build\except.o(.text) referenced from .\build\startup_efm32wg.o(RESET)
 <LI><a href="#[23]">I2C0_IRQHandler</a> from .\build\startup_efm32wg.o(.text) referenced from .\build\startup_efm32wg.o(RESET)
 <LI><a href="#[24]">I2C1_IRQHandler</a> from .\build\startup_efm32wg.o(.text) referenced from .\build\startup_efm32wg.o(RESET)
 <LI><a href="#[3c]">LCD_IRQHandler</a> from .\build\startup_efm32wg.o(.text) referenced from .\build\startup_efm32wg.o(RESET)
 <LI><a href="#[2b]">LESENSE_IRQHandler</a> from .\build\startup_efm32wg.o(.text) referenced from .\build\startup_efm32wg.o(RESET)
 <LI><a href="#[34]">LETIMER0_IRQHandler</a> from .\build\startup_efm32wg.o(.text) referenced from .\build\startup_efm32wg.o(RESET)
 <LI><a href="#[32]">LEUART0_IRQHandler</a> from .\build\startup_efm32wg.o(.text) referenced from .\build\startup_efm32wg.o(RESET)
 <LI><a href="#[33]">LEUART1_IRQHandler</a> from .\build\startup_efm32wg.o(.text) referenced from .\build\startup_efm32wg.o(RESET)
 <LI><a href="#[4e]">LcpEchoTimeout</a> from .\build\lwip_lcp.o(i.LcpEchoTimeout) referenced from .\build\lwip_lcp.o(i.LcpEchoCheck)
 <LI><a href="#[4e]">LcpEchoTimeout</a> from .\build\lwip_lcp.o(i.LcpEchoTimeout) referenced from .\build\lwip_lcp.o(i.lcp_echo_lowerdown)
 <LI><a href="#[3d]">MSC_IRQHandler</a> from .\build\startup_efm32wg.o(.text) referenced from .\build\startup_efm32wg.o(RESET)
 <LI><a href="#[13]">MemManage_Handler</a> from .\build\except.o(.text) referenced from .\build\startup_efm32wg.o(RESET)
 <LI><a href="#[11]">NMI_Handler</a> from .\build\startup_efm32wg.o(.text) referenced from .\build\startup_efm32wg.o(RESET)
 <LI><a href="#[35]">PCNT0_IRQHandler</a> from .\build\startup_efm32wg.o(.text) referenced from .\build\startup_efm32wg.o(RESET)
 <LI><a href="#[36]">PCNT1_IRQHandler</a> from .\build\startup_efm32wg.o(.text) referenced from .\build\startup_efm32wg.o(RESET)
 <LI><a href="#[37]">PCNT2_IRQHandler</a> from .\build\startup_efm32wg.o(.text) referenced from .\build\startup_efm32wg.o(RESET)
 <LI><a href="#[18]">PendSV_Handler</a> from .\build\irq_cm4f.o(.text) referenced from .\build\startup_efm32wg.o(RESET)
 <LI><a href="#[38]">RTC_IRQHandler</a> from .\build\rtc_api.o(i.RTC_IRQHandler) referenced from .\build\startup_efm32wg.o(RESET)
 <LI><a href="#[38]">RTC_IRQHandler</a> from .\build\rtc_api.o(i.RTC_IRQHandler) referenced from .\build\rtc_api.o(i.rtc_init_real)
 <LI><a href="#[10]">Reset_Handler</a> from .\build\startup_efm32wg.o(.text) referenced from .\build\startup_efm32wg.o(RESET)
 <LI><a href="#[16]">SVC_Handler</a> from .\build\irq_cm4f.o(.text) referenced from .\build\startup_efm32wg.o(RESET)
 <LI><a href="#[19]">SysTick_Handler</a> from .\build\irq_cm4f.o(.text) referenced from .\build\startup_efm32wg.o(RESET)
 <LI><a href="#[19]">SysTick_Handler</a> from .\build\irq_cm4f.o(.text) referenced from .\build\systimer.o(i._ZN4rtos8internal8SysTimer9setup_irqEv)
 <LI><a href="#[19]">SysTick_Handler</a> from .\build\irq_cm4f.o(.text) referenced from .\build\rtx_kernel.o(i.svcRtxKernelStart)
 <LI><a href="#[43]">SystemInit</a> from .\build\system_efm32wg.o(i.SystemInit) referenced from .\build\startup_efm32wg.o(.text)
 <LI><a href="#[1c]">TIMER0_IRQHandler</a> from .\build\startup_efm32wg.o(.text) referenced from .\build\startup_efm32wg.o(RESET)
 <LI><a href="#[26]">TIMER1_IRQHandler</a> from .\build\startup_efm32wg.o(.text) referenced from .\build\startup_efm32wg.o(RESET)
 <LI><a href="#[27]">TIMER2_IRQHandler</a> from .\build\startup_efm32wg.o(.text) referenced from .\build\startup_efm32wg.o(RESET)
 <LI><a href="#[28]">TIMER3_IRQHandler</a> from .\build\startup_efm32wg.o(.text) referenced from .\build\startup_efm32wg.o(RESET)
 <LI><a href="#[2e]">UART0_RX_IRQHandler</a> from .\build\startup_efm32wg.o(.text) referenced from .\build\startup_efm32wg.o(RESET)
 <LI><a href="#[2f]">UART0_TX_IRQHandler</a> from .\build\startup_efm32wg.o(.text) referenced from .\build\startup_efm32wg.o(RESET)
 <LI><a href="#[30]">UART1_RX_IRQHandler</a> from .\build\startup_efm32wg.o(.text) referenced from .\build\startup_efm32wg.o(RESET)
 <LI><a href="#[31]">UART1_TX_IRQHandler</a> from .\build\startup_efm32wg.o(.text) referenced from .\build\startup_efm32wg.o(RESET)
 <LI><a href="#[1d]">USART0_RX_IRQHandler</a> from .\build\startup_efm32wg.o(.text) referenced from .\build\startup_efm32wg.o(RESET)
 <LI><a href="#[1e]">USART0_TX_IRQHandler</a> from .\build\startup_efm32wg.o(.text) referenced from .\build\startup_efm32wg.o(RESET)
 <LI><a href="#[29]">USART1_RX_IRQHandler</a> from .\build\startup_efm32wg.o(.text) referenced from .\build\startup_efm32wg.o(RESET)
 <LI><a href="#[2a]">USART1_TX_IRQHandler</a> from .\build\startup_efm32wg.o(.text) referenced from .\build\startup_efm32wg.o(RESET)
 <LI><a href="#[2c]">USART2_RX_IRQHandler</a> from .\build\startup_efm32wg.o(.text) referenced from .\build\startup_efm32wg.o(RESET)
 <LI><a href="#[2d]">USART2_TX_IRQHandler</a> from .\build\startup_efm32wg.o(.text) referenced from .\build\startup_efm32wg.o(RESET)
 <LI><a href="#[1f]">USB_IRQHandler</a> from .\build\startup_efm32wg.o(.text) referenced from .\build\startup_efm32wg.o(RESET)
 <LI><a href="#[15]">UsageFault_Handler</a> from .\build\except.o(.text) referenced from .\build\startup_efm32wg.o(RESET)
 <LI><a href="#[3b]">VCMP_IRQHandler</a> from .\build\startup_efm32wg.o(.text) referenced from .\build\startup_efm32wg.o(RESET)
 <LI><a href="#[f]">default_idle_hook()</a> from .\build\mbed_rtx_idle.o(i._Z17default_idle_hookv) referenced 2 times from .\build\mbed_rtx_idle.o(.data)
 <LI><a href="#[50]">equeue_tick_update()</a> from .\build\equeue_mbed.o(i._Z18equeue_tick_updatev) referenced from .\build\equeue_mbed.o(i._Z16equeue_tick_initv)
 <LI><a href="#[70]">dot_event()</a> from .\build\main.o(i._Z9dot_eventv) referenced from .\build\main.o(i.main)
 <LI><a href="#[121]">CellularBase::~CellularBase__sub_object()</a> from .\build\easycellularconnection.o(i._ZN12CellularBaseD2Ev) referenced from .\build\easycellularconnection.o(.constdata__ZTV12CellularBase)
 <LI><a href="#[124]">DirectSerial::read(void*, unsigned)</a> from .\build\mbed_retarget.o(i._ZN12DirectSerial4readEPvj) referenced from .\build\mbed_retarget.o(.constdata__ZTV12DirectSerial)
 <LI><a href="#[126]">DirectSerial::seek(long, int)</a> from .\build\mbed_retarget.o(i._ZN12DirectSerial4seekEli) referenced from .\build\mbed_retarget.o(.constdata__ZTV12DirectSerial)
 <LI><a href="#[129]">DirectSerial::size()</a> from .\build\mbed_retarget.o(i._ZN12DirectSerial4sizeEv) referenced from .\build\mbed_retarget.o(.constdata__ZTV12DirectSerial)
 <LI><a href="#[127]">DirectSerial::close()</a> from .\build\mbed_retarget.o(i._ZN12DirectSerial5closeEv) referenced from .\build\mbed_retarget.o(.constdata__ZTV12DirectSerial)
 <LI><a href="#[125]">DirectSerial::write(const void*, unsigned)</a> from .\build\mbed_retarget.o(i._ZN12DirectSerial5writeEPKvj) referenced from .\build\mbed_retarget.o(.constdata__ZTV12DirectSerial)
 <LI><a href="#[128]">DirectSerial::isatty()</a> from .\build\mbed_retarget.o(i._ZN12DirectSerial6isattyEv) referenced from .\build\mbed_retarget.o(.constdata__ZTV12DirectSerial)
 <LI><a href="#[4f]">DirectSerial::~DirectSerial()</a> from .\build\mbed_retarget.o(i._ZN12DirectSerialD1Ev) referenced from .\build\mbed_retarget.o(.constdata__ZTV12DirectSerial)
 <LI><a href="#[4f]">DirectSerial::~DirectSerial()</a> from .\build\mbed_retarget.o(i._ZN12DirectSerialD1Ev) referenced from .\build\mbed_retarget.o(i._Z15default_consolev)
 <LI><a href="#[12d]">NetworkStack::gethostbyname(const char*, SocketAddress*, nsapi_version)</a> from .\build\networkstack.o(i._ZN12NetworkStack13gethostbynameEPKcP13SocketAddress13nsapi_version) referenced from .\build\networkstack.o(.constdata__ZTV12NetworkStack)
 <LI><a href="#[12d]">NetworkStack::gethostbyname(const char*, SocketAddress*, nsapi_version)</a> from .\build\networkstack.o(i._ZN12NetworkStack13gethostbynameEPKcP13SocketAddress13nsapi_version) referenced from .\build\at_cellularstack.o(.constdata__ZTVN4mbed16AT_CellularStackE)
 <LI><a href="#[12d]">NetworkStack::gethostbyname(const char*, SocketAddress*, nsapi_version)</a> from .\build\networkstack.o(i._ZN12NetworkStack13gethostbynameEPKcP13SocketAddress13nsapi_version) referenced from .\build\quectel_bg96_cellularstack.o(.constdata__ZTVN4mbed26QUECTEL_BG96_CellularStackE)
 <LI><a href="#[123]">NetworkInterface::gethostbyname(const char*, SocketAddress*, nsapi_version)</a> from .\build\networkinterface.o(i._ZN16NetworkInterface13gethostbynameEPKcP13SocketAddress13nsapi_version) referenced from .\build\easycellularconnection.o(.constdata__ZTV12CellularBase)
 <LI><a href="#[123]">NetworkInterface::gethostbyname(const char*, SocketAddress*, nsapi_version)</a> from .\build\networkinterface.o(i._ZN16NetworkInterface13gethostbynameEPKcP13SocketAddress13nsapi_version) referenced from .\build\networkinterface.o(.constdata__ZTV16NetworkInterface)
 <LI><a href="#[123]">NetworkInterface::gethostbyname(const char*, SocketAddress*, nsapi_version)</a> from .\build\networkinterface.o(i._ZN16NetworkInterface13gethostbynameEPKcP13SocketAddress13nsapi_version) referenced from .\build\at_cellularnetwork.o(.constdata__ZTVN4mbed15CellularNetworkE)
 <LI><a href="#[123]">NetworkInterface::gethostbyname(const char*, SocketAddress*, nsapi_version)</a> from .\build\networkinterface.o(i._ZN16NetworkInterface13gethostbynameEPKcP13SocketAddress13nsapi_version) referenced from .\build\at_cellularnetwork.o(.constdata__ZTVN4mbed18AT_CellularNetworkE)
 <LI><a href="#[123]">NetworkInterface::gethostbyname(const char*, SocketAddress*, nsapi_version)</a> from .\build\networkinterface.o(i._ZN16NetworkInterface13gethostbynameEPKcP13SocketAddress13nsapi_version) referenced from .\build\easycellularconnection.o(.constdata__ZTVN4mbed22EasyCellularConnectionE)
 <LI><a href="#[123]">NetworkInterface::gethostbyname(const char*, SocketAddress*, nsapi_version)</a> from .\build\networkinterface.o(i._ZN16NetworkInterface13gethostbynameEPKcP13SocketAddress13nsapi_version) referenced from .\build\quectel_bg96_cellularnetwork.o(.constdata__ZTVN4mbed28QUECTEL_BG96_CellularNetworkE)
 <LI><a href="#[130]">NetworkStackWrapper::socket_open(void**, nsapi_protocol)</a> from .\build\networkstack.o(i._ZN19NetworkStackWrapper11socket_openEPPv14nsapi_protocol) referenced from .\build\networkstack.o(.constdata__ZTV19NetworkStackWrapper)
 <LI><a href="#[134]">NetworkStackWrapper::socket_recv(void*, void*, unsigned)</a> from .\build\networkstack.o(i._ZN19NetworkStackWrapper11socket_recvEPvS0_j) referenced from .\build\networkstack.o(.constdata__ZTV19NetworkStackWrapper)
 <LI><a href="#[133]">NetworkStackWrapper::socket_send(void*, const void*, unsigned)</a> from .\build\networkstack.o(i._ZN19NetworkStackWrapper11socket_sendEPvPKvj) referenced from .\build\networkstack.o(.constdata__ZTV19NetworkStackWrapper)
 <LI><a href="#[131]">NetworkStackWrapper::socket_close(void*)</a> from .\build\networkstack.o(i._ZN19NetworkStackWrapper12socket_closeEPv) referenced from .\build\networkstack.o(.constdata__ZTV19NetworkStackWrapper)
 <LI><a href="#[12f]">NetworkStackWrapper::gethostbyname(const char*, SocketAddress*, nsapi_version)</a> from .\build\networkstack.o(i._ZN19NetworkStackWrapper13gethostbynameEPKcP13SocketAddress13nsapi_version) referenced from .\build\networkstack.o(.constdata__ZTV19NetworkStackWrapper)
 <LI><a href="#[137]">NetworkStackWrapper::socket_attach(void*, void(*)(void*), void*)</a> from .\build\networkstack.o(i._ZN19NetworkStackWrapper13socket_attachEPvPFvS0_ES0_) referenced from .\build\networkstack.o(.constdata__ZTV19NetworkStackWrapper)
 <LI><a href="#[135]">NetworkStackWrapper::socket_sendto(void*, const SocketAddress&, const void*, unsigned)</a> from .\build\networkstack.o(i._ZN19NetworkStackWrapper13socket_sendtoEPvRK13SocketAddressPKvj) referenced from .\build\networkstack.o(.constdata__ZTV19NetworkStackWrapper)
 <LI><a href="#[12e]">NetworkStackWrapper::get_ip_address()</a> from .\build\networkstack.o(i._ZN19NetworkStackWrapper14get_ip_addressEv) referenced from .\build\networkstack.o(.constdata__ZTV19NetworkStackWrapper)
 <LI><a href="#[132]">NetworkStackWrapper::socket_connect(void*, const SocketAddress&)</a> from .\build\networkstack.o(i._ZN19NetworkStackWrapper14socket_connectEPvRK13SocketAddress) referenced from .\build\networkstack.o(.constdata__ZTV19NetworkStackWrapper)
 <LI><a href="#[136]">NetworkStackWrapper::socket_recvfrom(void*, SocketAddress*, void*, unsigned)</a> from .\build\networkstack.o(i._ZN19NetworkStackWrapper15socket_recvfromEPvP13SocketAddressS0_j) referenced from .\build\networkstack.o(.constdata__ZTV19NetworkStackWrapper)
 <LI><a href="#[12a]">mbed::FileHandle::set_blocking(bool)</a> from .\build\file.o(i._ZN4mbed10FileHandle12set_blockingEb) referenced from .\build\mbed_retarget.o(.constdata__ZTV12DirectSerial)
 <LI><a href="#[12a]">mbed::FileHandle::set_blocking(bool)</a> from .\build\file.o(i._ZN4mbed10FileHandle12set_blockingEb) referenced from .\build\filehandle.o(.constdata__ZTVN4mbed10FileHandleE)
 <LI><a href="#[12a]">mbed::FileHandle::set_blocking(bool)</a> from .\build\file.o(i._ZN4mbed10FileHandle12set_blockingEb) referenced from .\build\serial.o(.constdata__ZTVN4mbed6SerialE)
 <LI><a href="#[12a]">mbed::FileHandle::set_blocking(bool)</a> from .\build\file.o(i._ZN4mbed10FileHandle12set_blockingEb) referenced from .\build\stream.o(.constdata__ZTVN4mbed6StreamE)
 <LI><a href="#[12a]">mbed::FileHandle::set_blocking(bool)</a> from .\build\file.o(i._ZN4mbed10FileHandle12set_blockingEb) referenced from .\build\stream.o(.constdata__ZTVN4mbed8FileLikeE)
 <LI><a href="#[141]">mbed::FileHandle::size()</a> from .\build\filehandle.o(i._ZN4mbed10FileHandle4sizeEv) referenced from .\build\filehandle.o(.constdata__ZTVN4mbed10FileHandleE)
 <LI><a href="#[141]">mbed::FileHandle::size()</a> from .\build\filehandle.o(i._ZN4mbed10FileHandle4sizeEv) referenced from .\build\uartserial.o(.constdata__ZTVN4mbed10UARTSerialE)
 <LI><a href="#[141]">mbed::FileHandle::size()</a> from .\build\filehandle.o(i._ZN4mbed10FileHandle4sizeEv) referenced from .\build\stream.o(.constdata__ZTVN4mbed8FileLikeE)
 <LI><a href="#[12c]">mbed::FileHandle::sigio(mbed::Callback&lang;void()&rang;)</a> from .\build\file.o(i._ZN4mbed10FileHandle5sigioENS_8CallbackIFvvEEE) referenced from .\build\mbed_retarget.o(.constdata__ZTV12DirectSerial)
 <LI><a href="#[12c]">mbed::FileHandle::sigio(mbed::Callback&lang;void()&rang;)</a> from .\build\file.o(i._ZN4mbed10FileHandle5sigioENS_8CallbackIFvvEEE) referenced from .\build\filehandle.o(.constdata__ZTVN4mbed10FileHandleE)
 <LI><a href="#[12c]">mbed::FileHandle::sigio(mbed::Callback&lang;void()&rang;)</a> from .\build\file.o(i._ZN4mbed10FileHandle5sigioENS_8CallbackIFvvEEE) referenced from .\build\serial.o(.constdata__ZTVN4mbed6SerialE)
 <LI><a href="#[12c]">mbed::FileHandle::sigio(mbed::Callback&lang;void()&rang;)</a> from .\build\file.o(i._ZN4mbed10FileHandle5sigioENS_8CallbackIFvvEEE) referenced from .\build\stream.o(.constdata__ZTVN4mbed6StreamE)
 <LI><a href="#[12c]">mbed::FileHandle::sigio(mbed::Callback&lang;void()&rang;)</a> from .\build\file.o(i._ZN4mbed10FileHandle5sigioENS_8CallbackIFvvEEE) referenced from .\build\stream.o(.constdata__ZTVN4mbed8FileLikeE)
 <LI><a href="#[140]">mbed::FileHandle::isatty()</a> from .\build\filehandle.o(i._ZN4mbed10FileHandle6isattyEv) referenced from .\build\filehandle.o(.constdata__ZTVN4mbed10FileHandleE)
 <LI><a href="#[140]">mbed::FileHandle::isatty()</a> from .\build\filehandle.o(i._ZN4mbed10FileHandle6isattyEv) referenced from .\build\stream.o(.constdata__ZTVN4mbed8FileLikeE)
 <LI><a href="#[13f]">mbed::FileHandle::~FileHandle__sub_object()</a> from .\build\filehandle.o(i._ZN4mbed10FileHandleD2Ev) referenced from .\build\filehandle.o(.constdata__ZTVN4mbed10FileHandleE)
 <LI><a href="#[52]">mbed::SerialBase::_irq_handler(unsigned, SerialIrq)</a> from .\build\serialbase.o(i._ZN4mbed10SerialBase12_irq_handlerEj9SerialIrq) referenced from .\build\serialbase.o(i._ZN4mbed10SerialBaseC1E7PinNameS1_i)
 <LI><a href="#[11d]">mbed::SerialBase::interrupt_handler_asynch()</a> from .\build\serialbase.o(i._ZN4mbed10SerialBase24interrupt_handler_asynchEv) referenced from .\build\serialbase.o(.constdata)
 <LI><a href="#[143]">mbed::SerialBase::lock()</a> from .\build\serialbase.o(i._ZN4mbed10SerialBase4lockEv) referenced from .\build\serialbase.o(.constdata__ZTVN4mbed10SerialBaseE)
 <LI><a href="#[144]">mbed::SerialBase::unlock()</a> from .\build\serialbase.o(i._ZN4mbed10SerialBase6unlockEv) referenced from .\build\serialbase.o(.constdata__ZTVN4mbed10SerialBaseE)
 <LI><a href="#[145]">mbed::SerialBase::~SerialBase()</a> from .\build\serialbase.o(i._ZN4mbed10SerialBaseD1Ev) referenced from .\build\serialbase.o(.constdata__ZTVN4mbed10SerialBaseE)
 <LI><a href="#[54]">mbed::TimerEvent::irq(unsigned)</a> from .\build\timerevent.o(i._ZN4mbed10TimerEvent3irqEj) referenced from .\build\timerevent.o(i._ZN4mbed10TimerEventC2EPK13ticker_data_t)
 <LI><a href="#[54]">mbed::TimerEvent::irq(unsigned)</a> from .\build\timerevent.o(i._ZN4mbed10TimerEvent3irqEj) referenced from .\build\timerevent.o(i._ZN4mbed10TimerEventC2Ev)
 <LI><a href="#[146]">mbed::TimerEvent::~TimerEvent__sub_object()</a> from .\build\timerevent.o(i._ZN4mbed10TimerEventD2Ev) referenced from .\build\timerevent.o(.constdata__ZTVN4mbed10TimerEventE)
 <LI><a href="#[153]">mbed::UARTSerial::api_unlock()</a> from .\build\uartserial.o(i._ZN4mbed10UARTSerial10api_unlockEv) referenced from .\build\uartserial.o(.constdata__ZTVN4mbed10UARTSerialE)
 <LI><a href="#[150]">mbed::UARTSerial::set_blocking(bool)</a> from .\build\uartserial.o(i._ZN4mbed10UARTSerial12set_blockingEb) referenced from .\build\uartserial.o(.constdata__ZTVN4mbed10UARTSerialE)
 <LI><a href="#[147]">mbed::UARTSerial::lock()</a> from .\build\uartserial.o(i._ZN4mbed10UARTSerial4lockEv) referenced from .\build\uartserial.o(.constdata__ZTVN4mbed10UARTSerialE)
 <LI><a href="#[14c]">mbed::UARTSerial::read(void*, unsigned)</a> from .\build\uartserial.o(i._ZN4mbed10UARTSerial4readEPvj) referenced from .\build\uartserial.o(.constdata__ZTVN4mbed10UARTSerialE)
 <LI><a href="#[14f]">mbed::UARTSerial::seek(long, int)</a> from .\build\uartserial.o(i._ZN4mbed10UARTSerial4seekEli) referenced from .\build\uartserial.o(.constdata__ZTVN4mbed10UARTSerialE)
 <LI><a href="#[14d]">mbed::UARTSerial::close()</a> from .\build\uartserial.o(i._ZN4mbed10UARTSerial5closeEv) referenced from .\build\uartserial.o(.constdata__ZTVN4mbed10UARTSerialE)
 <LI><a href="#[151]">mbed::UARTSerial::sigio(mbed::Callback&lang;void()&rang;)</a> from .\build\uartserial.o(i._ZN4mbed10UARTSerial5sigioENS_8CallbackIFvvEEE) referenced from .\build\uartserial.o(.constdata__ZTVN4mbed10UARTSerialE)
 <LI><a href="#[14b]">mbed::UARTSerial::write(const void*, unsigned)</a> from .\build\uartserial.o(i._ZN4mbed10UARTSerial5writeEPKvj) referenced from .\build\uartserial.o(.constdata__ZTVN4mbed10UARTSerialE)
 <LI><a href="#[14e]">mbed::UARTSerial::isatty()</a> from .\build\uartserial.o(i._ZN4mbed10UARTSerial6isattyEv) referenced from .\build\uartserial.o(.constdata__ZTVN4mbed10UARTSerialE)
 <LI><a href="#[120]">mbed::UARTSerial::rx_irq()</a> from .\build\uartserial.o(i._ZN4mbed10UARTSerial6rx_irqEv) referenced from .\build\uartserial.o(.constdata)
 <LI><a href="#[11f]">mbed::UARTSerial::tx_irq()</a> from .\build\uartserial.o(i._ZN4mbed10UARTSerial6tx_irqEv) referenced from .\build\uartserial.o(.constdata)
 <LI><a href="#[148]">mbed::UARTSerial::unlock()</a> from .\build\uartserial.o(i._ZN4mbed10UARTSerial6unlockEv) referenced from .\build\uartserial.o(.constdata__ZTVN4mbed10UARTSerialE)
 <LI><a href="#[11e]">mbed::UARTSerial::dcd_irq()</a> from .\build\uartserial.o(i._ZN4mbed10UARTSerial7dcd_irqEv) referenced from .\build\uartserial.o(.constdata)
 <LI><a href="#[152]">mbed::UARTSerial::api_lock()</a> from .\build\uartserial.o(i._ZN4mbed10UARTSerial8api_lockEv) referenced from .\build\uartserial.o(.constdata__ZTVN4mbed10UARTSerialE)
 <LI><a href="#[149]">mbed::UARTSerial::~UARTSerial()</a> from .\build\uartserial.o(i._ZN4mbed10UARTSerialD1Ev) referenced from .\build\uartserial.o(.constdata__ZTVN4mbed10UARTSerialE)
 <LI><a href="#[a3]">mbed::ppp_output(ppp_pcb_s*, unsigned char*, unsigned, void*)</a> from .\build\ppp_lwip.o(i._ZN4mbed10ppp_outputEP9ppp_pcb_sPhjPv) referenced from .\build\ppp_lwip.o(i.ppp_lwip_if_init)
 <LI><a href="#[5b]">mbed::Transaction&lang;mbed::SPI&rang;::Transaction()</a> from .\build\spi.o(t._ZN4mbed11TransactionINS_3SPIEEC1Ev) referenced from .\build\spi.o(i.__sti___7_SPI_cpp_ab1f1164)
 <LI><a href="#[c0]">mbed::Transaction&lang;mbed::SPI&rang;::~Transaction()</a> from .\build\spi.o(t._ZN4mbed11TransactionINS_3SPIEED1Ev) referenced from .\build\spi.o(t._ZN4mbed14CircularBufferINS_11TransactionINS_3SPIEEELj4EjED1Ev)
 <LI><a href="#[15c]">mbed::QUECTEL_BG96::open_network(mbed::FileHandle*)</a> from .\build\quectel_bg96.o(i._ZN4mbed12QUECTEL_BG9612open_networkEPNS_10FileHandleE) referenced from .\build\quectel_bg96.o(.constdata__ZTVN4mbed12QUECTEL_BG96E)
 <LI><a href="#[166]">mbed::AT_CellularSIM::get_sim_state(mbed::CellularSIM::SimState&)</a> from .\build\at_cellularsim.o(i._ZN4mbed14AT_CellularSIM13get_sim_stateERNS_11CellularSIM8SimStateE) referenced from .\build\at_cellularsim.o(.constdata__ZTVN4mbed14AT_CellularSIME)
 <LI><a href="#[165]">mbed::AT_CellularSIM::set_pin(const char*)</a> from .\build\at_cellularsim.o(i._ZN4mbed14AT_CellularSIM7set_pinEPKc) referenced from .\build\at_cellularsim.o(.constdata__ZTVN4mbed14AT_CellularSIME)
 <LI><a href="#[167]">mbed::AT_CellularSIM::get_imsi(char*)</a> from .\build\at_cellularsim.o(i._ZN4mbed14AT_CellularSIM8get_imsiEPc) referenced from .\build\at_cellularsim.o(.constdata__ZTVN4mbed14AT_CellularSIME)
 <LI><a href="#[5c]">mbed::CircularBuffer&lang;mbed::Transaction&lang;mbed::SPI&rang;, (unsigned)4, unsigned&rang;::~CircularBuffer()</a> from .\build\spi.o(t._ZN4mbed14CircularBufferINS_11TransactionINS_3SPIEEELj4EjED1Ev) referenced from .\build\spi.o(i.__sti___7_SPI_cpp_ab1f1164)
 <LI><a href="#[168]">mbed::CellularNetwork::~CellularNetwork__sub_object()</a> from .\build\at_cellularnetwork.o(i._ZN4mbed15CellularNetworkD2Ev) referenced from .\build\at_cellularnetwork.o(.constdata__ZTVN4mbed15CellularNetworkE)
 <LI><a href="#[a2]">mbed::ppp_link_status(ppp_pcb_s*, int, void*)</a> from .\build\ppp_lwip.o(i._ZN4mbed15ppp_link_statusEP9ppp_pcb_siPv) referenced from .\build\ppp_lwip.o(i.ppp_lwip_if_init)
 <LI><a href="#[16d]">mbed::AT_CellularPower::set_at_mode()</a> from .\build\at_cellularpower.o(i._ZN4mbed16AT_CellularPower11set_at_modeEv) referenced from .\build\at_cellularpower.o(.constdata__ZTVN4mbed16AT_CellularPowerE)
 <LI><a href="#[16b]">mbed::AT_CellularPower::on()</a> from .\build\at_cellularpower.o(i._ZN4mbed16AT_CellularPower2onEv) referenced from .\build\at_cellularpower.o(.constdata__ZTVN4mbed16AT_CellularPowerE)
 <LI><a href="#[16c]">mbed::AT_CellularPower::off()</a> from .\build\at_cellularpower.o(i._ZN4mbed16AT_CellularPower3offEv) referenced from .\build\at_cellularpower.o(.constdata__ZTVN4mbed16AT_CellularPowerE)
 <LI><a href="#[16a]">mbed::AT_CellularPower::~AT_CellularPower__deallocating()</a> from .\build\at_cellularpower.o(i._ZN4mbed16AT_CellularPowerD0Ev) referenced from .\build\at_cellularpower.o(.constdata__ZTVN4mbed16AT_CellularPowerE)
 <LI><a href="#[169]">mbed::AT_CellularPower::~AT_CellularPower()</a> from .\build\at_cellularpower.o(i._ZN4mbed16AT_CellularPowerD1Ev) referenced from .\build\at_cellularpower.o(.constdata__ZTVN4mbed16AT_CellularPowerE)
 <LI><a href="#[16f]">mbed::AT_CellularStack::socket_open(void**, nsapi_protocol)</a> from .\build\at_cellularstack.o(i._ZN4mbed16AT_CellularStack11socket_openEPPv14nsapi_protocol) referenced from .\build\at_cellularstack.o(.constdata__ZTVN4mbed16AT_CellularStackE)
 <LI><a href="#[16f]">mbed::AT_CellularStack::socket_open(void**, nsapi_protocol)</a> from .\build\at_cellularstack.o(i._ZN4mbed16AT_CellularStack11socket_openEPPv14nsapi_protocol) referenced from .\build\quectel_bg96_cellularstack.o(.constdata__ZTVN4mbed26QUECTEL_BG96_CellularStackE)
 <LI><a href="#[173]">mbed::AT_CellularStack::socket_recv(void*, void*, unsigned)</a> from .\build\at_cellularstack.o(i._ZN4mbed16AT_CellularStack11socket_recvEPvS1_j) referenced from .\build\at_cellularstack.o(.constdata__ZTVN4mbed16AT_CellularStackE)
 <LI><a href="#[173]">mbed::AT_CellularStack::socket_recv(void*, void*, unsigned)</a> from .\build\at_cellularstack.o(i._ZN4mbed16AT_CellularStack11socket_recvEPvS1_j) referenced from .\build\quectel_bg96_cellularstack.o(.constdata__ZTVN4mbed26QUECTEL_BG96_CellularStackE)
 <LI><a href="#[172]">mbed::AT_CellularStack::socket_send(void*, const void*, unsigned)</a> from .\build\at_cellularstack.o(i._ZN4mbed16AT_CellularStack11socket_sendEPvPKvj) referenced from .\build\at_cellularstack.o(.constdata__ZTVN4mbed16AT_CellularStackE)
 <LI><a href="#[172]">mbed::AT_CellularStack::socket_send(void*, const void*, unsigned)</a> from .\build\at_cellularstack.o(i._ZN4mbed16AT_CellularStack11socket_sendEPvPKvj) referenced from .\build\quectel_bg96_cellularstack.o(.constdata__ZTVN4mbed26QUECTEL_BG96_CellularStackE)
 <LI><a href="#[170]">mbed::AT_CellularStack::socket_close(void*)</a> from .\build\at_cellularstack.o(i._ZN4mbed16AT_CellularStack12socket_closeEPv) referenced from .\build\at_cellularstack.o(.constdata__ZTVN4mbed16AT_CellularStackE)
 <LI><a href="#[170]">mbed::AT_CellularStack::socket_close(void*)</a> from .\build\at_cellularstack.o(i._ZN4mbed16AT_CellularStack12socket_closeEPv) referenced from .\build\quectel_bg96_cellularstack.o(.constdata__ZTVN4mbed26QUECTEL_BG96_CellularStackE)
 <LI><a href="#[176]">mbed::AT_CellularStack::socket_attach(void*, void(*)(void*), void*)</a> from .\build\at_cellularstack.o(i._ZN4mbed16AT_CellularStack13socket_attachEPvPFvS1_ES1_) referenced from .\build\at_cellularstack.o(.constdata__ZTVN4mbed16AT_CellularStackE)
 <LI><a href="#[176]">mbed::AT_CellularStack::socket_attach(void*, void(*)(void*), void*)</a> from .\build\at_cellularstack.o(i._ZN4mbed16AT_CellularStack13socket_attachEPvPFvS1_ES1_) referenced from .\build\quectel_bg96_cellularstack.o(.constdata__ZTVN4mbed26QUECTEL_BG96_CellularStackE)
 <LI><a href="#[174]">mbed::AT_CellularStack::socket_sendto(void*, const SocketAddress&, const void*, unsigned)</a> from .\build\at_cellularstack.o(i._ZN4mbed16AT_CellularStack13socket_sendtoEPvRK13SocketAddressPKvj) referenced from .\build\at_cellularstack.o(.constdata__ZTVN4mbed16AT_CellularStackE)
 <LI><a href="#[174]">mbed::AT_CellularStack::socket_sendto(void*, const SocketAddress&, const void*, unsigned)</a> from .\build\at_cellularstack.o(i._ZN4mbed16AT_CellularStack13socket_sendtoEPvRK13SocketAddressPKvj) referenced from .\build\quectel_bg96_cellularstack.o(.constdata__ZTVN4mbed26QUECTEL_BG96_CellularStackE)
 <LI><a href="#[16e]">mbed::AT_CellularStack::get_ip_address()</a> from .\build\at_cellularstack.o(i._ZN4mbed16AT_CellularStack14get_ip_addressEv) referenced from .\build\at_cellularstack.o(.constdata__ZTVN4mbed16AT_CellularStackE)
 <LI><a href="#[16e]">mbed::AT_CellularStack::get_ip_address()</a> from .\build\at_cellularstack.o(i._ZN4mbed16AT_CellularStack14get_ip_addressEv) referenced from .\build\quectel_bg96_cellularstack.o(.constdata__ZTVN4mbed26QUECTEL_BG96_CellularStackE)
 <LI><a href="#[171]">mbed::AT_CellularStack::socket_connect(void*, const SocketAddress&)</a> from .\build\at_cellularstack.o(i._ZN4mbed16AT_CellularStack14socket_connectEPvRK13SocketAddress) referenced from .\build\at_cellularstack.o(.constdata__ZTVN4mbed16AT_CellularStackE)
 <LI><a href="#[171]">mbed::AT_CellularStack::socket_connect(void*, const SocketAddress&)</a> from .\build\at_cellularstack.o(i._ZN4mbed16AT_CellularStack14socket_connectEPvRK13SocketAddress) referenced from .\build\quectel_bg96_cellularstack.o(.constdata__ZTVN4mbed26QUECTEL_BG96_CellularStackE)
 <LI><a href="#[175]">mbed::AT_CellularStack::socket_recvfrom(void*, SocketAddress*, void*, unsigned)</a> from .\build\at_cellularstack.o(i._ZN4mbed16AT_CellularStack15socket_recvfromEPvP13SocketAddressS1_j) referenced from .\build\at_cellularstack.o(.constdata__ZTVN4mbed16AT_CellularStackE)
 <LI><a href="#[175]">mbed::AT_CellularStack::socket_recvfrom(void*, SocketAddress*, void*, unsigned)</a> from .\build\at_cellularstack.o(i._ZN4mbed16AT_CellularStack15socket_recvfromEPvP13SocketAddressS1_j) referenced from .\build\quectel_bg96_cellularstack.o(.constdata__ZTVN4mbed26QUECTEL_BG96_CellularStackE)
 <LI><a href="#[15d]">mbed::AT_CellularDevice::open_power(mbed::FileHandle*)</a> from .\build\at_cellulardevice.o(i._ZN4mbed17AT_CellularDevice10open_powerEPNS_10FileHandleE) referenced from .\build\quectel_bg96.o(.constdata__ZTVN4mbed12QUECTEL_BG96E)
 <LI><a href="#[15d]">mbed::AT_CellularDevice::open_power(mbed::FileHandle*)</a> from .\build\at_cellulardevice.o(i._ZN4mbed17AT_CellularDevice10open_powerEPNS_10FileHandleE) referenced from .\build\at_cellulardevice.o(.constdata__ZTVN4mbed17AT_CellularDeviceE)
 <LI><a href="#[161]">mbed::AT_CellularDevice::close_power()</a> from .\build\at_cellulardevice.o(i._ZN4mbed17AT_CellularDevice11close_powerEv) referenced from .\build\quectel_bg96.o(.constdata__ZTVN4mbed12QUECTEL_BG96E)
 <LI><a href="#[161]">mbed::AT_CellularDevice::close_power()</a> from .\build\at_cellulardevice.o(i._ZN4mbed17AT_CellularDevice11close_powerEv) referenced from .\build\at_cellulardevice.o(.constdata__ZTVN4mbed17AT_CellularDeviceE)
 <LI><a href="#[162]">mbed::AT_CellularDevice::set_timeout(int)</a> from .\build\at_cellulardevice.o(i._ZN4mbed17AT_CellularDevice11set_timeoutEi) referenced from .\build\quectel_bg96.o(.constdata__ZTVN4mbed12QUECTEL_BG96E)
 <LI><a href="#[162]">mbed::AT_CellularDevice::set_timeout(int)</a> from .\build\at_cellulardevice.o(i._ZN4mbed17AT_CellularDevice11set_timeoutEi) referenced from .\build\at_cellulardevice.o(.constdata__ZTVN4mbed17AT_CellularDeviceE)
 <LI><a href="#[177]">mbed::AT_CellularDevice::open_network(mbed::FileHandle*)</a> from .\build\at_cellulardevice.o(i._ZN4mbed17AT_CellularDevice12open_networkEPNS_10FileHandleE) referenced from .\build\at_cellulardevice.o(.constdata__ZTVN4mbed17AT_CellularDeviceE)
 <LI><a href="#[160]">mbed::AT_CellularDevice::close_network()</a> from .\build\at_cellulardevice.o(i._ZN4mbed17AT_CellularDevice13close_networkEv) referenced from .\build\quectel_bg96.o(.constdata__ZTVN4mbed12QUECTEL_BG96E)
 <LI><a href="#[160]">mbed::AT_CellularDevice::close_network()</a> from .\build\at_cellulardevice.o(i._ZN4mbed17AT_CellularDevice13close_networkEv) referenced from .\build\at_cellulardevice.o(.constdata__ZTVN4mbed17AT_CellularDeviceE)
 <LI><a href="#[163]">mbed::AT_CellularDevice::modem_debug_on(bool)</a> from .\build\at_cellulardevice.o(i._ZN4mbed17AT_CellularDevice14modem_debug_onEb) referenced from .\build\quectel_bg96.o(.constdata__ZTVN4mbed12QUECTEL_BG96E)
 <LI><a href="#[163]">mbed::AT_CellularDevice::modem_debug_on(bool)</a> from .\build\at_cellulardevice.o(i._ZN4mbed17AT_CellularDevice14modem_debug_onEb) referenced from .\build\at_cellulardevice.o(.constdata__ZTVN4mbed17AT_CellularDeviceE)
 <LI><a href="#[15f]">mbed::AT_CellularDevice::open_information(mbed::FileHandle*)</a> from .\build\at_cellulardevice.o(i._ZN4mbed17AT_CellularDevice16open_informationEPNS_10FileHandleE) referenced from .\build\quectel_bg96.o(.constdata__ZTVN4mbed12QUECTEL_BG96E)
 <LI><a href="#[15f]">mbed::AT_CellularDevice::open_information(mbed::FileHandle*)</a> from .\build\at_cellulardevice.o(i._ZN4mbed17AT_CellularDevice16open_informationEPNS_10FileHandleE) referenced from .\build\at_cellulardevice.o(.constdata__ZTVN4mbed17AT_CellularDeviceE)
 <LI><a href="#[15e]">mbed::AT_CellularDevice::open_sim(mbed::FileHandle*)</a> from .\build\at_cellulardevice.o(i._ZN4mbed17AT_CellularDevice8open_simEPNS_10FileHandleE) referenced from .\build\quectel_bg96.o(.constdata__ZTVN4mbed12QUECTEL_BG96E)
 <LI><a href="#[15e]">mbed::AT_CellularDevice::open_sim(mbed::FileHandle*)</a> from .\build\at_cellulardevice.o(i._ZN4mbed17AT_CellularDevice8open_simEPNS_10FileHandleE) referenced from .\build\at_cellulardevice.o(.constdata__ZTVN4mbed17AT_CellularDeviceE)
 <LI><a href="#[164]">mbed::AT_CellularDevice::get_stack()</a> from .\build\at_cellulardevice.o(i._ZN4mbed17AT_CellularDevice9get_stackEv) referenced from .\build\quectel_bg96.o(.constdata__ZTVN4mbed12QUECTEL_BG96E)
 <LI><a href="#[164]">mbed::AT_CellularDevice::get_stack()</a> from .\build\at_cellulardevice.o(i._ZN4mbed17AT_CellularDevice9get_stackEv) referenced from .\build\at_cellulardevice.o(.constdata__ZTVN4mbed17AT_CellularDeviceE)
 <LI><a href="#[180]">mbed::AT_CellularNetwork::get_attach(mbed::CellularNetwork::AttachStatus&)</a> from .\build\at_cellularnetwork.o(i._ZN4mbed18AT_CellularNetwork10get_attachERNS_15CellularNetwork12AttachStatusE) referenced from .\build\at_cellularnetwork.o(.constdata__ZTVN4mbed18AT_CellularNetworkE)
 <LI><a href="#[180]">mbed::AT_CellularNetwork::get_attach(mbed::CellularNetwork::AttachStatus&)</a> from .\build\at_cellularnetwork.o(i._ZN4mbed18AT_CellularNetwork10get_attachERNS_15CellularNetwork12AttachStatusE) referenced from .\build\quectel_bg96_cellularnetwork.o(.constdata__ZTVN4mbed28QUECTEL_BG96_CellularNetworkE)
 <LI><a href="#[17f]">mbed::AT_CellularNetwork::set_attach(int)</a> from .\build\at_cellularnetwork.o(i._ZN4mbed18AT_CellularNetwork10set_attachEi) referenced from .\build\at_cellularnetwork.o(.constdata__ZTVN4mbed18AT_CellularNetworkE)
 <LI><a href="#[17f]">mbed::AT_CellularNetwork::set_attach(int)</a> from .\build\at_cellularnetwork.o(i._ZN4mbed18AT_CellularNetwork10set_attachEi) referenced from .\build\quectel_bg96_cellularnetwork.o(.constdata__ZTVN4mbed28QUECTEL_BG96_CellularNetworkE)
 <LI><a href="#[c4]">mbed::AT_CellularNetwork::ppp_status_cb(nsapi_event, int)</a> from .\build\at_cellularnetwork.o(i._ZN4mbed18AT_CellularNetwork13ppp_status_cbE11nsapi_eventi) referenced from .\build\at_cellularnetwork.o(.constdata)
 <LI><a href="#[c5]">mbed::AT_CellularNetwork::urc_no_carrier()</a> from .\build\at_cellularnetwork.o(i._ZN4mbed18AT_CellularNetwork14urc_no_carrierEv) referenced from .\build\at_cellularnetwork.o(.constdata)
 <LI><a href="#[17e]">mbed::AT_CellularNetwork::set_credentials(const char*, const char*, const char*)</a> from .\build\at_cellularnetwork.o(i._ZN4mbed18AT_CellularNetwork15set_credentialsEPKcS2_S2_) referenced from .\build\at_cellularnetwork.o(.constdata__ZTVN4mbed18AT_CellularNetworkE)
 <LI><a href="#[17e]">mbed::AT_CellularNetwork::set_credentials(const char*, const char*, const char*)</a> from .\build\at_cellularnetwork.o(i._ZN4mbed18AT_CellularNetwork15set_credentialsEPKcS2_S2_) referenced from .\build\quectel_bg96_cellularnetwork.o(.constdata__ZTVN4mbed28QUECTEL_BG96_CellularNetworkE)
 <LI><a href="#[182]">mbed::AT_CellularNetwork::has_registration(mbed::CellularNetwork::RegistrationType)</a> from .\build\at_cellularnetwork.o(i._ZN4mbed18AT_CellularNetwork16has_registrationENS_15CellularNetwork16RegistrationTypeE) referenced from .\build\at_cellularnetwork.o(.constdata__ZTVN4mbed18AT_CellularNetworkE)
 <LI><a href="#[182]">mbed::AT_CellularNetwork::has_registration(mbed::CellularNetwork::RegistrationType)</a> from .\build\at_cellularnetwork.o(i._ZN4mbed18AT_CellularNetwork16has_registrationENS_15CellularNetwork16RegistrationTypeE) referenced from .\build\quectel_bg96_cellularnetwork.o(.constdata__ZTVN4mbed28QUECTEL_BG96_CellularNetworkE)
 <LI><a href="#[17c]">mbed::AT_CellularNetwork::set_registration(const char*)</a> from .\build\at_cellularnetwork.o(i._ZN4mbed18AT_CellularNetwork16set_registrationEPKc) referenced from .\build\at_cellularnetwork.o(.constdata__ZTVN4mbed18AT_CellularNetworkE)
 <LI><a href="#[17c]">mbed::AT_CellularNetwork::set_registration(const char*)</a> from .\build\at_cellularnetwork.o(i._ZN4mbed18AT_CellularNetwork16set_registrationEPKc) referenced from .\build\quectel_bg96_cellularnetwork.o(.constdata__ZTVN4mbed28QUECTEL_BG96_CellularNetworkE)
 <LI><a href="#[181]">mbed::AT_CellularNetwork::get_modem_stack_type(nsapi_ip_stack)</a> from .\build\at_cellularnetwork.o(i._ZN4mbed18AT_CellularNetwork20get_modem_stack_typeE14nsapi_ip_stack) referenced from .\build\at_cellularnetwork.o(.constdata__ZTVN4mbed18AT_CellularNetworkE)
 <LI><a href="#[17d]">mbed::AT_CellularNetwork::get_registration_status(mbed::CellularNetwork::RegistrationType, mbed::CellularNetwork::RegistrationStatus&)</a> from .\build\at_cellularnetwork.o(i._ZN4mbed18AT_CellularNetwork23get_registration_statusENS_15CellularNetwork16RegistrationTypeERNS1_18RegistrationStatusE) referenced from .\build\at_cellularnetwork.o(.constdata__ZTVN4mbed18AT_CellularNetworkE)
 <LI><a href="#[17d]">mbed::AT_CellularNetwork::get_registration_status(mbed::CellularNetwork::RegistrationType, mbed::CellularNetwork::RegistrationStatus&)</a> from .\build\at_cellularnetwork.o(i._ZN4mbed18AT_CellularNetwork23get_registration_statusENS_15CellularNetwork16RegistrationTypeERNS1_18RegistrationStatusE) referenced from .\build\quectel_bg96_cellularnetwork.o(.constdata__ZTVN4mbed28QUECTEL_BG96_CellularNetworkE)
 <LI><a href="#[17a]">mbed::AT_CellularNetwork::connect()</a> from .\build\at_cellularnetwork.o(i._ZN4mbed18AT_CellularNetwork7connectEv) referenced from .\build\at_cellularnetwork.o(.constdata__ZTVN4mbed18AT_CellularNetworkE)
 <LI><a href="#[17a]">mbed::AT_CellularNetwork::connect()</a> from .\build\at_cellularnetwork.o(i._ZN4mbed18AT_CellularNetwork7connectEv) referenced from .\build\quectel_bg96_cellularnetwork.o(.constdata__ZTVN4mbed28QUECTEL_BG96_CellularNetworkE)
 <LI><a href="#[17b]">mbed::AT_CellularNetwork::get_stack()</a> from .\build\at_cellularnetwork.o(i._ZN4mbed18AT_CellularNetwork9get_stackEv) referenced from .\build\at_cellularnetwork.o(.constdata__ZTVN4mbed18AT_CellularNetworkE)
 <LI><a href="#[179]">mbed::AT_CellularNetwork::~AT_CellularNetwork__deallocating()</a> from .\build\at_cellularnetwork.o(i._ZN4mbed18AT_CellularNetworkD0Ev) referenced from .\build\at_cellularnetwork.o(.constdata__ZTVN4mbed18AT_CellularNetworkE)
 <LI><a href="#[178]">mbed::AT_CellularNetwork::~AT_CellularNetwork()</a> from .\build\at_cellularnetwork.o(i._ZN4mbed18AT_CellularNetworkD1Ev) referenced from .\build\at_cellularnetwork.o(.constdata__ZTVN4mbed18AT_CellularNetworkE)
 <LI><a href="#[c8]">mbed::CellularConnectionFSM::event()</a> from .\build\cellularconnectionfsm.o(i._ZN4mbed21CellularConnectionFSM5eventEv) referenced from .\build\cellularconnectionfsm.o(.constdata)
 <LI><a href="#[183]">mbed::CellularConnectionFSM::~CellularConnectionFSM()</a> from .\build\cellularconnectionfsm.o(i._ZN4mbed21CellularConnectionFSMD1Ev) referenced from .\build\cellularconnectionfsm.o(.constdata__ZTVN4mbed21CellularConnectionFSME)
 <LI><a href="#[186]">mbed::AT_CellularInformation::get_revision(char*, unsigned)</a> from .\build\at_cellularinformation.o(i._ZN4mbed22AT_CellularInformation12get_revisionEPcj) referenced from .\build\at_cellularinformation.o(.constdata__ZTVN4mbed22AT_CellularInformationE)
 <LI><a href="#[184]">mbed::AT_CellularInformation::get_manufacturer(char*, unsigned)</a> from .\build\at_cellularinformation.o(i._ZN4mbed22AT_CellularInformation16get_manufacturerEPcj) referenced from .\build\at_cellularinformation.o(.constdata__ZTVN4mbed22AT_CellularInformationE)
 <LI><a href="#[185]">mbed::AT_CellularInformation::get_model(char*, unsigned)</a> from .\build\at_cellularinformation.o(i._ZN4mbed22AT_CellularInformation9get_modelEPcj) referenced from .\build\at_cellularinformation.o(.constdata__ZTVN4mbed22AT_CellularInformationE)
 <LI><a href="#[18a]">mbed::EasyCellularConnection::set_sim_pin(const char*)</a> from .\build\easycellularconnection.o(i._ZN4mbed22EasyCellularConnection11set_sim_pinEPKc) referenced from .\build\easycellularconnection.o(.constdata__ZTVN4mbed22EasyCellularConnectionE)
 <LI><a href="#[18b]">mbed::EasyCellularConnection::is_connected()</a> from .\build\easycellularconnection.o(i._ZN4mbed22EasyCellularConnection12is_connectedEv) referenced from .\build\easycellularconnection.o(.constdata__ZTVN4mbed22EasyCellularConnectionE)
 <LI><a href="#[ca]">mbed::EasyCellularConnection::cellular_status(int, int)</a> from .\build\easycellularconnection.o(i._ZN4mbed22EasyCellularConnection15cellular_statusEii) referenced from .\build\easycellularconnection.o(.constdata)
 <LI><a href="#[189]">mbed::EasyCellularConnection::set_credentials(const char*, const char*, const char*)</a> from .\build\easycellularconnection.o(i._ZN4mbed22EasyCellularConnection15set_credentialsEPKcS2_S2_) referenced from .\build\easycellularconnection.o(.constdata__ZTVN4mbed22EasyCellularConnectionE)
 <LI><a href="#[187]">mbed::EasyCellularConnection::connect()</a> from .\build\easycellularconnection.o(i._ZN4mbed22EasyCellularConnection7connectEv) referenced from .\build\easycellularconnection.o(.constdata__ZTVN4mbed22EasyCellularConnectionE)
 <LI><a href="#[188]">mbed::EasyCellularConnection::get_stack()</a> from .\build\easycellularconnection.o(i._ZN4mbed22EasyCellularConnection9get_stackEv) referenced from .\build\easycellularconnection.o(.constdata__ZTVN4mbed22EasyCellularConnectionE)
 <LI><a href="#[5e]">mbed::EasyCellularConnection::~EasyCellularConnection()</a> from .\build\easycellularconnection.o(i._ZN4mbed22EasyCellularConnectionD1Ev) referenced from .\build\easycellularconnection.o(.constdata__ZTVN4mbed22EasyCellularConnectionE)
 <LI><a href="#[5e]">mbed::EasyCellularConnection::~EasyCellularConnection()</a> from .\build\easycellularconnection.o(i._ZN4mbed22EasyCellularConnectionD1Ev) referenced from .\build\main.o(i.__sti___8_main_cpp_led0)
 <LI><a href="#[18f]">mbed::QUECTEL_BG96_CellularStack::socket_close_impl(int)</a> from .\build\quectel_bg96_cellularstack.o(i._ZN4mbed26QUECTEL_BG96_CellularStack17socket_close_implEi) referenced from .\build\quectel_bg96_cellularstack.o(.constdata__ZTVN4mbed26QUECTEL_BG96_CellularStackE)
 <LI><a href="#[190]">mbed::QUECTEL_BG96_CellularStack::create_socket_impl(mbed::AT_CellularStack::CellularSocket*)</a> from .\build\quectel_bg96_cellularstack.o(i._ZN4mbed26QUECTEL_BG96_CellularStack18create_socket_implEPNS_16AT_CellularStack14CellularSocketE) referenced from .\build\quectel_bg96_cellularstack.o(.constdata__ZTVN4mbed26QUECTEL_BG96_CellularStackE)
 <LI><a href="#[191]">mbed::QUECTEL_BG96_CellularStack::socket_sendto_impl(mbed::AT_CellularStack::CellularSocket*, const SocketAddress&, const void*, unsigned)</a> from .\build\quectel_bg96_cellularstack.o(i._ZN4mbed26QUECTEL_BG96_CellularStack18socket_sendto_implEPNS_16AT_CellularStack14CellularSocketERK13SocketAddressPKvj) referenced from .\build\quectel_bg96_cellularstack.o(.constdata__ZTVN4mbed26QUECTEL_BG96_CellularStackE)
 <LI><a href="#[18d]">mbed::QUECTEL_BG96_CellularStack::get_max_packet_size()</a> from .\build\quectel_bg96_cellularstack.o(i._ZN4mbed26QUECTEL_BG96_CellularStack19get_max_packet_sizeEv) referenced from .\build\quectel_bg96_cellularstack.o(.constdata__ZTVN4mbed26QUECTEL_BG96_CellularStackE)
 <LI><a href="#[18c]">mbed::QUECTEL_BG96_CellularStack::get_max_socket_count()</a> from .\build\quectel_bg96_cellularstack.o(i._ZN4mbed26QUECTEL_BG96_CellularStack20get_max_socket_countEv) referenced from .\build\quectel_bg96_cellularstack.o(.constdata__ZTVN4mbed26QUECTEL_BG96_CellularStackE)
 <LI><a href="#[192]">mbed::QUECTEL_BG96_CellularStack::socket_recvfrom_impl(mbed::AT_CellularStack::CellularSocket*, SocketAddress*, void*, unsigned)</a> from .\build\quectel_bg96_cellularstack.o(i._ZN4mbed26QUECTEL_BG96_CellularStack20socket_recvfrom_implEPNS_16AT_CellularStack14CellularSocketEP13SocketAddressPvj) referenced from .\build\quectel_bg96_cellularstack.o(.constdata__ZTVN4mbed26QUECTEL_BG96_CellularStackE)
 <LI><a href="#[18e]">mbed::QUECTEL_BG96_CellularStack::is_protocol_supported(nsapi_protocol)</a> from .\build\quectel_bg96_cellularstack.o(i._ZN4mbed26QUECTEL_BG96_CellularStack21is_protocol_supportedE14nsapi_protocol) referenced from .\build\quectel_bg96_cellularstack.o(.constdata__ZTVN4mbed26QUECTEL_BG96_CellularStackE)
 <LI><a href="#[11c]">mbed::QUECTEL_BG96_CellularStack::urc_qiurc()</a> from .\build\quectel_bg96_cellularstack.o(i._ZN4mbed26QUECTEL_BG96_CellularStack9urc_qiurcEv) referenced from .\build\quectel_bg96_cellularstack.o(.constdata)
 <LI><a href="#[196]">mbed::QUECTEL_BG96_CellularNetwork::get_modem_stack_type(nsapi_ip_stack)</a> from .\build\quectel_bg96_cellularnetwork.o(i._ZN4mbed28QUECTEL_BG96_CellularNetwork20get_modem_stack_typeE14nsapi_ip_stack) referenced from .\build\quectel_bg96_cellularnetwork.o(.constdata__ZTVN4mbed28QUECTEL_BG96_CellularNetworkE)
 <LI><a href="#[195]">mbed::QUECTEL_BG96_CellularNetwork::get_stack()</a> from .\build\quectel_bg96_cellularnetwork.o(i._ZN4mbed28QUECTEL_BG96_CellularNetwork9get_stackEv) referenced from .\build\quectel_bg96_cellularnetwork.o(.constdata__ZTVN4mbed28QUECTEL_BG96_CellularNetworkE)
 <LI><a href="#[194]">mbed::QUECTEL_BG96_CellularNetwork::~QUECTEL_BG96_CellularNetwork__deallocating()</a> from .\build\quectel_bg96_cellularnetwork.o(i._ZN4mbed28QUECTEL_BG96_CellularNetworkD0Ev) referenced from .\build\quectel_bg96_cellularnetwork.o(.constdata__ZTVN4mbed28QUECTEL_BG96_CellularNetworkE)
 <LI><a href="#[193]">mbed::QUECTEL_BG96_CellularNetwork::~QUECTEL_BG96_CellularNetwork()</a> from .\build\quectel_bg96_cellularnetwork.o(i._ZN4mbed28QUECTEL_BG96_CellularNetworkD1Ev) referenced from .\build\quectel_bg96_cellularnetwork.o(.constdata__ZTVN4mbed28QUECTEL_BG96_CellularNetworkE)
 <LI><a href="#[59]">mbed::Timer::~Timer()</a> from .\build\timer.o(i._ZN4mbed5TimerD1Ev) referenced from .\build\arm_hal_timer.o(i.__sti___17_arm_hal_timer_cpp_749a681d)
 <LI><a href="#[197]">mbed::Serial::lock()</a> from .\build\serial.o(i._ZN4mbed6Serial4lockEv) referenced from .\build\serial.o(.constdata__ZTVN4mbed6SerialE)
 <LI><a href="#[199]">mbed::Serial::_getc()</a> from .\build\serial.o(i._ZN4mbed6Serial5_getcEv) referenced from .\build\serial.o(.constdata__ZTVN4mbed6SerialE)
 <LI><a href="#[19a]">mbed::Serial::_putc(int)</a> from .\build\serial.o(i._ZN4mbed6Serial5_putcEi) referenced from .\build\serial.o(.constdata__ZTVN4mbed6SerialE)
 <LI><a href="#[198]">mbed::Serial::unlock()</a> from .\build\serial.o(i._ZN4mbed6Serial6unlockEv) referenced from .\build\serial.o(.constdata__ZTVN4mbed6SerialE)
 <LI><a href="#[5d]">mbed::Serial::~Serial()</a> from .\build\serial.o(i._ZN4mbed6SerialD1Ev) referenced from .\build\serial.o(.constdata__ZTVN4mbed6SerialE)
 <LI><a href="#[5d]">mbed::Serial::~Serial()</a> from .\build\serial.o(i._ZN4mbed6SerialD1Ev) referenced from .\build\main.o(i.__sti___8_main_cpp_led0)
 <LI><a href="#[1a6]">mbed::Stream::lock()</a> from .\build\stream.o(i._ZN4mbed6Stream4lockEv) referenced from .\build\stream.o(.constdata__ZTVN4mbed6StreamE)
 <LI><a href="#[19b]">mbed::Stream::read(void*, unsigned)</a> from .\build\stream.o(i._ZN4mbed6Stream4readEPvj) referenced from .\build\serial.o(.constdata__ZTVN4mbed6SerialE)
 <LI><a href="#[19b]">mbed::Stream::read(void*, unsigned)</a> from .\build\stream.o(i._ZN4mbed6Stream4readEPvj) referenced from .\build\stream.o(.constdata__ZTVN4mbed6StreamE)
 <LI><a href="#[19d]">mbed::Stream::seek(long, int)</a> from .\build\stream.o(i._ZN4mbed6Stream4seekEli) referenced from .\build\serial.o(.constdata__ZTVN4mbed6SerialE)
 <LI><a href="#[19d]">mbed::Stream::seek(long, int)</a> from .\build\stream.o(i._ZN4mbed6Stream4seekEli) referenced from .\build\stream.o(.constdata__ZTVN4mbed6StreamE)
 <LI><a href="#[1a0]">mbed::Stream::size()</a> from .\build\stream.o(i._ZN4mbed6Stream4sizeEv) referenced from .\build\serial.o(.constdata__ZTVN4mbed6SerialE)
 <LI><a href="#[1a0]">mbed::Stream::size()</a> from .\build\stream.o(i._ZN4mbed6Stream4sizeEv) referenced from .\build\stream.o(.constdata__ZTVN4mbed6StreamE)
 <LI><a href="#[19e]">mbed::Stream::close()</a> from .\build\stream.o(i._ZN4mbed6Stream5closeEv) referenced from .\build\serial.o(.constdata__ZTVN4mbed6SerialE)
 <LI><a href="#[19e]">mbed::Stream::close()</a> from .\build\stream.o(i._ZN4mbed6Stream5closeEv) referenced from .\build\stream.o(.constdata__ZTVN4mbed6StreamE)
 <LI><a href="#[19c]">mbed::Stream::write(const void*, unsigned)</a> from .\build\stream.o(i._ZN4mbed6Stream5writeEPKvj) referenced from .\build\serial.o(.constdata__ZTVN4mbed6SerialE)
 <LI><a href="#[19c]">mbed::Stream::write(const void*, unsigned)</a> from .\build\stream.o(i._ZN4mbed6Stream5writeEPKvj) referenced from .\build\stream.o(.constdata__ZTVN4mbed6StreamE)
 <LI><a href="#[19f]">mbed::Stream::isatty()</a> from .\build\stream.o(i._ZN4mbed6Stream6isattyEv) referenced from .\build\serial.o(.constdata__ZTVN4mbed6SerialE)
 <LI><a href="#[19f]">mbed::Stream::isatty()</a> from .\build\stream.o(i._ZN4mbed6Stream6isattyEv) referenced from .\build\stream.o(.constdata__ZTVN4mbed6StreamE)
 <LI><a href="#[1a7]">mbed::Stream::unlock()</a> from .\build\stream.o(i._ZN4mbed6Stream6unlockEv) referenced from .\build\stream.o(.constdata__ZTVN4mbed6StreamE)
 <LI><a href="#[1a5]">mbed::Stream::~Stream__sub_object()</a> from .\build\stream.o(i._ZN4mbed6StreamD2Ev) referenced from .\build\stream.o(.constdata__ZTVN4mbed6StreamE)
 <LI><a href="#[1a8]">mbed::Ticker::handler()</a> from .\build\ticker.o(i._ZN4mbed6Ticker7handlerEv) referenced from .\build\ticker.o(.constdata__ZTVN4mbed6TickerE)
 <LI><a href="#[1a9]">mbed::Timeout::handler()</a> from .\build\timeout.o(i._ZN4mbed7Timeout7handlerEv) referenced from .\build\timeout.o(.constdata__ZTVN4mbed7TimeoutE)
 <LI><a href="#[5a]">mbed::Timeout::~Timeout()</a> from .\build\arm_hal_timer.o(i._ZN4mbed7TimeoutD1Ev) referenced from .\build\timeout.o(.constdata__ZTVN4mbed7TimeoutE)
 <LI><a href="#[5a]">mbed::Timeout::~Timeout()</a> from .\build\arm_hal_timer.o(i._ZN4mbed7TimeoutD1Ev) referenced from .\build\arm_hal_timer.o(i.__sti___17_arm_hal_timer_cpp_749a681d)
 <LI><a href="#[1ae]">bool mbed::Callback&lang;bool(int, int)&rang;::function_call&lang;mbed::Callback&lang;bool(int, int)&rang;::method_context&lang;mbed::EasyCellularConnection, bool(mbed::EasyCellularConnection::*)(int, int)&rang;&rang;(const void*, int, int)</a> from .\build\easycellularconnection.o(t._ZN4mbed8CallbackIFbiiEE13function_callINS2_14method_contextINS_22EasyCellularConnectionEMS5_FbiiEEEEEbPKvii) referenced from .\build\easycellularconnection.o(.constdata__ZZN4mbed8CallbackIFbiiEE8generateINS2_14method_contextINS_22EasyCellularConnectionEMS5_FbiiEEEEEvRKT_E3ops)
 <LI><a href="#[1b1]">bool mbed::Callback&lang;bool(int, int)&rang;::function_call&lang;bool(*)(int, int)&rang;(const void*, int, int)</a> from .\build\cellularconnectionfsm.o(t._ZN4mbed8CallbackIFbiiEE13function_callIPS1_EEbPKvii) referenced from .\build\cellularconnectionfsm.o(.constdata__ZZN4mbed8CallbackIFbiiEE8generateIPS1_EEvRKT_E3ops)
 <LI><a href="#[1b0]">void mbed::Callback&lang;bool(int, int)&rang;::function_dtor&lang;mbed::Callback&lang;bool(int, int)&rang;::method_context&lang;mbed::EasyCellularConnection, bool(mbed::EasyCellularConnection::*)(int, int)&rang;&rang;(void*)</a> from .\build\easycellularconnection.o(t._ZN4mbed8CallbackIFbiiEE13function_dtorINS2_14method_contextINS_22EasyCellularConnectionEMS5_FbiiEEEEEvPv) referenced from .\build\easycellularconnection.o(.constdata__ZZN4mbed8CallbackIFbiiEE8generateINS2_14method_contextINS_22EasyCellularConnectionEMS5_FbiiEEEEEvRKT_E3ops)
 <LI><a href="#[1b3]">void mbed::Callback&lang;bool(int, int)&rang;::function_dtor&lang;bool(*)(int, int)&rang;(void*)</a> from .\build\cellularconnectionfsm.o(t._ZN4mbed8CallbackIFbiiEE13function_dtorIPS1_EEvPv) referenced from .\build\cellularconnectionfsm.o(.constdata__ZZN4mbed8CallbackIFbiiEE8generateIPS1_EEvRKT_E3ops)
 <LI><a href="#[1af]">void mbed::Callback&lang;bool(int, int)&rang;::function_move&lang;mbed::Callback&lang;bool(int, int)&rang;::method_context&lang;mbed::EasyCellularConnection, bool(mbed::EasyCellularConnection::*)(int, int)&rang;&rang;(void*, const void*)</a> from .\build\easycellularconnection.o(t._ZN4mbed8CallbackIFbiiEE13function_moveINS2_14method_contextINS_22EasyCellularConnectionEMS5_FbiiEEEEEvPvPKv) referenced from .\build\easycellularconnection.o(.constdata__ZZN4mbed8CallbackIFbiiEE8generateINS2_14method_contextINS_22EasyCellularConnectionEMS5_FbiiEEEEEvRKT_E3ops)
 <LI><a href="#[1b2]">void mbed::Callback&lang;bool(int, int)&rang;::function_move&lang;bool(*)(int, int)&rang;(void*, const void*)</a> from .\build\cellularconnectionfsm.o(t._ZN4mbed8CallbackIFbiiEE13function_moveIPS1_EEvPvPKv) referenced from .\build\cellularconnectionfsm.o(.constdata__ZZN4mbed8CallbackIFbiiEE8generateIPS1_EEvRKT_E3ops)
 <LI><a href="#[1b4]">void mbed::Callback&lang;void(nsapi_event, int)&rang;::function_call&lang;mbed::Callback&lang;void(nsapi_event, int)&rang;::method_context&lang;mbed::AT_CellularNetwork, void(mbed::AT_CellularNetwork::*)(nsapi_event, int)&rang;&rang;(const void*, nsapi_event, int)</a> from .\build\at_cellularnetwork.o(t._ZN4mbed8CallbackIFv11nsapi_eventiEE13function_callINS3_14method_contextINS_18AT_CellularNetworkEMS6_FvS1_iEEEEEvPKvS1_i) referenced from .\build\at_cellularnetwork.o(.constdata__ZZN4mbed8CallbackIFv11nsapi_eventiEE8generateINS3_14method_contextINS_18AT_CellularNetworkEMS6_FvS1_iEEEEEvRKT_E3ops)
 <LI><a href="#[1b7]">void mbed::Callback&lang;void(nsapi_event, int)&rang;::function_call&lang;void(*)(nsapi_event, int)&rang;(const void*, nsapi_event, int)</a> from .\build\at_cellularnetwork.o(t._ZN4mbed8CallbackIFv11nsapi_eventiEE13function_callIPS2_EEvPKvS1_i) referenced from .\build\at_cellularnetwork.o(.constdata__ZZN4mbed8CallbackIFv11nsapi_eventiEE8generateIPS2_EEvRKT_E3ops)
 <LI><a href="#[1b6]">void mbed::Callback&lang;void(nsapi_event, int)&rang;::function_dtor&lang;mbed::Callback&lang;void(nsapi_event, int)&rang;::method_context&lang;mbed::AT_CellularNetwork, void(mbed::AT_CellularNetwork::*)(nsapi_event, int)&rang;&rang;(void*)</a> from .\build\at_cellularnetwork.o(t._ZN4mbed8CallbackIFv11nsapi_eventiEE13function_dtorINS3_14method_contextINS_18AT_CellularNetworkEMS6_FvS1_iEEEEEvPv) referenced from .\build\at_cellularnetwork.o(.constdata__ZZN4mbed8CallbackIFv11nsapi_eventiEE8generateINS3_14method_contextINS_18AT_CellularNetworkEMS6_FvS1_iEEEEEvRKT_E3ops)
 <LI><a href="#[1b9]">void mbed::Callback&lang;void(nsapi_event, int)&rang;::function_dtor&lang;void(*)(nsapi_event, int)&rang;(void*)</a> from .\build\at_cellularnetwork.o(t._ZN4mbed8CallbackIFv11nsapi_eventiEE13function_dtorIPS2_EEvPv) referenced from .\build\at_cellularnetwork.o(.constdata__ZZN4mbed8CallbackIFv11nsapi_eventiEE8generateIPS2_EEvRKT_E3ops)
 <LI><a href="#[1b5]">void mbed::Callback&lang;void(nsapi_event, int)&rang;::function_move&lang;mbed::Callback&lang;void(nsapi_event, int)&rang;::method_context&lang;mbed::AT_CellularNetwork, void(mbed::AT_CellularNetwork::*)(nsapi_event, int)&rang;&rang;(void*, const void*)</a> from .\build\at_cellularnetwork.o(t._ZN4mbed8CallbackIFv11nsapi_eventiEE13function_moveINS3_14method_contextINS_18AT_CellularNetworkEMS6_FvS1_iEEEEEvPvPKv) referenced from .\build\at_cellularnetwork.o(.constdata__ZZN4mbed8CallbackIFv11nsapi_eventiEE8generateINS3_14method_contextINS_18AT_CellularNetworkEMS6_FvS1_iEEEEEvRKT_E3ops)
 <LI><a href="#[1b8]">void mbed::Callback&lang;void(nsapi_event, int)&rang;::function_move&lang;void(*)(nsapi_event, int)&rang;(void*, const void*)</a> from .\build\at_cellularnetwork.o(t._ZN4mbed8CallbackIFv11nsapi_eventiEE13function_moveIPS2_EEvPvPKv) referenced from .\build\at_cellularnetwork.o(.constdata__ZZN4mbed8CallbackIFv11nsapi_eventiEE8generateIPS2_EEvRKT_E3ops)
 <LI><a href="#[58]">mbed::Callback&lang;void(nsapi_event, int)&rang;::~Callback()</a> from .\build\at_cellularnetwork.o(t._ZN4mbed8CallbackIFv11nsapi_eventiEED1Ev) referenced from .\build\ppp_lwip.o(i.__sti___12_ppp_lwip_cpp_b3a13e7c)
 <LI><a href="#[1ba]">void mbed::Callback&lang;void(int)&rang;::function_call&lang;void(*)(int)&rang;(const void*, int)</a> from .\build\eventqueue.o(t._ZN4mbed8CallbackIFviEE13function_callIPS1_EEvPKvi) referenced from .\build\eventqueue.o(.constdata__ZZN4mbed8CallbackIFviEE8generateIPS1_EEvRKT_E3ops)
 <LI><a href="#[1bc]">void mbed::Callback&lang;void(int)&rang;::function_dtor&lang;void(*)(int)&rang;(void*)</a> from .\build\eventqueue.o(t._ZN4mbed8CallbackIFviEE13function_dtorIPS1_EEvPv) referenced from .\build\eventqueue.o(.constdata__ZZN4mbed8CallbackIFviEE8generateIPS1_EEvRKT_E3ops)
 <LI><a href="#[1bb]">void mbed::Callback&lang;void(int)&rang;::function_move&lang;void(*)(int)&rang;(void*, const void*)</a> from .\build\eventqueue.o(t._ZN4mbed8CallbackIFviEE13function_moveIPS1_EEvPvPKv) referenced from .\build\eventqueue.o(.constdata__ZZN4mbed8CallbackIFviEE8generateIPS1_EEvRKT_E3ops)
 <LI><a href="#[1bd]">void mbed::Callback&lang;void()&rang;::function_call&lang;mbed::Callback&lang;void()&rang;::method_context&lang;Socket, void(Socket::*)()&rang;&rang;(const void*)</a> from .\build\socket.o(t._ZN4mbed8CallbackIFvvEE13function_callINS2_14method_contextI6SocketMS5_FvvEEEEEvPKv) referenced from .\build\socket.o(.constdata__ZZN4mbed8CallbackIFvvEE8generateINS2_14method_contextI6SocketMS5_FvvEEEEEvRKT_E3ops)
 <LI><a href="#[1c0]">void mbed::Callback&lang;void()&rang;::function_call&lang;mbed::Callback&lang;void()&rang;::method_context&lang;events::EventQueue, void(events::EventQueue::*)()&rang;&rang;(const void*)</a> from .\build\cellularconnectionfsm.o(t._ZN4mbed8CallbackIFvvEE13function_callINS2_14method_contextIN6events10EventQueueEMS6_FvvEEEEEvPKv) referenced from .\build\cellularconnectionfsm.o(.constdata__ZZN4mbed8CallbackIFvvEE8generateINS2_14method_contextIN6events10EventQueueEMS6_FvvEEEEEvRKT_E3ops)
 <LI><a href="#[1c3]">void mbed::Callback&lang;void()&rang;::function_call&lang;mbed::Callback&lang;void()&rang;::method_context&lang;mbed::UARTSerial, void(mbed::UARTSerial::*)()&rang;&rang;(const void*)</a> from .\build\uartserial.o(t._ZN4mbed8CallbackIFvvEE13function_callINS2_14method_contextINS_10UARTSerialEMS5_FvvEEEEEvPKv) referenced from .\build\uartserial.o(.constdata__ZZN4mbed8CallbackIFvvEE8generateINS2_14method_contextINS_10UARTSerialEMS5_FvvEEEEEvRKT_E3ops)
 <LI><a href="#[1c6]">void mbed::Callback&lang;void()&rang;::function_call&lang;mbed::Callback&lang;void()&rang;::method_context&lang;mbed::AT_CellularNetwork, void(mbed::AT_CellularNetwork::*)()&rang;&rang;(const void*)</a> from .\build\at_cellularnetwork.o(t._ZN4mbed8CallbackIFvvEE13function_callINS2_14method_contextINS_18AT_CellularNetworkEMS5_FvvEEEEEvPKv) referenced from .\build\at_cellularnetwork.o(.constdata__ZZN4mbed8CallbackIFvvEE8generateINS2_14method_contextINS_18AT_CellularNetworkEMS5_FvvEEEEEvRKT_E3ops)
 <LI><a href="#[1c9]">void mbed::Callback&lang;void()&rang;::function_call&lang;mbed::Callback&lang;void()&rang;::method_context&lang;mbed::CellularConnectionFSM, void(mbed::CellularConnectionFSM::*)()&rang;&rang;(const void*)</a> from .\build\cellularconnectionfsm.o(t._ZN4mbed8CallbackIFvvEE13function_callINS2_14method_contextINS_21CellularConnectionFSMEMS5_FvvEEEEEvPKv) referenced from .\build\cellularconnectionfsm.o(.constdata__ZZN4mbed8CallbackIFvvEE8generateINS2_14method_contextINS_21CellularConnectionFSMEMS5_FvvEEEEEvRKT_E3ops)
 <LI><a href="#[1cc]">void mbed::Callback&lang;void()&rang;::function_call&lang;mbed::Callback&lang;void()&rang;::method_context&lang;mbed::QUECTEL_BG96_CellularStack, void(mbed::QUECTEL_BG96_CellularStack::*)()&rang;&rang;(const void*)</a> from .\build\quectel_bg96_cellularstack.o(t._ZN4mbed8CallbackIFvvEE13function_callINS2_14method_contextINS_26QUECTEL_BG96_CellularStackEMS5_FvvEEEEEvPKv) referenced from .\build\quectel_bg96_cellularstack.o(.constdata__ZZN4mbed8CallbackIFvvEE8generateINS2_14method_contextINS_26QUECTEL_BG96_CellularStackEMS5_FvvEEEEEvRKT_E3ops)
 <LI><a href="#[1cf]">void mbed::Callback&lang;void()&rang;::function_call&lang;mbed::Callback&lang;void()&rang;::method_context&lang;mbed::ATHandler, void(mbed::ATHandler::*)()&rang;&rang;(const void*)</a> from .\build\athandler.o(t._ZN4mbed8CallbackIFvvEE13function_callINS2_14method_contextINS_9ATHandlerEMS5_FvvEEEEEvPKv) referenced from .\build\athandler.o(.constdata__ZZN4mbed8CallbackIFvvEE8generateINS2_14method_contextINS_9ATHandlerEMS5_FvvEEEEEvRKT_E3ops)
 <LI><a href="#[1d2]">void mbed::Callback&lang;void()&rang;::function_call&lang;void(*)()&rang;(const void*)</a> from .\build\arm_hal_timer.o(t._ZN4mbed8CallbackIFvvEE13function_callIPS1_EEvPKv) referenced from .\build\arm_hal_timer.o(.constdata__ZZN4mbed8CallbackIFvvEE8generateIPS1_EEvRKT_E3ops)
 <LI><a href="#[1bf]">void mbed::Callback&lang;void()&rang;::function_dtor&lang;mbed::Callback&lang;void()&rang;::method_context&lang;Socket, void(Socket::*)()&rang;&rang;(void*)</a> from .\build\socket.o(t._ZN4mbed8CallbackIFvvEE13function_dtorINS2_14method_contextI6SocketMS5_FvvEEEEEvPv) referenced from .\build\socket.o(.constdata__ZZN4mbed8CallbackIFvvEE8generateINS2_14method_contextI6SocketMS5_FvvEEEEEvRKT_E3ops)
 <LI><a href="#[1c2]">void mbed::Callback&lang;void()&rang;::function_dtor&lang;mbed::Callback&lang;void()&rang;::method_context&lang;events::EventQueue, void(events::EventQueue::*)()&rang;&rang;(void*)</a> from .\build\cellularconnectionfsm.o(t._ZN4mbed8CallbackIFvvEE13function_dtorINS2_14method_contextIN6events10EventQueueEMS6_FvvEEEEEvPv) referenced from .\build\cellularconnectionfsm.o(.constdata__ZZN4mbed8CallbackIFvvEE8generateINS2_14method_contextIN6events10EventQueueEMS6_FvvEEEEEvRKT_E3ops)
 <LI><a href="#[1c5]">void mbed::Callback&lang;void()&rang;::function_dtor&lang;mbed::Callback&lang;void()&rang;::method_context&lang;mbed::UARTSerial, void(mbed::UARTSerial::*)()&rang;&rang;(void*)</a> from .\build\uartserial.o(t._ZN4mbed8CallbackIFvvEE13function_dtorINS2_14method_contextINS_10UARTSerialEMS5_FvvEEEEEvPv) referenced from .\build\uartserial.o(.constdata__ZZN4mbed8CallbackIFvvEE8generateINS2_14method_contextINS_10UARTSerialEMS5_FvvEEEEEvRKT_E3ops)
 <LI><a href="#[1c8]">void mbed::Callback&lang;void()&rang;::function_dtor&lang;mbed::Callback&lang;void()&rang;::method_context&lang;mbed::AT_CellularNetwork, void(mbed::AT_CellularNetwork::*)()&rang;&rang;(void*)</a> from .\build\at_cellularnetwork.o(t._ZN4mbed8CallbackIFvvEE13function_dtorINS2_14method_contextINS_18AT_CellularNetworkEMS5_FvvEEEEEvPv) referenced from .\build\at_cellularnetwork.o(.constdata__ZZN4mbed8CallbackIFvvEE8generateINS2_14method_contextINS_18AT_CellularNetworkEMS5_FvvEEEEEvRKT_E3ops)
 <LI><a href="#[1cb]">void mbed::Callback&lang;void()&rang;::function_dtor&lang;mbed::Callback&lang;void()&rang;::method_context&lang;mbed::CellularConnectionFSM, void(mbed::CellularConnectionFSM::*)()&rang;&rang;(void*)</a> from .\build\cellularconnectionfsm.o(t._ZN4mbed8CallbackIFvvEE13function_dtorINS2_14method_contextINS_21CellularConnectionFSMEMS5_FvvEEEEEvPv) referenced from .\build\cellularconnectionfsm.o(.constdata__ZZN4mbed8CallbackIFvvEE8generateINS2_14method_contextINS_21CellularConnectionFSMEMS5_FvvEEEEEvRKT_E3ops)
 <LI><a href="#[1ce]">void mbed::Callback&lang;void()&rang;::function_dtor&lang;mbed::Callback&lang;void()&rang;::method_context&lang;mbed::QUECTEL_BG96_CellularStack, void(mbed::QUECTEL_BG96_CellularStack::*)()&rang;&rang;(void*)</a> from .\build\quectel_bg96_cellularstack.o(t._ZN4mbed8CallbackIFvvEE13function_dtorINS2_14method_contextINS_26QUECTEL_BG96_CellularStackEMS5_FvvEEEEEvPv) referenced from .\build\quectel_bg96_cellularstack.o(.constdata__ZZN4mbed8CallbackIFvvEE8generateINS2_14method_contextINS_26QUECTEL_BG96_CellularStackEMS5_FvvEEEEEvRKT_E3ops)
 <LI><a href="#[1d1]">void mbed::Callback&lang;void()&rang;::function_dtor&lang;mbed::Callback&lang;void()&rang;::method_context&lang;mbed::ATHandler, void(mbed::ATHandler::*)()&rang;&rang;(void*)</a> from .\build\athandler.o(t._ZN4mbed8CallbackIFvvEE13function_dtorINS2_14method_contextINS_9ATHandlerEMS5_FvvEEEEEvPv) referenced from .\build\athandler.o(.constdata__ZZN4mbed8CallbackIFvvEE8generateINS2_14method_contextINS_9ATHandlerEMS5_FvvEEEEEvRKT_E3ops)
 <LI><a href="#[1d4]">void mbed::Callback&lang;void()&rang;::function_dtor&lang;void(*)()&rang;(void*)</a> from .\build\arm_hal_timer.o(t._ZN4mbed8CallbackIFvvEE13function_dtorIPS1_EEvPv) referenced from .\build\arm_hal_timer.o(.constdata__ZZN4mbed8CallbackIFvvEE8generateIPS1_EEvRKT_E3ops)
 <LI><a href="#[1be]">void mbed::Callback&lang;void()&rang;::function_move&lang;mbed::Callback&lang;void()&rang;::method_context&lang;Socket, void(Socket::*)()&rang;&rang;(void*, const void*)</a> from .\build\socket.o(t._ZN4mbed8CallbackIFvvEE13function_moveINS2_14method_contextI6SocketMS5_FvvEEEEEvPvPKv) referenced from .\build\socket.o(.constdata__ZZN4mbed8CallbackIFvvEE8generateINS2_14method_contextI6SocketMS5_FvvEEEEEvRKT_E3ops)
 <LI><a href="#[1c1]">void mbed::Callback&lang;void()&rang;::function_move&lang;mbed::Callback&lang;void()&rang;::method_context&lang;events::EventQueue, void(events::EventQueue::*)()&rang;&rang;(void*, const void*)</a> from .\build\cellularconnectionfsm.o(t._ZN4mbed8CallbackIFvvEE13function_moveINS2_14method_contextIN6events10EventQueueEMS6_FvvEEEEEvPvPKv) referenced from .\build\cellularconnectionfsm.o(.constdata__ZZN4mbed8CallbackIFvvEE8generateINS2_14method_contextIN6events10EventQueueEMS6_FvvEEEEEvRKT_E3ops)
 <LI><a href="#[1c4]">void mbed::Callback&lang;void()&rang;::function_move&lang;mbed::Callback&lang;void()&rang;::method_context&lang;mbed::UARTSerial, void(mbed::UARTSerial::*)()&rang;&rang;(void*, const void*)</a> from .\build\uartserial.o(t._ZN4mbed8CallbackIFvvEE13function_moveINS2_14method_contextINS_10UARTSerialEMS5_FvvEEEEEvPvPKv) referenced from .\build\uartserial.o(.constdata__ZZN4mbed8CallbackIFvvEE8generateINS2_14method_contextINS_10UARTSerialEMS5_FvvEEEEEvRKT_E3ops)
 <LI><a href="#[1c7]">void mbed::Callback&lang;void()&rang;::function_move&lang;mbed::Callback&lang;void()&rang;::method_context&lang;mbed::AT_CellularNetwork, void(mbed::AT_CellularNetwork::*)()&rang;&rang;(void*, const void*)</a> from .\build\at_cellularnetwork.o(t._ZN4mbed8CallbackIFvvEE13function_moveINS2_14method_contextINS_18AT_CellularNetworkEMS5_FvvEEEEEvPvPKv) referenced from .\build\at_cellularnetwork.o(.constdata__ZZN4mbed8CallbackIFvvEE8generateINS2_14method_contextINS_18AT_CellularNetworkEMS5_FvvEEEEEvRKT_E3ops)
 <LI><a href="#[1ca]">void mbed::Callback&lang;void()&rang;::function_move&lang;mbed::Callback&lang;void()&rang;::method_context&lang;mbed::CellularConnectionFSM, void(mbed::CellularConnectionFSM::*)()&rang;&rang;(void*, const void*)</a> from .\build\cellularconnectionfsm.o(t._ZN4mbed8CallbackIFvvEE13function_moveINS2_14method_contextINS_21CellularConnectionFSMEMS5_FvvEEEEEvPvPKv) referenced from .\build\cellularconnectionfsm.o(.constdata__ZZN4mbed8CallbackIFvvEE8generateINS2_14method_contextINS_21CellularConnectionFSMEMS5_FvvEEEEEvRKT_E3ops)
 <LI><a href="#[1cd]">void mbed::Callback&lang;void()&rang;::function_move&lang;mbed::Callback&lang;void()&rang;::method_context&lang;mbed::QUECTEL_BG96_CellularStack, void(mbed::QUECTEL_BG96_CellularStack::*)()&rang;&rang;(void*, const void*)</a> from .\build\quectel_bg96_cellularstack.o(t._ZN4mbed8CallbackIFvvEE13function_moveINS2_14method_contextINS_26QUECTEL_BG96_CellularStackEMS5_FvvEEEEEvPvPKv) referenced from .\build\quectel_bg96_cellularstack.o(.constdata__ZZN4mbed8CallbackIFvvEE8generateINS2_14method_contextINS_26QUECTEL_BG96_CellularStackEMS5_FvvEEEEEvRKT_E3ops)
 <LI><a href="#[1d0]">void mbed::Callback&lang;void()&rang;::function_move&lang;mbed::Callback&lang;void()&rang;::method_context&lang;mbed::ATHandler, void(mbed::ATHandler::*)()&rang;&rang;(void*, const void*)</a> from .\build\athandler.o(t._ZN4mbed8CallbackIFvvEE13function_moveINS2_14method_contextINS_9ATHandlerEMS5_FvvEEEEEvPvPKv) referenced from .\build\athandler.o(.constdata__ZZN4mbed8CallbackIFvvEE8generateINS2_14method_contextINS_9ATHandlerEMS5_FvvEEEEEvRKT_E3ops)
 <LI><a href="#[1d3]">void mbed::Callback&lang;void()&rang;::function_move&lang;void(*)()&rang;(void*, const void*)</a> from .\build\arm_hal_timer.o(t._ZN4mbed8CallbackIFvvEE13function_moveIPS1_EEvPvPKv) referenced from .\build\arm_hal_timer.o(.constdata__ZZN4mbed8CallbackIFvvEE8generateIPS1_EEvRKT_E3ops)
 <LI><a href="#[57]">mbed::Callback&lang;void()&rang;::thunk(void*)</a> from .\build\tcpserver.o(t._ZN4mbed8CallbackIFvvEE5thunkEPv) referenced from .\build\socket.o(i._ZN6Socket4openEP12NetworkStack)
 <LI><a href="#[53]">mbed::Callback&lang;void()&rang;::~Callback()</a> from .\build\arm_hal_timer.o(t._ZN4mbed8CallbackIFvvEED1Ev) referenced from .\build\serialbase.o(i._ZN4mbed10SerialBaseD1Ev)
 <LI><a href="#[1aa]">mbed::FileBase::~FileBase()</a> from .\build\filebase.o(i._ZN4mbed8FileBaseD1Ev) referenced from .\build\filebase.o(.constdata__ZTVN4mbed8FileBaseE)
 <LI><a href="#[1ab]">mbed::FileLike::~FileLike__sub_object()</a> from .\build\stream.o(i._ZN4mbed8FileLikeD2Ev) referenced from .\build\stream.o(.constdata__ZTVN4mbed8FileLikeE)
 <LI><a href="#[c6]">mbed::ATHandler::process_oob()</a> from .\build\athandler.o(i._ZN4mbed9ATHandler11process_oobEv) referenced from .\build\athandler.o(.constdata)
 <LI><a href="#[c7]">mbed::ATHandler::event()</a> from .\build\athandler.o(i._ZN4mbed9ATHandler5eventEv) referenced from .\build\athandler.o(.constdata)
 <LI><a href="#[55]">mbed::ppp_input()</a> from .\build\ppp_lwip.o(i._ZN4mbed9ppp_inputEv) referenced from .\build\ppp_lwip.o(i._ZN4mbed9stream_cbEv)
 <LI><a href="#[a1]">mbed::stream_cb()</a> from .\build\ppp_lwip.o(i._ZN4mbed9stream_cbEv) referenced from .\build\ppp_lwip.o(i.ppp_lwip_connect)
 <LI><a href="#[5f]">rtos::Mutex::~Mutex()</a> from .\build\mutex.o(i._ZN4rtos5MutexD1Ev) referenced from .\build\main.o(i.__sti___8_main_cpp_led0)
 <LI><a href="#[56]">rtos::Thread::_thunk(void*)</a> from .\build\thread.o(i._ZN4rtos6Thread6_thunkEPv) referenced from .\build\thread.o(i._ZN4rtos6Thread5startEN4mbed8CallbackIFvvEEE)
 <LI><a href="#[1ac]">rtos::Thread::~Thread__deallocating()</a> from .\build\thread.o(i._ZN4rtos6ThreadD0Ev) referenced from .\build\thread.o(.constdata__ZTVN4rtos6ThreadE)
 <LI><a href="#[60]">rtos::Thread::~Thread()</a> from .\build\thread.o(i._ZN4rtos6ThreadD1Ev) referenced from .\build\thread.o(.constdata__ZTVN4rtos6ThreadE)
 <LI><a href="#[60]">rtos::Thread::~Thread()</a> from .\build\thread.o(i._ZN4rtos6ThreadD1Ev) referenced from .\build\main.o(i.__sti___8_main_cpp_led0)
 <LI><a href="#[1ad]">rtos::internal::SysTimer::handler()</a> from .\build\systimer.o(i._ZN4rtos8internal8SysTimer7handlerEv) referenced from .\build\systimer.o(.constdata__ZTVN4rtos8internal8SysTimerE)
 <LI><a href="#[c1]">CThunk&lang;mbed::SerialBase&rang;::trampoline(mbed::SerialBase*, void*, void(mbed::SerialBase::**)(void*))</a> from .\build\serialbase.o(t._ZN6CThunkIN4mbed10SerialBaseEE10trampolineEPS1_PvPMS1_FvS4_E) referenced from .\build\serialbase.o(t._ZN6CThunkIN4mbed10SerialBaseEE4initEPS1_MS1_FvPvES4_)
 <LI><a href="#[138]">Socket::~Socket__sub_object()</a> from .\build\socket.o(i._ZN6SocketD2Ev) referenced from .\build\socket.o(.constdata__ZTV6Socket)
 <LI><a href="#[c3]">void events::EventQueue::function_call&lang;mbed::Callback&lang;void()&rang;&rang;(void*)</a> from .\build\athandler.o(t._ZN6events10EventQueue13function_callIN4mbed8CallbackIFvvEEEEEvPv) referenced from .\build\athandler.o(t._ZN6events10EventQueue4callIN4mbed8CallbackIFvvEEEEEiT_)
 <LI><a href="#[c3]">void events::EventQueue::function_call&lang;mbed::Callback&lang;void()&rang;&rang;(void*)</a> from .\build\athandler.o(t._ZN6events10EventQueue13function_callIN4mbed8CallbackIFvvEEEEEvPv) referenced from .\build\cellularconnectionfsm.o(t._ZN6events10EventQueue7call_inIN4mbed8CallbackIFvvEEEEEiiT_)
 <LI><a href="#[c2]">void events::EventQueue::function_dtor&lang;mbed::Callback&lang;void()&rang;&rang;(void*)</a> from .\build\athandler.o(t._ZN6events10EventQueue13function_dtorIN4mbed8CallbackIFvvEEEEEvPv) referenced from .\build\athandler.o(t._ZN6events10EventQueue4callIN4mbed8CallbackIFvvEEEEEiT_)
 <LI><a href="#[c2]">void events::EventQueue::function_dtor&lang;mbed::Callback&lang;void()&rang;&rang;(void*)</a> from .\build\athandler.o(t._ZN6events10EventQueue13function_dtorIN4mbed8CallbackIFvvEEEEEvPv) referenced from .\build\cellularconnectionfsm.o(t._ZN6events10EventQueue7call_inIN4mbed8CallbackIFvvEEEEEiiT_)
 <LI><a href="#[c9]">events::EventQueue::dispatch_forever()</a> from .\build\cellularconnectionfsm.o(i._ZN6events10EventQueue16dispatch_foreverEv) referenced 2 times from .\build\cellularconnectionfsm.o(.constdata)
 <LI><a href="#[13b]">TCPSocket::event()</a> from .\build\tcpsocket.o(i._ZN9TCPSocket5eventEv) referenced from .\build\tcpsocket.o(.constdata__ZTV9TCPSocket)
 <LI><a href="#[13a]">TCPSocket::get_proto()</a> from .\build\tcpsocket.o(i._ZN9TCPSocket9get_protoEv) referenced from .\build\tcpsocket.o(.constdata__ZTV9TCPSocket)
 <LI><a href="#[139]">TCPSocket::~TCPSocket()</a> from .\build\tcpsocket.o(i._ZN9TCPSocketD1Ev) referenced from .\build\tcpsocket.o(.constdata__ZTV9TCPSocket)
 <LI><a href="#[13e]">UDPSocket::event()</a> from .\build\udpsocket.o(i._ZN9UDPSocket5eventEv) referenced from .\build\udpsocket.o(.constdata__ZTV9UDPSocket)
 <LI><a href="#[13d]">UDPSocket::get_proto()</a> from .\build\udpsocket.o(i._ZN9UDPSocket9get_protoEv) referenced from .\build\udpsocket.o(.constdata__ZTV9UDPSocket)
 <LI><a href="#[13c]">UDPSocket::~UDPSocket()</a> from .\build\udpsocket.o(i._ZN9UDPSocketD1Ev) referenced from .\build\udpsocket.o(.constdata__ZTV9UDPSocket)
 <LI><a href="#[12b]">DirectSerial::poll(short) const</a> from .\build\mbed_retarget.o(i._ZNK12DirectSerial4pollEs) referenced from .\build\mbed_retarget.o(.constdata__ZTV12DirectSerial)
 <LI><a href="#[142]">mbed::FileHandle::poll(short) const</a> from .\build\file.o(i._ZNK4mbed10FileHandle4pollEs) referenced from .\build\filehandle.o(.constdata__ZTVN4mbed10FileHandleE)
 <LI><a href="#[142]">mbed::FileHandle::poll(short) const</a> from .\build\file.o(i._ZNK4mbed10FileHandle4pollEs) referenced from .\build\serial.o(.constdata__ZTVN4mbed6SerialE)
 <LI><a href="#[142]">mbed::FileHandle::poll(short) const</a> from .\build\file.o(i._ZNK4mbed10FileHandle4pollEs) referenced from .\build\stream.o(.constdata__ZTVN4mbed6StreamE)
 <LI><a href="#[142]">mbed::FileHandle::poll(short) const</a> from .\build\file.o(i._ZNK4mbed10FileHandle4pollEs) referenced from .\build\stream.o(.constdata__ZTVN4mbed8FileLikeE)
 <LI><a href="#[14a]">mbed::UARTSerial::poll(short) const</a> from .\build\uartserial.o(i._ZNK4mbed10UARTSerial4pollEs) referenced from .\build\uartserial.o(.constdata__ZTVN4mbed10UARTSerialE)
 <LI><a href="#[159]">thunk{-212} to mbed::UARTSerial::set_blocking(bool)</a> from .\build\uartserial.o(i._ZThn212_N4mbed10UARTSerial12set_blockingEb) referenced from .\build\uartserial.o(.constdata__ZTVN4mbed10UARTSerialE)
 <LI><a href="#[154]">thunk{-212} to mbed::UARTSerial::read(void*, unsigned)</a> from .\build\uartserial.o(i._ZThn212_N4mbed10UARTSerial4readEPvj) referenced from .\build\uartserial.o(.constdata__ZTVN4mbed10UARTSerialE)
 <LI><a href="#[156]">thunk{-212} to mbed::UARTSerial::seek(long, int)</a> from .\build\uartserial.o(i._ZThn212_N4mbed10UARTSerial4seekEli) referenced from .\build\uartserial.o(.constdata__ZTVN4mbed10UARTSerialE)
 <LI><a href="#[157]">thunk{-212} to mbed::UARTSerial::close()</a> from .\build\uartserial.o(i._ZThn212_N4mbed10UARTSerial5closeEv) referenced from .\build\uartserial.o(.constdata__ZTVN4mbed10UARTSerialE)
 <LI><a href="#[15b]">thunk{-212} to mbed::UARTSerial::sigio(mbed::Callback&lang;void()&rang;)</a> from .\build\uartserial.o(i._ZThn212_N4mbed10UARTSerial5sigioENS_8CallbackIFvvEEE) referenced from .\build\uartserial.o(.constdata__ZTVN4mbed10UARTSerialE)
 <LI><a href="#[155]">thunk{-212} to mbed::UARTSerial::write(const void*, unsigned)</a> from .\build\uartserial.o(i._ZThn212_N4mbed10UARTSerial5writeEPKvj) referenced from .\build\uartserial.o(.constdata__ZTVN4mbed10UARTSerialE)
 <LI><a href="#[158]">thunk{-212} to mbed::UARTSerial::isatty()</a> from .\build\uartserial.o(i._ZThn212_N4mbed10UARTSerial6isattyEv) referenced from .\build\uartserial.o(.constdata__ZTVN4mbed10UARTSerialE)
 <LI><a href="#[1a3]">thunk{-212} to mbed::Serial::lock()</a> from .\build\serial.o(i._ZThn212_N4mbed6Serial4lockEv) referenced from .\build\serial.o(.constdata__ZTVN4mbed6SerialE)
 <LI><a href="#[1a2]">thunk{-212} to mbed::Serial::_getc()</a> from .\build\serial.o(i._ZThn212_N4mbed6Serial5_getcEv) referenced from .\build\serial.o(.constdata__ZTVN4mbed6SerialE)
 <LI><a href="#[1a1]">thunk{-212} to mbed::Serial::_putc(int)</a> from .\build\serial.o(i._ZThn212_N4mbed6Serial5_putcEi) referenced from .\build\serial.o(.constdata__ZTVN4mbed6SerialE)
 <LI><a href="#[1a4]">thunk{-212} to mbed::Serial::unlock()</a> from .\build\serial.o(i._ZThn212_N4mbed6Serial6unlockEv) referenced from .\build\serial.o(.constdata__ZTVN4mbed6SerialE)
 <LI><a href="#[15a]">thunk{-212} to mbed::UARTSerial::poll(short) const</a> from .\build\uartserial.o(i._ZThn212_NK4mbed10UARTSerial4pollEs) referenced from .\build\uartserial.o(.constdata__ZTVN4mbed10UARTSerialE)
 <LI><a href="#[122]">__cxa_pure_virtual</a> from C:\Keil_v5\ARM\ARMCC\Bin\..\lib\cpplib\cpprt_w.l(pure_virt.o)(i.__cxa_pure_virtual) referenced 10 times from .\build\easycellularconnection.o(.constdata__ZTV12CellularBase)
 <LI><a href="#[122]">__cxa_pure_virtual</a> from C:\Keil_v5\ARM\ARMCC\Bin\..\lib\cpplib\cpprt_w.l(pure_virt.o)(i.__cxa_pure_virtual) referenced 12 times from .\build\networkstack.o(.constdata__ZTV12NetworkStack)
 <LI><a href="#[122]">__cxa_pure_virtual</a> from C:\Keil_v5\ARM\ARMCC\Bin\..\lib\cpplib\cpprt_w.l(pure_virt.o)(i.__cxa_pure_virtual) referenced 3 times from .\build\networkinterface.o(.constdata__ZTV16NetworkInterface)
 <LI><a href="#[122]">__cxa_pure_virtual</a> from C:\Keil_v5\ARM\ARMCC\Bin\..\lib\cpplib\cpprt_w.l(pure_virt.o)(i.__cxa_pure_virtual) referenced 2 times from .\build\socket.o(.constdata__ZTV6Socket)
 <LI><a href="#[122]">__cxa_pure_virtual</a> from C:\Keil_v5\ARM\ARMCC\Bin\..\lib\cpplib\cpprt_w.l(pure_virt.o)(i.__cxa_pure_virtual) referenced 4 times from .\build\filehandle.o(.constdata__ZTVN4mbed10FileHandleE)
 <LI><a href="#[122]">__cxa_pure_virtual</a> from C:\Keil_v5\ARM\ARMCC\Bin\..\lib\cpplib\cpprt_w.l(pure_virt.o)(i.__cxa_pure_virtual) referenced from .\build\timerevent.o(.constdata__ZTVN4mbed10TimerEventE)
 <LI><a href="#[122]">__cxa_pure_virtual</a> from C:\Keil_v5\ARM\ARMCC\Bin\..\lib\cpplib\cpprt_w.l(pure_virt.o)(i.__cxa_pure_virtual) referenced 5 times from .\build\at_cellularsim.o(.constdata__ZTVN4mbed11CellularSIME)
 <LI><a href="#[122]">__cxa_pure_virtual</a> from C:\Keil_v5\ARM\ARMCC\Bin\..\lib\cpplib\cpprt_w.l(pure_virt.o)(i.__cxa_pure_virtual) referenced 7 times from .\build\at_cellularpower.o(.constdata__ZTVN4mbed13CellularPowerE)
 <LI><a href="#[122]">__cxa_pure_virtual</a> from C:\Keil_v5\ARM\ARMCC\Bin\..\lib\cpplib\cpprt_w.l(pure_virt.o)(i.__cxa_pure_virtual) referenced 13 times from .\build\at_cellulardevice.o(.constdata__ZTVN4mbed14CellularDeviceE)
 <LI><a href="#[122]">__cxa_pure_virtual</a> from C:\Keil_v5\ARM\ARMCC\Bin\..\lib\cpplib\cpprt_w.l(pure_virt.o)(i.__cxa_pure_virtual) referenced 27 times from .\build\at_cellularnetwork.o(.constdata__ZTVN4mbed15CellularNetworkE)
 <LI><a href="#[122]">__cxa_pure_virtual</a> from C:\Keil_v5\ARM\ARMCC\Bin\..\lib\cpplib\cpprt_w.l(pure_virt.o)(i.__cxa_pure_virtual) referenced 7 times from .\build\at_cellularstack.o(.constdata__ZTVN4mbed16AT_CellularStackE)
 <LI><a href="#[122]">__cxa_pure_virtual</a> from C:\Keil_v5\ARM\ARMCC\Bin\..\lib\cpplib\cpprt_w.l(pure_virt.o)(i.__cxa_pure_virtual) referenced 3 times from .\build\at_cellularinformation.o(.constdata__ZTVN4mbed19CellularInformationE)
 <LI><a href="#[122]">__cxa_pure_virtual</a> from C:\Keil_v5\ARM\ARMCC\Bin\..\lib\cpplib\cpprt_w.l(pure_virt.o)(i.__cxa_pure_virtual) referenced 2 times from .\build\stream.o(.constdata__ZTVN4mbed6StreamE)
 <LI><a href="#[122]">__cxa_pure_virtual</a> from C:\Keil_v5\ARM\ARMCC\Bin\..\lib\cpplib\cpprt_w.l(pure_virt.o)(i.__cxa_pure_virtual) referenced 4 times from .\build\stream.o(.constdata__ZTVN4mbed8FileLikeE)
 <LI><a href="#[1d9]">__main</a> from C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(__main.o)(!!!main) referenced from .\build\startup_efm32wg.o(.text)
 <LI><a href="#[1d6]">__sti___12_ppp_lwip_cpp_b3a13e7c</a> from .\build\ppp_lwip.o(i.__sti___12_ppp_lwip_cpp_b3a13e7c) referenced from .\build\ppp_lwip.o(.init_array)
 <LI><a href="#[1d5]">__sti___17_arm_hal_timer_cpp_749a681d</a> from .\build\arm_hal_timer.o(i.__sti___17_arm_hal_timer_cpp_749a681d) referenced from .\build\arm_hal_timer.o(.init_array)
 <LI><a href="#[1d7]">__sti___7_SPI_cpp_ab1f1164</a> from .\build\spi.o(i.__sti___7_SPI_cpp_ab1f1164) referenced from .\build\spi.o(.init_array)
 <LI><a href="#[1d8]">__sti___8_main_cpp_led0</a> from .\build\main.o(i.__sti___8_main_cpp_led0) referenced from .\build\main.o(.init_array)
 <LI><a href="#[4d]">_fputc$unlocked</a> from C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(fputc.o)(i.fputc) referenced from C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(_printf_char_file_locked.o)(.text)
 <LI><a href="#[45]">_get_lc_ctype</a> from C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(lc_ctype_c.o)(locale$$code) referenced from C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(rt_ctype_table.o)(.text)
 <LI><a href="#[4a]">_printf_input_char</a> from C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(_printf_char_common.o)(.text) referenced from C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(_printf_char_common.o)(.text)
 <LI><a href="#[49]">_sbackspace</a> from C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(_sgetc.o)(.text) referenced from C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(__0sscanf.o)(.text)
 <LI><a href="#[4b]">_scanf_char_input</a> from C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(scanf_char.o)(.text) referenced from C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(scanf_char.o)(.text)
 <LI><a href="#[48]">_sgetc</a> from C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(_sgetc.o)(.text) referenced from C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(__0sscanf.o)(.text)
 <LI><a href="#[46]">_snputc</a> from C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(_snputc.o)(.text) referenced 2 times from C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(vsnprintf.o)(.text)
 <LI><a href="#[47]">_sputc</a> from C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(_sputc.o)(.text) referenced from C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(__2sprintf.o)(.text)
 <LI><a href="#[6f]">accept_function</a> from .\build\lwip_api_msg.o(i.accept_function) referenced from .\build\lwip_api_msg.o(i.lwip_netconn_do_listen)
 <LI><a href="#[cc]">chap_init</a> from .\build\lwip_chap-new.o(i.chap_init) referenced from .\build\lwip_chap-new.o(.constdata)
 <LI><a href="#[cd]">chap_input</a> from .\build\lwip_chap-new.o(i.chap_input) referenced from .\build\lwip_chap-new.o(.constdata)
 <LI><a href="#[d0]">chap_lowerdown</a> from .\build\lwip_chap-new.o(i.chap_lowerdown) referenced from .\build\lwip_chap-new.o(.constdata)
 <LI><a href="#[cf]">chap_lowerup</a> from .\build\lwip_chap-new.o(i.chap_lowerup) referenced from .\build\lwip_chap-new.o(.constdata)
 <LI><a href="#[cb]">chap_md5_make_response</a> from .\build\lwip_chap-md5.o(i.chap_md5_make_response) referenced from .\build\lwip_chap-md5.o(.constdata)
 <LI><a href="#[ce]">chap_protrej</a> from .\build\lwip_chap-new.o(i.chap_protrej) referenced from .\build\lwip_chap-new.o(.constdata)
 <LI><a href="#[61]">cyclic_timer</a> from .\build\lwip_timeouts.o(i.cyclic_timer) referenced from .\build\lwip_timeouts.o(i.cyclic_timer)
 <LI><a href="#[61]">cyclic_timer</a> from .\build\lwip_timeouts.o(i.cyclic_timer) referenced from .\build\lwip_timeouts.o(i.sys_timeouts_init)
 <LI><a href="#[62]">dns_recv</a> from .\build\lwip_dns.o(i.dns_recv) referenced from .\build\lwip_dns.o(i.dns_alloc_random_port)
 <LI><a href="#[10d]">dns_tmr</a> from .\build\lwip_dns.o(i.dns_tmr) referenced from .\build\lwip_timeouts.o(.constdata)
 <LI><a href="#[63]">ecallback_dispatch</a> from .\build\equeue.o(i.ecallback_dispatch) referenced from .\build\equeue.o(i.equeue_call_in)
 <LI><a href="#[65]">equeue_chain_dispatch</a> from .\build\equeue.o(i.equeue_chain_dispatch) referenced from .\build\equeue.o(i.equeue_chain_update)
 <LI><a href="#[64]">equeue_chain_update</a> from .\build\equeue.o(i.equeue_chain_update) referenced from .\build\equeue.o(i.equeue_chain)
 <LI><a href="#[6c]">err_tcp</a> from .\build\lwip_api_msg.o(i.err_tcp) referenced from .\build\lwip_api_msg.o(i.lwip_netconn_do_close_internal)
 <LI><a href="#[6c]">err_tcp</a> from .\build\lwip_api_msg.o(i.err_tcp) referenced from .\build\lwip_api_msg.o(i.setup_tcp)
 <LI><a href="#[66]">fsm_timeout</a> from .\build\lwip_fsm.o(i.fsm_timeout) referenced from .\build\lwip_fsm.o(i.fsm_lowerdown)
 <LI><a href="#[66]">fsm_timeout</a> from .\build\lwip_fsm.o(i.fsm_timeout) referenced from .\build\lwip_fsm.o(i.fsm_protreject)
 <LI><a href="#[66]">fsm_timeout</a> from .\build\lwip_fsm.o(i.fsm_timeout) referenced from .\build\lwip_fsm.o(i.fsm_rconfack)
 <LI><a href="#[66]">fsm_timeout</a> from .\build\lwip_fsm.o(i.fsm_timeout) referenced from .\build\lwip_fsm.o(i.fsm_rconfnakrej)
 <LI><a href="#[66]">fsm_timeout</a> from .\build\lwip_fsm.o(i.fsm_timeout) referenced from .\build\lwip_fsm.o(i.fsm_rconfreq)
 <LI><a href="#[66]">fsm_timeout</a> from .\build\lwip_fsm.o(i.fsm_timeout) referenced from .\build\lwip_fsm.o(i.fsm_rtermack)
 <LI><a href="#[66]">fsm_timeout</a> from .\build\lwip_fsm.o(i.fsm_timeout) referenced from .\build\lwip_fsm.o(i.fsm_rtermreq)
 <LI><a href="#[66]">fsm_timeout</a> from .\build\lwip_fsm.o(i.fsm_timeout) referenced from .\build\lwip_fsm.o(i.fsm_sconfreq)
 <LI><a href="#[66]">fsm_timeout</a> from .\build\lwip_fsm.o(i.fsm_timeout) referenced from .\build\lwip_fsm.o(i.fsm_timeout)
 <LI><a href="#[66]">fsm_timeout</a> from .\build\lwip_fsm.o(i.fsm_timeout) referenced from .\build\lwip_fsm.o(i.terminate_layer)
 <LI><a href="#[10c]">igmp_tmr</a> from .\build\lwip_igmp.o(i.igmp_tmr) referenced from .\build\lwip_timeouts.o(.constdata)
 <LI><a href="#[10b]">ip_reass_tmr</a> from .\build\lwip_ip4_frag.o(i.ip_reass_tmr) referenced from .\build\lwip_timeouts.o(.constdata)
 <LI><a href="#[d4]">ipcp_ackci</a> from .\build\lwip_ipcp.o(i.ipcp_ackci) referenced from .\build\lwip_ipcp.o(.constdata)
 <LI><a href="#[d3]">ipcp_addci</a> from .\build\lwip_ipcp.o(i.ipcp_addci) referenced from .\build\lwip_ipcp.o(.constdata)
 <LI><a href="#[d2]">ipcp_cilen</a> from .\build\lwip_ipcp.o(i.ipcp_cilen) referenced from .\build\lwip_ipcp.o(.constdata)
 <LI><a href="#[e1]">ipcp_close</a> from .\build\lwip_ipcp.o(i.ipcp_close) referenced from .\build\lwip_ipcp.o(.constdata)
 <LI><a href="#[d9]">ipcp_down</a> from .\build\lwip_ipcp.o(i.ipcp_down) referenced from .\build\lwip_ipcp.o(.constdata)
 <LI><a href="#[da]">ipcp_finished</a> from .\build\lwip_ipcp.o(i.ipcp_finished) referenced from .\build\lwip_ipcp.o(.constdata)
 <LI><a href="#[db]">ipcp_init</a> from .\build\lwip_ipcp.o(i.ipcp_init) referenced from .\build\lwip_ipcp.o(.constdata)
 <LI><a href="#[dc]">ipcp_input</a> from .\build\lwip_ipcp.o(i.ipcp_input) referenced from .\build\lwip_ipcp.o(.constdata)
 <LI><a href="#[df]">ipcp_lowerdown</a> from .\build\lwip_ipcp.o(i.ipcp_lowerdown) referenced from .\build\lwip_ipcp.o(.constdata)
 <LI><a href="#[de]">ipcp_lowerup</a> from .\build\lwip_ipcp.o(i.ipcp_lowerup) referenced from .\build\lwip_ipcp.o(.constdata)
 <LI><a href="#[d5]">ipcp_nakci</a> from .\build\lwip_ipcp.o(i.ipcp_nakci) referenced from .\build\lwip_ipcp.o(.constdata)
 <LI><a href="#[e0]">ipcp_open</a> from .\build\lwip_ipcp.o(i.ipcp_open) referenced from .\build\lwip_ipcp.o(.constdata)
 <LI><a href="#[dd]">ipcp_protrej</a> from .\build\lwip_ipcp.o(i.ipcp_protrej) referenced from .\build\lwip_ipcp.o(.constdata)
 <LI><a href="#[d6]">ipcp_rejci</a> from .\build\lwip_ipcp.o(i.ipcp_rejci) referenced from .\build\lwip_ipcp.o(.constdata)
 <LI><a href="#[d7]">ipcp_reqci</a> from .\build\lwip_ipcp.o(i.ipcp_reqci) referenced from .\build\lwip_ipcp.o(.constdata)
 <LI><a href="#[d1]">ipcp_resetci</a> from .\build\lwip_ipcp.o(i.ipcp_resetci) referenced from .\build\lwip_ipcp.o(.constdata)
 <LI><a href="#[d8]">ipcp_up</a> from .\build\lwip_ipcp.o(i.ipcp_up) referenced from .\build\lwip_ipcp.o(.constdata)
 <LI><a href="#[67]">ipfrag_free_pbuf_custom</a> from .\build\lwip_ip4_frag.o(i.ipfrag_free_pbuf_custom) referenced from .\build\lwip_ip4_frag.o(i.ip4_frag)
 <LI><a href="#[4c]">isspace</a> from .\build\greentea_test_env.o(i.isspace) referenced from C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(scanf_char.o)(.text)
 <LI><a href="#[e5]">lcp_ackci</a> from .\build\lwip_lcp.o(i.lcp_ackci) referenced from .\build\lwip_lcp.o(.constdata)
 <LI><a href="#[e4]">lcp_addci</a> from .\build\lwip_lcp.o(i.lcp_addci) referenced from .\build\lwip_lcp.o(.constdata)
 <LI><a href="#[e3]">lcp_cilen</a> from .\build\lwip_lcp.o(i.lcp_cilen) referenced from .\build\lwip_lcp.o(.constdata)
 <LI><a href="#[f4]">lcp_close</a> from .\build\lwip_lcp.o(i.lcp_close) referenced from .\build\lwip_lcp.o(.constdata)
 <LI><a href="#[68]">lcp_delayed_up</a> from .\build\lwip_lcp.o(i.lcp_delayed_up) referenced from .\build\lwip_lcp.o(i.lcp_close)
 <LI><a href="#[68]">lcp_delayed_up</a> from .\build\lwip_lcp.o(i.lcp_delayed_up) referenced from .\build\lwip_lcp.o(i.lcp_input)
 <LI><a href="#[68]">lcp_delayed_up</a> from .\build\lwip_lcp.o(i.lcp_delayed_up) referenced from .\build\lwip_lcp.o(i.lcp_lowerdown)
 <LI><a href="#[68]">lcp_delayed_up</a> from .\build\lwip_lcp.o(i.lcp_delayed_up) referenced from .\build\lwip_lcp.o(i.lcp_lowerup)
 <LI><a href="#[ea]">lcp_down</a> from .\build\lwip_lcp.o(i.lcp_down) referenced from .\build\lwip_lcp.o(.constdata)
 <LI><a href="#[ed]">lcp_extcode</a> from .\build\lwip_lcp.o(i.lcp_extcode) referenced from .\build\lwip_lcp.o(.constdata)
 <LI><a href="#[ec]">lcp_finished</a> from .\build\lwip_lcp.o(i.lcp_finished) referenced from .\build\lwip_lcp.o(.constdata)
 <LI><a href="#[ee]">lcp_init</a> from .\build\lwip_lcp.o(i.lcp_init) referenced from .\build\lwip_lcp.o(.constdata)
 <LI><a href="#[ef]">lcp_input</a> from .\build\lwip_lcp.o(i.lcp_input) referenced from .\build\lwip_lcp.o(.constdata)
 <LI><a href="#[f2]">lcp_lowerdown</a> from .\build\lwip_lcp.o(i.lcp_lowerdown) referenced from .\build\lwip_lcp.o(.constdata)
 <LI><a href="#[f1]">lcp_lowerup</a> from .\build\lwip_lcp.o(i.lcp_lowerup) referenced from .\build\lwip_lcp.o(.constdata)
 <LI><a href="#[e6]">lcp_nakci</a> from .\build\lwip_lcp.o(i.lcp_nakci) referenced from .\build\lwip_lcp.o(.constdata)
 <LI><a href="#[f3]">lcp_open</a> from .\build\lwip_lcp.o(i.lcp_open) referenced from .\build\lwip_lcp.o(.constdata)
 <LI><a href="#[f0]">lcp_protrej</a> from .\build\lwip_lcp.o(i.lcp_protrej) referenced from .\build\lwip_lcp.o(.constdata)
 <LI><a href="#[e7]">lcp_rejci</a> from .\build\lwip_lcp.o(i.lcp_rejci) referenced from .\build\lwip_lcp.o(.constdata)
 <LI><a href="#[e8]">lcp_reqci</a> from .\build\lwip_lcp.o(i.lcp_reqci) referenced from .\build\lwip_lcp.o(.constdata)
 <LI><a href="#[e2]">lcp_resetci</a> from .\build\lwip_lcp.o(i.lcp_resetci) referenced from .\build\lwip_lcp.o(.constdata)
 <LI><a href="#[eb]">lcp_starting</a> from .\build\lwip_lcp.o(i.lcp_starting) referenced from .\build\lwip_lcp.o(.constdata)
 <LI><a href="#[e9]">lcp_up</a> from .\build\lwip_lcp.o(i.lcp_up) referenced from .\build\lwip_lcp.o(.constdata)
 <LI><a href="#[b1]">leuart0_irq</a> from .\build\serial_api.o(i.leuart0_irq) referenced from .\build\serial_api.o(i.serial_preinit)
 <LI><a href="#[b2]">leuart1_irq</a> from .\build\serial_api.o(i.leuart1_irq) referenced from .\build\serial_api.o(i.serial_preinit)
 <LI><a href="#[111]">lp_ticker_clear_interrupt</a> from .\build\lp_ticker.o(i.lp_ticker_clear_interrupt) referenced from .\build\mbed_lp_ticker_api.o(.constdata)
 <LI><a href="#[110]">lp_ticker_disable_interrupt</a> from .\build\lp_ticker.o(i.lp_ticker_disable_interrupt) referenced from .\build\mbed_lp_ticker_api.o(.constdata)
 <LI><a href="#[113]">lp_ticker_fire_interrupt</a> from .\build\lp_ticker.o(i.lp_ticker_fire_interrupt) referenced from .\build\mbed_lp_ticker_api.o(.constdata)
 <LI><a href="#[114]">lp_ticker_get_info</a> from .\build\mbed_retarget.o(i.lp_ticker_get_info) referenced from .\build\mbed_lp_ticker_api.o(.constdata)
 <LI><a href="#[10e]">lp_ticker_init</a> from .\build\lp_ticker.o(i.lp_ticker_init) referenced from .\build\mbed_lp_ticker_api.o(.constdata)
 <LI><a href="#[69]">lp_ticker_irq_handler</a> from .\build\mbed_lp_ticker_api.o(i.lp_ticker_irq_handler) referenced from .\build\lp_ticker.o(i.lp_ticker_init)
 <LI><a href="#[10f]">lp_ticker_read</a> from .\build\lp_ticker.o(i.lp_ticker_read) referenced from .\build\mbed_lp_ticker_api.o(.constdata)
 <LI><a href="#[112]">lp_ticker_set_interrupt</a> from .\build\lp_ticker.o(i.lp_ticker_set_interrupt) referenced from .\build\mbed_lp_ticker_api.o(.constdata)
 <LI><a href="#[76]">lwip_netconn_do_bind</a> from .\build\lwip_api_msg.o(i.lwip_netconn_do_bind) referenced from .\build\lwip_api_lib.o(i.netconn_bind)
 <LI><a href="#[77]">lwip_netconn_do_close</a> from .\build\lwip_api_msg.o(i.lwip_netconn_do_close) referenced from .\build\lwip_api_lib.o(i.netconn_close_shutdown)
 <LI><a href="#[78]">lwip_netconn_do_connect</a> from .\build\lwip_api_msg.o(i.lwip_netconn_do_connect) referenced from .\build\lwip_api_lib.o(i.netconn_connect)
 <LI><a href="#[6d]">lwip_netconn_do_connected</a> from .\build\lwip_api_msg.o(i.lwip_netconn_do_connected) referenced from .\build\lwip_api_msg.o(i.lwip_netconn_do_connect)
 <LI><a href="#[79]">lwip_netconn_do_delconn</a> from .\build\lwip_api_msg.o(i.lwip_netconn_do_delconn) referenced from .\build\lwip_api_lib.o(i.netconn_delete)
 <LI><a href="#[6e]">lwip_netconn_do_dns_found</a> from .\build\lwip_api_msg.o(i.lwip_netconn_do_dns_found) referenced from .\build\lwip_api_msg.o(i.lwip_netconn_do_gethostbyname)
 <LI><a href="#[7a]">lwip_netconn_do_getaddr</a> from .\build\lwip_api_msg.o(i.lwip_netconn_do_getaddr) referenced from .\build\lwip_api_lib.o(i.netconn_getaddr)
 <LI><a href="#[7b]">lwip_netconn_do_gethostbyname</a> from .\build\lwip_api_msg.o(i.lwip_netconn_do_gethostbyname) referenced from .\build\lwip_api_lib.o(i.netconn_gethostbyname)
 <LI><a href="#[7c]">lwip_netconn_do_listen</a> from .\build\lwip_api_msg.o(i.lwip_netconn_do_listen) referenced from .\build\lwip_api_lib.o(i.netconn_listen_with_backlog)
 <LI><a href="#[7d]">lwip_netconn_do_newconn</a> from .\build\lwip_api_msg.o(i.lwip_netconn_do_newconn) referenced from .\build\lwip_api_lib.o(i.netconn_new_with_proto_and_callback)
 <LI><a href="#[7e]">lwip_netconn_do_recv</a> from .\build\lwip_api_msg.o(i.lwip_netconn_do_recv) referenced from .\build\lwip_api_lib.o(i.netconn_recv_data)
 <LI><a href="#[7f]">lwip_netconn_do_send</a> from .\build\lwip_api_msg.o(i.lwip_netconn_do_send) referenced from .\build\lwip_api_lib.o(i.netconn_send)
 <LI><a href="#[80]">lwip_netconn_do_write</a> from .\build\lwip_api_msg.o(i.lwip_netconn_do_write) referenced from .\build\lwip_api_lib.o(i.netconn_write_partly)
 <LI><a href="#[42]">mbed_fault_handler</a> from .\build\mbed_rtx_fault_handler.o(i.mbed_fault_handler) referenced from .\build\except.o(.text)
 <LI><a href="#[fd]">mbed_lwip_add_dns_server</a> from .\build\lwip_stack.o(i.mbed_lwip_add_dns_server) referenced from .\build\lwip_stack.o(.constdata)
 <LI><a href="#[fc]">mbed_lwip_gethostbyname</a> from .\build\lwip_stack.o(i.mbed_lwip_gethostbyname) referenced from .\build\lwip_stack.o(.constdata)
 <LI><a href="#[71]">mbed_lwip_netif_link_irq</a> from .\build\lwip_stack.o(i.mbed_lwip_netif_link_irq) referenced from .\build\lwip_stack.o(i.mbed_lwip_bringup_2)
 <LI><a href="#[72]">mbed_lwip_netif_status_irq</a> from .\build\lwip_stack.o(i.mbed_lwip_netif_status_irq) referenced from .\build\lwip_stack.o(i.mbed_lwip_bringup_2)
 <LI><a href="#[109]">mbed_lwip_setsockopt</a> from .\build\lwip_stack.o(i.mbed_lwip_setsockopt) referenced from .\build\lwip_stack.o(.constdata)
 <LI><a href="#[103]">mbed_lwip_socket_accept</a> from .\build\lwip_stack.o(i.mbed_lwip_socket_accept) referenced from .\build\lwip_stack.o(.constdata)
 <LI><a href="#[108]">mbed_lwip_socket_attach</a> from .\build\lwip_stack.o(i.mbed_lwip_socket_attach) referenced from .\build\lwip_stack.o(.constdata)
 <LI><a href="#[100]">mbed_lwip_socket_bind</a> from .\build\lwip_stack.o(i.mbed_lwip_socket_bind) referenced from .\build\lwip_stack.o(.constdata)
 <LI><a href="#[74]">mbed_lwip_socket_callback</a> from .\build\lwip_stack.o(i.mbed_lwip_socket_callback) referenced from .\build\lwip_stack.o(i.mbed_lwip_socket_open)
 <LI><a href="#[ff]">mbed_lwip_socket_close</a> from .\build\lwip_stack.o(i.mbed_lwip_socket_close) referenced from .\build\lwip_stack.o(.constdata)
 <LI><a href="#[102]">mbed_lwip_socket_connect</a> from .\build\lwip_stack.o(i.mbed_lwip_socket_connect) referenced from .\build\lwip_stack.o(.constdata)
 <LI><a href="#[101]">mbed_lwip_socket_listen</a> from .\build\lwip_stack.o(i.mbed_lwip_socket_listen) referenced from .\build\lwip_stack.o(.constdata)
 <LI><a href="#[fe]">mbed_lwip_socket_open</a> from .\build\lwip_stack.o(i.mbed_lwip_socket_open) referenced from .\build\lwip_stack.o(.constdata)
 <LI><a href="#[105]">mbed_lwip_socket_recv</a> from .\build\lwip_stack.o(i.mbed_lwip_socket_recv) referenced from .\build\lwip_stack.o(.constdata)
 <LI><a href="#[107]">mbed_lwip_socket_recvfrom</a> from .\build\lwip_stack.o(i.mbed_lwip_socket_recvfrom) referenced from .\build\lwip_stack.o(.constdata)
 <LI><a href="#[104]">mbed_lwip_socket_send</a> from .\build\lwip_stack.o(i.mbed_lwip_socket_send) referenced from .\build\lwip_stack.o(.constdata)
 <LI><a href="#[106]">mbed_lwip_socket_sendto</a> from .\build\lwip_stack.o(i.mbed_lwip_socket_sendto) referenced from .\build\lwip_stack.o(.constdata)
 <LI><a href="#[73]">mbed_lwip_tcpip_init_irq</a> from .\build\lwip_stack.o(i.mbed_lwip_tcpip_init_irq) referenced from .\build\lwip_stack.o(i.mbed_lwip_core_init)
 <LI><a href="#[b4]">osRtxEventFlagsPostProcess</a> from .\build\rtx_evflags.o(i.osRtxEventFlagsPostProcess) referenced from .\build\rtx_evflags.o(i.svcRtxEventFlagsNew)
 <LI><a href="#[b5]">osRtxIdleThread</a> from .\build\mbed_rtx_handlers.o(i.osRtxIdleThread) referenced from .\build\rtx_kernel.o(i.svcRtxKernelStart)
 <LI><a href="#[b7]">osRtxMessageQueuePostProcess</a> from .\build\rtx_msgqueue.o(i.osRtxMessageQueuePostProcess) referenced from .\build\rtx_msgqueue.o(i.svcRtxMessageQueueNew)
 <LI><a href="#[b8]">osRtxSemaphorePostProcess</a> from .\build\rtx_semaphore.o(i.osRtxSemaphorePostProcess) referenced from .\build\rtx_semaphore.o(i.svcRtxSemaphoreNew)
 <LI><a href="#[ba]">osRtxThreadPostProcess</a> from .\build\rtx_thread.o(i.osRtxThreadPostProcess) referenced from .\build\rtx_thread.o(i.svcRtxThreadNew)
 <LI><a href="#[b6]">osRtxTimerThread</a> from .\build\rtx_timer.o(i.osRtxTimerThread) referenced from .\build\rtx_kernel.o(i.svcRtxKernelStart)
 <LI><a href="#[93]">osRtxTimerTick</a> from .\build\rtx_timer.o(i.osRtxTimerTick) referenced from .\build\rtx_timer.o(i.osRtxTimerThread)
 <LI><a href="#[b9]">osThreadExit</a> from .\build\rtx_thread.o(i.osThreadExit) referenced from .\build\rtx_thread.o(i.svcRtxThreadNew)
 <LI><a href="#[6b]">poll_tcp</a> from .\build\lwip_api_msg.o(i.poll_tcp) referenced from .\build\lwip_api_msg.o(i.lwip_netconn_do_close_internal)
 <LI><a href="#[6b]">poll_tcp</a> from .\build\lwip_api_msg.o(i.poll_tcp) referenced from .\build\lwip_api_msg.o(i.setup_tcp)
 <LI><a href="#[a0]">ppp_do_connect</a> from .\build\lwip_ppp.o(i.ppp_do_connect) referenced from .\build\lwip_ppp.o(i.ppp_close)
 <LI><a href="#[a0]">ppp_do_connect</a> from .\build\lwip_ppp.o(i.ppp_do_connect) referenced from .\build\lwip_ppp.o(i.ppp_connect)
 <LI><a href="#[a5]">ppp_netif_init_cb</a> from .\build\lwip_ppp.o(i.ppp_netif_init_cb) referenced from .\build\lwip_ppp.o(i.ppp_new)
 <LI><a href="#[a4]">ppp_netif_output_ip4</a> from .\build\lwip_ppp.o(i.ppp_netif_output_ip4) referenced from .\build\lwip_ppp.o(i.ppp_netif_init_cb)
 <LI><a href="#[f5]">pppos_connect</a> from .\build\lwip_pppos.o(i.pppos_connect) referenced from .\build\lwip_pppos.o(.constdata)
 <LI><a href="#[f7]">pppos_destroy</a> from .\build\lwip_pppos.o(i.pppos_destroy) referenced from .\build\lwip_pppos.o(.constdata)
 <LI><a href="#[f6]">pppos_disconnect</a> from .\build\lwip_pppos.o(i.pppos_disconnect) referenced from .\build\lwip_pppos.o(.constdata)
 <LI><a href="#[a6]">pppos_input_callback</a> from .\build\lwip_pppos.o(i.pppos_input_callback) referenced from .\build\lwip_pppos.o(i.pppos_input)
 <LI><a href="#[f9]">pppos_netif_output</a> from .\build\lwip_pppos.o(i.pppos_netif_output) referenced from .\build\lwip_pppos.o(.constdata)
 <LI><a href="#[fb]">pppos_recv_config</a> from .\build\lwip_pppos.o(i.pppos_recv_config) referenced from .\build\lwip_pppos.o(.constdata)
 <LI><a href="#[fa]">pppos_send_config</a> from .\build\lwip_pppos.o(i.pppos_send_config) referenced from .\build\lwip_pppos.o(.constdata)
 <LI><a href="#[f8]">pppos_write</a> from .\build\lwip_pppos.o(i.pppos_write) referenced from .\build\lwip_pppos.o(.constdata)
 <LI><a href="#[75]">pre_main</a> from .\build\mbed_boot.o(i.pre_main) referenced from .\build\mbed_boot.o(i.mbed_start_main)
 <LI><a href="#[b3]">recv_tcp</a> from .\build\lwip_api_msg.o(i.recv_tcp) referenced from .\build\lwip_api_msg.o(i.setup_tcp)
 <LI><a href="#[9f]">recv_udp</a> from .\build\lwip_api_msg.o(i.recv_udp) referenced from .\build\lwip_api_msg.o(i.pcb_new)
 <LI><a href="#[6a]">sent_tcp</a> from .\build\lwip_api_msg.o(i.sent_tcp) referenced from .\build\lwip_api_msg.o(i.lwip_netconn_do_close_internal)
 <LI><a href="#[6a]">sent_tcp</a> from .\build\lwip_api_msg.o(i.sent_tcp) referenced from .\build\lwip_api_msg.o(i.setup_tcp)
 <LI><a href="#[81]">svcRtxDelay</a> from .\build\rtx_delay.o(i.svcRtxDelay) referenced from .\build\rtx_delay.o(i.osDelay)
 <LI><a href="#[82]">svcRtxEventFlagsClear</a> from .\build\rtx_evflags.o(i.svcRtxEventFlagsClear) referenced from .\build\rtx_evflags.o(i.osEventFlagsClear)
 <LI><a href="#[83]">svcRtxEventFlagsDelete</a> from .\build\rtx_evflags.o(i.svcRtxEventFlagsDelete) referenced from .\build\rtx_evflags.o(i.osEventFlagsDelete)
 <LI><a href="#[84]">svcRtxEventFlagsNew</a> from .\build\rtx_evflags.o(i.svcRtxEventFlagsNew) referenced from .\build\rtx_evflags.o(i.osEventFlagsNew)
 <LI><a href="#[85]">svcRtxEventFlagsSet</a> from .\build\rtx_evflags.o(i.svcRtxEventFlagsSet) referenced from .\build\rtx_evflags.o(i.osEventFlagsSet)
 <LI><a href="#[86]">svcRtxEventFlagsWait</a> from .\build\rtx_evflags.o(i.svcRtxEventFlagsWait) referenced from .\build\rtx_evflags.o(i.osEventFlagsWait)
 <LI><a href="#[87]">svcRtxKernelGetState</a> from .\build\rtx_kernel.o(i.svcRtxKernelGetState) referenced from .\build\rtx_kernel.o(i.osKernelGetState)
 <LI><a href="#[88]">svcRtxKernelInitialize</a> from .\build\rtx_kernel.o(i.svcRtxKernelInitialize) referenced from .\build\rtx_kernel.o(i.osKernelInitialize)
 <LI><a href="#[89]">svcRtxKernelLock</a> from .\build\rtx_kernel.o(i.svcRtxKernelLock) referenced from .\build\rtx_kernel.o(i.osKernelLock)
 <LI><a href="#[8a]">svcRtxKernelRestoreLock</a> from .\build\rtx_kernel.o(i.svcRtxKernelRestoreLock) referenced from .\build\rtx_kernel.o(i.osKernelRestoreLock)
 <LI><a href="#[8b]">svcRtxKernelStart</a> from .\build\rtx_kernel.o(i.svcRtxKernelStart) referenced from .\build\rtx_kernel.o(i.osKernelStart)
 <LI><a href="#[8c]">svcRtxMessageQueueGet</a> from .\build\rtx_msgqueue.o(i.svcRtxMessageQueueGet) referenced from .\build\rtx_msgqueue.o(i.osMessageQueueGet)
 <LI><a href="#[8d]">svcRtxMessageQueueNew</a> from .\build\rtx_msgqueue.o(i.svcRtxMessageQueueNew) referenced from .\build\rtx_msgqueue.o(i.osMessageQueueNew)
 <LI><a href="#[8e]">svcRtxMessageQueuePut</a> from .\build\rtx_msgqueue.o(i.svcRtxMessageQueuePut) referenced from .\build\rtx_msgqueue.o(i.osMessageQueuePut)
 <LI><a href="#[8f]">svcRtxMutexAcquire</a> from .\build\rtx_mutex.o(i.svcRtxMutexAcquire) referenced from .\build\rtx_mutex.o(i.osMutexAcquire)
 <LI><a href="#[90]">svcRtxMutexDelete</a> from .\build\rtx_mutex.o(i.svcRtxMutexDelete) referenced from .\build\rtx_mutex.o(i.osMutexDelete)
 <LI><a href="#[91]">svcRtxMutexNew</a> from .\build\rtx_mutex.o(i.svcRtxMutexNew) referenced from .\build\rtx_mutex.o(i.osMutexNew)
 <LI><a href="#[92]">svcRtxMutexRelease</a> from .\build\rtx_mutex.o(i.svcRtxMutexRelease) referenced from .\build\rtx_mutex.o(i.osMutexRelease)
 <LI><a href="#[94]">svcRtxSemaphoreAcquire</a> from .\build\rtx_semaphore.o(i.svcRtxSemaphoreAcquire) referenced from .\build\rtx_semaphore.o(i.osSemaphoreAcquire)
 <LI><a href="#[95]">svcRtxSemaphoreDelete</a> from .\build\rtx_semaphore.o(i.svcRtxSemaphoreDelete) referenced from .\build\rtx_semaphore.o(i.osSemaphoreDelete)
 <LI><a href="#[96]">svcRtxSemaphoreGetCount</a> from .\build\rtx_semaphore.o(i.svcRtxSemaphoreGetCount) referenced from .\build\rtx_semaphore.o(i.osSemaphoreGetCount)
 <LI><a href="#[97]">svcRtxSemaphoreNew</a> from .\build\rtx_semaphore.o(i.svcRtxSemaphoreNew) referenced from .\build\rtx_semaphore.o(i.osSemaphoreNew)
 <LI><a href="#[98]">svcRtxSemaphoreRelease</a> from .\build\rtx_semaphore.o(i.svcRtxSemaphoreRelease) referenced from .\build\rtx_semaphore.o(i.osSemaphoreRelease)
 <LI><a href="#[9a]">svcRtxThreadExit</a> from .\build\rtx_thread.o(i.svcRtxThreadExit) referenced from .\build\rtx_thread.o(i.osThreadExit)
 <LI><a href="#[9b]">svcRtxThreadGetId</a> from .\build\rtx_thread.o(i.svcRtxThreadGetId) referenced from .\build\rtx_thread.o(i.osThreadGetId)
 <LI><a href="#[9c]">svcRtxThreadGetName</a> from .\build\rtx_thread.o(i.svcRtxThreadGetName) referenced from .\build\rtx_thread.o(i.osThreadGetName)
 <LI><a href="#[99]">svcRtxThreadNew</a> from .\build\rtx_thread.o(i.svcRtxThreadNew) referenced from .\build\rtx_thread.o(i.osThreadContextNew)
 <LI><a href="#[9d]">svcRtxThreadTerminate</a> from .\build\rtx_thread.o(i.svcRtxThreadTerminate) referenced from .\build\rtx_thread.o(i.osThreadTerminate)
 <LI><a href="#[9e]">svcRtxThreadYield</a> from .\build\rtx_thread.o(i.svcRtxThreadYield) referenced from .\build\rtx_thread.o(i.osThreadYield)
 <LI><a href="#[bc]">tcp_accept_null</a> from .\build\lwip_tcp.o(i.tcp_accept_null) referenced from .\build\lwip_tcp.o(i.tcp_listen_with_backlog_and_err)
 <LI><a href="#[bb]">tcp_recv_null</a> from .\build\lwip_tcp.o(i.tcp_recv_null) referenced from .\build\lwip_tcp.o(i.tcp_alloc)
 <LI><a href="#[10a]">tcp_tmr</a> from .\build\lwip_tcp.o(i.tcp_tmr) referenced from .\build\lwip_timeouts.o(.constdata)
 <LI><a href="#[bd]">tcpip_tcp_timer</a> from .\build\lwip_timeouts.o(i.tcpip_tcp_timer) referenced from .\build\lwip_timeouts.o(i.tcp_timer_needed)
 <LI><a href="#[bd]">tcpip_tcp_timer</a> from .\build\lwip_timeouts.o(i.tcpip_tcp_timer) referenced from .\build\lwip_timeouts.o(i.tcpip_tcp_timer)
 <LI><a href="#[be]">tcpip_thread</a> from .\build\lwip_tcpip.o(i.tcpip_thread) referenced from .\build\lwip_tcpip.o(i.tcpip_init)
 <LI><a href="#[e]">ticker_irq_handler</a> from .\build\mbed_ticker_api.o(i.ticker_irq_handler) referenced 4 times from .\build\mbed_lp_ticker_api.o(.data)
 <LI><a href="#[a7]">uart0_rx_irq</a> from .\build\serial_api.o(i.uart0_rx_irq) referenced from .\build\serial_api.o(i.serial_preinit)
 <LI><a href="#[a8]">uart0_tx_irq</a> from .\build\serial_api.o(i.uart0_tx_irq) referenced from .\build\serial_api.o(i.serial_preinit)
 <LI><a href="#[a9]">uart1_rx_irq</a> from .\build\serial_api.o(i.uart1_rx_irq) referenced from .\build\serial_api.o(i.serial_preinit)
 <LI><a href="#[aa]">uart1_tx_irq</a> from .\build\serial_api.o(i.uart1_tx_irq) referenced from .\build\serial_api.o(i.serial_preinit)
 <LI><a href="#[118]">us_ticker_clear_interrupt</a> from .\build\us_ticker.o(i.us_ticker_clear_interrupt) referenced from .\build\mbed_us_ticker_api.o(.constdata)
 <LI><a href="#[117]">us_ticker_disable_interrupt</a> from .\build\us_ticker.o(i.us_ticker_disable_interrupt) referenced from .\build\mbed_us_ticker_api.o(.constdata)
 <LI><a href="#[11a]">us_ticker_fire_interrupt</a> from .\build\us_ticker.o(i.us_ticker_fire_interrupt) referenced from .\build\mbed_us_ticker_api.o(.constdata)
 <LI><a href="#[11b]">us_ticker_get_info</a> from .\build\mbed_retarget.o(i.us_ticker_get_info) referenced from .\build\mbed_us_ticker_api.o(.constdata)
 <LI><a href="#[115]">us_ticker_init</a> from .\build\us_ticker.o(i.us_ticker_init) referenced from .\build\mbed_us_ticker_api.o(.constdata)
 <LI><a href="#[bf]">us_ticker_irq_handler_internal</a> from .\build\us_ticker.o(i.us_ticker_irq_handler_internal) referenced from .\build\us_ticker.o(i.us_ticker_init)
 <LI><a href="#[116]">us_ticker_read</a> from .\build\us_ticker.o(i.us_ticker_read) referenced from .\build\mbed_us_ticker_api.o(.constdata)
 <LI><a href="#[119]">us_ticker_set_interrupt</a> from .\build\us_ticker.o(i.us_ticker_set_interrupt) referenced from .\build\mbed_us_ticker_api.o(.constdata)
 <LI><a href="#[ab]">usart0_rx_irq</a> from .\build\serial_api.o(i.usart0_rx_irq) referenced from .\build\serial_api.o(i.serial_preinit)
 <LI><a href="#[ac]">usart0_tx_irq</a> from .\build\serial_api.o(i.usart0_tx_irq) referenced from .\build\serial_api.o(i.serial_preinit)
 <LI><a href="#[ad]">usart1_rx_irq</a> from .\build\serial_api.o(i.usart1_rx_irq) referenced from .\build\serial_api.o(i.serial_preinit)
 <LI><a href="#[ae]">usart1_tx_irq</a> from .\build\serial_api.o(i.usart1_tx_irq) referenced from .\build\serial_api.o(i.serial_preinit)
 <LI><a href="#[af]">usart2_rx_irq</a> from .\build\serial_api.o(i.usart2_rx_irq) referenced from .\build\serial_api.o(i.serial_preinit)
 <LI><a href="#[b0]">usart2_tx_irq</a> from .\build\serial_api.o(i.usart2_tx_irq) referenced from .\build\serial_api.o(i.serial_preinit)
</UL>
<P>
<H3>
Global Symbols
</H3>
<P><STRONG><a name="[1d9]"></a>__main</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(__main.o)(!!!main))
<BR><BR>[Stack]<UL><LI>Max Depth = 672 + Unknown Stack Size
<LI>Call Chain = __main &rArr; __rt_entry &rArr; mbed_sdk_init &rArr; gpio_init_out_ex &rArr; _gpio_init_out &rArr; gpio_dir &rArr; gpio_mode &rArr; pin_mode &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[1de]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_entry
<LI><a href="#[1dd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__scatterload
</UL>

<P><STRONG><a name="[1dd]"></a>__scatterload</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(__scatter.o)(!!!scatter))
<BR><BR>[Called By]<UL><LI><a href="#[1d9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__main
</UL>

<P><STRONG><a name="[1df]"></a>__scatterload_rt2</STRONG> (Thumb, 44 bytes, Stack size unknown bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(__scatter.o)(!!!scatter), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[1de]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_entry
</UL>

<P><STRONG><a name="[6d7]"></a>__scatterload_rt2_thumb_only</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(__scatter.o)(!!!scatter), UNUSED)

<P><STRONG><a name="[6d8]"></a>__scatterload_null</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(__scatter.o)(!!!scatter), UNUSED)

<P><STRONG><a name="[6d9]"></a>__decompress</STRONG> (Thumb, 90 bytes, Stack size unknown bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(__dczerorl2.o)(!!dczerorl2), UNUSED)

<P><STRONG><a name="[6da]"></a>__decompress1</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(__dczerorl2.o)(!!dczerorl2), UNUSED)

<P><STRONG><a name="[6db]"></a>__scatterload_zeroinit</STRONG> (Thumb, 28 bytes, Stack size unknown bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(__scatter_zi.o)(!!handler_zi), UNUSED)

<P><STRONG><a name="[1e0]"></a>_printf_n</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(_printf_n.o)(.ARM.Collect$$_printf_percent$$00000001))
<BR><BR>[Calls]<UL><LI><a href="#[1e1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_charcount
</UL>

<P><STRONG><a name="[230]"></a>_printf_percent</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(_printf_percent.o)(.ARM.Collect$$_printf_percent$$00000000))
<BR><BR>[Called By]<UL><LI><a href="#[22e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__printf
</UL>

<P><STRONG><a name="[1e2]"></a>_printf_p</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(_printf_p.o)(.ARM.Collect$$_printf_percent$$00000002))
<BR><BR>[Stack]<UL><LI>Max Depth = 64 + Unknown Stack Size
<LI>Call Chain = _printf_p &rArr; _printf_hex_ptr &rArr; _printf_longlong_hex &rArr; _printf_int_common &rArr; _printf_post_padding
</UL>
<BR>[Calls]<UL><LI><a href="#[1e3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_hex_ptr
</UL>

<P><STRONG><a name="[1e4]"></a>_printf_f</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(_printf_f.o)(.ARM.Collect$$_printf_percent$$00000003))
<BR><BR>[Stack]<UL><LI>Max Depth = 324 + Unknown Stack Size
<LI>Call Chain = _printf_f &rArr; _printf_fp_dec &rArr; _printf_fp_dec_real &rArr; _fp_digits &rArr; _btod_etento &rArr; _btod_emul &rArr; _e2e
</UL>
<BR>[Calls]<UL><LI><a href="#[1e5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_fp_dec
</UL>

<P><STRONG><a name="[1e6]"></a>_printf_e</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(_printf_e.o)(.ARM.Collect$$_printf_percent$$00000004))
<BR><BR>[Stack]<UL><LI>Max Depth = 324 + Unknown Stack Size
<LI>Call Chain = _printf_e &rArr; _printf_fp_dec &rArr; _printf_fp_dec_real &rArr; _fp_digits &rArr; _btod_etento &rArr; _btod_emul &rArr; _e2e
</UL>
<BR>[Calls]<UL><LI><a href="#[1e5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_fp_dec
</UL>

<P><STRONG><a name="[1e7]"></a>_printf_g</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(_printf_g.o)(.ARM.Collect$$_printf_percent$$00000005))
<BR><BR>[Stack]<UL><LI>Max Depth = 324 + Unknown Stack Size
<LI>Call Chain = _printf_g &rArr; _printf_fp_dec &rArr; _printf_fp_dec_real &rArr; _fp_digits &rArr; _btod_etento &rArr; _btod_emul &rArr; _e2e
</UL>
<BR>[Calls]<UL><LI><a href="#[1e5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_fp_dec
</UL>

<P><STRONG><a name="[1e8]"></a>_printf_a</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(_printf_a.o)(.ARM.Collect$$_printf_percent$$00000006))
<BR><BR>[Stack]<UL><LI>Max Depth = 112 + Unknown Stack Size
<LI>Call Chain = _printf_a &rArr; _printf_fp_hex &rArr; _printf_fp_hex_real &rArr; _printf_fp_infnan &rArr; _printf_post_padding
</UL>
<BR>[Calls]<UL><LI><a href="#[1e9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_fp_hex
</UL>

<P><STRONG><a name="[6dc]"></a>_printf_ll</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(_printf_ll.o)(.ARM.Collect$$_printf_percent$$00000007))

<P><STRONG><a name="[1ea]"></a>_printf_i</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(_printf_i.o)(.ARM.Collect$$_printf_percent$$00000008))
<BR><BR>[Stack]<UL><LI>Max Depth = 72 + Unknown Stack Size
<LI>Call Chain = _printf_i &rArr; _printf_int_dec &rArr; _printf_int_common &rArr; _printf_post_padding
</UL>
<BR>[Calls]<UL><LI><a href="#[1eb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_int_dec
</UL>

<P><STRONG><a name="[1ec]"></a>_printf_d</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(_printf_d.o)(.ARM.Collect$$_printf_percent$$00000009))
<BR><BR>[Stack]<UL><LI>Max Depth = 72 + Unknown Stack Size
<LI>Call Chain = _printf_d &rArr; _printf_int_dec &rArr; _printf_int_common &rArr; _printf_post_padding
</UL>
<BR>[Calls]<UL><LI><a href="#[1eb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_int_dec
</UL>

<P><STRONG><a name="[1ed]"></a>_printf_u</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(_printf_u.o)(.ARM.Collect$$_printf_percent$$0000000A))
<BR><BR>[Stack]<UL><LI>Max Depth = 72 + Unknown Stack Size
<LI>Call Chain = _printf_u &rArr; _printf_int_dec &rArr; _printf_int_common &rArr; _printf_post_padding
</UL>
<BR>[Calls]<UL><LI><a href="#[1eb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_int_dec
</UL>

<P><STRONG><a name="[1ee]"></a>_printf_o</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(_printf_o.o)(.ARM.Collect$$_printf_percent$$0000000B))
<BR><BR>[Stack]<UL><LI>Max Depth = 64 + Unknown Stack Size
<LI>Call Chain = _printf_o &rArr; _printf_int_oct &rArr; _printf_longlong_oct &rArr; _printf_int_common &rArr; _printf_post_padding
</UL>
<BR>[Calls]<UL><LI><a href="#[1ef]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_int_oct
</UL>

<P><STRONG><a name="[1f0]"></a>_printf_x</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(_printf_x.o)(.ARM.Collect$$_printf_percent$$0000000C))
<BR><BR>[Stack]<UL><LI>Max Depth = 80 + Unknown Stack Size
<LI>Call Chain = _printf_x &rArr; _printf_int_hex &rArr; _printf_longlong_hex &rArr; _printf_int_common &rArr; _printf_post_padding
</UL>
<BR>[Calls]<UL><LI><a href="#[1f1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_int_hex
</UL>

<P><STRONG><a name="[1f2]"></a>_printf_lli</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(_printf_lli.o)(.ARM.Collect$$_printf_percent$$0000000D))
<BR><BR>[Stack]<UL><LI>Max Depth = 72 + Unknown Stack Size
<LI>Call Chain = _printf_lli &rArr; _printf_longlong_dec &rArr; _printf_int_common &rArr; _printf_post_padding
</UL>
<BR>[Calls]<UL><LI><a href="#[1f3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_longlong_dec
</UL>

<P><STRONG><a name="[1f4]"></a>_printf_lld</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(_printf_lld.o)(.ARM.Collect$$_printf_percent$$0000000E))
<BR><BR>[Stack]<UL><LI>Max Depth = 72 + Unknown Stack Size
<LI>Call Chain = _printf_lld &rArr; _printf_longlong_dec &rArr; _printf_int_common &rArr; _printf_post_padding
</UL>
<BR>[Calls]<UL><LI><a href="#[1f3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_longlong_dec
</UL>

<P><STRONG><a name="[1f5]"></a>_printf_llu</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(_printf_llu.o)(.ARM.Collect$$_printf_percent$$0000000F))
<BR><BR>[Stack]<UL><LI>Max Depth = 72 + Unknown Stack Size
<LI>Call Chain = _printf_llu &rArr; _printf_longlong_dec &rArr; _printf_int_common &rArr; _printf_post_padding
</UL>
<BR>[Calls]<UL><LI><a href="#[1f3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_longlong_dec
</UL>

<P><STRONG><a name="[1f6]"></a>_printf_llo</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(_printf_llo.o)(.ARM.Collect$$_printf_percent$$00000010))
<BR><BR>[Stack]<UL><LI>Max Depth = 56 + Unknown Stack Size
<LI>Call Chain = _printf_llo &rArr; _printf_ll_oct &rArr; _printf_longlong_oct &rArr; _printf_int_common &rArr; _printf_post_padding
</UL>
<BR>[Calls]<UL><LI><a href="#[1f7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_ll_oct
</UL>

<P><STRONG><a name="[1f8]"></a>_printf_llx</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(_printf_llx.o)(.ARM.Collect$$_printf_percent$$00000011))
<BR><BR>[Stack]<UL><LI>Max Depth = 64 + Unknown Stack Size
<LI>Call Chain = _printf_llx &rArr; _printf_ll_hex &rArr; _printf_longlong_hex &rArr; _printf_int_common &rArr; _printf_post_padding
</UL>
<BR>[Calls]<UL><LI><a href="#[1f9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_ll_hex
</UL>

<P><STRONG><a name="[6dd]"></a>_printf_l</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(_printf_l.o)(.ARM.Collect$$_printf_percent$$00000012))

<P><STRONG><a name="[1fa]"></a>_printf_c</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(_printf_c.o)(.ARM.Collect$$_printf_percent$$00000013))
<BR><BR>[Stack]<UL><LI>Max Depth = 40 + Unknown Stack Size
<LI>Call Chain = _printf_c &rArr; _printf_char &rArr; _printf_cs_common &rArr; _printf_str &rArr; _printf_post_padding
</UL>
<BR>[Calls]<UL><LI><a href="#[1fb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_char
</UL>

<P><STRONG><a name="[1fc]"></a>_printf_s</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(_printf_s.o)(.ARM.Collect$$_printf_percent$$00000014))
<BR><BR>[Stack]<UL><LI>Max Depth = 40 + Unknown Stack Size
<LI>Call Chain = _printf_s &rArr; _printf_string &rArr; _printf_cs_common &rArr; _printf_str &rArr; _printf_post_padding
</UL>
<BR>[Calls]<UL><LI><a href="#[1fd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_string
</UL>

<P><STRONG><a name="[1fe]"></a>_printf_lc</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(_printf_lc.o)(.ARM.Collect$$_printf_percent$$00000015))
<BR><BR>[Stack]<UL><LI>Max Depth = 96 + Unknown Stack Size
<LI>Call Chain = _printf_lc &rArr; _printf_wchar &rArr; _printf_lcs_common &rArr; _printf_wctomb &rArr; _wcrtomb &rArr; __rt_ctype_table &rArr; __rt_locale
</UL>
<BR>[Calls]<UL><LI><a href="#[1ff]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_wchar
</UL>

<P><STRONG><a name="[200]"></a>_printf_ls</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(_printf_ls.o)(.ARM.Collect$$_printf_percent$$00000016))
<BR><BR>[Stack]<UL><LI>Max Depth = 96 + Unknown Stack Size
<LI>Call Chain = _printf_ls &rArr; _printf_wstring &rArr; _printf_lcs_common &rArr; _printf_wctomb &rArr; _wcrtomb &rArr; __rt_ctype_table &rArr; __rt_locale
</UL>
<BR>[Calls]<UL><LI><a href="#[201]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_wstring
</UL>

<P><STRONG><a name="[6de]"></a>_printf_percent_end</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(_printf_percent_end.o)(.ARM.Collect$$_printf_percent$$00000017))

<P><STRONG><a name="[63d]"></a>__rt_lib_init</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(libinit.o)(.ARM.Collect$$libinit$$00000000))
<BR><BR>[Called By]<UL><LI><a href="#[75]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pre_main
</UL>

<P><STRONG><a name="[202]"></a>__rt_lib_init_fp_1</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(libinit2.o)(.ARM.Collect$$libinit$$00000001))
<BR><BR>[Calls]<UL><LI><a href="#[203]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_fp_init
</UL>

<P><STRONG><a name="[204]"></a>__rt_lib_init_heap_2</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(libinit2.o)(.ARM.Collect$$libinit$$00000005))
<BR><BR>[Stack]<UL><LI>Max Depth = 160 + Unknown Stack Size
<LI>Call Chain = __rt_lib_init_heap_2 &rArr; _init_alloc &rArr; __Heap_Initialize &rArr; _mutex_initialize &rArr; malloc &rArr; _malloc_internal &rArr; __Heap_Full &rArr; __Heap_ProvideMemory &rArr; _free_internal &rArr; _mutex_release &rArr; os_kernel_is_active &rArr; osKernelGetState &rArr; svcRtxKernelGetState
</UL>
<BR>[Calls]<UL><LI><a href="#[205]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_init_alloc
</UL>

<P><STRONG><a name="[6df]"></a>__rt_lib_init_preinit_1</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(libinit2.o)(.ARM.Collect$$libinit$$00000004))

<P><STRONG><a name="[6e0]"></a>__rt_lib_init_heap_1</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(libinit2.o)(.ARM.Collect$$libinit$$0000000A))

<P><STRONG><a name="[206]"></a>__rt_lib_init_lc_common</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(libinit2.o)(.ARM.Collect$$libinit$$0000000F))
<BR><BR>[Stack]<UL><LI>Max Depth = 8 + Unknown Stack Size
<LI>Call Chain = __rt_lib_init_lc_common &rArr; __rt_locale
</UL>
<BR>[Calls]<UL><LI><a href="#[207]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_locale
</UL>

<P><STRONG><a name="[6e1]"></a>__rt_lib_init_rand_1</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(libinit2.o)(.ARM.Collect$$libinit$$0000000E))

<P><STRONG><a name="[6e2]"></a>__rt_lib_init_user_alloc_1</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(libinit2.o)(.ARM.Collect$$libinit$$0000000C))

<P><STRONG><a name="[6e3]"></a>__rt_lib_init_lc_collate_1</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(libinit2.o)(.ARM.Collect$$libinit$$00000011))

<P><STRONG><a name="[208]"></a>__rt_lib_init_lc_ctype_2</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(libinit2.o)(.ARM.Collect$$libinit$$00000012))
<BR><BR>[Stack]<UL><LI>Max Depth = 8 + Unknown Stack Size
<LI>Call Chain = __rt_lib_init_lc_ctype_2 &rArr; _get_lc_ctype
</UL>
<BR>[Calls]<UL><LI><a href="#[45]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_get_lc_ctype
</UL>

<P><STRONG><a name="[6e4]"></a>__rt_lib_init_lc_ctype_1</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(libinit2.o)(.ARM.Collect$$libinit$$00000013))

<P><STRONG><a name="[6e5]"></a>__rt_lib_init_lc_monetary_1</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(libinit2.o)(.ARM.Collect$$libinit$$00000015))

<P><STRONG><a name="[209]"></a>__rt_lib_init_lc_numeric_2</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(libinit2.o)(.ARM.Collect$$libinit$$00000016))
<BR><BR>[Stack]<UL><LI>Max Depth = 8 + Unknown Stack Size
<LI>Call Chain = __rt_lib_init_lc_numeric_2 &rArr; _get_lc_numeric
</UL>
<BR>[Calls]<UL><LI><a href="#[20a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_get_lc_numeric
</UL>

<P><STRONG><a name="[6e6]"></a>__rt_lib_init_atexit_1</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(libinit2.o)(.ARM.Collect$$libinit$$0000001B))

<P><STRONG><a name="[6e7]"></a>__rt_lib_init_clock_1</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(libinit2.o)(.ARM.Collect$$libinit$$00000021))

<P><STRONG><a name="[6e8]"></a>__rt_lib_init_fp_trap_1</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(libinit2.o)(.ARM.Collect$$libinit$$0000001F))

<P><STRONG><a name="[6e9]"></a>__rt_lib_init_getenv_1</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(libinit2.o)(.ARM.Collect$$libinit$$00000023))

<P><STRONG><a name="[6ea]"></a>__rt_lib_init_lc_numeric_1</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(libinit2.o)(.ARM.Collect$$libinit$$00000017))

<P><STRONG><a name="[6eb]"></a>__rt_lib_init_lc_time_1</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(libinit2.o)(.ARM.Collect$$libinit$$00000019))

<P><STRONG><a name="[6ec]"></a>__rt_lib_init_signal_1</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(libinit2.o)(.ARM.Collect$$libinit$$0000001D))

<P><STRONG><a name="[20b]"></a>__rt_lib_init_stdio_2</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(libinit2.o)(.ARM.Collect$$libinit$$00000024))
<BR><BR>[Stack]<UL><LI>Max Depth = 768 + Unknown Stack Size
<LI>Call Chain = __rt_lib_init_stdio_2 &rArr; _initio &rArr; freopen &rArr; _freopen_locked &rArr; _sys_open &rArr; open &rArr; mbed::FilePath::FilePath(const char*) &rArr; mbed::FileBase::lookup(const char*, unsigned) &rArr; SingletonPtr&lang;rtos::Mutex&rang;::operator -&rang;() &rArr; SingletonPtr&lang;rtos::Mutex&rang;::get() &rArr; rtos::Mutex::Mutex() &rArr; rtos::Mutex::constructor(const char*) &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[20c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_initio
</UL>

<P><STRONG><a name="[6ed]"></a>__rt_lib_init_alloca_1</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(libinit2.o)(.ARM.Collect$$libinit$$0000002E))

<P><STRONG><a name="[6ee]"></a>__rt_lib_init_argv_1</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(libinit2.o)(.ARM.Collect$$libinit$$0000002C))

<P><STRONG><a name="[20d]"></a>__rt_lib_init_cpp_2</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(libinit2.o)(.ARM.Collect$$libinit$$00000031))
<BR><BR>[Stack]<UL><LI>Max Depth = 16 + Unknown Stack Size
<LI>Call Chain = __rt_lib_init_cpp_2 &rArr; __cpp_initialize__aeabi_
</UL>
<BR>[Calls]<UL><LI><a href="#[1dc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__cpp_initialize__aeabi_
</UL>

<P><STRONG><a name="[6ef]"></a>__rt_lib_init_exceptions_1</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(libinit2.o)(.ARM.Collect$$libinit$$00000030))

<P><STRONG><a name="[6f0]"></a>__rt_lib_init_stdio_1</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(libinit2.o)(.ARM.Collect$$libinit$$00000025))

<P><STRONG><a name="[6f1]"></a>__rt_lib_init_cpp_1</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(libinit2.o)(.ARM.Collect$$libinit$$00000032))

<P><STRONG><a name="[6f2]"></a>__rt_lib_init_return</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(libinit2.o)(.ARM.Collect$$libinit$$00000033))

<P><STRONG><a name="[6f3]"></a>__asm___13_rtx_evflags_c_736f7bde__atomic_wr8</STRONG> (Thumb, 16 bytes, Stack size 0 bytes, .\build\rtx_evflags.o(.emb_text), UNUSED)

<P><STRONG><a name="[6f4]"></a>__rt_lib_shutdown_heap_2</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(libshutdown2.o)(.ARM.Collect$$libshutdown$$0000000F))

<P><STRONG><a name="[6f5]"></a>__rt_lib_shutdown_stdio_2</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(libshutdown2.o)(.ARM.Collect$$libshutdown$$00000004))

<P><STRONG><a name="[2a4]"></a>__asm___13_rtx_evflags_c_736f7bde__atomic_set32</STRONG> (Thumb, 20 bytes, Stack size 0 bytes, .\build\rtx_evflags.o(.emb_text))
<BR><BR>[Called By]<UL><LI><a href="#[2a3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EventFlagsSet
</UL>

<P><STRONG><a name="[2a2]"></a>__asm___13_rtx_evflags_c_736f7bde__atomic_clr32</STRONG> (Thumb, 22 bytes, Stack size 0 bytes, .\build\rtx_evflags.o(.emb_text))
<BR><BR>[Called By]<UL><LI><a href="#[2a1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EventFlagsClear
</UL>

<P><STRONG><a name="[29f]"></a>__asm___13_rtx_evflags_c_736f7bde__atomic_chk32_all</STRONG> (Thumb, 38 bytes, Stack size 0 bytes, .\build\rtx_evflags.o(.emb_text))
<BR><BR>[Called By]<UL><LI><a href="#[29e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EventFlagsCheck
</UL>

<P><STRONG><a name="[2a0]"></a>__asm___13_rtx_evflags_c_736f7bde__atomic_chk32_any</STRONG> (Thumb, 34 bytes, Stack size 0 bytes, .\build\rtx_evflags.o(.emb_text))
<BR><BR>[Called By]<UL><LI><a href="#[29e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EventFlagsCheck
</UL>

<P><STRONG><a name="[6f6]"></a>__asm___13_rtx_evflags_c_736f7bde__atomic_inc32</STRONG> (Thumb, 18 bytes, Stack size 0 bytes, .\build\rtx_evflags.o(.emb_text), UNUSED)

<P><STRONG><a name="[6f7]"></a>__asm___13_rtx_evflags_c_736f7bde__atomic_inc32_lt</STRONG> (Thumb, 30 bytes, Stack size 0 bytes, .\build\rtx_evflags.o(.emb_text), UNUSED)

<P><STRONG><a name="[6f8]"></a>__asm___13_rtx_evflags_c_736f7bde__atomic_inc16_lt</STRONG> (Thumb, 30 bytes, Stack size 0 bytes, .\build\rtx_evflags.o(.emb_text), UNUSED)

<P><STRONG><a name="[6f9]"></a>__asm___13_rtx_evflags_c_736f7bde__atomic_inc16_lim</STRONG> (Thumb, 26 bytes, Stack size 0 bytes, .\build\rtx_evflags.o(.emb_text), UNUSED)

<P><STRONG><a name="[6fa]"></a>__asm___13_rtx_evflags_c_736f7bde__atomic_dec32_nz</STRONG> (Thumb, 26 bytes, Stack size 0 bytes, .\build\rtx_evflags.o(.emb_text), UNUSED)

<P><STRONG><a name="[6fb]"></a>__asm___13_rtx_evflags_c_736f7bde__atomic_dec16_nz</STRONG> (Thumb, 26 bytes, Stack size 0 bytes, .\build\rtx_evflags.o(.emb_text), UNUSED)

<P><STRONG><a name="[6fc]"></a>__asm___13_rtx_evflags_c_736f7bde__atomic_link_get</STRONG> (Thumb, 26 bytes, Stack size 0 bytes, .\build\rtx_evflags.o(.emb_text), UNUSED)

<P><STRONG><a name="[20e]"></a>__asm___13_rtx_evflags_c_736f7bde__atomic_link_put</STRONG> (Thumb, 28 bytes, Stack size 0 bytes, .\build\rtx_evflags.o(.emb_text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[20e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__asm___13_rtx_evflags_c_736f7bde__atomic_link_put
</UL>
<BR>[Called By]<UL><LI><a href="#[20e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__asm___13_rtx_evflags_c_736f7bde__atomic_link_put
</UL>

<P><STRONG><a name="[6fd]"></a>__asm___13_rtx_mempool_c_7914b4c7__atomic_wr8</STRONG> (Thumb, 16 bytes, Stack size 0 bytes, .\build\rtx_mempool.o(.emb_text), UNUSED)

<P><STRONG><a name="[6fe]"></a>__asm___13_rtx_mempool_c_7914b4c7__atomic_set32</STRONG> (Thumb, 20 bytes, Stack size 0 bytes, .\build\rtx_mempool.o(.emb_text), UNUSED)

<P><STRONG><a name="[6ff]"></a>__asm___13_rtx_mempool_c_7914b4c7__atomic_clr32</STRONG> (Thumb, 22 bytes, Stack size 0 bytes, .\build\rtx_mempool.o(.emb_text), UNUSED)

<P><STRONG><a name="[700]"></a>__asm___13_rtx_mempool_c_7914b4c7__atomic_chk32_all</STRONG> (Thumb, 38 bytes, Stack size 0 bytes, .\build\rtx_mempool.o(.emb_text), UNUSED)

<P><STRONG><a name="[701]"></a>__asm___13_rtx_mempool_c_7914b4c7__atomic_chk32_any</STRONG> (Thumb, 34 bytes, Stack size 0 bytes, .\build\rtx_mempool.o(.emb_text), UNUSED)

<P><STRONG><a name="[702]"></a>__asm___13_rtx_mempool_c_7914b4c7__atomic_inc32</STRONG> (Thumb, 18 bytes, Stack size 0 bytes, .\build\rtx_mempool.o(.emb_text), UNUSED)

<P><STRONG><a name="[5e4]"></a>__asm___13_rtx_mempool_c_7914b4c7__atomic_inc32_lt</STRONG> (Thumb, 30 bytes, Stack size 0 bytes, .\build\rtx_mempool.o(.emb_text))
<BR><BR>[Called By]<UL><LI><a href="#[51b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxMemoryPoolAlloc
</UL>

<P><STRONG><a name="[703]"></a>__asm___13_rtx_mempool_c_7914b4c7__atomic_inc16_lt</STRONG> (Thumb, 30 bytes, Stack size 0 bytes, .\build\rtx_mempool.o(.emb_text), UNUSED)

<P><STRONG><a name="[704]"></a>__asm___13_rtx_mempool_c_7914b4c7__atomic_inc16_lim</STRONG> (Thumb, 26 bytes, Stack size 0 bytes, .\build\rtx_mempool.o(.emb_text), UNUSED)

<P><STRONG><a name="[5e8]"></a>__asm___13_rtx_mempool_c_7914b4c7__atomic_dec32_nz</STRONG> (Thumb, 26 bytes, Stack size 0 bytes, .\build\rtx_mempool.o(.emb_text))
<BR><BR>[Called By]<UL><LI><a href="#[5e6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxMemoryPoolFree
</UL>

<P><STRONG><a name="[705]"></a>__asm___13_rtx_mempool_c_7914b4c7__atomic_dec16_nz</STRONG> (Thumb, 26 bytes, Stack size 0 bytes, .\build\rtx_mempool.o(.emb_text), UNUSED)

<P><STRONG><a name="[5e5]"></a>__asm___13_rtx_mempool_c_7914b4c7__atomic_link_get</STRONG> (Thumb, 26 bytes, Stack size 0 bytes, .\build\rtx_mempool.o(.emb_text))
<BR><BR>[Called By]<UL><LI><a href="#[51b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxMemoryPoolAlloc
</UL>

<P><STRONG><a name="[20f]"></a>__asm___13_rtx_mempool_c_7914b4c7__atomic_link_put</STRONG> (Thumb, 28 bytes, Stack size 0 bytes, .\build\rtx_mempool.o(.emb_text))
<BR><BR>[Calls]<UL><LI><a href="#[20f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__asm___13_rtx_mempool_c_7914b4c7__atomic_link_put
</UL>
<BR>[Called By]<UL><LI><a href="#[5e6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxMemoryPoolFree
<LI><a href="#[20f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__asm___13_rtx_mempool_c_7914b4c7__atomic_link_put
</UL>

<P><STRONG><a name="[2c7]"></a>__asm___14_rtx_msgqueue_c_3fd3b50e__atomic_wr8</STRONG> (Thumb, 16 bytes, Stack size 0 bytes, .\build\rtx_msgqueue.o(.emb_text))
<BR><BR>[Called By]<UL><LI><a href="#[2c5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MessageQueueGet
</UL>

<P><STRONG><a name="[706]"></a>__asm___14_rtx_msgqueue_c_3fd3b50e__atomic_set32</STRONG> (Thumb, 20 bytes, Stack size 0 bytes, .\build\rtx_msgqueue.o(.emb_text), UNUSED)

<P><STRONG><a name="[707]"></a>__asm___14_rtx_msgqueue_c_3fd3b50e__atomic_clr32</STRONG> (Thumb, 22 bytes, Stack size 0 bytes, .\build\rtx_msgqueue.o(.emb_text), UNUSED)

<P><STRONG><a name="[708]"></a>__asm___14_rtx_msgqueue_c_3fd3b50e__atomic_chk32_all</STRONG> (Thumb, 38 bytes, Stack size 0 bytes, .\build\rtx_msgqueue.o(.emb_text), UNUSED)

<P><STRONG><a name="[709]"></a>__asm___14_rtx_msgqueue_c_3fd3b50e__atomic_chk32_any</STRONG> (Thumb, 34 bytes, Stack size 0 bytes, .\build\rtx_msgqueue.o(.emb_text), UNUSED)

<P><STRONG><a name="[2c9]"></a>__asm___14_rtx_msgqueue_c_3fd3b50e__atomic_inc32</STRONG> (Thumb, 18 bytes, Stack size 0 bytes, .\build\rtx_msgqueue.o(.emb_text))
<BR><BR>[Called By]<UL><LI><a href="#[2c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MessageQueuePut
</UL>

<P><STRONG><a name="[70a]"></a>__asm___14_rtx_msgqueue_c_3fd3b50e__atomic_inc32_lt</STRONG> (Thumb, 30 bytes, Stack size 0 bytes, .\build\rtx_msgqueue.o(.emb_text), UNUSED)

<P><STRONG><a name="[70b]"></a>__asm___14_rtx_msgqueue_c_3fd3b50e__atomic_inc16_lt</STRONG> (Thumb, 30 bytes, Stack size 0 bytes, .\build\rtx_msgqueue.o(.emb_text), UNUSED)

<P><STRONG><a name="[70c]"></a>__asm___14_rtx_msgqueue_c_3fd3b50e__atomic_inc16_lim</STRONG> (Thumb, 26 bytes, Stack size 0 bytes, .\build\rtx_msgqueue.o(.emb_text), UNUSED)

<P><STRONG><a name="[2c6]"></a>__asm___14_rtx_msgqueue_c_3fd3b50e__atomic_dec32_nz</STRONG> (Thumb, 26 bytes, Stack size 0 bytes, .\build\rtx_msgqueue.o(.emb_text))
<BR><BR>[Called By]<UL><LI><a href="#[2c5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MessageQueueGet
</UL>

<P><STRONG><a name="[70d]"></a>__asm___14_rtx_msgqueue_c_3fd3b50e__atomic_dec16_nz</STRONG> (Thumb, 26 bytes, Stack size 0 bytes, .\build\rtx_msgqueue.o(.emb_text), UNUSED)

<P><STRONG><a name="[70e]"></a>__asm___14_rtx_msgqueue_c_3fd3b50e__atomic_link_get</STRONG> (Thumb, 26 bytes, Stack size 0 bytes, .\build\rtx_msgqueue.o(.emb_text), UNUSED)

<P><STRONG><a name="[210]"></a>__asm___14_rtx_msgqueue_c_3fd3b50e__atomic_link_put</STRONG> (Thumb, 28 bytes, Stack size 0 bytes, .\build\rtx_msgqueue.o(.emb_text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[210]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__asm___14_rtx_msgqueue_c_3fd3b50e__atomic_link_put
</UL>
<BR>[Called By]<UL><LI><a href="#[210]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__asm___14_rtx_msgqueue_c_3fd3b50e__atomic_link_put
</UL>

<P><STRONG><a name="[70f]"></a>__asm___15_rtx_semaphore_c_eca73427__atomic_wr8</STRONG> (Thumb, 16 bytes, Stack size 0 bytes, .\build\rtx_semaphore.o(.emb_text), UNUSED)

<P><STRONG><a name="[710]"></a>__asm___15_rtx_semaphore_c_eca73427__atomic_set32</STRONG> (Thumb, 20 bytes, Stack size 0 bytes, .\build\rtx_semaphore.o(.emb_text), UNUSED)

<P><STRONG><a name="[711]"></a>__asm___15_rtx_semaphore_c_eca73427__atomic_clr32</STRONG> (Thumb, 22 bytes, Stack size 0 bytes, .\build\rtx_semaphore.o(.emb_text), UNUSED)

<P><STRONG><a name="[712]"></a>__asm___15_rtx_semaphore_c_eca73427__atomic_chk32_all</STRONG> (Thumb, 38 bytes, Stack size 0 bytes, .\build\rtx_semaphore.o(.emb_text), UNUSED)

<P><STRONG><a name="[713]"></a>__asm___15_rtx_semaphore_c_eca73427__atomic_chk32_any</STRONG> (Thumb, 34 bytes, Stack size 0 bytes, .\build\rtx_semaphore.o(.emb_text), UNUSED)

<P><STRONG><a name="[714]"></a>__asm___15_rtx_semaphore_c_eca73427__atomic_inc32</STRONG> (Thumb, 18 bytes, Stack size 0 bytes, .\build\rtx_semaphore.o(.emb_text), UNUSED)

<P><STRONG><a name="[715]"></a>__asm___15_rtx_semaphore_c_eca73427__atomic_inc32_lt</STRONG> (Thumb, 30 bytes, Stack size 0 bytes, .\build\rtx_semaphore.o(.emb_text), UNUSED)

<P><STRONG><a name="[2d3]"></a>__asm___15_rtx_semaphore_c_eca73427__atomic_inc16_lt</STRONG> (Thumb, 30 bytes, Stack size 0 bytes, .\build\rtx_semaphore.o(.emb_text))
<BR><BR>[Called By]<UL><LI><a href="#[2d2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SemaphoreTokenIncrement
</UL>

<P><STRONG><a name="[716]"></a>__asm___15_rtx_semaphore_c_eca73427__atomic_inc16_lim</STRONG> (Thumb, 26 bytes, Stack size 0 bytes, .\build\rtx_semaphore.o(.emb_text), UNUSED)

<P><STRONG><a name="[717]"></a>__asm___15_rtx_semaphore_c_eca73427__atomic_dec32_nz</STRONG> (Thumb, 26 bytes, Stack size 0 bytes, .\build\rtx_semaphore.o(.emb_text), UNUSED)

<P><STRONG><a name="[2d1]"></a>__asm___15_rtx_semaphore_c_eca73427__atomic_dec16_nz</STRONG> (Thumb, 26 bytes, Stack size 0 bytes, .\build\rtx_semaphore.o(.emb_text))
<BR><BR>[Called By]<UL><LI><a href="#[2d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SemaphoreTokenDecrement
</UL>

<P><STRONG><a name="[718]"></a>__asm___15_rtx_semaphore_c_eca73427__atomic_link_get</STRONG> (Thumb, 26 bytes, Stack size 0 bytes, .\build\rtx_semaphore.o(.emb_text), UNUSED)

<P><STRONG><a name="[211]"></a>__asm___15_rtx_semaphore_c_eca73427__atomic_link_put</STRONG> (Thumb, 28 bytes, Stack size 0 bytes, .\build\rtx_semaphore.o(.emb_text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[211]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__asm___15_rtx_semaphore_c_eca73427__atomic_link_put
</UL>
<BR>[Called By]<UL><LI><a href="#[211]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__asm___15_rtx_semaphore_c_eca73427__atomic_link_put
</UL>

<P><STRONG><a name="[719]"></a>__asm___12_rtx_system_c_024f2f18__atomic_wr8</STRONG> (Thumb, 16 bytes, Stack size 0 bytes, .\build\rtx_system.o(.emb_text), UNUSED)

<P><STRONG><a name="[71a]"></a>__asm___12_rtx_system_c_024f2f18__atomic_set32</STRONG> (Thumb, 20 bytes, Stack size 0 bytes, .\build\rtx_system.o(.emb_text), UNUSED)

<P><STRONG><a name="[71b]"></a>__asm___12_rtx_system_c_024f2f18__atomic_clr32</STRONG> (Thumb, 22 bytes, Stack size 0 bytes, .\build\rtx_system.o(.emb_text), UNUSED)

<P><STRONG><a name="[71c]"></a>__asm___12_rtx_system_c_024f2f18__atomic_chk32_all</STRONG> (Thumb, 38 bytes, Stack size 0 bytes, .\build\rtx_system.o(.emb_text), UNUSED)

<P><STRONG><a name="[71d]"></a>__asm___12_rtx_system_c_024f2f18__atomic_chk32_any</STRONG> (Thumb, 34 bytes, Stack size 0 bytes, .\build\rtx_system.o(.emb_text), UNUSED)

<P><STRONG><a name="[71e]"></a>__asm___12_rtx_system_c_024f2f18__atomic_inc32</STRONG> (Thumb, 18 bytes, Stack size 0 bytes, .\build\rtx_system.o(.emb_text), UNUSED)

<P><STRONG><a name="[71f]"></a>__asm___12_rtx_system_c_024f2f18__atomic_inc32_lt</STRONG> (Thumb, 30 bytes, Stack size 0 bytes, .\build\rtx_system.o(.emb_text), UNUSED)

<P><STRONG><a name="[522]"></a>__asm___12_rtx_system_c_024f2f18__atomic_inc16_lt</STRONG> (Thumb, 30 bytes, Stack size 0 bytes, .\build\rtx_system.o(.emb_text))
<BR><BR>[Called By]<UL><LI><a href="#[521]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;isr_queue_put
</UL>

<P><STRONG><a name="[520]"></a>__asm___12_rtx_system_c_024f2f18__atomic_inc16_lim</STRONG> (Thumb, 26 bytes, Stack size 0 bytes, .\build\rtx_system.o(.emb_text))
<BR><BR>[Called By]<UL><LI><a href="#[521]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;isr_queue_put
<LI><a href="#[51e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;isr_queue_get
</UL>

<P><STRONG><a name="[720]"></a>__asm___12_rtx_system_c_024f2f18__atomic_dec32_nz</STRONG> (Thumb, 26 bytes, Stack size 0 bytes, .\build\rtx_system.o(.emb_text), UNUSED)

<P><STRONG><a name="[51f]"></a>__asm___12_rtx_system_c_024f2f18__atomic_dec16_nz</STRONG> (Thumb, 26 bytes, Stack size 0 bytes, .\build\rtx_system.o(.emb_text))
<BR><BR>[Called By]<UL><LI><a href="#[51e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;isr_queue_get
</UL>

<P><STRONG><a name="[721]"></a>__asm___12_rtx_system_c_024f2f18__atomic_link_get</STRONG> (Thumb, 26 bytes, Stack size 0 bytes, .\build\rtx_system.o(.emb_text), UNUSED)

<P><STRONG><a name="[212]"></a>__asm___12_rtx_system_c_024f2f18__atomic_link_put</STRONG> (Thumb, 28 bytes, Stack size 0 bytes, .\build\rtx_system.o(.emb_text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[212]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__asm___12_rtx_system_c_024f2f18__atomic_link_put
</UL>
<BR>[Called By]<UL><LI><a href="#[212]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__asm___12_rtx_system_c_024f2f18__atomic_link_put
</UL>

<P><STRONG><a name="[722]"></a>__asm___12_rtx_thread_c_add96be5__atomic_wr8</STRONG> (Thumb, 16 bytes, Stack size 0 bytes, .\build\rtx_thread.o(.emb_text), UNUSED)

<P><STRONG><a name="[723]"></a>__asm___12_rtx_thread_c_add96be5__atomic_set32</STRONG> (Thumb, 20 bytes, Stack size 0 bytes, .\build\rtx_thread.o(.emb_text), UNUSED)

<P><STRONG><a name="[724]"></a>__asm___12_rtx_thread_c_add96be5__atomic_clr32</STRONG> (Thumb, 22 bytes, Stack size 0 bytes, .\build\rtx_thread.o(.emb_text), UNUSED)

<P><STRONG><a name="[2d9]"></a>__asm___12_rtx_thread_c_add96be5__atomic_chk32_all</STRONG> (Thumb, 38 bytes, Stack size 0 bytes, .\build\rtx_thread.o(.emb_text))
<BR><BR>[Called By]<UL><LI><a href="#[2d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ThreadFlagsCheck
</UL>

<P><STRONG><a name="[2da]"></a>__asm___12_rtx_thread_c_add96be5__atomic_chk32_any</STRONG> (Thumb, 34 bytes, Stack size 0 bytes, .\build\rtx_thread.o(.emb_text))
<BR><BR>[Called By]<UL><LI><a href="#[2d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ThreadFlagsCheck
</UL>

<P><STRONG><a name="[725]"></a>__asm___12_rtx_thread_c_add96be5__atomic_inc32</STRONG> (Thumb, 18 bytes, Stack size 0 bytes, .\build\rtx_thread.o(.emb_text), UNUSED)

<P><STRONG><a name="[726]"></a>__asm___12_rtx_thread_c_add96be5__atomic_inc32_lt</STRONG> (Thumb, 30 bytes, Stack size 0 bytes, .\build\rtx_thread.o(.emb_text), UNUSED)

<P><STRONG><a name="[727]"></a>__asm___12_rtx_thread_c_add96be5__atomic_inc16_lt</STRONG> (Thumb, 30 bytes, Stack size 0 bytes, .\build\rtx_thread.o(.emb_text), UNUSED)

<P><STRONG><a name="[728]"></a>__asm___12_rtx_thread_c_add96be5__atomic_inc16_lim</STRONG> (Thumb, 26 bytes, Stack size 0 bytes, .\build\rtx_thread.o(.emb_text), UNUSED)

<P><STRONG><a name="[729]"></a>__asm___12_rtx_thread_c_add96be5__atomic_dec32_nz</STRONG> (Thumb, 26 bytes, Stack size 0 bytes, .\build\rtx_thread.o(.emb_text), UNUSED)

<P><STRONG><a name="[72a]"></a>__asm___12_rtx_thread_c_add96be5__atomic_dec16_nz</STRONG> (Thumb, 26 bytes, Stack size 0 bytes, .\build\rtx_thread.o(.emb_text), UNUSED)

<P><STRONG><a name="[72b]"></a>__asm___12_rtx_thread_c_add96be5__atomic_link_get</STRONG> (Thumb, 26 bytes, Stack size 0 bytes, .\build\rtx_thread.o(.emb_text), UNUSED)

<P><STRONG><a name="[213]"></a>__asm___12_rtx_thread_c_add96be5__atomic_link_put</STRONG> (Thumb, 28 bytes, Stack size 0 bytes, .\build\rtx_thread.o(.emb_text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[213]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__asm___12_rtx_thread_c_add96be5__atomic_link_put
</UL>
<BR>[Called By]<UL><LI><a href="#[213]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__asm___12_rtx_thread_c_add96be5__atomic_link_put
</UL>

<P><STRONG><a name="[12]"></a>HardFault_Handler</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, .\build\except.o(.text))
<BR><BR>[Calls]<UL><LI><a href="#[214]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Fault_Handler
</UL>
<BR>[Address Reference Count : 1]<UL><LI> startup_efm32wg.o(RESET)
</UL>
<P><STRONG><a name="[72c]"></a>_maybe_terminate_alloc</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(maybetermalloc2.o)(.emb_text), UNUSED)

<P><STRONG><a name="[13]"></a>MemManage_Handler</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, .\build\except.o(.text))
<BR><BR>[Calls]<UL><LI><a href="#[214]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Fault_Handler
</UL>
<BR>[Address Reference Count : 1]<UL><LI> startup_efm32wg.o(RESET)
</UL>
<P><STRONG><a name="[14]"></a>BusFault_Handler</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, .\build\except.o(.text))
<BR><BR>[Calls]<UL><LI><a href="#[214]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Fault_Handler
</UL>
<BR>[Address Reference Count : 1]<UL><LI> startup_efm32wg.o(RESET)
</UL>
<P><STRONG><a name="[15]"></a>UsageFault_Handler</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, .\build\except.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_efm32wg.o(RESET)
</UL>
<P><STRONG><a name="[214]"></a>Fault_Handler</STRONG> (Thumb, 168 bytes, Stack size 0 bytes, .\build\except.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[14]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BusFault_Handler
<LI><a href="#[13]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MemManage_Handler
<LI><a href="#[12]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HardFault_Handler
</UL>

<P><STRONG><a name="[16]"></a>SVC_Handler</STRONG> (Thumb, 140 bytes, Stack size 0 bytes, .\build\irq_cm4f.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_efm32wg.o(RESET)
</UL>
<P><STRONG><a name="[18]"></a>PendSV_Handler</STRONG> (Thumb, 16 bytes, Stack size 0 bytes, .\build\irq_cm4f.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = PendSV_Handler &rArr; osRtxPendSV_Handler &rArr; osRtxThreadDispatch &rArr; osRtxThreadSwitch &rArr; osRtxThreadStackCheck &rArr; osRtxErrorNotify &rArr;  error (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[215]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxPendSV_Handler
</UL>
<BR>[Address Reference Count : 1]<UL><LI> startup_efm32wg.o(RESET)
</UL>
<P><STRONG><a name="[19]"></a>SysTick_Handler</STRONG> (Thumb, 16 bytes, Stack size 0 bytes, .\build\irq_cm4f.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 240<LI>Call Chain = SysTick_Handler &rArr; osRtxTick_Handler &rArr; OS_Tick_AcknowledgeIRQ &rArr; rtos::internal::SysTimer::schedule_tick(unsigned) &rArr; mbed::TimerEvent::insert_absolute(unsigned long long) &rArr; ticker_insert_event_us &rArr; schedule_interrupt &rArr; update_present_time &rArr; __aeabi_uldivmod
</UL>
<BR>[Calls]<UL><LI><a href="#[216]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxTick_Handler
</UL>
<BR>[Address Reference Count : 3]<UL><LI> systimer.o(i._ZN4rtos8internal8SysTimer9setup_irqEv)
<LI> rtx_kernel.o(i.svcRtxKernelStart)
<LI> startup_efm32wg.o(RESET)
</UL>
<P><STRONG><a name="[10]"></a>Reset_Handler</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, .\build\startup_efm32wg.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_efm32wg.o(RESET)
</UL>
<P><STRONG><a name="[11]"></a>NMI_Handler</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\startup_efm32wg.o(.text))
<BR><BR>[Calls]<UL><LI><a href="#[11]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;NMI_Handler
</UL>
<BR>[Called By]<UL><LI><a href="#[11]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;NMI_Handler
</UL>
<BR>[Address Reference Count : 1]<UL><LI> startup_efm32wg.o(RESET)
</UL>
<P><STRONG><a name="[17]"></a>DebugMon_Handler</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\startup_efm32wg.o(.text))
<BR><BR>[Calls]<UL><LI><a href="#[17]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DebugMon_Handler
</UL>
<BR>[Called By]<UL><LI><a href="#[17]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DebugMon_Handler
</UL>
<BR>[Address Reference Count : 1]<UL><LI> startup_efm32wg.o(RESET)
</UL>
<P><STRONG><a name="[20]"></a>ACMP0_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, .\build\startup_efm32wg.o(.text))
<BR><BR>[Calls]<UL><LI><a href="#[20]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ACMP0_IRQHandler
</UL>
<BR>[Called By]<UL><LI><a href="#[20]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ACMP0_IRQHandler
</UL>
<BR>[Address Reference Count : 1]<UL><LI> startup_efm32wg.o(RESET)
</UL>
<P><STRONG><a name="[21]"></a>ADC0_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, .\build\startup_efm32wg.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_efm32wg.o(RESET)
</UL>
<P><STRONG><a name="[3e]"></a>AES_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, .\build\startup_efm32wg.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_efm32wg.o(RESET)
</UL>
<P><STRONG><a name="[39]"></a>BURTC_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, .\build\startup_efm32wg.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_efm32wg.o(RESET)
</UL>
<P><STRONG><a name="[3a]"></a>CMU_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, .\build\startup_efm32wg.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_efm32wg.o(RESET)
</UL>
<P><STRONG><a name="[22]"></a>DAC0_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, .\build\startup_efm32wg.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_efm32wg.o(RESET)
</UL>
<P><STRONG><a name="[3f]"></a>EBI_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, .\build\startup_efm32wg.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_efm32wg.o(RESET)
</UL>
<P><STRONG><a name="[40]"></a>EMU_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, .\build\startup_efm32wg.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_efm32wg.o(RESET)
</UL>
<P><STRONG><a name="[41]"></a>FPUEH_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, .\build\startup_efm32wg.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_efm32wg.o(RESET)
</UL>
<P><STRONG><a name="[23]"></a>I2C0_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, .\build\startup_efm32wg.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_efm32wg.o(RESET)
</UL>
<P><STRONG><a name="[24]"></a>I2C1_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, .\build\startup_efm32wg.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_efm32wg.o(RESET)
</UL>
<P><STRONG><a name="[3c]"></a>LCD_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, .\build\startup_efm32wg.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_efm32wg.o(RESET)
</UL>
<P><STRONG><a name="[2b]"></a>LESENSE_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, .\build\startup_efm32wg.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_efm32wg.o(RESET)
</UL>
<P><STRONG><a name="[34]"></a>LETIMER0_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, .\build\startup_efm32wg.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_efm32wg.o(RESET)
</UL>
<P><STRONG><a name="[32]"></a>LEUART0_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, .\build\startup_efm32wg.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_efm32wg.o(RESET)
</UL>
<P><STRONG><a name="[33]"></a>LEUART1_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, .\build\startup_efm32wg.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_efm32wg.o(RESET)
</UL>
<P><STRONG><a name="[3d]"></a>MSC_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, .\build\startup_efm32wg.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_efm32wg.o(RESET)
</UL>
<P><STRONG><a name="[35]"></a>PCNT0_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, .\build\startup_efm32wg.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_efm32wg.o(RESET)
</UL>
<P><STRONG><a name="[36]"></a>PCNT1_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, .\build\startup_efm32wg.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_efm32wg.o(RESET)
</UL>
<P><STRONG><a name="[37]"></a>PCNT2_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, .\build\startup_efm32wg.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_efm32wg.o(RESET)
</UL>
<P><STRONG><a name="[1c]"></a>TIMER0_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, .\build\startup_efm32wg.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_efm32wg.o(RESET)
</UL>
<P><STRONG><a name="[26]"></a>TIMER1_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, .\build\startup_efm32wg.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_efm32wg.o(RESET)
</UL>
<P><STRONG><a name="[27]"></a>TIMER2_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, .\build\startup_efm32wg.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_efm32wg.o(RESET)
</UL>
<P><STRONG><a name="[28]"></a>TIMER3_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, .\build\startup_efm32wg.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_efm32wg.o(RESET)
</UL>
<P><STRONG><a name="[2e]"></a>UART0_RX_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, .\build\startup_efm32wg.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_efm32wg.o(RESET)
</UL>
<P><STRONG><a name="[2f]"></a>UART0_TX_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, .\build\startup_efm32wg.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_efm32wg.o(RESET)
</UL>
<P><STRONG><a name="[30]"></a>UART1_RX_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, .\build\startup_efm32wg.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_efm32wg.o(RESET)
</UL>
<P><STRONG><a name="[31]"></a>UART1_TX_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, .\build\startup_efm32wg.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_efm32wg.o(RESET)
</UL>
<P><STRONG><a name="[1d]"></a>USART0_RX_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, .\build\startup_efm32wg.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_efm32wg.o(RESET)
</UL>
<P><STRONG><a name="[1e]"></a>USART0_TX_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, .\build\startup_efm32wg.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_efm32wg.o(RESET)
</UL>
<P><STRONG><a name="[29]"></a>USART1_RX_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, .\build\startup_efm32wg.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_efm32wg.o(RESET)
</UL>
<P><STRONG><a name="[2a]"></a>USART1_TX_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, .\build\startup_efm32wg.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_efm32wg.o(RESET)
</UL>
<P><STRONG><a name="[2c]"></a>USART2_RX_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, .\build\startup_efm32wg.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_efm32wg.o(RESET)
</UL>
<P><STRONG><a name="[2d]"></a>USART2_TX_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, .\build\startup_efm32wg.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_efm32wg.o(RESET)
</UL>
<P><STRONG><a name="[1f]"></a>USB_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, .\build\startup_efm32wg.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_efm32wg.o(RESET)
</UL>
<P><STRONG><a name="[3b]"></a>VCMP_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, .\build\startup_efm32wg.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_efm32wg.o(RESET)
</UL>
<P><STRONG><a name="[72d]"></a>__user_initial_stackheap</STRONG> (Thumb, 10 bytes, Stack size 0 bytes, .\build\startup_efm32wg.o(.text), UNUSED)

<P><STRONG><a name="[217]"></a>__rt_ctype_table</STRONG> (Thumb, 16 bytes, Stack size 8 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(rt_ctype_table.o)(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = __rt_ctype_table &rArr; __rt_locale
</UL>
<BR>[Calls]<UL><LI><a href="#[207]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_locale
</UL>
<BR>[Called By]<UL><LI><a href="#[4c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;isspace
<LI><a href="#[632]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_vslprintf
<LI><a href="#[25f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_wcrtomb
<LI><a href="#[235]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;strtol
</UL>

<P><STRONG><a name="[218]"></a>__aeabi_errno_addr</STRONG> (Thumb, 4 bytes, Stack size 0 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(rt_errno_addr_twolibspace.o)(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = __aeabi_errno_addr &rArr; __user_perthread_libspace &rArr; os_kernel_is_active &rArr; osKernelGetState &rArr; svcRtxKernelGetState
</UL>
<BR>[Calls]<UL><LI><a href="#[219]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__user_perthread_libspace
</UL>
<BR>[Called By]<UL><LI><a href="#[319]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;reserve_filehandle()
<LI><a href="#[318]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;handle_open_errors(int, unsigned)
<LI><a href="#[2f7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;unbind_from_fd(int, mbed::FileHandle*)
<LI><a href="#[44e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;write
<LI><a href="#[44d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lseek
<LI><a href="#[2e5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;isatty
<LI><a href="#[44b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;close
<LI><a href="#[26a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_sys_write
<LI><a href="#[265]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_sys_flen
<LI><a href="#[3e3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Stream::Stream__sub_object(const char*)
<LI><a href="#[268]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_ftell_internal
<LI><a href="#[236]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_strtoul
<LI><a href="#[235]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;strtol
</UL>

<P><STRONG><a name="[72e]"></a>__errno$twolibspace</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(rt_errno_addr_twolibspace.o)(.text), UNUSED)

<P><STRONG><a name="[72f]"></a>__rt_errno_addr$twolibspace</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(rt_errno_addr_twolibspace.o)(.text), UNUSED)

<P><STRONG><a name="[21a]"></a>_malloc_internal</STRONG> (Thumb, 130 bytes, Stack size 24 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(h1_alloc_mt.o)(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 96<LI>Call Chain = _malloc_internal &rArr; __Heap_Full &rArr; __Heap_ProvideMemory &rArr; _free_internal &rArr; _mutex_release &rArr; os_kernel_is_active &rArr; osKernelGetState &rArr; svcRtxKernelGetState
</UL>
<BR>[Calls]<UL><LI><a href="#[1db]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_mutex_release
<LI><a href="#[1da]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_mutex_acquire
<LI><a href="#[21c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__Heap_Full
<LI><a href="#[21b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Heap1_SizeAdjust
</UL>
<BR>[Called By]<UL><LI><a href="#[21d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;malloc
</UL>

<P><STRONG><a name="[21d]"></a>malloc</STRONG> (Thumb, 20 bytes, Stack size 8 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(h1_alloc_mt.o)(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 104<LI>Call Chain = malloc &rArr; _malloc_internal &rArr; __Heap_Full &rArr; __Heap_ProvideMemory &rArr; _free_internal &rArr; _mutex_release &rArr; os_kernel_is_active &rArr; osKernelGetState &rArr; svcRtxKernelGetState
</UL>
<BR>[Calls]<UL><LI><a href="#[21e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_heap_descriptor
<LI><a href="#[21a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_malloc_internal
</UL>
<BR>[Called By]<UL><LI><a href="#[367]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;operator new(unsigned)
<LI><a href="#[17e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::set_credentials(const char*, const char*, const char*)
<LI><a href="#[395]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::get_context()
<LI><a href="#[37f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;operator new[] (unsigned)
<LI><a href="#[438]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_create
<LI><a href="#[109]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_setsockopt
<LI><a href="#[690]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_thread_new
<LI><a href="#[245]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_mutex_initialize
<LI><a href="#[303]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;nsapi_dns_query_multiple(NetworkStack*, const char*, nsapi_addr*, unsigned, nsapi_version)
<LI><a href="#[262]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__flsbuf
<LI><a href="#[244]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fopen
</UL>

<P><STRONG><a name="[21f]"></a>_free_internal</STRONG> (Thumb, 98 bytes, Stack size 16 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(h1_free_mt.o)(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = _free_internal &rArr; _mutex_release &rArr; os_kernel_is_active &rArr; osKernelGetState &rArr; svcRtxKernelGetState
</UL>
<BR>[Calls]<UL><LI><a href="#[1db]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_mutex_release
<LI><a href="#[1da]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_mutex_acquire
</UL>
<BR>[Called By]<UL><LI><a href="#[250]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__Heap_ProvideMemory
<LI><a href="#[220]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;free
</UL>

<P><STRONG><a name="[220]"></a>free</STRONG> (Thumb, 20 bytes, Stack size 8 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(h1_free_mt.o)(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = free &rArr; _free_internal &rArr; _mutex_release &rArr; os_kernel_is_active &rArr; osKernelGetState &rArr; svcRtxKernelGetState
</UL>
<BR>[Calls]<UL><LI><a href="#[21e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_heap_descriptor
<LI><a href="#[21f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_free_internal
</UL>
<BR>[Called By]<UL><LI><a href="#[37e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;operator delete (void*)
<LI><a href="#[39a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::free_credentials()
<LI><a href="#[411]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;operator delete[] (void*)
<LI><a href="#[43a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_destroy
<LI><a href="#[570]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_arena_dealloc
<LI><a href="#[303]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;nsapi_dns_query_multiple(NetworkStack*, const char*, nsapi_addr*, unsigned, nsapi_version)
<LI><a href="#[26c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_terminateio
<LI><a href="#[239]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_fclose_internal
</UL>

<P><STRONG><a name="[3e1]"></a>__aeabi_uldivmod</STRONG> (Thumb, 0 bytes, Stack size 48 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(lludivv7m.o)(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = __aeabi_uldivmod
</UL>
<BR>[Called By]<UL><LI><a href="#[316]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Timer::read_ms()
<LI><a href="#[112]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lp_ticker_set_interrupt
<LI><a href="#[10f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lp_ticker_read
<LI><a href="#[2cb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::internal::SysTimer::schedule_tick(unsigned)
<LI><a href="#[30f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::internal::SysTimer::update_tick()
<LI><a href="#[4f1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;update_present_time
<LI><a href="#[4ef]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;initialize
<LI><a href="#[472]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;compute_tick
</UL>

<P><STRONG><a name="[730]"></a>_ll_udiv</STRONG> (Thumb, 238 bytes, Stack size 48 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(lludivv7m.o)(.text), UNUSED)

<P><STRONG><a name="[4f0]"></a>__aeabi_llsl</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(llshl.o)(.text))
<BR><BR>[Called By]<UL><LI><a href="#[4ef]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;initialize
<LI><a href="#[641]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rol
</UL>

<P><STRONG><a name="[731]"></a>_ll_shift_l</STRONG> (Thumb, 38 bytes, Stack size 0 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(llshl.o)(.text), UNUSED)

<P><STRONG><a name="[644]"></a>__aeabi_llsr</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(llushr.o)(.text))
<BR><BR>[Called By]<UL><LI><a href="#[641]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rol
</UL>

<P><STRONG><a name="[732]"></a>_ll_ushift_r</STRONG> (Thumb, 38 bytes, Stack size 0 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(llushr.o)(.text), UNUSED)

<P><STRONG><a name="[221]"></a>vsnprintf</STRONG> (Thumb, 48 bytes, Stack size 24 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(vsnprintf.o)(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 128 + Unknown Stack Size
<LI>Call Chain = vsnprintf &rArr; _printf_char_common &rArr; __printf
</UL>
<BR>[Calls]<UL><LI><a href="#[47]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_sputc
<LI><a href="#[222]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_char_common
</UL>
<BR>[Called By]<UL><LI><a href="#[4b1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_error_vfprintf
</UL>

<P><STRONG><a name="[223]"></a>__2printf</STRONG> (Thumb, 20 bytes, Stack size 24 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(__2printf.o)(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 152 + Unknown Stack Size
<LI>Call Chain = __2printf &rArr; _printf_char_file &rArr; _printf_char_common &rArr; __printf
</UL>
<BR>[Calls]<UL><LI><a href="#[224]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_char_file
</UL>
<BR>[Called By]<UL><LI><a href="#[2df]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;print_function(const char*)
</UL>

<P><STRONG><a name="[225]"></a>__2sprintf</STRONG> (Thumb, 38 bytes, Stack size 32 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(__2sprintf.o)(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 136 + Unknown Stack Size
<LI>Call Chain = __2sprintf &rArr; _printf_char_common &rArr; __printf
</UL>
<BR>[Calls]<UL><LI><a href="#[47]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_sputc
<LI><a href="#[222]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_char_common
</UL>
<BR>[Called By]<UL><LI><a href="#[382]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::write_int(int)
<LI><a href="#[301]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ipv6_to_address(char*, const unsigned char*)
<LI><a href="#[2ff]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ipv4_to_address(char*, const unsigned char*)
</UL>

<P><STRONG><a name="[226]"></a>__2snprintf</STRONG> (Thumb, 50 bytes, Stack size 40 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(__2snprintf.o)(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 144 + Unknown Stack Size
<LI>Call Chain = __2snprintf &rArr; _printf_char_common &rArr; __printf
</UL>
<BR>[Calls]<UL><LI><a href="#[47]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_sputc
<LI><a href="#[222]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_char_common
</UL>
<BR>[Called By]<UL><LI><a href="#[2ec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;test_send_recv()
<LI><a href="#[2de]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;do_connect()
</UL>

<P><STRONG><a name="[228]"></a>_printf_pre_padding</STRONG> (Thumb, 44 bytes, Stack size 16 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(_printf_pad.o)(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = _printf_pre_padding
</UL>
<BR>[Called By]<UL><LI><a href="#[25c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_fp_infnan
<LI><a href="#[271]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_fp_hex_real
<LI><a href="#[25e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_wctomb
<LI><a href="#[25a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_fp_dec_real
<LI><a href="#[22c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_int_common
<LI><a href="#[227]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_str
</UL>

<P><STRONG><a name="[229]"></a>_printf_post_padding</STRONG> (Thumb, 34 bytes, Stack size 16 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(_printf_pad.o)(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = _printf_post_padding
</UL>
<BR>[Called By]<UL><LI><a href="#[25c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_fp_infnan
<LI><a href="#[271]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_fp_hex_real
<LI><a href="#[25e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_wctomb
<LI><a href="#[25a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_fp_dec_real
<LI><a href="#[22c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_int_common
<LI><a href="#[227]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_str
</UL>

<P><STRONG><a name="[227]"></a>_printf_str</STRONG> (Thumb, 82 bytes, Stack size 16 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(_printf_str.o)(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = _printf_str &rArr; _printf_post_padding
</UL>
<BR>[Calls]<UL><LI><a href="#[229]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_post_padding
<LI><a href="#[228]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_pre_padding
</UL>
<BR>[Called By]<UL><LI><a href="#[25d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_cs_common
</UL>

<P><STRONG><a name="[1eb]"></a>_printf_int_dec</STRONG> (Thumb, 104 bytes, Stack size 24 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(_printf_dec.o)(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 72<LI>Call Chain = _printf_int_dec &rArr; _printf_int_common &rArr; _printf_post_padding
</UL>
<BR>[Calls]<UL><LI><a href="#[22c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_int_common
<LI><a href="#[22b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_truncate_unsigned
<LI><a href="#[22a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_truncate_signed
</UL>
<BR>[Called By]<UL><LI><a href="#[1ea]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_i
<LI><a href="#[1ed]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_u
<LI><a href="#[1ec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_d
</UL>

<P><STRONG><a name="[22d]"></a>_printf_longlong_hex</STRONG> (Thumb, 86 bytes, Stack size 16 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(_printf_hex_int_ll_ptr.o)(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 64<LI>Call Chain = _printf_longlong_hex &rArr; _printf_int_common &rArr; _printf_post_padding
</UL>
<BR>[Calls]<UL><LI><a href="#[22c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_int_common
</UL>
<BR>[Called By]<UL><LI><a href="#[1e3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_hex_ptr
<LI><a href="#[1f9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_ll_hex
<LI><a href="#[1f1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_int_hex
</UL>

<P><STRONG><a name="[1f1]"></a>_printf_int_hex</STRONG> (Thumb, 28 bytes, Stack size 16 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(_printf_hex_int_ll_ptr.o)(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 80<LI>Call Chain = _printf_int_hex &rArr; _printf_longlong_hex &rArr; _printf_int_common &rArr; _printf_post_padding
</UL>
<BR>[Calls]<UL><LI><a href="#[22b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_truncate_unsigned
<LI><a href="#[22d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_longlong_hex
</UL>
<BR>[Called By]<UL><LI><a href="#[1f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_x
</UL>

<P><STRONG><a name="[1f9]"></a>_printf_ll_hex</STRONG> (Thumb, 12 bytes, Stack size 0 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(_printf_hex_int_ll_ptr.o)(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 64<LI>Call Chain = _printf_ll_hex &rArr; _printf_longlong_hex &rArr; _printf_int_common &rArr; _printf_post_padding
</UL>
<BR>[Calls]<UL><LI><a href="#[22d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_longlong_hex
</UL>
<BR>[Called By]<UL><LI><a href="#[1f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_llx
</UL>

<P><STRONG><a name="[1e3]"></a>_printf_hex_ptr</STRONG> (Thumb, 18 bytes, Stack size 0 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(_printf_hex_int_ll_ptr.o)(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 64<LI>Call Chain = _printf_hex_ptr &rArr; _printf_longlong_hex &rArr; _printf_int_common &rArr; _printf_post_padding
</UL>
<BR>[Calls]<UL><LI><a href="#[22d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_longlong_hex
</UL>
<BR>[Called By]<UL><LI><a href="#[1e2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_p
</UL>

<P><STRONG><a name="[22e]"></a>__printf</STRONG> (Thumb, 388 bytes, Stack size 40 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(__printf_flags_ss_wp.o)(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 40 + Unknown Stack Size
<LI>Call Chain = __printf
</UL>
<BR>[Calls]<UL><LI><a href="#[230]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_percent
<LI><a href="#[22f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_is_digit
</UL>
<BR>[Called By]<UL><LI><a href="#[222]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_char_common
</UL>

<P><STRONG><a name="[231]"></a>__0sscanf</STRONG> (Thumb, 52 bytes, Stack size 72 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(__0sscanf.o)(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 224<LI>Call Chain = __0sscanf &rArr; __vfscanf_char &rArr; __vfscanf &rArr; _scanf_int
</UL>
<BR>[Calls]<UL><LI><a href="#[232]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__vfscanf_char
</UL>
<BR>[Called By]<UL><LI><a href="#[313]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ipv4_from_address(unsigned char*, const char*)
<LI><a href="#[300]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ipv6_scan_chunk(unsigned short*, const char*)
</UL>

<P><STRONG><a name="[233]"></a>_scanf_int</STRONG> (Thumb, 332 bytes, Stack size 56 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(_scanf_int.o)(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = _scanf_int
</UL>
<BR>[Calls]<UL><LI><a href="#[234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_chval
</UL>
<BR>[Called By]<UL><LI><a href="#[261]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__vfscanf
</UL>

<P><STRONG><a name="[235]"></a>strtol</STRONG> (Thumb, 112 bytes, Stack size 32 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(strtol.o)(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 112<LI>Call Chain = strtol &rArr; _strtoul &rArr; __aeabi_errno_addr &rArr; __user_perthread_libspace &rArr; os_kernel_is_active &rArr; osKernelGetState &rArr; svcRtxKernelGetState
</UL>
<BR>[Calls]<UL><LI><a href="#[236]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_strtoul
<LI><a href="#[218]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_errno_addr
<LI><a href="#[217]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_ctype_table
</UL>
<BR>[Called By]<UL><LI><a href="#[394]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::read_int()
<LI><a href="#[32e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_cellular_util::convert_ipv6(char*)
</UL>

<P><STRONG><a name="[237]"></a>setbuf</STRONG> (Thumb, 20 bytes, Stack size 0 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(setbuf.o)(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 64<LI>Call Chain = setbuf &rArr; setvbuf &rArr; _mutex_release &rArr; os_kernel_is_active &rArr; osKernelGetState &rArr; svcRtxKernelGetState
</UL>
<BR>[Calls]<UL><LI><a href="#[238]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;setvbuf
</UL>
<BR>[Called By]<UL><LI><a href="#[3dd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::mbed_set_unbuffered_stream(std::__FILE*)
</UL>

<P><STRONG><a name="[733]"></a>_fclose$unlocked</STRONG> (Thumb, 0 bytes, Stack size 32 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(fclose.o)(.text), UNUSED)

<P><STRONG><a name="[239]"></a>_fclose_internal</STRONG> (Thumb, 76 bytes, Stack size 32 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(fclose.o)(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 416<LI>Call Chain = _fclose_internal &rArr; _fflush &rArr; _writebuf &rArr; _sys_write &rArr; convert_crlf(int) &rArr; isatty &rArr; get_fhc(int) &rArr; get_console(int) &rArr; default_console() &rArr; DirectSerial::DirectSerial(PinName, PinName, int) &rArr; serial_init &rArr; uart_init &rArr; serial_baud &rArr; serial_leuart_baud &rArr;  mbed_assert_internal (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[23b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_sys_close
<LI><a href="#[23a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_fflush
<LI><a href="#[23c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memclr4
<LI><a href="#[220]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;free
</UL>
<BR>[Called By]<UL><LI><a href="#[26c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_terminateio
<LI><a href="#[241]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_freopen_locked
<LI><a href="#[23d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fclose
</UL>

<P><STRONG><a name="[23d]"></a>fclose</STRONG> (Thumb, 46 bytes, Stack size 16 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(fclose_locked.o)(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 432<LI>Call Chain = fclose &rArr; _fclose_internal &rArr; _fflush &rArr; _writebuf &rArr; _sys_write &rArr; convert_crlf(int) &rArr; isatty &rArr; get_fhc(int) &rArr; get_console(int) &rArr; default_console() &rArr; DirectSerial::DirectSerial(PinName, PinName, int) &rArr; serial_init &rArr; uart_init &rArr; serial_baud &rArr; serial_leuart_baud &rArr;  mbed_assert_internal (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[1db]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_mutex_release
<LI><a href="#[1da]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_mutex_acquire
<LI><a href="#[239]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_fclose_internal
</UL>
<BR>[Called By]<UL><LI><a href="#[1a5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Stream::~Stream__sub_object()
</UL>

<P><STRONG><a name="[23e]"></a>_do_fflush</STRONG> (Thumb, 74 bytes, Stack size 24 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(fflush_locked.o)(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 408<LI>Call Chain = _do_fflush &rArr; _fflush &rArr; _writebuf &rArr; _sys_write &rArr; convert_crlf(int) &rArr; isatty &rArr; get_fhc(int) &rArr; get_console(int) &rArr; default_console() &rArr; DirectSerial::DirectSerial(PinName, PinName, int) &rArr; serial_init &rArr; uart_init &rArr; serial_baud &rArr; serial_leuart_baud &rArr;  mbed_assert_internal (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[1db]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_mutex_release
<LI><a href="#[1da]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_mutex_acquire
<LI><a href="#[23a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_fflush
<LI><a href="#[23f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_fseek
</UL>
<BR>[Called By]<UL><LI><a href="#[240]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fflush
</UL>

<P><STRONG><a name="[240]"></a>fflush</STRONG> (Thumb, 60 bytes, Stack size 24 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(fflush_locked.o)(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 432<LI>Call Chain = fflush &rArr; _do_fflush &rArr; _fflush &rArr; _writebuf &rArr; _sys_write &rArr; convert_crlf(int) &rArr; isatty &rArr; get_fhc(int) &rArr; get_console(int) &rArr; default_console() &rArr; DirectSerial::DirectSerial(PinName, PinName, int) &rArr; serial_init &rArr; uart_init &rArr; serial_baud &rArr; serial_leuart_baud &rArr;  mbed_assert_internal (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[1db]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_mutex_release
<LI><a href="#[1da]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_mutex_acquire
<LI><a href="#[23e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_do_fflush
</UL>
<BR>[Called By]<UL><LI><a href="#[4b2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;exit
<LI><a href="#[2df]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;print_function(const char*)
</UL>

<P><STRONG><a name="[243]"></a>freopen</STRONG> (Thumb, 42 bytes, Stack size 24 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(fopen_locked.o)(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 760 + Unknown Stack Size
<LI>Call Chain = freopen &rArr; _freopen_locked &rArr; _sys_open &rArr; open &rArr; mbed::FilePath::FilePath(const char*) &rArr; mbed::FileBase::lookup(const char*, unsigned) &rArr; SingletonPtr&lang;rtos::Mutex&rang;::operator -&rang;() &rArr; SingletonPtr&lang;rtos::Mutex&rang;::get() &rArr; rtos::Mutex::Mutex() &rArr; rtos::Mutex::constructor(const char*) &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[1db]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_mutex_release
<LI><a href="#[1da]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_mutex_acquire
<LI><a href="#[241]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_freopen_locked
</UL>
<BR>[Called By]<UL><LI><a href="#[20c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_initio
</UL>

<P><STRONG><a name="[244]"></a>fopen</STRONG> (Thumb, 100 bytes, Stack size 24 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(fopen_locked.o)(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 760 + Unknown Stack Size
<LI>Call Chain = fopen &rArr; _freopen_locked &rArr; _sys_open &rArr; open &rArr; mbed::FilePath::FilePath(const char*) &rArr; mbed::FileBase::lookup(const char*, unsigned) &rArr; SingletonPtr&lang;rtos::Mutex&rang;::operator -&rang;() &rArr; SingletonPtr&lang;rtos::Mutex&rang;::get() &rArr; rtos::Mutex::Mutex() &rArr; rtos::Mutex::constructor(const char*) &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[245]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_mutex_initialize
<LI><a href="#[1db]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_mutex_release
<LI><a href="#[1da]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_mutex_acquire
<LI><a href="#[23c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memclr4
<LI><a href="#[241]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_freopen_locked
<LI><a href="#[21d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;malloc
</UL>
<BR>[Called By]<UL><LI><a href="#[3e9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fdopen
</UL>

<P><STRONG><a name="[31c]"></a>strcspn</STRONG> (Thumb, 32 bytes, Stack size 12 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(strcspn.o)(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = strcspn
</UL>
<BR>[Called By]<UL><LI><a href="#[31b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dns_append_question(unsigned char**, const char*, nsapi_version)
</UL>

<P><STRONG><a name="[3f2]"></a>strspn</STRONG> (Thumb, 28 bytes, Stack size 12 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(strspn.o)(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = strspn
</UL>
<BR>[Called By]<UL><LI><a href="#[3f1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::FilePath::FilePath(const char*)
</UL>

<P><STRONG><a name="[323]"></a>memcmp</STRONG> (Thumb, 88 bytes, Stack size 8 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(memcmp.o)(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = memcmp
</UL>
<BR>[Called By]<UL><LI><a href="#[166]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularSIM::get_sim_state(mbed::CellularSIM::SimState&)
<LI><a href="#[17d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::get_registration_status(mbed::CellularNetwork::RegistrationType, mbed::CellularNetwork::RegistrationStatus&)
<LI><a href="#[397]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::string_to_stack_type(const char*)
<LI><a href="#[402]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::mem_str(const char*, unsigned, const char*, unsigned)
<LI><a href="#[3fe]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::match(const char*, unsigned)
<LI><a href="#[322]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;apnconfig(const char*)
<LI><a href="#[4b7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;find_multicast_member
</UL>

<P><STRONG><a name="[3f7]"></a>strcpy</STRONG> (Thumb, 72 bytes, Stack size 12 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(strcpy.o)(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = strcpy
</UL>
<BR>[Called By]<UL><LI><a href="#[372]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::resp_start(const char*, bool)
</UL>

<P><STRONG><a name="[31d]"></a>strlen</STRONG> (Thumb, 62 bytes, Stack size 8 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(strlen.o)(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = strlen
</UL>
<BR>[Called By]<UL><LI><a href="#[38b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::ATHandler(mbed::FileHandle*, events::EventQueue&, int, const char*)
<LI><a href="#[370]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::cmd_start(const char*)
<LI><a href="#[372]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::resp_start(const char*, bool)
<LI><a href="#[382]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::write_int(int)
<LI><a href="#[3a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::set_urc_handler(const char*, mbed::Callback&lang;void()&rang;)
<LI><a href="#[376]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::write_string(const char*, bool)
<LI><a href="#[397]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::string_to_stack_type(const char*)
<LI><a href="#[17e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::set_credentials(const char*, const char*, const char*)
<LI><a href="#[32e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_cellular_util::convert_ipv6(char*)
<LI><a href="#[401]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::match_urc()
<LI><a href="#[406]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::set_tag(mbed::ATHandler::tag_t*, const char*)
<LI><a href="#[3f9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::resp(const char*, bool)
<LI><a href="#[403]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::consume_to_tag(const char*, bool)
<LI><a href="#[3c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::CellularConnectionFSM::open_sim()
<LI><a href="#[187]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::EasyCellularConnection::connect()
<LI><a href="#[189]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::EasyCellularConnection::set_credentials(const char*, const char*, const char*)
<LI><a href="#[3ea]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::FileBase::lookup(const char*, unsigned)
<LI><a href="#[484]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dns_send
<LI><a href="#[466]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;chap_respond
<LI><a href="#[46d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;get_secret
<LI><a href="#[4bb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fsm_close
<LI><a href="#[48a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dns_gethostbyname_addrtype
<LI><a href="#[632]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_vslprintf
<LI><a href="#[303]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;nsapi_dns_query_multiple(NetworkStack*, const char*, nsapi_addr*, unsigned, nsapi_version)
</UL>

<P><STRONG><a name="[3eb]"></a>strncmp</STRONG> (Thumb, 150 bytes, Stack size 16 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(strncmp.o)(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = strncmp
</UL>
<BR>[Called By]<UL><LI><a href="#[3ea]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::FileBase::lookup(const char*, unsigned)
</UL>

<P><STRONG><a name="[249]"></a>__aeabi_memcpy</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(rt_memcpy_v6.o)(.text))
<BR><BR>[Called By]<UL><LI><a href="#[17e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::set_credentials(const char*, const char*, const char*)
<LI><a href="#[395]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::get_context()
<LI><a href="#[333]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SocketAddress::get_addr() const
<LI><a href="#[304]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SocketAddress::set_addr(nsapi_addr)
<LI><a href="#[171]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularStack::socket_connect(void*, const SocketAddress&)
<LI><a href="#[16f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularStack::socket_open(void**, nsapi_protocol)
<LI><a href="#[3fa]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::set_string(char*, const char*, unsigned)
<LI><a href="#[493]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_take_at
<LI><a href="#[491]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_take
<LI><a href="#[48d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_copy_partial
<LI><a href="#[488]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dns_enqueue
<LI><a href="#[466]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;chap_respond
<LI><a href="#[468]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;md5_update
<LI><a href="#[46d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;get_secret
<LI><a href="#[561]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_write
<LI><a href="#[4d5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_copy
<LI><a href="#[4d1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;icmp_input
<LI><a href="#[4d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;icmp_send_response
<LI><a href="#[2c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fsm_sdata
<LI><a href="#[e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lcp_reqci
<LI><a href="#[d7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ipcp_reqci
<LI><a href="#[506]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip_reass_free_complete_datagram
<LI><a href="#[502]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip_reass_enqueue_new_datagram
<LI><a href="#[4fa]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip4_reass
<LI><a href="#[4f3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip4_frag
<LI><a href="#[4fe]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip4_output_if_opt_src
<LI><a href="#[565]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;magic_random_bytes
<LI><a href="#[630]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_singlebuf
<LI><a href="#[54e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_init_tcp_isn
<LI><a href="#[109]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_setsockopt
<LI><a href="#[632]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_vslprintf
<LI><a href="#[329]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SocketAddress::set_ip_address(const char*)
<LI><a href="#[303]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;nsapi_dns_query_multiple(NetworkStack*, const char*, nsapi_addr*, unsigned, nsapi_version)
<LI><a href="#[2fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dns_append_name(unsigned char**, const char*, unsigned char)
<LI><a href="#[8e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxMessageQueuePut
<LI><a href="#[8c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxMessageQueueGet
<LI><a href="#[b7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxMessageQueuePostProcess
<LI><a href="#[51a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;isrRtxMessageQueuePut
<LI><a href="#[515]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;isrRtxMessageQueueGet
<LI><a href="#[248]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_memmove
</UL>

<P><STRONG><a name="[246]"></a>__rt_memcpy</STRONG> (Thumb, 138 bytes, Stack size 0 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(rt_memcpy_v6.o)(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[247]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy4
</UL>

<P><STRONG><a name="[734]"></a>_memcpy_lastbytes</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(rt_memcpy_v6.o)(.text), UNUSED)

<P><STRONG><a name="[315]"></a>__aeabi_memmove</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(rt_memmove_v6.o)(.text))
<BR><BR>[Called By]<UL><LI><a href="#[3f5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::rewind_buffer()
<LI><a href="#[314]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ipv6_from_address(unsigned char*, const char*)
</UL>

<P><STRONG><a name="[248]"></a>__rt_memmove</STRONG> (Thumb, 132 bytes, Stack size 0 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(rt_memmove_v6.o)(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[24a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__memmove_aligned
<LI><a href="#[249]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>

<P><STRONG><a name="[735]"></a>__memmove_lastfew</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(rt_memmove_v6.o)(.text), UNUSED)

<P><STRONG><a name="[247]"></a>__aeabi_memcpy4</STRONG> (Thumb, 0 bytes, Stack size 8 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(rt_memcpy_w.o)(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = __aeabi_memcpy4
</UL>
<BR>[Called By]<UL><LI><a href="#[e2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lcp_resetci
<LI><a href="#[e7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lcp_rejci
<LI><a href="#[e6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lcp_nakci
<LI><a href="#[d1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ipcp_resetci
<LI><a href="#[d6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ipcp_rejci
<LI><a href="#[d5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ipcp_nakci
<LI><a href="#[327]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_init
<LI><a href="#[136]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;NetworkStackWrapper::socket_recvfrom(void*, SocketAddress*, void*, unsigned)
<LI><a href="#[132]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;NetworkStackWrapper::socket_connect(void*, const SocketAddress&)
<LI><a href="#[135]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;NetworkStackWrapper::socket_sendto(void*, const SocketAddress&, const void*, unsigned)
<LI><a href="#[656]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;uart_init
<LI><a href="#[270]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_memmove_w
<LI><a href="#[246]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_memcpy
</UL>

<P><STRONG><a name="[736]"></a>__aeabi_memcpy8</STRONG> (Thumb, 0 bytes, Stack size 8 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(rt_memcpy_w.o)(.text), UNUSED)

<P><STRONG><a name="[737]"></a>__rt_memcpy_w</STRONG> (Thumb, 100 bytes, Stack size 8 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(rt_memcpy_w.o)(.text), UNUSED)

<P><STRONG><a name="[738]"></a>_memcpy_lastbytes_aligned</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(rt_memcpy_w.o)(.text), UNUSED)

<P><STRONG><a name="[24e]"></a>__aeabi_memclr</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(rt_memclr.o)(.text))
<BR><BR>[Called By]<UL><LI><a href="#[4fe]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip4_output_if_opt_src
<LI><a href="#[54e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_init_tcp_isn
<LI><a href="#[8d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxMessageQueueNew
<LI><a href="#[24d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;strncpy
</UL>

<P><STRONG><a name="[24b]"></a>__rt_memclr</STRONG> (Thumb, 68 bytes, Stack size 0 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(rt_memclr.o)(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[24c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_memset_w
</UL>

<P><STRONG><a name="[739]"></a>_memset</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(rt_memclr.o)(.text), UNUSED)

<P><STRONG><a name="[23c]"></a>__aeabi_memclr4</STRONG> (Thumb, 0 bytes, Stack size 4 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(rt_memclr_w.o)(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = __aeabi_memclr4
</UL>
<BR>[Called By]<UL><LI><a href="#[12d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;NetworkStack::gethostbyname(const char*, SocketAddress*, nsapi_version)
<LI><a href="#[385]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularStack::AT_CellularStack__sub_object(mbed::ATHandler&, int, nsapi_ip_stack)
<LI><a href="#[16f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularStack::socket_open(void**, nsapi_protocol)
<LI><a href="#[3ad]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Thread::start(mbed::Callback&lang;void()&rang;)
<LI><a href="#[3ab]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Thread::constructor(osPriority_t, unsigned, unsigned char*, const char*)
<LI><a href="#[3c5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::CellularConnectionFSM::CellularConnectionFSM()
<LI><a href="#[466]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;chap_respond
<LI><a href="#[55c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_mbox_new
<LI><a href="#[57b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_sem_new
<LI><a href="#[e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lcp_reqci
<LI><a href="#[e6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lcp_nakci
<LI><a href="#[ee]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lcp_init
<LI><a href="#[d1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ipcp_resetci
<LI><a href="#[d7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ipcp_reqci
<LI><a href="#[d5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ipcp_nakci
<LI><a href="#[502]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip_reass_enqueue_new_datagram
<LI><a href="#[595]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_mutex_new
<LI><a href="#[f5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pppos_connect
<LI><a href="#[635]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pppos_create
<LI><a href="#[637]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_new
<LI><a href="#[56f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_arena_alloc
<LI><a href="#[697]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_alloc
<LI><a href="#[690]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_thread_new
<LI><a href="#[6c1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_new
<LI><a href="#[56c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;print_context_info
<LI><a href="#[329]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SocketAddress::set_ip_address(const char*)
<LI><a href="#[422]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Mutex::constructor(const char*)
<LI><a href="#[12f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;NetworkStackWrapper::gethostbyname(const char*, SocketAddress*, nsapi_version)
<LI><a href="#[347]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::SerialBase::SerialBase(PinName, PinName, int)
<LI><a href="#[88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxKernelInitialize
<LI><a href="#[5b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Transaction&lang;mbed::SPI&rang;::Transaction()
<LI><a href="#[314]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ipv6_from_address(unsigned char*, const char*)
<LI><a href="#[20c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_initio
<LI><a href="#[244]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fopen
<LI><a href="#[239]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_fclose_internal
<LI><a href="#[2ec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;test_send_recv()
</UL>

<P><STRONG><a name="[73a]"></a>__aeabi_memclr8</STRONG> (Thumb, 0 bytes, Stack size 4 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(rt_memclr_w.o)(.text), UNUSED)

<P><STRONG><a name="[73b]"></a>__rt_memclr_w</STRONG> (Thumb, 78 bytes, Stack size 4 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(rt_memclr_w.o)(.text), UNUSED)

<P><STRONG><a name="[24c]"></a>_memset_w</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(rt_memclr_w.o)(.text), UNUSED)
<BR><BR>[Called By]<UL><LI><a href="#[24b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_memclr
</UL>

<P><STRONG><a name="[24d]"></a>strncpy</STRONG> (Thumb, 86 bytes, Stack size 8 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(strncpy.o)(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = strncpy
</UL>
<BR>[Calls]<UL><LI><a href="#[24e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memclr
</UL>
<BR>[Called By]<UL><LI><a href="#[398]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::set_new_context(int)
<LI><a href="#[3af]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::CellularConnectionFSM::set_sim_pin(const char*)
</UL>

<P><STRONG><a name="[396]"></a>strcmp</STRONG> (Thumb, 128 bytes, Stack size 0 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(strcmpv7m.o)(.text))
<BR><BR>[Called By]<UL><LI><a href="#[395]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::get_context()
<LI><a href="#[46d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;get_secret
<LI><a href="#[242]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_sys_open
<LI><a href="#[20a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_get_lc_numeric
<LI><a href="#[45]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_get_lc_ctype
</UL>

<P><STRONG><a name="[73c]"></a>__use_two_region_memory</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(heapauxi.o)(.text), UNUSED)

<P><STRONG><a name="[4]"></a>__rt_heap_escrow</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(heapauxi.o)(.text), UNUSED)

<P><STRONG><a name="[3]"></a>__rt_heap_expand</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(heapauxi.o)(.text), UNUSED)

<P><STRONG><a name="[1dc]"></a>__cpp_initialize__aeabi_</STRONG> (Thumb, 26 bytes, Stack size 16 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(init_aeabi.o)(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = __cpp_initialize__aeabi_
</UL>
<BR>[Called By]<UL><LI><a href="#[20d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init_cpp_2
</UL>

<P><STRONG><a name="[34c]"></a>__aeabi_vec_dtor</STRONG> (Thumb, 34 bytes, Stack size 24 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\cpplib\cpprt_w.l(aeabi_vec_dtor_noexceptions.o)(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = __aeabi_vec_dtor
</UL>
<BR>[Called By]<UL><LI><a href="#[145]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::SerialBase::~SerialBase()
<LI><a href="#[5c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::CircularBuffer&lang;mbed::Transaction&lang;mbed::SPI&rang;, (unsigned)4, unsigned&rang;::~CircularBuffer()
</UL>

<P><STRONG><a name="[73d]"></a>__user_libspace</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(libspace.o)(.text), UNUSED)

<P><STRONG><a name="[24f]"></a>__user_perproc_libspace</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(libspace.o)(.text))
<BR><BR>[Called By]<UL><LI><a href="#[207]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_locale
<LI><a href="#[21e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_heap_descriptor
</UL>

<P><STRONG><a name="[21e]"></a>__rt_heap_descriptor</STRONG> (Thumb, 10 bytes, Stack size 8 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(rt_heap_descriptor_twolibspace.o)(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = __rt_heap_descriptor
</UL>
<BR>[Calls]<UL><LI><a href="#[24f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__user_perproc_libspace
</UL>
<BR>[Called By]<UL><LI><a href="#[205]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_init_alloc
<LI><a href="#[220]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;free
<LI><a href="#[21d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;malloc
<LI><a href="#[277]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_terminate_alloc
</UL>

<P><STRONG><a name="[207]"></a>__rt_locale</STRONG> (Thumb, 10 bytes, Stack size 8 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(rt_locale_twolibspace.o)(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = __rt_locale
</UL>
<BR>[Calls]<UL><LI><a href="#[24f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__user_perproc_libspace
</UL>
<BR>[Called By]<UL><LI><a href="#[206]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init_lc_common
<LI><a href="#[25a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_fp_dec_real
<LI><a href="#[217]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_ctype_table
</UL>

<P><STRONG><a name="[73e]"></a>__use_no_heap</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(hguard.o)(.text), UNUSED)

<P><STRONG><a name="[73f]"></a>__heap$guard</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(hguard.o)(.text), UNUSED)

<P><STRONG><a name="[9]"></a>_terminate_user_alloc</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(init_alloc.o)(.text), UNUSED)

<P><STRONG><a name="[7]"></a>_init_user_alloc</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(init_alloc.o)(.text), UNUSED)

<P><STRONG><a name="[21c]"></a>__Heap_Full</STRONG> (Thumb, 34 bytes, Stack size 16 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(init_alloc.o)(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 72<LI>Call Chain = __Heap_Full &rArr; __Heap_ProvideMemory &rArr; _free_internal &rArr; _mutex_release &rArr; os_kernel_is_active &rArr; osKernelGetState &rArr; svcRtxKernelGetState
</UL>
<BR>[Calls]<UL><LI><a href="#[250]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__Heap_ProvideMemory
</UL>
<BR>[Called By]<UL><LI><a href="#[21a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_malloc_internal
</UL>

<P><STRONG><a name="[251]"></a>__Heap_Broken</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(init_alloc.o)(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[252]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_SIGRTMEM
</UL>

<P><STRONG><a name="[205]"></a>_init_alloc</STRONG> (Thumb, 94 bytes, Stack size 24 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(init_alloc.o)(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 160<LI>Call Chain = _init_alloc &rArr; __Heap_Initialize &rArr; _mutex_initialize &rArr; malloc &rArr; _malloc_internal &rArr; __Heap_Full &rArr; __Heap_ProvideMemory &rArr; _free_internal &rArr; _mutex_release &rArr; os_kernel_is_active &rArr; osKernelGetState &rArr; svcRtxKernelGetState
</UL>
<BR>[Calls]<UL><LI><a href="#[252]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_SIGRTMEM
<LI><a href="#[250]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__Heap_ProvideMemory
<LI><a href="#[253]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__Heap_Initialize
<LI><a href="#[21e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_heap_descriptor
</UL>
<BR>[Called By]<UL><LI><a href="#[204]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init_heap_2
</UL>

<P><STRONG><a name="[253]"></a>__Heap_Initialize</STRONG> (Thumb, 14 bytes, Stack size 0 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(h1_init_mt.o)(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 136<LI>Call Chain = __Heap_Initialize &rArr; _mutex_initialize &rArr; malloc &rArr; _malloc_internal &rArr; __Heap_Full &rArr; __Heap_ProvideMemory &rArr; _free_internal &rArr; _mutex_release &rArr; os_kernel_is_active &rArr; osKernelGetState &rArr; svcRtxKernelGetState
</UL>
<BR>[Calls]<UL><LI><a href="#[245]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_mutex_initialize
</UL>
<BR>[Called By]<UL><LI><a href="#[205]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_init_alloc
</UL>

<P><STRONG><a name="[5]"></a>__Heap_DescSize</STRONG> (Thumb, 4 bytes, Stack size 0 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(h1_init_mt.o)(.text), UNUSED)

<P><STRONG><a name="[22a]"></a>_printf_truncate_signed</STRONG> (Thumb, 18 bytes, Stack size 0 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(_printf_truncate.o)(.text))
<BR><BR>[Called By]<UL><LI><a href="#[1eb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_int_dec
</UL>

<P><STRONG><a name="[22b]"></a>_printf_truncate_unsigned</STRONG> (Thumb, 18 bytes, Stack size 0 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(_printf_truncate.o)(.text))
<BR><BR>[Called By]<UL><LI><a href="#[1ef]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_int_oct
<LI><a href="#[1f1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_int_hex
<LI><a href="#[1eb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_int_dec
</UL>

<P><STRONG><a name="[22c]"></a>_printf_int_common</STRONG> (Thumb, 178 bytes, Stack size 32 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(_printf_intcommon.o)(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = _printf_int_common &rArr; _printf_post_padding
</UL>
<BR>[Calls]<UL><LI><a href="#[229]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_post_padding
<LI><a href="#[228]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_pre_padding
</UL>
<BR>[Called By]<UL><LI><a href="#[260]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_longlong_oct
<LI><a href="#[1f3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_longlong_dec
<LI><a href="#[22d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_longlong_hex
<LI><a href="#[1eb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_int_dec
</UL>

<P><STRONG><a name="[1e1]"></a>_printf_charcount</STRONG> (Thumb, 40 bytes, Stack size 0 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(_printf_charcount.o)(.text))
<BR><BR>[Called By]<UL><LI><a href="#[1e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_n
</UL>

<P><STRONG><a name="[740]"></a>__lib_sel_fp_printf</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(_printf_fp_dec.o)(.text), UNUSED)

<P><STRONG><a name="[25a]"></a>_printf_fp_dec_real</STRONG> (Thumb, 620 bytes, Stack size 104 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(_printf_fp_dec.o)(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 324<LI>Call Chain = _printf_fp_dec_real &rArr; _fp_digits &rArr; _btod_etento &rArr; _btod_emul &rArr; _e2e
</UL>
<BR>[Calls]<UL><LI><a href="#[25c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_fp_infnan
<LI><a href="#[254]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_fp_digits
<LI><a href="#[207]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_locale
<LI><a href="#[229]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_post_padding
<LI><a href="#[228]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_pre_padding
<LI><a href="#[25b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_fpclassify
</UL>
<BR>[Called By]<UL><LI><a href="#[1e5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_fp_dec
</UL>

<P><STRONG><a name="[222]"></a>_printf_char_common</STRONG> (Thumb, 32 bytes, Stack size 64 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(_printf_char_common.o)(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 104 + Unknown Stack Size
<LI>Call Chain = _printf_char_common &rArr; __printf
</UL>
<BR>[Calls]<UL><LI><a href="#[22e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__printf
</UL>
<BR>[Called By]<UL><LI><a href="#[224]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_char_file
<LI><a href="#[226]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__2snprintf
<LI><a href="#[225]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__2sprintf
<LI><a href="#[221]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vsnprintf
</UL>

<P><STRONG><a name="[47]"></a>_sputc</STRONG> (Thumb, 10 bytes, Stack size 0 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(_sputc.o)(.text))
<BR><BR>[Called By]<UL><LI><a href="#[226]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__2snprintf
<LI><a href="#[225]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__2sprintf
<LI><a href="#[221]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vsnprintf
</UL>
<BR>[Address Reference Count : 1]<UL><LI> __2sprintf.o(.text)
</UL>
<P><STRONG><a name="[46]"></a>_snputc</STRONG> (Thumb, 16 bytes, Stack size 0 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(_snputc.o)(.text))
<BR>[Address Reference Count : 2]<UL><LI> vsnprintf.o(.text)
<LI> __2snprintf.o(.text)
</UL>
<P><STRONG><a name="[25d]"></a>_printf_cs_common</STRONG> (Thumb, 20 bytes, Stack size 8 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(_printf_char.o)(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = _printf_cs_common &rArr; _printf_str &rArr; _printf_post_padding
</UL>
<BR>[Calls]<UL><LI><a href="#[227]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_str
</UL>
<BR>[Called By]<UL><LI><a href="#[1fd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_string
<LI><a href="#[1fb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_char
</UL>

<P><STRONG><a name="[1fb]"></a>_printf_char</STRONG> (Thumb, 16 bytes, Stack size 0 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(_printf_char.o)(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = _printf_char &rArr; _printf_cs_common &rArr; _printf_str &rArr; _printf_post_padding
</UL>
<BR>[Calls]<UL><LI><a href="#[25d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_cs_common
</UL>
<BR>[Called By]<UL><LI><a href="#[1fa]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_c
</UL>

<P><STRONG><a name="[1fd]"></a>_printf_string</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(_printf_char.o)(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = _printf_string &rArr; _printf_cs_common &rArr; _printf_str &rArr; _printf_post_padding
</UL>
<BR>[Calls]<UL><LI><a href="#[25d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_cs_common
</UL>
<BR>[Called By]<UL><LI><a href="#[1fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_s
</UL>

<P><STRONG><a name="[25e]"></a>_printf_wctomb</STRONG> (Thumb, 182 bytes, Stack size 56 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(_printf_wctomb.o)(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 88<LI>Call Chain = _printf_wctomb &rArr; _wcrtomb &rArr; __rt_ctype_table &rArr; __rt_locale
</UL>
<BR>[Calls]<UL><LI><a href="#[25f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_wcrtomb
<LI><a href="#[229]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_post_padding
<LI><a href="#[228]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_pre_padding
</UL>
<BR>[Called By]<UL><LI><a href="#[272]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_lcs_common
</UL>

<P><STRONG><a name="[1f3]"></a>_printf_longlong_dec</STRONG> (Thumb, 108 bytes, Stack size 24 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(_printf_longlong_dec.o)(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 72<LI>Call Chain = _printf_longlong_dec &rArr; _printf_int_common &rArr; _printf_post_padding
</UL>
<BR>[Calls]<UL><LI><a href="#[259]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_ll_udiv10
<LI><a href="#[22c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_int_common
</UL>
<BR>[Called By]<UL><LI><a href="#[1f5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_llu
<LI><a href="#[1f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_lld
<LI><a href="#[1f2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_lli
</UL>

<P><STRONG><a name="[260]"></a>_printf_longlong_oct</STRONG> (Thumb, 66 bytes, Stack size 8 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(_printf_oct_int_ll.o)(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = _printf_longlong_oct &rArr; _printf_int_common &rArr; _printf_post_padding
</UL>
<BR>[Calls]<UL><LI><a href="#[22c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_int_common
</UL>
<BR>[Called By]<UL><LI><a href="#[1f7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_ll_oct
<LI><a href="#[1ef]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_int_oct
</UL>

<P><STRONG><a name="[1ef]"></a>_printf_int_oct</STRONG> (Thumb, 24 bytes, Stack size 8 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(_printf_oct_int_ll.o)(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 64<LI>Call Chain = _printf_int_oct &rArr; _printf_longlong_oct &rArr; _printf_int_common &rArr; _printf_post_padding
</UL>
<BR>[Calls]<UL><LI><a href="#[260]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_longlong_oct
<LI><a href="#[22b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_truncate_unsigned
</UL>
<BR>[Called By]<UL><LI><a href="#[1ee]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_o
</UL>

<P><STRONG><a name="[1f7]"></a>_printf_ll_oct</STRONG> (Thumb, 12 bytes, Stack size 0 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(_printf_oct_int_ll.o)(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = _printf_ll_oct &rArr; _printf_longlong_oct &rArr; _printf_int_common &rArr; _printf_post_padding
</UL>
<BR>[Calls]<UL><LI><a href="#[260]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_longlong_oct
</UL>
<BR>[Called By]<UL><LI><a href="#[1f6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_llo
</UL>

<P><STRONG><a name="[234]"></a>_chval</STRONG> (Thumb, 28 bytes, Stack size 0 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(_chval.o)(.text))
<BR><BR>[Called By]<UL><LI><a href="#[236]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_strtoul
<LI><a href="#[233]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_scanf_int
</UL>

<P><STRONG><a name="[232]"></a>__vfscanf_char</STRONG> (Thumb, 24 bytes, Stack size 0 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(scanf_char.o)(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 152<LI>Call Chain = __vfscanf_char &rArr; __vfscanf &rArr; _scanf_int
</UL>
<BR>[Calls]<UL><LI><a href="#[261]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__vfscanf
</UL>
<BR>[Called By]<UL><LI><a href="#[231]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__0sscanf
</UL>

<P><STRONG><a name="[48]"></a>_sgetc</STRONG> (Thumb, 30 bytes, Stack size 0 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(_sgetc.o)(.text))
<BR>[Address Reference Count : 1]<UL><LI> __0sscanf.o(.text)
</UL>
<P><STRONG><a name="[49]"></a>_sbackspace</STRONG> (Thumb, 34 bytes, Stack size 0 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(_sgetc.o)(.text))
<BR>[Address Reference Count : 1]<UL><LI> __0sscanf.o(.text)
</UL>
<P><STRONG><a name="[236]"></a>_strtoul</STRONG> (Thumb, 158 bytes, Stack size 40 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(_strtoul.o)(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 80<LI>Call Chain = _strtoul &rArr; __aeabi_errno_addr &rArr; __user_perthread_libspace &rArr; os_kernel_is_active &rArr; osKernelGetState &rArr; svcRtxKernelGetState
</UL>
<BR>[Calls]<UL><LI><a href="#[234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_chval
<LI><a href="#[218]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_errno_addr
</UL>
<BR>[Called By]<UL><LI><a href="#[235]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;strtol
</UL>

<P><STRONG><a name="[262]"></a>__flsbuf</STRONG> (Thumb, 470 bytes, Stack size 32 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(flsbuf.o)(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[266]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_sys_istty
<LI><a href="#[265]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_sys_flen
<LI><a href="#[263]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_deferredlazyseek
<LI><a href="#[267]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_writebuf
<LI><a href="#[264]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_seterr
<LI><a href="#[21d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;malloc
</UL>

<P><STRONG><a name="[4ba]"></a>__flsbuf_byte</STRONG> (Thumb, 0 bytes, Stack size 32 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(flsbuf.o)(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = __flsbuf_byte
</UL>
<BR>[Called By]<UL><LI><a href="#[4d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_fputc$unlocked
</UL>

<P><STRONG><a name="[741]"></a>__flsbuf_wide</STRONG> (Thumb, 0 bytes, Stack size 32 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(flsbuf.o)(.text), UNUSED)

<P><STRONG><a name="[23f]"></a>_fseek</STRONG> (Thumb, 242 bytes, Stack size 24 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(fseek.o)(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 320<LI>Call Chain = _fseek &rArr; _sys_istty &rArr; isatty &rArr; get_fhc(int) &rArr; get_console(int) &rArr; default_console() &rArr; DirectSerial::DirectSerial(PinName, PinName, int) &rArr; serial_init &rArr; uart_init &rArr; serial_baud &rArr; serial_leuart_baud &rArr;  mbed_assert_internal (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[266]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_sys_istty
<LI><a href="#[265]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_sys_flen
<LI><a href="#[268]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_ftell_internal
<LI><a href="#[264]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_seterr
</UL>
<BR>[Called By]<UL><LI><a href="#[241]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_freopen_locked
<LI><a href="#[23e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_do_fflush
</UL>

<P><STRONG><a name="[742]"></a>fseek</STRONG> (Thumb, 0 bytes, Stack size 24 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(fseek.o)(.text), UNUSED)

<P><STRONG><a name="[264]"></a>_seterr</STRONG> (Thumb, 20 bytes, Stack size 0 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(stdio.o)(.text))
<BR><BR>[Called By]<UL><LI><a href="#[267]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_writebuf
<LI><a href="#[23f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_fseek
<LI><a href="#[262]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__flsbuf
</UL>

<P><STRONG><a name="[267]"></a>_writebuf</STRONG> (Thumb, 84 bytes, Stack size 32 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(stdio.o)(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 368<LI>Call Chain = _writebuf &rArr; _sys_write &rArr; convert_crlf(int) &rArr; isatty &rArr; get_fhc(int) &rArr; get_console(int) &rArr; default_console() &rArr; DirectSerial::DirectSerial(PinName, PinName, int) &rArr; serial_init &rArr; uart_init &rArr; serial_baud &rArr; serial_leuart_baud &rArr;  mbed_assert_internal (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[26a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_sys_write
<LI><a href="#[269]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_sys_seek
<LI><a href="#[264]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_seterr
</UL>
<BR>[Called By]<UL><LI><a href="#[23a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_fflush
<LI><a href="#[262]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__flsbuf
</UL>

<P><STRONG><a name="[23a]"></a>_fflush</STRONG> (Thumb, 70 bytes, Stack size 16 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(stdio.o)(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 384<LI>Call Chain = _fflush &rArr; _writebuf &rArr; _sys_write &rArr; convert_crlf(int) &rArr; isatty &rArr; get_fhc(int) &rArr; get_console(int) &rArr; default_console() &rArr; DirectSerial::DirectSerial(PinName, PinName, int) &rArr; serial_init &rArr; uart_init &rArr; serial_baud &rArr; serial_leuart_baud &rArr;  mbed_assert_internal (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[267]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_writebuf
</UL>
<BR>[Called By]<UL><LI><a href="#[263]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_deferredlazyseek
<LI><a href="#[23e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_do_fflush
<LI><a href="#[239]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_fclose_internal
</UL>

<P><STRONG><a name="[263]"></a>_deferredlazyseek</STRONG> (Thumb, 60 bytes, Stack size 8 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(stdio.o)(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[23a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_fflush
</UL>
<BR>[Called By]<UL><LI><a href="#[262]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__flsbuf
</UL>

<P><STRONG><a name="[238]"></a>setvbuf</STRONG> (Thumb, 104 bytes, Stack size 32 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(setvbuf_locked.o)(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 64<LI>Call Chain = setvbuf &rArr; _mutex_release &rArr; os_kernel_is_active &rArr; osKernelGetState &rArr; svcRtxKernelGetState
</UL>
<BR>[Calls]<UL><LI><a href="#[1db]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_mutex_release
<LI><a href="#[1da]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_mutex_acquire
</UL>
<BR>[Called By]<UL><LI><a href="#[20c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_initio
<LI><a href="#[237]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;setbuf
</UL>

<P><STRONG><a name="[20c]"></a>_initio</STRONG> (Thumb, 240 bytes, Stack size 8 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(initio_locked.o)(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 768 + Unknown Stack Size
<LI>Call Chain = _initio &rArr; freopen &rArr; _freopen_locked &rArr; _sys_open &rArr; open &rArr; mbed::FilePath::FilePath(const char*) &rArr; mbed::FileBase::lookup(const char*, unsigned) &rArr; SingletonPtr&lang;rtos::Mutex&rang;::operator -&rang;() &rArr; SingletonPtr&lang;rtos::Mutex&rang;::get() &rArr; rtos::Mutex::Mutex() &rArr; rtos::Mutex::constructor(const char*) &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[245]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_mutex_initialize
<LI><a href="#[26b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_SIGRTRED
<LI><a href="#[238]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;setvbuf
<LI><a href="#[23c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memclr4
<LI><a href="#[243]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;freopen
</UL>
<BR>[Called By]<UL><LI><a href="#[20b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init_stdio_2
</UL>

<P><STRONG><a name="[26c]"></a>_terminateio</STRONG> (Thumb, 168 bytes, Stack size 24 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(initio_locked.o)(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[1db]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_mutex_release
<LI><a href="#[1da]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_mutex_acquire
<LI><a href="#[239]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_fclose_internal
<LI><a href="#[220]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;free
</UL>

<P><STRONG><a name="[26d]"></a>__rt_SIGPVFN</STRONG> (Thumb, 14 bytes, Stack size 8 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(defsig_pvfn_outer.o)(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = __rt_SIGPVFN &rArr; __rt_SIGPVFN_inner &rArr; __default_signal_display &rArr; _ttywrch
</UL>
<BR>[Calls]<UL><LI><a href="#[26e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_SIGPVFN_inner
<LI><a href="#[26f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__sig_exit
</UL>
<BR>[Called By]<UL><LI><a href="#[122]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__cxa_pure_virtual
</UL>

<P><STRONG><a name="[743]"></a>__aeabi_memmove4</STRONG> (Thumb, 0 bytes, Stack size 8 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(rt_memmove_w.o)(.text), UNUSED)

<P><STRONG><a name="[744]"></a>__aeabi_memmove8</STRONG> (Thumb, 0 bytes, Stack size 8 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(rt_memmove_w.o)(.text), UNUSED)

<P><STRONG><a name="[270]"></a>__rt_memmove_w</STRONG> (Thumb, 122 bytes, Stack size 8 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(rt_memmove_w.o)(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[247]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy4
</UL>

<P><STRONG><a name="[24a]"></a>__memmove_aligned</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(rt_memmove_w.o)(.text), UNUSED)
<BR><BR>[Called By]<UL><LI><a href="#[248]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_memmove
</UL>

<P><STRONG><a name="[745]"></a>__memmove_lastfew_aligned</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(rt_memmove_w.o)(.text), UNUSED)

<P><STRONG><a name="[279]"></a>_ttywrch</STRONG> (Thumb, 14 bytes, Stack size 8 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(sys_wrch.o)(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = _ttywrch
</UL>
<BR>[Called By]<UL><LI><a href="#[276]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__default_signal_display
</UL>

<P><STRONG><a name="[273]"></a>_sys_exit</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(sys_exit.o)(.text))
<BR><BR>[Called By]<UL><LI><a href="#[26f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__sig_exit
</UL>

<P><STRONG><a name="[250]"></a>__Heap_ProvideMemory</STRONG> (Thumb, 62 bytes, Stack size 8 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(h1_extend_mt.o)(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = __Heap_ProvideMemory &rArr; _free_internal &rArr; _mutex_release &rArr; os_kernel_is_active &rArr; osKernelGetState &rArr; svcRtxKernelGetState
</UL>
<BR>[Calls]<UL><LI><a href="#[21f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_free_internal
</UL>
<BR>[Called By]<UL><LI><a href="#[205]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_init_alloc
<LI><a href="#[21c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__Heap_Full
</UL>

<P><STRONG><a name="[259]"></a>_ll_udiv10</STRONG> (Thumb, 138 bytes, Stack size 12 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(lludiv10.o)(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = _ll_udiv10
</UL>
<BR>[Called By]<UL><LI><a href="#[1f3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_longlong_dec
<LI><a href="#[254]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_fp_digits
</UL>

<P><STRONG><a name="[271]"></a>_printf_fp_hex_real</STRONG> (Thumb, 756 bytes, Stack size 72 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(_printf_fp_hex.o)(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 112<LI>Call Chain = _printf_fp_hex_real &rArr; _printf_fp_infnan &rArr; _printf_post_padding
</UL>
<BR>[Calls]<UL><LI><a href="#[25c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_fp_infnan
<LI><a href="#[229]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_post_padding
<LI><a href="#[228]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_pre_padding
<LI><a href="#[25b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_fpclassify
</UL>
<BR>[Called By]<UL><LI><a href="#[1e9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_fp_hex
</UL>

<P><STRONG><a name="[25c]"></a>_printf_fp_infnan</STRONG> (Thumb, 112 bytes, Stack size 24 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(_printf_fp_infnan.o)(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = _printf_fp_infnan &rArr; _printf_post_padding
</UL>
<BR>[Calls]<UL><LI><a href="#[229]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_post_padding
<LI><a href="#[228]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_pre_padding
</UL>
<BR>[Called By]<UL><LI><a href="#[271]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_fp_hex_real
<LI><a href="#[25a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_fp_dec_real
</UL>

<P><STRONG><a name="[224]"></a>_printf_char_file</STRONG> (Thumb, 58 bytes, Stack size 24 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(_printf_char_file_locked.o)(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 128 + Unknown Stack Size
<LI>Call Chain = _printf_char_file &rArr; _printf_char_common &rArr; __printf
</UL>
<BR>[Calls]<UL><LI><a href="#[1db]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_mutex_release
<LI><a href="#[1da]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_mutex_acquire
<LI><a href="#[222]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_char_common
</UL>
<BR>[Called By]<UL><LI><a href="#[223]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__2printf
</UL>

<P><STRONG><a name="[272]"></a>_printf_lcs_common</STRONG> (Thumb, 20 bytes, Stack size 8 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(_printf_wchar.o)(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 96<LI>Call Chain = _printf_lcs_common &rArr; _printf_wctomb &rArr; _wcrtomb &rArr; __rt_ctype_table &rArr; __rt_locale
</UL>
<BR>[Calls]<UL><LI><a href="#[25e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_wctomb
</UL>
<BR>[Called By]<UL><LI><a href="#[201]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_wstring
<LI><a href="#[1ff]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_wchar
</UL>

<P><STRONG><a name="[1ff]"></a>_printf_wchar</STRONG> (Thumb, 16 bytes, Stack size 0 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(_printf_wchar.o)(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 96<LI>Call Chain = _printf_wchar &rArr; _printf_lcs_common &rArr; _printf_wctomb &rArr; _wcrtomb &rArr; __rt_ctype_table &rArr; __rt_locale
</UL>
<BR>[Calls]<UL><LI><a href="#[272]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_lcs_common
</UL>
<BR>[Called By]<UL><LI><a href="#[1fe]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_lc
</UL>

<P><STRONG><a name="[201]"></a>_printf_wstring</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(_printf_wchar.o)(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 96<LI>Call Chain = _printf_wstring &rArr; _printf_lcs_common &rArr; _printf_wctomb &rArr; _wcrtomb &rArr; __rt_ctype_table &rArr; __rt_locale
</UL>
<BR>[Calls]<UL><LI><a href="#[272]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_lcs_common
</UL>
<BR>[Called By]<UL><LI><a href="#[200]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_ls
</UL>

<P><STRONG><a name="[261]"></a>__vfscanf</STRONG> (Thumb, 878 bytes, Stack size 96 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(_scanf.o)(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 152<LI>Call Chain = __vfscanf &rArr; _scanf_int
</UL>
<BR>[Calls]<UL><LI><a href="#[233]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_scanf_int
</UL>
<BR>[Called By]<UL><LI><a href="#[232]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__vfscanf_char
</UL>

<P><STRONG><a name="[255]"></a>_btod_etento</STRONG> (Thumb, 224 bytes, Stack size 72 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(bigflt0.o)(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 124<LI>Call Chain = _btod_etento &rArr; _btod_emul &rArr; _e2e
</UL>
<BR>[Calls]<UL><LI><a href="#[258]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_btod_emul
<LI><a href="#[257]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_btod_ediv
</UL>
<BR>[Called By]<UL><LI><a href="#[254]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_fp_digits
</UL>

<P><STRONG><a name="[268]"></a>_ftell_internal</STRONG> (Thumb, 66 bytes, Stack size 8 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(ftell.o)(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = _ftell_internal &rArr; __aeabi_errno_addr &rArr; __user_perthread_libspace &rArr; os_kernel_is_active &rArr; osKernelGetState &rArr; svcRtxKernelGetState
</UL>
<BR>[Calls]<UL><LI><a href="#[218]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_errno_addr
</UL>
<BR>[Called By]<UL><LI><a href="#[23f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_fseek
</UL>

<P><STRONG><a name="[746]"></a>ftell</STRONG> (Thumb, 0 bytes, Stack size 8 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(ftell.o)(.text), UNUSED)

<P><STRONG><a name="[25f]"></a>_wcrtomb</STRONG> (Thumb, 64 bytes, Stack size 16 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(_wcrtomb.o)(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = _wcrtomb &rArr; __rt_ctype_table &rArr; __rt_locale
</UL>
<BR>[Calls]<UL><LI><a href="#[217]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_ctype_table
</UL>
<BR>[Called By]<UL><LI><a href="#[25e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_wctomb
</UL>

<P><STRONG><a name="[26f]"></a>__sig_exit</STRONG> (Thumb, 10 bytes, Stack size 0 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(defsig_exit.o)(.text))
<BR><BR>[Calls]<UL><LI><a href="#[273]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_sys_exit
</UL>
<BR>[Called By]<UL><LI><a href="#[252]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_SIGRTMEM
<LI><a href="#[26b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_SIGRTRED
<LI><a href="#[26d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_SIGPVFN
</UL>

<P><STRONG><a name="[26b]"></a>__rt_SIGRTRED</STRONG> (Thumb, 14 bytes, Stack size 8 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(defsig_rtred_outer.o)(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = __rt_SIGRTRED &rArr; __rt_SIGRTRED_inner &rArr; __default_signal_display &rArr; _ttywrch
</UL>
<BR>[Calls]<UL><LI><a href="#[26f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__sig_exit
<LI><a href="#[274]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_SIGRTRED_inner
</UL>
<BR>[Called By]<UL><LI><a href="#[20c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_initio
</UL>

<P><STRONG><a name="[252]"></a>__rt_SIGRTMEM</STRONG> (Thumb, 14 bytes, Stack size 8 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(defsig_rtmem_outer.o)(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = __rt_SIGRTMEM &rArr; __rt_SIGRTMEM_inner &rArr; __default_signal_display &rArr; _ttywrch
</UL>
<BR>[Calls]<UL><LI><a href="#[26f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__sig_exit
<LI><a href="#[275]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_SIGRTMEM_inner
</UL>
<BR>[Called By]<UL><LI><a href="#[205]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_init_alloc
<LI><a href="#[251]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__Heap_Broken
</UL>

<P><STRONG><a name="[26e]"></a>__rt_SIGPVFN_inner</STRONG> (Thumb, 14 bytes, Stack size 8 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(defsig_pvfn_inner.o)(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = __rt_SIGPVFN_inner &rArr; __default_signal_display &rArr; _ttywrch
</UL>
<BR>[Calls]<UL><LI><a href="#[276]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__default_signal_display
</UL>
<BR>[Called By]<UL><LI><a href="#[26d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_SIGPVFN
</UL>

<P><STRONG><a name="[747]"></a>__I$use$semihosting</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(use_no_semi.o)(.text), UNUSED)

<P><STRONG><a name="[748]"></a>__use_no_semihosting_swi</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(use_no_semi.o)(.text), UNUSED)

<P><STRONG><a name="[749]"></a>__semihosting_library_function</STRONG> (Thumb, 0 bytes, Stack size 8 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(indicate_semi.o)(.text), UNUSED)

<P><STRONG><a name="[277]"></a>_terminate_alloc</STRONG> (Thumb, 16 bytes, Stack size 8 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(term_alloc.o)(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[21e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_heap_descriptor
<LI><a href="#[278]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__Heap_Finalize
</UL>

<P><STRONG><a name="[276]"></a>__default_signal_display</STRONG> (Thumb, 50 bytes, Stack size 16 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(defsig_general.o)(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = __default_signal_display &rArr; _ttywrch
</UL>
<BR>[Calls]<UL><LI><a href="#[279]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_ttywrch
</UL>
<BR>[Called By]<UL><LI><a href="#[26e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_SIGPVFN_inner
<LI><a href="#[275]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_SIGRTMEM_inner
<LI><a href="#[274]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_SIGRTRED_inner
</UL>

<P><STRONG><a name="[274]"></a>__rt_SIGRTRED_inner</STRONG> (Thumb, 14 bytes, Stack size 8 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(defsig_rtred_inner.o)(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = __rt_SIGRTRED_inner &rArr; __default_signal_display &rArr; _ttywrch
</UL>
<BR>[Calls]<UL><LI><a href="#[276]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__default_signal_display
</UL>
<BR>[Called By]<UL><LI><a href="#[26b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_SIGRTRED
</UL>

<P><STRONG><a name="[275]"></a>__rt_SIGRTMEM_inner</STRONG> (Thumb, 22 bytes, Stack size 8 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(defsig_rtmem_inner.o)(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = __rt_SIGRTMEM_inner &rArr; __default_signal_display &rArr; _ttywrch
</UL>
<BR>[Calls]<UL><LI><a href="#[276]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__default_signal_display
</UL>
<BR>[Called By]<UL><LI><a href="#[252]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_SIGRTMEM
</UL>

<P><STRONG><a name="[278]"></a>__Heap_Finalize</STRONG> (Thumb, 10 bytes, Stack size 8 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(h1_final_mt.o)(.text), UNUSED)
<BR><BR>[Called By]<UL><LI><a href="#[277]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_terminate_alloc
</UL>

<P><STRONG><a name="[256]"></a>_btod_d2e</STRONG> (Thumb, 62 bytes, Stack size 0 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(btod.o)(CL$$btod_d2e))
<BR><BR>[Calls]<UL><LI><a href="#[27a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_d2e_norm_op1
</UL>
<BR>[Called By]<UL><LI><a href="#[254]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_fp_digits
</UL>

<P><STRONG><a name="[27b]"></a>_d2e_denorm_low</STRONG> (Thumb, 70 bytes, Stack size 0 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(btod.o)(CL$$btod_d2e_denorm_low))
<BR><BR>[Called By]<UL><LI><a href="#[27a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_d2e_norm_op1
</UL>

<P><STRONG><a name="[27a]"></a>_d2e_norm_op1</STRONG> (Thumb, 96 bytes, Stack size 0 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(btod.o)(CL$$btod_d2e_norm_op1))
<BR><BR>[Calls]<UL><LI><a href="#[27b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_d2e_denorm_low
</UL>
<BR>[Called By]<UL><LI><a href="#[256]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_btod_d2e
</UL>

<P><STRONG><a name="[27c]"></a>__btod_div_common</STRONG> (Thumb, 696 bytes, Stack size 24 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(btod.o)(CL$$btod_div_common))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = __btod_div_common
</UL>
<BR>[Called By]<UL><LI><a href="#[257]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_btod_ediv
</UL>

<P><STRONG><a name="[27d]"></a>_e2e</STRONG> (Thumb, 220 bytes, Stack size 24 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(btod.o)(CL$$btod_e2e))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = _e2e
</UL>
<BR>[Called By]<UL><LI><a href="#[258]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_btod_emul
<LI><a href="#[257]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_btod_ediv
</UL>

<P><STRONG><a name="[257]"></a>_btod_ediv</STRONG> (Thumb, 42 bytes, Stack size 28 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(btod.o)(CL$$btod_ediv))
<BR><BR>[Stack]<UL><LI>Max Depth = 52<LI>Call Chain = _btod_ediv &rArr; _e2e
</UL>
<BR>[Calls]<UL><LI><a href="#[27d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_e2e
<LI><a href="#[27c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__btod_div_common
</UL>
<BR>[Called By]<UL><LI><a href="#[255]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_btod_etento
<LI><a href="#[254]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_fp_digits
</UL>

<P><STRONG><a name="[258]"></a>_btod_emul</STRONG> (Thumb, 42 bytes, Stack size 28 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(btod.o)(CL$$btod_emul))
<BR><BR>[Stack]<UL><LI>Max Depth = 52<LI>Call Chain = _btod_emul &rArr; _e2e
</UL>
<BR>[Calls]<UL><LI><a href="#[27e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__btod_mult_common
<LI><a href="#[27d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_e2e
</UL>
<BR>[Called By]<UL><LI><a href="#[255]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_btod_etento
<LI><a href="#[254]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_fp_digits
</UL>

<P><STRONG><a name="[27e]"></a>__btod_mult_common</STRONG> (Thumb, 580 bytes, Stack size 16 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(btod.o)(CL$$btod_mult_common))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = __btod_mult_common
</UL>
<BR>[Called By]<UL><LI><a href="#[258]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_btod_emul
</UL>

<P><STRONG><a name="[27f]"></a>main</STRONG> (Thumb, 12 bytes, Stack size 8 bytes, .\build\mbed_boot.o(i.$Sub$$main))
<BR><BR>[Stack]<UL><LI>Max Depth = 864 + Unknown Stack Size
<LI>Call Chain = main &rArr; $Super$$main &rArr; test_send_recv() &rArr; TCPSocket::TCPSocket() &rArr; Socket::Socket__sub_object() &rArr; rtos::Mutex::Mutex() &rArr; rtos::Mutex::constructor(const char*) &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[280]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_main
<LI><a href="#[281]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;$Super$$main
</UL>
<BR>[Called By]<UL><LI><a href="#[75]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pre_main
</UL>

<P><STRONG><a name="[283]"></a>CMU_ClockDivSet</STRONG> (Thumb, 406 bytes, Stack size 24 bytes, .\build\em_cmu.o(i.CMU_ClockDivSet))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = CMU_ClockDivSet &rArr; CMU_UpdateWaitStates &rArr; flashWaitStateControl
</UL>
<BR>[Calls]<UL><LI><a href="#[28a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;syncReg
<LI><a href="#[289]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;setHfLeConfig
<LI><a href="#[284]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;flashWaitStateMax
<LI><a href="#[287]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CMU_DivToLog2
<LI><a href="#[288]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SystemHFClockGet
<LI><a href="#[285]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SystemCoreClockGet
<LI><a href="#[286]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CMU_UpdateWaitStates
</UL>
<BR>[Called By]<UL><LI><a href="#[53c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtc_init_real
<LI><a href="#[64a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_leuart_baud
</UL>

<P><STRONG><a name="[28b]"></a>CMU_ClockEnable</STRONG> (Thumb, 126 bytes, Stack size 32 bytes, .\build\em_cmu.o(i.CMU_ClockEnable))
<BR><BR>[Stack]<UL><LI>Max Depth = 88<LI>Call Chain = CMU_ClockEnable &rArr; CMU_ClockFreqGet &rArr; lfClkGet &rArr; getHfLeConfig &rArr; BUS_RegBitRead
</UL>
<BR>[Calls]<UL><LI><a href="#[28a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;syncReg
<LI><a href="#[289]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;setHfLeConfig
<LI><a href="#[28d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BUS_RegBitWrite
<LI><a href="#[28c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CMU_ClockFreqGet
</UL>
<BR>[Called By]<UL><LI><a href="#[4cb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pin_mode
<LI><a href="#[445]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;gpio_init
<LI><a href="#[53c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtc_init_real
<LI><a href="#[43e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_sdk_init
<LI><a href="#[327]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_init
<LI><a href="#[115]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;us_ticker_init
</UL>

<P><STRONG><a name="[28c]"></a>CMU_ClockFreqGet</STRONG> (Thumb, 300 bytes, Stack size 16 bytes, .\build\em_cmu.o(i.CMU_ClockFreqGet))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = CMU_ClockFreqGet &rArr; lfClkGet &rArr; getHfLeConfig &rArr; BUS_RegBitRead
</UL>
<BR>[Calls]<UL><LI><a href="#[291]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;usbCClkGet
<LI><a href="#[28e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lfClkGet
<LI><a href="#[28f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dbgClkGet
<LI><a href="#[290]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;auxClkGet
<LI><a href="#[287]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CMU_DivToLog2
<LI><a href="#[288]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SystemHFClockGet
<LI><a href="#[285]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SystemCoreClockGet
</UL>
<BR>[Called By]<UL><LI><a href="#[28b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CMU_ClockEnable
<LI><a href="#[292]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CMU_ClockSelectSet
<LI><a href="#[2b6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LEUART_BaudrateSet
<LI><a href="#[2b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LEUART_BaudrateGet
<LI><a href="#[2db]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;USART_BaudrateAsyncSet
</UL>

<P><STRONG><a name="[478]"></a>CMU_ClockSelectGet</STRONG> (Thumb, 266 bytes, Stack size 0 bytes, .\build\em_cmu.o(i.CMU_ClockSelectGet))
<BR><BR>[Called By]<UL><LI><a href="#[291]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;usbCClkGet
<LI><a href="#[28e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lfClkGet
<LI><a href="#[28f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dbgClkGet
<LI><a href="#[29a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;emState
</UL>

<P><STRONG><a name="[292]"></a>CMU_ClockSelectSet</STRONG> (Thumb, 510 bytes, Stack size 40 bytes, .\build\em_cmu.o(i.CMU_ClockSelectSet))
<BR><BR>[Stack]<UL><LI>Max Depth = 96<LI>Call Chain = CMU_ClockSelectSet &rArr; CMU_ClockFreqGet &rArr; lfClkGet &rArr; getHfLeConfig &rArr; BUS_RegBitRead
</UL>
<BR>[Calls]<UL><LI><a href="#[294]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CMU_OscillatorEnable
<LI><a href="#[289]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;setHfLeConfig
<LI><a href="#[284]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;flashWaitStateMax
<LI><a href="#[28d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BUS_RegBitWrite
<LI><a href="#[28c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CMU_ClockFreqGet
<LI><a href="#[293]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SystemHFXOClockGet
<LI><a href="#[285]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SystemCoreClockGet
<LI><a href="#[286]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CMU_UpdateWaitStates
</UL>
<BR>[Called By]<UL><LI><a href="#[29a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;emState
<LI><a href="#[43e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_sdk_init
<LI><a href="#[327]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_init
<LI><a href="#[64a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_leuart_baud
</UL>

<P><STRONG><a name="[294]"></a>CMU_OscillatorEnable</STRONG> (Thumb, 114 bytes, Stack size 32 bytes, .\build\em_cmu.o(i.CMU_OscillatorEnable))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = CMU_OscillatorEnable &rArr; BUS_RegBitRead
</UL>
<BR>[Calls]<UL><LI><a href="#[295]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BUS_RegBitRead
</UL>
<BR>[Called By]<UL><LI><a href="#[292]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CMU_ClockSelectSet
</UL>

<P><STRONG><a name="[286]"></a>CMU_UpdateWaitStates</STRONG> (Thumb, 16 bytes, Stack size 16 bytes, .\build\em_cmu.o(i.CMU_UpdateWaitStates))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = CMU_UpdateWaitStates &rArr; flashWaitStateControl
</UL>
<BR>[Calls]<UL><LI><a href="#[296]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;flashWaitStateControl
</UL>
<BR>[Called By]<UL><LI><a href="#[292]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CMU_ClockSelectSet
<LI><a href="#[283]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CMU_ClockDivSet
</UL>

<P><STRONG><a name="[297]"></a>CORE_EnterCritical</STRONG> (Thumb, 14 bytes, Stack size 8 bytes, .\build\em_core.o(i.CORE_EnterCritical))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = CORE_EnterCritical
</UL>
<BR>[Calls]<UL><LI><a href="#[298]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__get_PRIMASK
</UL>
<BR>[Called By]<UL><LI><a href="#[299]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EMU_EnterEM2
</UL>

<P><STRONG><a name="[29d]"></a>CORE_ExitCritical</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, .\build\em_core.o(i.CORE_ExitCritical))
<BR><BR>[Called By]<UL><LI><a href="#[299]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EMU_EnterEM2
</UL>

<P><STRONG><a name="[665]"></a>DMA_ChannelEnable</STRONG> (Thumb, 22 bytes, Stack size 0 bytes, .\build\em_dma.o(i.DMA_ChannelEnable))
<BR><BR>[Called By]<UL><LI><a href="#[65a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_tx_abort_asynch_intern
<LI><a href="#[659]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_rx_abort_asynch_intern
</UL>

<P><STRONG><a name="[1a]"></a>DMA_IRQHandler</STRONG> (Thumb, 130 bytes, Stack size 40 bytes, .\build\em_dma.o(i.DMA_IRQHandler))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = DMA_IRQHandler
</UL>
<BR>[Address Reference Count : 1]<UL><LI> startup_efm32wg.o(RESET)
</UL>
<P><STRONG><a name="[299]"></a>EMU_EnterEM2</STRONG> (Thumb, 128 bytes, Stack size 24 bytes, .\build\em_emu.o(i.EMU_EnterEM2))
<BR><BR>[Stack]<UL><LI>Max Depth = 136<LI>Call Chain = EMU_EnterEM2 &rArr; emState &rArr; CMU_ClockSelectSet &rArr; CMU_ClockFreqGet &rArr; lfClkGet &rArr; getHfLeConfig &rArr; BUS_RegBitRead
</UL>
<BR>[Calls]<UL><LI><a href="#[29c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ramWFI
<LI><a href="#[29b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;getErrataFixEmuE107En
<LI><a href="#[29a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;emState
<LI><a href="#[29d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CORE_ExitCritical
<LI><a href="#[297]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CORE_EnterCritical
<LI><a href="#[285]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SystemCoreClockGet
</UL>
<BR>[Called By]<UL><LI><a href="#[4ce]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hal_deepsleep
</UL>

<P><STRONG><a name="[5b2]"></a>EvrRtxEventFlagsClear</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\rtx_evr.o(i.EvrRtxEventFlagsClear))
<BR><BR>[Called By]<UL><LI><a href="#[5b1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osEventFlagsClear
</UL>

<P><STRONG><a name="[674]"></a>EvrRtxEventFlagsClearDone</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\rtx_evr.o(i.EvrRtxEventFlagsClearDone))
<BR><BR>[Called By]<UL><LI><a href="#[82]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxEventFlagsClear
</UL>

<P><STRONG><a name="[676]"></a>EvrRtxEventFlagsCreated</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\rtx_evr.o(i.EvrRtxEventFlagsCreated))
<BR><BR>[Called By]<UL><LI><a href="#[84]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxEventFlagsNew
</UL>

<P><STRONG><a name="[5b6]"></a>EvrRtxEventFlagsDelete</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\rtx_evr.o(i.EvrRtxEventFlagsDelete))
<BR><BR>[Called By]<UL><LI><a href="#[421]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osEventFlagsDelete
</UL>

<P><STRONG><a name="[675]"></a>EvrRtxEventFlagsDestroyed</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\rtx_evr.o(i.EvrRtxEventFlagsDestroyed))
<BR><BR>[Called By]<UL><LI><a href="#[83]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxEventFlagsDelete
</UL>

<P><STRONG><a name="[512]"></a>EvrRtxEventFlagsError</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\rtx_evr.o(i.EvrRtxEventFlagsError))
<BR><BR>[Called By]<UL><LI><a href="#[41b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osEventFlagsSet
<LI><a href="#[419]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osEventFlagsNew
<LI><a href="#[421]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osEventFlagsDelete
<LI><a href="#[511]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;isrRtxEventFlagsWait
<LI><a href="#[86]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxEventFlagsWait
<LI><a href="#[85]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxEventFlagsSet
<LI><a href="#[84]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxEventFlagsNew
<LI><a href="#[83]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxEventFlagsDelete
<LI><a href="#[82]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxEventFlagsClear
</UL>

<P><STRONG><a name="[5b7]"></a>EvrRtxEventFlagsNew</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\rtx_evr.o(i.EvrRtxEventFlagsNew))
<BR><BR>[Called By]<UL><LI><a href="#[419]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osEventFlagsNew
</UL>

<P><STRONG><a name="[5b8]"></a>EvrRtxEventFlagsSet</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\rtx_evr.o(i.EvrRtxEventFlagsSet))
<BR><BR>[Called By]<UL><LI><a href="#[41b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osEventFlagsSet
</UL>

<P><STRONG><a name="[5b9]"></a>EvrRtxEventFlagsSetDone</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\rtx_evr.o(i.EvrRtxEventFlagsSetDone))
<BR><BR>[Called By]<UL><LI><a href="#[41b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osEventFlagsSet
<LI><a href="#[85]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxEventFlagsSet
</UL>

<P><STRONG><a name="[5ba]"></a>EvrRtxEventFlagsWait</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\rtx_evr.o(i.EvrRtxEventFlagsWait))
<BR><BR>[Called By]<UL><LI><a href="#[41d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osEventFlagsWait
</UL>

<P><STRONG><a name="[513]"></a>EvrRtxEventFlagsWaitCompleted</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\rtx_evr.o(i.EvrRtxEventFlagsWaitCompleted))
<BR><BR>[Called By]<UL><LI><a href="#[511]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;isrRtxEventFlagsWait
<LI><a href="#[86]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxEventFlagsWait
<LI><a href="#[85]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxEventFlagsSet
<LI><a href="#[b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxEventFlagsPostProcess
</UL>

<P><STRONG><a name="[514]"></a>EvrRtxEventFlagsWaitNotCompleted</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\rtx_evr.o(i.EvrRtxEventFlagsWaitNotCompleted))
<BR><BR>[Called By]<UL><LI><a href="#[511]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;isrRtxEventFlagsWait
<LI><a href="#[86]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxEventFlagsWait
</UL>

<P><STRONG><a name="[677]"></a>EvrRtxEventFlagsWaitPending</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\rtx_evr.o(i.EvrRtxEventFlagsWaitPending))
<BR><BR>[Called By]<UL><LI><a href="#[86]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxEventFlagsWait
</UL>

<P><STRONG><a name="[5f8]"></a>EvrRtxEventFlagsWaitTimeout</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\rtx_evr.o(i.EvrRtxEventFlagsWaitTimeout))
<BR><BR>[Called By]<UL><LI><a href="#[5f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadDelayTick
</UL>

<P><STRONG><a name="[5c2]"></a>EvrRtxKernelError</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\rtx_evr.o(i.EvrRtxKernelError))
<BR><BR>[Called By]<UL><LI><a href="#[5c5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osKernelRestoreLock
<LI><a href="#[5c3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osKernelLock
<LI><a href="#[591]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osKernelStart
<LI><a href="#[30d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxKernelSuspend
<LI><a href="#[8b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxKernelStart
<LI><a href="#[8a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxKernelRestoreLock
<LI><a href="#[89]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxKernelLock
<LI><a href="#[88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxKernelInitialize
<LI><a href="#[44a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osKernelInitialize
</UL>

<P><STRONG><a name="[5bf]"></a>EvrRtxKernelGetState</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\rtx_evr.o(i.EvrRtxKernelGetState))
<BR><BR>[Called By]<UL><LI><a href="#[87]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxKernelGetState
<LI><a href="#[5bb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osKernelGetState
</UL>

<P><STRONG><a name="[5c1]"></a>EvrRtxKernelInitialize</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\rtx_evr.o(i.EvrRtxKernelInitialize))
<BR><BR>[Called By]<UL><LI><a href="#[44a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osKernelInitialize
</UL>

<P><STRONG><a name="[678]"></a>EvrRtxKernelInitializeCompleted</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\rtx_evr.o(i.EvrRtxKernelInitializeCompleted))
<BR><BR>[Called By]<UL><LI><a href="#[88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxKernelInitialize
</UL>

<P><STRONG><a name="[5c4]"></a>EvrRtxKernelLock</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\rtx_evr.o(i.EvrRtxKernelLock))
<BR><BR>[Called By]<UL><LI><a href="#[5c3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osKernelLock
</UL>

<P><STRONG><a name="[67a]"></a>EvrRtxKernelLockRestored</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\rtx_evr.o(i.EvrRtxKernelLockRestored))
<BR><BR>[Called By]<UL><LI><a href="#[8a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxKernelRestoreLock
</UL>

<P><STRONG><a name="[679]"></a>EvrRtxKernelLocked</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\rtx_evr.o(i.EvrRtxKernelLocked))
<BR><BR>[Called By]<UL><LI><a href="#[89]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxKernelLock
</UL>

<P><STRONG><a name="[5c6]"></a>EvrRtxKernelRestoreLock</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\rtx_evr.o(i.EvrRtxKernelRestoreLock))
<BR><BR>[Called By]<UL><LI><a href="#[5c5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osKernelRestoreLock
</UL>

<P><STRONG><a name="[67b]"></a>EvrRtxKernelResumed</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\rtx_evr.o(i.EvrRtxKernelResumed))
<BR><BR>[Called By]<UL><LI><a href="#[310]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxKernelResume
</UL>

<P><STRONG><a name="[5c7]"></a>EvrRtxKernelStart</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\rtx_evr.o(i.EvrRtxKernelStart))
<BR><BR>[Called By]<UL><LI><a href="#[591]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osKernelStart
</UL>

<P><STRONG><a name="[67d]"></a>EvrRtxKernelStarted</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\rtx_evr.o(i.EvrRtxKernelStarted))
<BR><BR>[Called By]<UL><LI><a href="#[8b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxKernelStart
</UL>

<P><STRONG><a name="[67e]"></a>EvrRtxKernelSuspended</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\rtx_evr.o(i.EvrRtxKernelSuspended))
<BR><BR>[Called By]<UL><LI><a href="#[30d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxKernelSuspend
</UL>

<P><STRONG><a name="[5de]"></a>EvrRtxMemoryAlloc</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\rtx_evr.o(i.EvrRtxMemoryAlloc))
<BR><BR>[Called By]<UL><LI><a href="#[5dd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxMemoryAlloc
</UL>

<P><STRONG><a name="[5e3]"></a>EvrRtxMemoryBlockAlloc</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\rtx_evr.o(i.EvrRtxMemoryBlockAlloc))
<BR><BR>[Called By]<UL><LI><a href="#[51b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxMemoryPoolAlloc
</UL>

<P><STRONG><a name="[5e7]"></a>EvrRtxMemoryBlockFree</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\rtx_evr.o(i.EvrRtxMemoryBlockFree))
<BR><BR>[Called By]<UL><LI><a href="#[5e6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxMemoryPoolFree
</UL>

<P><STRONG><a name="[5ea]"></a>EvrRtxMemoryBlockInit</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\rtx_evr.o(i.EvrRtxMemoryBlockInit))
<BR><BR>[Called By]<UL><LI><a href="#[5e9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxMemoryPoolInit
</UL>

<P><STRONG><a name="[5e0]"></a>EvrRtxMemoryFree</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\rtx_evr.o(i.EvrRtxMemoryFree))
<BR><BR>[Called By]<UL><LI><a href="#[5df]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxMemoryFree
</UL>

<P><STRONG><a name="[5e2]"></a>EvrRtxMemoryInit</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\rtx_evr.o(i.EvrRtxMemoryInit))
<BR><BR>[Called By]<UL><LI><a href="#[5e1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxMemoryInit
</UL>

<P><STRONG><a name="[5fb]"></a>EvrRtxMemoryPoolAllocTimeout</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\rtx_evr.o(i.EvrRtxMemoryPoolAllocTimeout))
<BR><BR>[Called By]<UL><LI><a href="#[5f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadDelayTick
</UL>

<P><STRONG><a name="[680]"></a>EvrRtxMessageQueueCreated</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\rtx_evr.o(i.EvrRtxMessageQueueCreated))
<BR><BR>[Called By]<UL><LI><a href="#[8d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxMessageQueueNew
</UL>

<P><STRONG><a name="[516]"></a>EvrRtxMessageQueueError</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\rtx_evr.o(i.EvrRtxMessageQueueError))
<BR><BR>[Called By]<UL><LI><a href="#[5cd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osMessageQueueNew
<LI><a href="#[8e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxMessageQueuePut
<LI><a href="#[8d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxMessageQueueNew
<LI><a href="#[8c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxMessageQueueGet
<LI><a href="#[51a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;isrRtxMessageQueuePut
<LI><a href="#[515]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;isrRtxMessageQueueGet
</UL>

<P><STRONG><a name="[5c9]"></a>EvrRtxMessageQueueGet</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\rtx_evr.o(i.EvrRtxMessageQueueGet))
<BR><BR>[Called By]<UL><LI><a href="#[5c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osMessageQueueGet
</UL>

<P><STRONG><a name="[67f]"></a>EvrRtxMessageQueueGetPending</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\rtx_evr.o(i.EvrRtxMessageQueueGetPending))
<BR><BR>[Called By]<UL><LI><a href="#[8c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxMessageQueueGet
</UL>

<P><STRONG><a name="[5fc]"></a>EvrRtxMessageQueueGetTimeout</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\rtx_evr.o(i.EvrRtxMessageQueueGetTimeout))
<BR><BR>[Called By]<UL><LI><a href="#[5f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadDelayTick
</UL>

<P><STRONG><a name="[51d]"></a>EvrRtxMessageQueueInsertPending</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\rtx_evr.o(i.EvrRtxMessageQueueInsertPending))
<BR><BR>[Called By]<UL><LI><a href="#[51a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;isrRtxMessageQueuePut
</UL>

<P><STRONG><a name="[5ee]"></a>EvrRtxMessageQueueInserted</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\rtx_evr.o(i.EvrRtxMessageQueueInserted))
<BR><BR>[Called By]<UL><LI><a href="#[8e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxMessageQueuePut
<LI><a href="#[8c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxMessageQueueGet
<LI><a href="#[b7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxMessageQueuePostProcess
</UL>

<P><STRONG><a name="[5ce]"></a>EvrRtxMessageQueueNew</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\rtx_evr.o(i.EvrRtxMessageQueueNew))
<BR><BR>[Called By]<UL><LI><a href="#[5cd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osMessageQueueNew
</UL>

<P><STRONG><a name="[51c]"></a>EvrRtxMessageQueueNotInserted</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\rtx_evr.o(i.EvrRtxMessageQueueNotInserted))
<BR><BR>[Called By]<UL><LI><a href="#[8e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxMessageQueuePut
<LI><a href="#[51a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;isrRtxMessageQueuePut
</UL>

<P><STRONG><a name="[519]"></a>EvrRtxMessageQueueNotRetrieved</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\rtx_evr.o(i.EvrRtxMessageQueueNotRetrieved))
<BR><BR>[Called By]<UL><LI><a href="#[8c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxMessageQueueGet
<LI><a href="#[515]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;isrRtxMessageQueueGet
</UL>

<P><STRONG><a name="[5d0]"></a>EvrRtxMessageQueuePut</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\rtx_evr.o(i.EvrRtxMessageQueuePut))
<BR><BR>[Called By]<UL><LI><a href="#[5cf]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osMessageQueuePut
</UL>

<P><STRONG><a name="[681]"></a>EvrRtxMessageQueuePutPending</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\rtx_evr.o(i.EvrRtxMessageQueuePutPending))
<BR><BR>[Called By]<UL><LI><a href="#[8e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxMessageQueuePut
</UL>

<P><STRONG><a name="[5fd]"></a>EvrRtxMessageQueuePutTimeout</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\rtx_evr.o(i.EvrRtxMessageQueuePutTimeout))
<BR><BR>[Called By]<UL><LI><a href="#[5f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadDelayTick
</UL>

<P><STRONG><a name="[517]"></a>EvrRtxMessageQueueRetrieved</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\rtx_evr.o(i.EvrRtxMessageQueueRetrieved))
<BR><BR>[Called By]<UL><LI><a href="#[8e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxMessageQueuePut
<LI><a href="#[8c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxMessageQueueGet
<LI><a href="#[b7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxMessageQueuePostProcess
<LI><a href="#[515]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;isrRtxMessageQueueGet
</UL>

<P><STRONG><a name="[5d1]"></a>EvrRtxMutexAcquire</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\rtx_evr.o(i.EvrRtxMutexAcquire))
<BR><BR>[Called By]<UL><LI><a href="#[2eb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osMutexAcquire
</UL>

<P><STRONG><a name="[682]"></a>EvrRtxMutexAcquirePending</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\rtx_evr.o(i.EvrRtxMutexAcquirePending))
<BR><BR>[Called By]<UL><LI><a href="#[8f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxMutexAcquire
</UL>

<P><STRONG><a name="[5f9]"></a>EvrRtxMutexAcquireTimeout</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\rtx_evr.o(i.EvrRtxMutexAcquireTimeout))
<BR><BR>[Called By]<UL><LI><a href="#[5f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadDelayTick
</UL>

<P><STRONG><a name="[5f1]"></a>EvrRtxMutexAcquired</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\rtx_evr.o(i.EvrRtxMutexAcquired))
<BR><BR>[Called By]<UL><LI><a href="#[92]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxMutexRelease
<LI><a href="#[8f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxMutexAcquire
<LI><a href="#[5ef]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxMutexOwnerRelease
</UL>

<P><STRONG><a name="[685]"></a>EvrRtxMutexCreated</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\rtx_evr.o(i.EvrRtxMutexCreated))
<BR><BR>[Called By]<UL><LI><a href="#[91]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxMutexNew
</UL>

<P><STRONG><a name="[5d6]"></a>EvrRtxMutexDelete</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\rtx_evr.o(i.EvrRtxMutexDelete))
<BR><BR>[Called By]<UL><LI><a href="#[424]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osMutexDelete
</UL>

<P><STRONG><a name="[684]"></a>EvrRtxMutexDestroyed</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\rtx_evr.o(i.EvrRtxMutexDestroyed))
<BR><BR>[Called By]<UL><LI><a href="#[90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxMutexDelete
</UL>

<P><STRONG><a name="[5d5]"></a>EvrRtxMutexError</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\rtx_evr.o(i.EvrRtxMutexError))
<BR><BR>[Called By]<UL><LI><a href="#[30b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osMutexRelease
<LI><a href="#[423]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osMutexNew
<LI><a href="#[2eb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osMutexAcquire
<LI><a href="#[424]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osMutexDelete
<LI><a href="#[92]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxMutexRelease
<LI><a href="#[91]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxMutexNew
<LI><a href="#[90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxMutexDelete
<LI><a href="#[8f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxMutexAcquire
</UL>

<P><STRONG><a name="[5d7]"></a>EvrRtxMutexNew</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\rtx_evr.o(i.EvrRtxMutexNew))
<BR><BR>[Called By]<UL><LI><a href="#[423]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osMutexNew
</UL>

<P><STRONG><a name="[683]"></a>EvrRtxMutexNotAcquired</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\rtx_evr.o(i.EvrRtxMutexNotAcquired))
<BR><BR>[Called By]<UL><LI><a href="#[8f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxMutexAcquire
</UL>

<P><STRONG><a name="[5d8]"></a>EvrRtxMutexRelease</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\rtx_evr.o(i.EvrRtxMutexRelease))
<BR><BR>[Called By]<UL><LI><a href="#[30b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osMutexRelease
</UL>

<P><STRONG><a name="[5f0]"></a>EvrRtxMutexReleased</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\rtx_evr.o(i.EvrRtxMutexReleased))
<BR><BR>[Called By]<UL><LI><a href="#[92]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxMutexRelease
<LI><a href="#[5ef]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxMutexOwnerRelease
</UL>

<P><STRONG><a name="[611]"></a>EvrRtxSemaphoreAcquire</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\rtx_evr.o(i.EvrRtxSemaphoreAcquire))
<BR><BR>[Called By]<UL><LI><a href="#[42f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osSemaphoreAcquire
</UL>

<P><STRONG><a name="[686]"></a>EvrRtxSemaphoreAcquirePending</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\rtx_evr.o(i.EvrRtxSemaphoreAcquirePending))
<BR><BR>[Called By]<UL><LI><a href="#[94]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxSemaphoreAcquire
</UL>

<P><STRONG><a name="[5fa]"></a>EvrRtxSemaphoreAcquireTimeout</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\rtx_evr.o(i.EvrRtxSemaphoreAcquireTimeout))
<BR><BR>[Called By]<UL><LI><a href="#[5f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadDelayTick
</UL>

<P><STRONG><a name="[5f3]"></a>EvrRtxSemaphoreAcquired</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\rtx_evr.o(i.EvrRtxSemaphoreAcquired))
<BR><BR>[Called By]<UL><LI><a href="#[42f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osSemaphoreAcquire
<LI><a href="#[98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxSemaphoreRelease
<LI><a href="#[94]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxSemaphoreAcquire
<LI><a href="#[b8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxSemaphorePostProcess
</UL>

<P><STRONG><a name="[689]"></a>EvrRtxSemaphoreCreated</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\rtx_evr.o(i.EvrRtxSemaphoreCreated))
<BR><BR>[Called By]<UL><LI><a href="#[97]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxSemaphoreNew
</UL>

<P><STRONG><a name="[617]"></a>EvrRtxSemaphoreDelete</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\rtx_evr.o(i.EvrRtxSemaphoreDelete))
<BR><BR>[Called By]<UL><LI><a href="#[432]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osSemaphoreDelete
</UL>

<P><STRONG><a name="[687]"></a>EvrRtxSemaphoreDestroyed</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\rtx_evr.o(i.EvrRtxSemaphoreDestroyed))
<BR><BR>[Called By]<UL><LI><a href="#[95]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxSemaphoreDelete
</UL>

<P><STRONG><a name="[615]"></a>EvrRtxSemaphoreError</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\rtx_evr.o(i.EvrRtxSemaphoreError))
<BR><BR>[Called By]<UL><LI><a href="#[42e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osSemaphoreNew
<LI><a href="#[42f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osSemaphoreAcquire
<LI><a href="#[431]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osSemaphoreRelease
<LI><a href="#[98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxSemaphoreRelease
<LI><a href="#[97]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxSemaphoreNew
<LI><a href="#[95]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxSemaphoreDelete
<LI><a href="#[94]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxSemaphoreAcquire
<LI><a href="#[432]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osSemaphoreDelete
</UL>

<P><STRONG><a name="[688]"></a>EvrRtxSemaphoreGetCount</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\rtx_evr.o(i.EvrRtxSemaphoreGetCount))
<BR><BR>[Called By]<UL><LI><a href="#[96]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxSemaphoreGetCount
</UL>

<P><STRONG><a name="[618]"></a>EvrRtxSemaphoreNew</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\rtx_evr.o(i.EvrRtxSemaphoreNew))
<BR><BR>[Called By]<UL><LI><a href="#[42e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osSemaphoreNew
</UL>

<P><STRONG><a name="[616]"></a>EvrRtxSemaphoreNotAcquired</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\rtx_evr.o(i.EvrRtxSemaphoreNotAcquired))
<BR><BR>[Called By]<UL><LI><a href="#[42f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osSemaphoreAcquire
<LI><a href="#[94]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxSemaphoreAcquire
</UL>

<P><STRONG><a name="[619]"></a>EvrRtxSemaphoreRelease</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\rtx_evr.o(i.EvrRtxSemaphoreRelease))
<BR><BR>[Called By]<UL><LI><a href="#[431]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osSemaphoreRelease
</UL>

<P><STRONG><a name="[61a]"></a>EvrRtxSemaphoreReleased</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\rtx_evr.o(i.EvrRtxSemaphoreReleased))
<BR><BR>[Called By]<UL><LI><a href="#[431]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osSemaphoreRelease
<LI><a href="#[98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxSemaphoreRelease
</UL>

<P><STRONG><a name="[60b]"></a>EvrRtxThreadBlocked</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\rtx_evr.o(i.EvrRtxThreadBlocked))
<BR><BR>[Called By]<UL><LI><a href="#[60a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadWaitEnter
</UL>

<P><STRONG><a name="[68d]"></a>EvrRtxThreadCreated</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\rtx_evr.o(i.EvrRtxThreadCreated))
<BR><BR>[Called By]<UL><LI><a href="#[99]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxThreadNew
</UL>

<P><STRONG><a name="[5af]"></a>EvrRtxThreadDelay</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\rtx_evr.o(i.EvrRtxThreadDelay))
<BR><BR>[Called By]<UL><LI><a href="#[425]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osDelay
</UL>

<P><STRONG><a name="[5f5]"></a>EvrRtxThreadDelayCompleted</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\rtx_evr.o(i.EvrRtxThreadDelayCompleted))
<BR><BR>[Called By]<UL><LI><a href="#[5f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadDelayTick
</UL>

<P><STRONG><a name="[68c]"></a>EvrRtxThreadDestroyed</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\rtx_evr.o(i.EvrRtxThreadDestroyed))
<BR><BR>[Called By]<UL><LI><a href="#[9d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxThreadTerminate
<LI><a href="#[9a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxThreadExit
</UL>

<P><STRONG><a name="[5b0]"></a>EvrRtxThreadError</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\rtx_evr.o(i.EvrRtxThreadError))
<BR><BR>[Called By]<UL><LI><a href="#[425]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osDelay
<LI><a href="#[99]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxThreadNew
<LI><a href="#[9d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxThreadTerminate
<LI><a href="#[427]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osThreadYield
<LI><a href="#[428]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osThreadTerminate
<LI><a href="#[b9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osThreadExit
<LI><a href="#[61b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osThreadContextNew
</UL>

<P><STRONG><a name="[2a5]"></a>EvrRtxThreadExit</STRONG> (Thumb, 16 bytes, Stack size 8 bytes, .\build\mbed_rtx_handlers.o(i.EvrRtxThreadExit))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = EvrRtxThreadExit &rArr; osThreadGetId
</UL>
<BR>[Calls]<UL><LI><a href="#[2a6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osThreadGetId
<LI><a href="#[2a7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;thread_terminate_hook
</UL>
<BR>[Called By]<UL><LI><a href="#[b9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osThreadExit
</UL>

<P><STRONG><a name="[607]"></a>EvrRtxThreadFlagsWaitCompleted</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\rtx_evr.o(i.EvrRtxThreadFlagsWaitCompleted))
<BR><BR>[Called By]<UL><LI><a href="#[ba]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadPostProcess
</UL>

<P><STRONG><a name="[5f6]"></a>EvrRtxThreadFlagsWaitTimeout</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\rtx_evr.o(i.EvrRtxThreadFlagsWaitTimeout))
<BR><BR>[Called By]<UL><LI><a href="#[5f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadDelayTick
</UL>

<P><STRONG><a name="[620]"></a>EvrRtxThreadGetId</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\rtx_evr.o(i.EvrRtxThreadGetId))
<BR><BR>[Called By]<UL><LI><a href="#[2a6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osThreadGetId
<LI><a href="#[9b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxThreadGetId
</UL>

<P><STRONG><a name="[621]"></a>EvrRtxThreadGetName</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\rtx_evr.o(i.EvrRtxThreadGetName))
<BR><BR>[Called By]<UL><LI><a href="#[5d9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osThreadGetName
<LI><a href="#[9c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxThreadGetName
</UL>

<P><STRONG><a name="[68a]"></a>EvrRtxThreadJoined</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\rtx_evr.o(i.EvrRtxThreadJoined))
<BR><BR>[Called By]<UL><LI><a href="#[9d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxThreadTerminate
<LI><a href="#[9a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxThreadExit
</UL>

<P><STRONG><a name="[61c]"></a>EvrRtxThreadNew</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\rtx_evr.o(i.EvrRtxThreadNew))
<BR><BR>[Called By]<UL><LI><a href="#[61b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osThreadContextNew
</UL>

<P><STRONG><a name="[609]"></a>EvrRtxThreadSwitch</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\rtx_evr.o(i.EvrRtxThreadSwitch))
<BR><BR>[Called By]<UL><LI><a href="#[603]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadSwitch
</UL>

<P><STRONG><a name="[2a8]"></a>EvrRtxThreadTerminate</STRONG> (Thumb, 12 bytes, Stack size 8 bytes, .\build\mbed_rtx_handlers.o(i.EvrRtxThreadTerminate))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = EvrRtxThreadTerminate &rArr; thread_terminate_hook
</UL>
<BR>[Calls]<UL><LI><a href="#[2a7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;thread_terminate_hook
</UL>
<BR>[Called By]<UL><LI><a href="#[428]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osThreadTerminate
</UL>

<P><STRONG><a name="[5fe]"></a>EvrRtxThreadUnblocked</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\rtx_evr.o(i.EvrRtxThreadUnblocked))
<BR><BR>[Called By]<UL><LI><a href="#[5db]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadWaitExit
<LI><a href="#[5f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadDelayTick
</UL>

<P><STRONG><a name="[622]"></a>EvrRtxThreadYield</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\rtx_evr.o(i.EvrRtxThreadYield))
<BR><BR>[Called By]<UL><LI><a href="#[427]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osThreadYield
</UL>

<P><STRONG><a name="[60e]"></a>EvrRtxTimerCallback</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\rtx_evr.o(i.EvrRtxTimerCallback))
<BR><BR>[Called By]<UL><LI><a href="#[b6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxTimerThread
</UL>

<P><STRONG><a name="[1b]"></a>GPIO_EVEN_IRQHandler</STRONG> (Thumb, 28 bytes, Stack size 8 bytes, .\build\gpio_irq_api.o(i.GPIO_EVEN_IRQHandler))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = GPIO_EVEN_IRQHandler &rArr; GPIOINT_IRQDispatcher &rArr; handle_interrupt_in
</UL>
<BR>[Calls]<UL><LI><a href="#[2ab]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GPIO_IntGetEnabled
<LI><a href="#[2ac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GPIO_IntClear
<LI><a href="#[2a9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GPIOINT_IRQDispatcher
</UL>
<BR>[Address Reference Count : 1]<UL><LI> startup_efm32wg.o(RESET)
</UL>
<P><STRONG><a name="[25]"></a>GPIO_ODD_IRQHandler</STRONG> (Thumb, 28 bytes, Stack size 8 bytes, .\build\gpio_irq_api.o(i.GPIO_ODD_IRQHandler))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = GPIO_ODD_IRQHandler &rArr; GPIOINT_IRQDispatcher &rArr; handle_interrupt_in
</UL>
<BR>[Calls]<UL><LI><a href="#[2ab]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GPIO_IntGetEnabled
<LI><a href="#[2ac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GPIO_IntClear
<LI><a href="#[2a9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GPIOINT_IRQDispatcher
</UL>
<BR>[Address Reference Count : 1]<UL><LI> startup_efm32wg.o(RESET)
</UL>
<P><STRONG><a name="[2ad]"></a>GPIO_PinModeSet</STRONG> (Thumb, 154 bytes, Stack size 24 bytes, .\build\em_gpio.o(i.GPIO_PinModeSet))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = GPIO_PinModeSet &rArr; GPIO_PinOutSet
</UL>
<BR>[Calls]<UL><LI><a href="#[2ae]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GPIO_PinOutSet
<LI><a href="#[2af]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GPIO_PinOutClear
</UL>
<BR>[Called By]<UL><LI><a href="#[4cb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pin_mode
</UL>

<P><STRONG><a name="[2b5]"></a>LEUART_BaudrateCalc</STRONG> (Thumb, 38 bytes, Stack size 16 bytes, .\build\em_leuart.o(i.LEUART_BaudrateCalc))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = LEUART_BaudrateCalc
</UL>
<BR>[Called By]<UL><LI><a href="#[2b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LEUART_BaudrateGet
</UL>

<P><STRONG><a name="[2b4]"></a>LEUART_BaudrateGet</STRONG> (Thumb, 46 bytes, Stack size 16 bytes, .\build\em_leuart.o(i.LEUART_BaudrateGet))
<BR><BR>[Stack]<UL><LI>Max Depth = 72<LI>Call Chain = LEUART_BaudrateGet &rArr; CMU_ClockFreqGet &rArr; lfClkGet &rArr; getHfLeConfig &rArr; BUS_RegBitRead
</UL>
<BR>[Calls]<UL><LI><a href="#[28c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CMU_ClockFreqGet
<LI><a href="#[2b5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LEUART_BaudrateCalc
</UL>
<BR>[Called By]<UL><LI><a href="#[66a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_unblock_sleep
</UL>

<P><STRONG><a name="[2b6]"></a>LEUART_BaudrateSet</STRONG> (Thumb, 74 bytes, Stack size 24 bytes, .\build\em_leuart.o(i.LEUART_BaudrateSet))
<BR><BR>[Stack]<UL><LI>Max Depth = 80<LI>Call Chain = LEUART_BaudrateSet &rArr; CMU_ClockFreqGet &rArr; lfClkGet &rArr; getHfLeConfig &rArr; BUS_RegBitRead
</UL>
<BR>[Calls]<UL><LI><a href="#[28c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CMU_ClockFreqGet
<LI><a href="#[2b7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LEUART_Sync
</UL>
<BR>[Called By]<UL><LI><a href="#[2b9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LEUART_Init
<LI><a href="#[64a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_leuart_baud
</UL>

<P><STRONG><a name="[2b8]"></a>LEUART_Enable</STRONG> (Thumb, 28 bytes, Stack size 16 bytes, .\build\em_leuart.o(i.LEUART_Enable))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = LEUART_Enable
</UL>
<BR>[Calls]<UL><LI><a href="#[2b7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LEUART_Sync
</UL>
<BR>[Called By]<UL><LI><a href="#[64b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_enable
</UL>

<P><STRONG><a name="[2ba]"></a>LEUART_FreezeEnable</STRONG> (Thumb, 22 bytes, Stack size 0 bytes, .\build\em_leuart.o(i.LEUART_FreezeEnable))
<BR><BR>[Called By]<UL><LI><a href="#[2b9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LEUART_Init
</UL>

<P><STRONG><a name="[2b9]"></a>LEUART_Init</STRONG> (Thumb, 70 bytes, Stack size 16 bytes, .\build\em_leuart.o(i.LEUART_Init))
<BR><BR>[Stack]<UL><LI>Max Depth = 96<LI>Call Chain = LEUART_Init &rArr; LEUART_BaudrateSet &rArr; CMU_ClockFreqGet &rArr; lfClkGet &rArr; getHfLeConfig &rArr; BUS_RegBitRead
</UL>
<BR>[Calls]<UL><LI><a href="#[2ba]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LEUART_FreezeEnable
<LI><a href="#[2b6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LEUART_BaudrateSet
<LI><a href="#[2b7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LEUART_Sync
</UL>
<BR>[Called By]<UL><LI><a href="#[656]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;uart_init
</UL>

<P><STRONG><a name="[652]"></a>LEUART_Rx</STRONG> (Thumb, 20 bytes, Stack size 0 bytes, .\build\em_leuart.o(i.LEUART_Rx))
<BR><BR>[Called By]<UL><LI><a href="#[325]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_getc
</UL>

<P><STRONG><a name="[2bb]"></a>LEUART_Tx</STRONG> (Thumb, 30 bytes, Stack size 16 bytes, .\build\em_leuart.o(i.LEUART_Tx))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = LEUART_Tx
</UL>
<BR>[Calls]<UL><LI><a href="#[2b7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LEUART_Sync
</UL>
<BR>[Called By]<UL><LI><a href="#[326]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_putc
<LI><a href="#[65d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_tx_irq_handler_asynch
</UL>

<P><STRONG><a name="[2ca]"></a>OS_Tick_AcknowledgeIRQ</STRONG> (Thumb, 16 bytes, Stack size 8 bytes, .\build\mbed_rtx_idle.o(i.OS_Tick_AcknowledgeIRQ))
<BR><BR>[Stack]<UL><LI>Max Depth = 232<LI>Call Chain = OS_Tick_AcknowledgeIRQ &rArr; rtos::internal::SysTimer::schedule_tick(unsigned) &rArr; mbed::TimerEvent::insert_absolute(unsigned long long) &rArr; ticker_insert_event_us &rArr; schedule_interrupt &rArr; update_present_time &rArr; __aeabi_uldivmod
</UL>
<BR>[Calls]<UL><LI><a href="#[2cb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::internal::SysTimer::schedule_tick(unsigned)
</UL>
<BR>[Called By]<UL><LI><a href="#[216]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxTick_Handler
</UL>

<P><STRONG><a name="[2b1]"></a>OS_Tick_Disable</STRONG> (Thumb, 14 bytes, Stack size 8 bytes, .\build\mbed_rtx_idle.o(i.OS_Tick_Disable))
<BR><BR>[Stack]<UL><LI>Max Depth = 176<LI>Call Chain = OS_Tick_Disable &rArr; rtos::internal::SysTimer::cancel_tick() &rArr; mbed::TimerEvent::remove() &rArr; ticker_remove_event &rArr; schedule_interrupt &rArr; update_present_time &rArr; __aeabi_uldivmod
</UL>
<BR>[Calls]<UL><LI><a href="#[2cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::internal::SysTimer::cancel_tick()
</UL>
<BR>[Called By]<UL><LI><a href="#[2b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;KernelBlock
</UL>

<P><STRONG><a name="[2b3]"></a>OS_Tick_Enable</STRONG> (Thumb, 52 bytes, Stack size 8 bytes, .\build\mbed_rtx_idle.o(i.OS_Tick_Enable))
<BR><BR>[Stack]<UL><LI>Max Depth = 240<LI>Call Chain = OS_Tick_Enable &rArr; rtos::internal::SysTimer::SysTimer() &rArr; mbed::TimerEvent::TimerEvent__sub_object(const ticker_data_t*) &rArr; ticker_set_handler &rArr; initialize &rArr;  mbed_assert_internal (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[2cd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::internal::SysTimer::SysTimer()
<LI><a href="#[2ce]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::internal::SysTimer::setup_irq()
<LI><a href="#[2cb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::internal::SysTimer::schedule_tick(unsigned)
</UL>
<BR>[Called By]<UL><LI><a href="#[8b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxKernelStart
<LI><a href="#[2b2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;KernelUnblock
</UL>

<P><STRONG><a name="[67c]"></a>OS_Tick_GetIRQn</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, .\build\mbed_rtx_idle.o(i.OS_Tick_GetIRQn))
<BR><BR>[Called By]<UL><LI><a href="#[8b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxKernelStart
</UL>

<P><STRONG><a name="[42b]"></a>OS_Tick_Setup</STRONG> (Thumb, 66 bytes, Stack size 8 bytes, .\build\os_systick.o(i.OS_Tick_Setup))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = OS_Tick_Setup
</UL>
<BR>[Called By]<UL><LI><a href="#[2ce]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::internal::SysTimer::setup_irq()
<LI><a href="#[8b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxKernelStart
</UL>

<P><STRONG><a name="[648]"></a>RTC_CompareSet</STRONG> (Thumb, 30 bytes, Stack size 0 bytes, .\build\em_rtc.o(i.RTC_CompareSet))
<BR><BR>[Called By]<UL><LI><a href="#[53f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtc_set_comp0_value
</UL>

<P><STRONG><a name="[645]"></a>RTC_FreezeEnable</STRONG> (Thumb, 18 bytes, Stack size 0 bytes, .\build\em_rtc.o(i.RTC_FreezeEnable))
<BR><BR>[Called By]<UL><LI><a href="#[53f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtc_set_comp0_value
<LI><a href="#[53a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtc_enable_comp0
</UL>

<P><STRONG><a name="[38]"></a>RTC_IRQHandler</STRONG> (Thumb, 82 bytes, Stack size 8 bytes, .\build\rtc_api.o(i.RTC_IRQHandler))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = RTC_IRQHandler
</UL>
<BR>[Calls]<UL><LI><a href="#[2cf]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RTC_IntClear
</UL>
<BR>[Address Reference Count : 2]<UL><LI> rtc_api.o(i.rtc_init_real)
<LI> startup_efm32wg.o(RESET)
</UL>
<P><STRONG><a name="[647]"></a>RTC_Init</STRONG> (Thumb, 34 bytes, Stack size 0 bytes, .\build\em_rtc.o(i.RTC_Init))
<BR><BR>[Called By]<UL><LI><a href="#[53c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtc_init_real
</UL>

<P><STRONG><a name="[285]"></a>SystemCoreClockGet</STRONG> (Thumb, 26 bytes, Stack size 4 bytes, .\build\system_efm32wg.o(i.SystemCoreClockGet))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = SystemCoreClockGet
</UL>
<BR>[Calls]<UL><LI><a href="#[288]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SystemHFClockGet
</UL>
<BR>[Called By]<UL><LI><a href="#[292]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CMU_ClockSelectSet
<LI><a href="#[283]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CMU_ClockDivSet
<LI><a href="#[28e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lfClkGet
<LI><a href="#[28c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CMU_ClockFreqGet
<LI><a href="#[299]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EMU_EnterEM2
<LI><a href="#[2d5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SystemLFXOClockSet
<LI><a href="#[2d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SystemHFXOClockSet
</UL>

<P><STRONG><a name="[288]"></a>SystemHFClockGet</STRONG> (Thumb, 170 bytes, Stack size 0 bytes, .\build\system_efm32wg.o(i.SystemHFClockGet))
<BR><BR>[Called By]<UL><LI><a href="#[283]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CMU_ClockDivSet
<LI><a href="#[291]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;usbCClkGet
<LI><a href="#[28f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dbgClkGet
<LI><a href="#[28c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CMU_ClockFreqGet
<LI><a href="#[285]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SystemCoreClockGet
</UL>

<P><STRONG><a name="[293]"></a>SystemHFXOClockGet</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, .\build\system_efm32wg.o(i.SystemHFXOClockGet))
<BR><BR>[Called By]<UL><LI><a href="#[292]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CMU_ClockSelectSet
</UL>

<P><STRONG><a name="[2d4]"></a>SystemHFXOClockSet</STRONG> (Thumb, 24 bytes, Stack size 4 bytes, .\build\system_efm32wg.o(i.SystemHFXOClockSet))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = SystemHFXOClockSet &rArr; SystemCoreClockGet
</UL>
<BR>[Calls]<UL><LI><a href="#[285]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SystemCoreClockGet
</UL>
<BR>[Called By]<UL><LI><a href="#[43e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_sdk_init
</UL>

<P><STRONG><a name="[43]"></a>SystemInit</STRONG> (Thumb, 14 bytes, Stack size 0 bytes, .\build\system_efm32wg.o(i.SystemInit))
<BR>[Address Reference Count : 1]<UL><LI> startup_efm32wg.o(.text)
</UL>
<P><STRONG><a name="[535]"></a>SystemLFRCOClockGet</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, .\build\system_efm32wg.o(i.SystemLFRCOClockGet))
<BR><BR>[Called By]<UL><LI><a href="#[291]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;usbCClkGet
<LI><a href="#[28e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lfClkGet
</UL>

<P><STRONG><a name="[536]"></a>SystemLFXOClockGet</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, .\build\system_efm32wg.o(i.SystemLFXOClockGet))
<BR><BR>[Called By]<UL><LI><a href="#[291]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;usbCClkGet
<LI><a href="#[28e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lfClkGet
</UL>

<P><STRONG><a name="[2d5]"></a>SystemLFXOClockSet</STRONG> (Thumb, 24 bytes, Stack size 4 bytes, .\build\system_efm32wg.o(i.SystemLFXOClockSet))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = SystemLFXOClockSet &rArr; SystemCoreClockGet
</UL>
<BR>[Calls]<UL><LI><a href="#[285]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SystemCoreClockGet
</UL>
<BR>[Called By]<UL><LI><a href="#[43e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_sdk_init
</UL>

<P><STRONG><a name="[4b9]"></a>SystemMaxCoreClockGet</STRONG> (Thumb, 4 bytes, Stack size 0 bytes, .\build\system_efm32wg.o(i.SystemMaxCoreClockGet))
<BR><BR>[Called By]<UL><LI><a href="#[284]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;flashWaitStateMax
</UL>

<P><STRONG><a name="[537]"></a>SystemULFRCOClockGet</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, .\build\system_efm32wg.o(i.SystemULFRCOClockGet))
<BR><BR>[Called By]<UL><LI><a href="#[28e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lfClkGet
</UL>

<P><STRONG><a name="[2d6]"></a>TIMER_InitCC</STRONG> (Thumb, 116 bytes, Stack size 16 bytes, .\build\em_timer.o(i.TIMER_InitCC))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = TIMER_InitCC
</UL>
<BR>[Calls]<UL><LI><a href="#[2d7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TIMER_Valid
</UL>
<BR>[Called By]<UL><LI><a href="#[115]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;us_ticker_init
</UL>

<P><STRONG><a name="[2db]"></a>USART_BaudrateAsyncSet</STRONG> (Thumb, 118 bytes, Stack size 32 bytes, .\build\em_usart.o(i.USART_BaudrateAsyncSet))
<BR><BR>[Stack]<UL><LI>Max Depth = 88<LI>Call Chain = USART_BaudrateAsyncSet &rArr; CMU_ClockFreqGet &rArr; lfClkGet &rArr; getHfLeConfig &rArr; BUS_RegBitRead
</UL>
<BR>[Calls]<UL><LI><a href="#[28c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CMU_ClockFreqGet
</UL>
<BR>[Called By]<UL><LI><a href="#[2dc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;USART_InitAsync
<LI><a href="#[328]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_baud
</UL>

<P><STRONG><a name="[64c]"></a>USART_Enable</STRONG> (Thumb, 14 bytes, Stack size 0 bytes, .\build\em_usart.o(i.USART_Enable))
<BR><BR>[Called By]<UL><LI><a href="#[64b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_enable
</UL>

<P><STRONG><a name="[2dc]"></a>USART_InitAsync</STRONG> (Thumb, 66 bytes, Stack size 16 bytes, .\build\em_usart.o(i.USART_InitAsync))
<BR><BR>[Stack]<UL><LI>Max Depth = 104<LI>Call Chain = USART_InitAsync &rArr; USART_BaudrateAsyncSet &rArr; CMU_ClockFreqGet &rArr; lfClkGet &rArr; getHfLeConfig &rArr; BUS_RegBitRead
</UL>
<BR>[Calls]<UL><LI><a href="#[2dd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;USART_Reset
<LI><a href="#[2db]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;USART_BaudrateAsyncSet
</UL>
<BR>[Called By]<UL><LI><a href="#[656]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;uart_init
</UL>

<P><STRONG><a name="[2dd]"></a>USART_Reset</STRONG> (Thumb, 66 bytes, Stack size 0 bytes, .\build\em_usart.o(i.USART_Reset))
<BR><BR>[Called By]<UL><LI><a href="#[2dc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;USART_InitAsync
</UL>

<P><STRONG><a name="[653]"></a>USART_Rx</STRONG> (Thumb, 20 bytes, Stack size 0 bytes, .\build\em_usart.o(i.USART_Rx))
<BR><BR>[Called By]<UL><LI><a href="#[325]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_getc
</UL>

<P><STRONG><a name="[664]"></a>USART_Tx</STRONG> (Thumb, 16 bytes, Stack size 0 bytes, .\build\em_usart.o(i.USART_Tx))
<BR><BR>[Called By]<UL><LI><a href="#[326]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_putc
<LI><a href="#[65d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_tx_irq_handler_asynch
</UL>

<P><STRONG><a name="[2de]"></a>do_connect()</STRONG> (Thumb, 108 bytes, Stack size 16 bytes, .\build\main.o(i._Z10do_connectv))
<BR><BR>[Stack]<UL><LI>Max Depth = 776 + Unknown Stack Size
<LI>Call Chain = do_connect() &rArr; mbed::EasyCellularConnection::connect() &rArr; mbed::EasyCellularConnection::check_connect() &rArr; mbed::EasyCellularConnection::init() &rArr; mbed::CellularConnectionFSM::start_dispatch() &rArr; rtos::Thread::Thread(osPriority_t, unsigned, unsigned char*, const char*) &rArr; rtos::Semaphore::Semaphore(int) &rArr; rtos::Semaphore::constructor(int, unsigned short) &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[187]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::EasyCellularConnection::connect()
<LI><a href="#[18b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::EasyCellularConnection::is_connected()
<LI><a href="#[226]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__2snprintf
<LI><a href="#[2df]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;print_function(const char*)
</UL>
<BR>[Called By]<UL><LI><a href="#[281]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;$Super$$main
</UL>

<P><STRONG><a name="[2df]"></a>print_function(const char*)</STRONG> (Thumb, 36 bytes, Stack size 8 bytes, .\build\main.o(i._Z14print_functionPKc))
<BR><BR>[Stack]<UL><LI>Max Depth = 440 + Unknown Stack Size
<LI>Call Chain = print_function(const char*) &rArr; fflush &rArr; _do_fflush &rArr; _fflush &rArr; _writebuf &rArr; _sys_write &rArr; convert_crlf(int) &rArr; isatty &rArr; get_fhc(int) &rArr; get_console(int) &rArr; default_console() &rArr; DirectSerial::DirectSerial(PinName, PinName, int) &rArr; serial_init &rArr; uart_init &rArr; serial_baud &rArr; serial_leuart_baud &rArr;  mbed_assert_internal (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[2e9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Mutex::unlock()
<LI><a href="#[2e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Mutex::lock(unsigned)
<LI><a href="#[240]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fflush
<LI><a href="#[223]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__2printf
</UL>
<BR>[Called By]<UL><LI><a href="#[281]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;$Super$$main
<LI><a href="#[70]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dot_event()
<LI><a href="#[2ec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;test_send_recv()
<LI><a href="#[2de]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;do_connect()
</UL>

<P><STRONG><a name="[2ec]"></a>test_send_recv()</STRONG> (Thumb, 374 bytes, Stack size 240 bytes, .\build\main.o(i._Z14test_send_recvv))
<BR><BR>[Stack]<UL><LI>Max Depth = 824 + Unknown Stack Size
<LI>Call Chain = test_send_recv() &rArr; TCPSocket::TCPSocket() &rArr; Socket::Socket__sub_object() &rArr; rtos::Mutex::Mutex() &rArr; rtos::Mutex::constructor(const char*) &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[123]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;NetworkInterface::gethostbyname(const char*, SocketAddress*, nsapi_version)
<LI><a href="#[2f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SocketAddress::SocketAddress(nsapi_addr, unsigned short)
<LI><a href="#[2f1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SocketAddress::set_port(unsigned short)
<LI><a href="#[2f6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Socket::close()
<LI><a href="#[2ef]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Socket::open(NetworkStack*)
<LI><a href="#[2f2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Socket::set_timeout(int)
<LI><a href="#[139]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TCPSocket::~TCPSocket()
<LI><a href="#[2ed]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TCPSocket::TCPSocket()
<LI><a href="#[2f3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TCPSocket::connect(const SocketAddress&)
<LI><a href="#[2f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TCPSocket::send(const void*, unsigned)
<LI><a href="#[2f5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TCPSocket::recv(void*, unsigned)
<LI><a href="#[23c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memclr4
<LI><a href="#[226]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__2snprintf
<LI><a href="#[2ee]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;NetworkStack* nsapi_create_stack&lang;mbed::EasyCellularConnection&rang;(T1*)
<LI><a href="#[2df]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;print_function(const char*)
</UL>
<BR>[Called By]<UL><LI><a href="#[281]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;$Super$$main
</UL>

<P><STRONG><a name="[302]"></a>nsapi_dns_query(NetworkStack*, const char*, SocketAddress*, nsapi_version)</STRONG> (Thumb, 70 bytes, Stack size 56 bytes, .\build\nsapi_dns.o(i._Z15nsapi_dns_queryP12NetworkStackPKcP13SocketAddress13nsapi_version))
<BR><BR>[Stack]<UL><LI>Max Depth = 912 + Unknown Stack Size
<LI>Call Chain = nsapi_dns_query(NetworkStack*, const char*, SocketAddress*, nsapi_version) &rArr; nsapi_dns_query_multiple(NetworkStack*, const char*, nsapi_addr*, unsigned, nsapi_version) &rArr; UDPSocket::UDPSocket() &rArr; Socket::Socket__sub_object() &rArr; rtos::Mutex::Mutex() &rArr; rtos::Mutex::constructor(const char*) &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[304]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SocketAddress::set_addr(nsapi_addr)
<LI><a href="#[303]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;nsapi_dns_query_multiple(NetworkStack*, const char*, nsapi_addr*, unsigned, nsapi_version)
</UL>
<BR>[Called By]<UL><LI><a href="#[12d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;NetworkStack::gethostbyname(const char*, SocketAddress*, nsapi_version)
</UL>

<P><STRONG><a name="[3a7]"></a>nsapi_create_stack(nsapi_stack*)</STRONG> (Thumb, 26 bytes, Stack size 0 bytes, .\build\networkstack.o(i._Z18nsapi_create_stackP11nsapi_stack))
<BR><BR>[Called By]<UL><LI><a href="#[3a2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::nsapi_ppp_get_stack()
</UL>

<P><STRONG><a name="[6cc]"></a>nsapi_create_stack(NetworkStack*)</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\networkstack.o(i._Z18nsapi_create_stackP12NetworkStack))
<BR><BR>[Called By]<UL><LI><a href="#[2ee]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;NetworkStack* nsapi_create_stack&lang;mbed::EasyCellularConnection&rang;(T1*)
</UL>

<P><STRONG><a name="[322]"></a>apnconfig(const char*)</STRONG> (Thumb, 154 bytes, Stack size 24 bytes, .\build\easycellularconnection.o(i._Z9apnconfigPKc))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = apnconfig(const char*) &rArr; memcmp
</UL>
<BR>[Calls]<UL><LI><a href="#[323]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memcmp
</UL>
<BR>[Called By]<UL><LI><a href="#[187]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::EasyCellularConnection::connect()
</UL>

<P><STRONG><a name="[70]"></a>dot_event()</STRONG> (Thumb, 36 bytes, Stack size 8 bytes, .\build\main.o(i._Z9dot_eventv))
<BR><BR>[Stack]<UL><LI>Max Depth = 512 + Unknown Stack Size
<LI>Call Chain = dot_event() &rArr; wait &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[324]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;wait
<LI><a href="#[18b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::EasyCellularConnection::is_connected()
<LI><a href="#[2df]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;print_function(const char*)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> main.o(i.main)
</UL>
<P><STRONG><a name="[74a]"></a>CellularBase::~CellularBase()</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, .\build\easycellularconnection.o(i._ZN12CellularBaseD2Ev), UNUSED)

<P><STRONG><a name="[121]"></a>CellularBase::~CellularBase__sub_object()</STRONG> (Thumb, 4 bytes, Stack size 0 bytes, .\build\easycellularconnection.o(i._ZN12CellularBaseD2Ev))
<BR><BR>[Called By]<UL><LI><a href="#[5e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::EasyCellularConnection::~EasyCellularConnection()
</UL>
<BR>[Address Reference Count : 1]<UL><LI> easycellularconnection.o(.constdata__ZTV12CellularBase)
</UL>
<P><STRONG><a name="[124]"></a>DirectSerial::read(void*, unsigned)</STRONG> (Thumb, 32 bytes, Stack size 24 bytes, .\build\mbed_retarget.o(i._ZN12DirectSerial4readEPvj))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = DirectSerial::read(void*, unsigned) &rArr; serial_getc
</UL>
<BR>[Calls]<UL><LI><a href="#[325]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_getc
</UL>
<BR>[Address Reference Count : 1]<UL><LI> mbed_retarget.o(.constdata__ZTV12DirectSerial)
</UL>
<P><STRONG><a name="[126]"></a>DirectSerial::seek(long, int)</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, .\build\mbed_retarget.o(i._ZN12DirectSerial4seekEli))
<BR>[Address Reference Count : 1]<UL><LI> mbed_retarget.o(.constdata__ZTV12DirectSerial)
</UL>
<P><STRONG><a name="[129]"></a>DirectSerial::size()</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, .\build\mbed_retarget.o(i._ZN12DirectSerial4sizeEv))
<BR>[Address Reference Count : 1]<UL><LI> mbed_retarget.o(.constdata__ZTV12DirectSerial)
</UL>
<P><STRONG><a name="[127]"></a>DirectSerial::close()</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, .\build\mbed_retarget.o(i._ZN12DirectSerial5closeEv))
<BR>[Address Reference Count : 1]<UL><LI> mbed_retarget.o(.constdata__ZTV12DirectSerial)
</UL>
<P><STRONG><a name="[125]"></a>DirectSerial::write(const void*, unsigned)</STRONG> (Thumb, 36 bytes, Stack size 24 bytes, .\build\mbed_retarget.o(i._ZN12DirectSerial5writeEPKvj))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = DirectSerial::write(const void*, unsigned) &rArr; serial_putc &rArr; LEUART_Tx
</UL>
<BR>[Calls]<UL><LI><a href="#[326]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_putc
</UL>
<BR>[Address Reference Count : 1]<UL><LI> mbed_retarget.o(.constdata__ZTV12DirectSerial)
</UL>
<P><STRONG><a name="[128]"></a>DirectSerial::isatty()</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, .\build\mbed_retarget.o(i._ZN12DirectSerial6isattyEv))
<BR>[Address Reference Count : 1]<UL><LI> mbed_retarget.o(.constdata__ZTV12DirectSerial)
</UL>
<P><STRONG><a name="[2f9]"></a>DirectSerial::DirectSerial(PinName, PinName, int)</STRONG> (Thumb, 56 bytes, Stack size 24 bytes, .\build\mbed_retarget.o(i._ZN12DirectSerialC1E7PinNameS0_i))
<BR><BR>[Stack]<UL><LI>Max Depth = 232<LI>Call Chain = DirectSerial::DirectSerial(PinName, PinName, int) &rArr; serial_init &rArr; uart_init &rArr; serial_baud &rArr; serial_leuart_baud &rArr;  mbed_assert_internal (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[327]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_init
<LI><a href="#[328]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_baud
</UL>
<BR>[Called By]<UL><LI><a href="#[2e3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;default_console()
</UL>

<P><STRONG><a name="[74b]"></a>DirectSerial::DirectSerial__sub_object(PinName, PinName, int)</STRONG> (Thumb, 0 bytes, Stack size 24 bytes, .\build\mbed_retarget.o(i._ZN12DirectSerialC1E7PinNameS0_i), UNUSED)

<P><STRONG><a name="[4f]"></a>DirectSerial::~DirectSerial()</STRONG> (Thumb, 14 bytes, Stack size 8 bytes, .\build\mbed_retarget.o(i._ZN12DirectSerialD1Ev))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = DirectSerial::~DirectSerial()
</UL>
<BR>[Calls]<UL><LI><a href="#[13f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::FileHandle::~FileHandle__sub_object()
</UL>
<BR>[Address Reference Count : 2]<UL><LI> mbed_retarget.o(i._Z15default_consolev)
<LI> mbed_retarget.o(.constdata__ZTV12DirectSerial)
</UL>
<P><STRONG><a name="[74c]"></a>DirectSerial::~DirectSerial__sub_object()</STRONG> (Thumb, 0 bytes, Stack size 8 bytes, .\build\mbed_retarget.o(i._ZN12DirectSerialD1Ev), UNUSED)

<P><STRONG><a name="[12d]"></a>NetworkStack::gethostbyname(const char*, SocketAddress*, nsapi_version)</STRONG> (Thumb, 130 bytes, Stack size 120 bytes, .\build\networkstack.o(i._ZN12NetworkStack13gethostbynameEPKcP13SocketAddress13nsapi_version))
<BR><BR>[Stack]<UL><LI>Max Depth = 1032 + Unknown Stack Size
<LI>Call Chain = NetworkStack::gethostbyname(const char*, SocketAddress*, nsapi_version) &rArr; nsapi_dns_query(NetworkStack*, const char*, SocketAddress*, nsapi_version) &rArr; nsapi_dns_query_multiple(NetworkStack*, const char*, nsapi_addr*, unsigned, nsapi_version) &rArr; UDPSocket::UDPSocket() &rArr; Socket::Socket__sub_object() &rArr; rtos::Mutex::Mutex() &rArr; rtos::Mutex::constructor(const char*) &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[32a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SocketAddress::get_ip_version() const
<LI><a href="#[2f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SocketAddress::SocketAddress(nsapi_addr, unsigned short)
<LI><a href="#[329]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SocketAddress::set_ip_address(const char*)
<LI><a href="#[302]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;nsapi_dns_query(NetworkStack*, const char*, SocketAddress*, nsapi_version)
<LI><a href="#[23c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memclr4
</UL>
<BR>[Called By]<UL><LI><a href="#[12f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;NetworkStackWrapper::gethostbyname(const char*, SocketAddress*, nsapi_version)
</UL>
<BR>[Address Reference Count : 3]<UL><LI> at_cellularstack.o(.constdata__ZTVN4mbed16AT_CellularStackE)
<LI> networkstack.o(.constdata__ZTV12NetworkStack)
<LI> quectel_bg96_cellularstack.o(.constdata__ZTVN4mbed26QUECTEL_BG96_CellularStackE)
</UL>
<P><STRONG><a name="[329]"></a>SocketAddress::set_ip_address(const char*)</STRONG> (Thumb, 98 bytes, Stack size 32 bytes, .\build\socketaddress.o(i._ZN13SocketAddress14set_ip_addressEPKc))
<BR><BR>[Stack]<UL><LI>Max Depth = 328<LI>Call Chain = SocketAddress::set_ip_address(const char*) &rArr; ipv6_from_address(unsigned char*, const char*) &rArr; ipv6_scan_chunk(unsigned short*, const char*) &rArr; __0sscanf &rArr; __vfscanf_char &rArr; __vfscanf &rArr; _scanf_int
</UL>
<BR>[Calls]<UL><LI><a href="#[314]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ipv6_from_address(unsigned char*, const char*)
<LI><a href="#[313]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ipv4_from_address(unsigned char*, const char*)
<LI><a href="#[32c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ipv6_is_valid(const char*)
<LI><a href="#[32b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ipv4_is_valid(const char*)
<LI><a href="#[23c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memclr4
<LI><a href="#[249]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Called By]<UL><LI><a href="#[32d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SocketAddress::SocketAddress(const char*, unsigned short)
<LI><a href="#[12d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;NetworkStack::gethostbyname(const char*, SocketAddress*, nsapi_version)
<LI><a href="#[192]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::QUECTEL_BG96_CellularStack::socket_recvfrom_impl(mbed::AT_CellularStack::CellularSocket*, SocketAddress*, void*, unsigned)
</UL>

<P><STRONG><a name="[304]"></a>SocketAddress::set_addr(nsapi_addr)</STRONG> (Thumb, 28 bytes, Stack size 24 bytes, .\build\socketaddress.o(i._ZN13SocketAddress8set_addrE10nsapi_addr))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = SocketAddress::set_addr(nsapi_addr)
</UL>
<BR>[Calls]<UL><LI><a href="#[249]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Called By]<UL><LI><a href="#[2f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SocketAddress::SocketAddress(nsapi_addr, unsigned short)
<LI><a href="#[302]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;nsapi_dns_query(NetworkStack*, const char*, SocketAddress*, nsapi_version)
<LI><a href="#[136]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;NetworkStackWrapper::socket_recvfrom(void*, SocketAddress*, void*, unsigned)
<LI><a href="#[12f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;NetworkStackWrapper::gethostbyname(const char*, SocketAddress*, nsapi_version)
</UL>

<P><STRONG><a name="[2f1]"></a>SocketAddress::set_port(unsigned short)</STRONG> (Thumb, 4 bytes, Stack size 0 bytes, .\build\socketaddress.o(i._ZN13SocketAddress8set_portEt))
<BR><BR>[Called By]<UL><LI><a href="#[32d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SocketAddress::SocketAddress(const char*, unsigned short)
<LI><a href="#[2f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SocketAddress::SocketAddress(nsapi_addr, unsigned short)
<LI><a href="#[136]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;NetworkStackWrapper::socket_recvfrom(void*, SocketAddress*, void*, unsigned)
<LI><a href="#[192]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::QUECTEL_BG96_CellularStack::socket_recvfrom_impl(mbed::AT_CellularStack::CellularSocket*, SocketAddress*, void*, unsigned)
<LI><a href="#[2ec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;test_send_recv()
</UL>

<P><STRONG><a name="[2f0]"></a>SocketAddress::SocketAddress(nsapi_addr, unsigned short)</STRONG> (Thumb, 50 bytes, Stack size 40 bytes, .\build\socketaddress.o(i._ZN13SocketAddressC1E10nsapi_addrt))
<BR><BR>[Stack]<UL><LI>Max Depth = 64<LI>Call Chain = SocketAddress::SocketAddress(nsapi_addr, unsigned short) &rArr; SocketAddress::set_addr(nsapi_addr)
</UL>
<BR>[Calls]<UL><LI><a href="#[2f1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SocketAddress::set_port(unsigned short)
<LI><a href="#[304]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SocketAddress::set_addr(nsapi_addr)
</UL>
<BR>[Called By]<UL><LI><a href="#[12d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;NetworkStack::gethostbyname(const char*, SocketAddress*, nsapi_version)
<LI><a href="#[16f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularStack::socket_open(void**, nsapi_protocol)
<LI><a href="#[303]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;nsapi_dns_query_multiple(NetworkStack*, const char*, nsapi_addr*, unsigned, nsapi_version)
<LI><a href="#[12e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;NetworkStackWrapper::get_ip_address()
<LI><a href="#[2ec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;test_send_recv()
</UL>

<P><STRONG><a name="[74d]"></a>SocketAddress::SocketAddress__sub_object(nsapi_addr, unsigned short)</STRONG> (Thumb, 0 bytes, Stack size 40 bytes, .\build\socketaddress.o(i._ZN13SocketAddressC1E10nsapi_addrt), UNUSED)

<P><STRONG><a name="[32d]"></a>SocketAddress::SocketAddress(const char*, unsigned short)</STRONG> (Thumb, 32 bytes, Stack size 16 bytes, .\build\socketaddress.o(i._ZN13SocketAddressC1EPKct))
<BR><BR>[Stack]<UL><LI>Max Depth = 344<LI>Call Chain = SocketAddress::SocketAddress(const char*, unsigned short) &rArr; SocketAddress::set_ip_address(const char*) &rArr; ipv6_from_address(unsigned char*, const char*) &rArr; ipv6_scan_chunk(unsigned short*, const char*) &rArr; __0sscanf &rArr; __vfscanf_char &rArr; __vfscanf &rArr; _scanf_int
</UL>
<BR>[Calls]<UL><LI><a href="#[2f1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SocketAddress::set_port(unsigned short)
<LI><a href="#[329]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SocketAddress::set_ip_address(const char*)
</UL>
<BR>[Called By]<UL><LI><a href="#[16f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularStack::socket_open(void**, nsapi_protocol)
</UL>

<P><STRONG><a name="[74e]"></a>SocketAddress::SocketAddress__sub_object(const char*, unsigned short)</STRONG> (Thumb, 0 bytes, Stack size 16 bytes, .\build\socketaddress.o(i._ZN13SocketAddressC1EPKct), UNUSED)

<P><STRONG><a name="[123]"></a>NetworkInterface::gethostbyname(const char*, SocketAddress*, nsapi_version)</STRONG> (Thumb, 42 bytes, Stack size 24 bytes, .\build\networkinterface.o(i._ZN16NetworkInterface13gethostbynameEPKcP13SocketAddress13nsapi_version))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = NetworkInterface::gethostbyname(const char*, SocketAddress*, nsapi_version)
</UL>
<BR>[Called By]<UL><LI><a href="#[2ec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;test_send_recv()
</UL>
<BR>[Address Reference Count : 6]<UL><LI> at_cellularnetwork.o(.constdata__ZTVN4mbed18AT_CellularNetworkE)
<LI> at_cellularnetwork.o(.constdata__ZTVN4mbed15CellularNetworkE)
<LI> easycellularconnection.o(.constdata__ZTV12CellularBase)
<LI> easycellularconnection.o(.constdata__ZTVN4mbed22EasyCellularConnectionE)
<LI> networkinterface.o(.constdata__ZTV16NetworkInterface)
<LI> quectel_bg96_cellularnetwork.o(.constdata__ZTVN4mbed28QUECTEL_BG96_CellularNetworkE)
</UL>
<P><STRONG><a name="[32e]"></a>mbed_cellular_util::convert_ipv6(char*)</STRONG> (Thumb, 182 bytes, Stack size 32 bytes, .\build\cellularutil.o(i._ZN18mbed_cellular_util12convert_ipv6EPc))
<BR><BR>[Stack]<UL><LI>Max Depth = 144<LI>Call Chain = mbed_cellular_util::convert_ipv6(char*) &rArr; strtol &rArr; _strtoul &rArr; __aeabi_errno_addr &rArr; __user_perthread_libspace &rArr; os_kernel_is_active &rArr; osKernelGetState &rArr; svcRtxKernelGetState
</UL>
<BR>[Calls]<UL><LI><a href="#[32f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_cellular_util::char_str_to_hex_str(const char*, unsigned short, char*, bool)
<LI><a href="#[31d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;strlen
<LI><a href="#[235]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;strtol
</UL>
<BR>[Called By]<UL><LI><a href="#[16e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularStack::get_ip_address()
</UL>

<P><STRONG><a name="[3a0]"></a>mbed_cellular_util::hex_str_to_int(const char*, int)</STRONG> (Thumb, 80 bytes, Stack size 16 bytes, .\build\cellularutil.o(i._ZN18mbed_cellular_util14hex_str_to_intEPKci))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = mbed_cellular_util::hex_str_to_int(const char*, int)
</UL>
<BR>[Called By]<UL><LI><a href="#[17d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::get_registration_status(mbed::CellularNetwork::RegistrationType, mbed::CellularNetwork::RegistrationStatus&)
</UL>

<P><STRONG><a name="[32f]"></a>mbed_cellular_util::char_str_to_hex_str(const char*, unsigned short, char*, bool)</STRONG> (Thumb, 86 bytes, Stack size 20 bytes, .\build\cellularutil.o(i._ZN18mbed_cellular_util19char_str_to_hex_strEPKctPcb))
<BR><BR>[Stack]<UL><LI>Max Depth = 20<LI>Call Chain = mbed_cellular_util::char_str_to_hex_str(const char*, unsigned short, char*, bool)
</UL>
<BR>[Called By]<UL><LI><a href="#[32e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_cellular_util::convert_ipv6(char*)
</UL>

<P><STRONG><a name="[380]"></a>mbed_cellular_util::get_dynamic_ip_port()</STRONG> (Thumb, 32 bytes, Stack size 0 bytes, .\build\cellularutil.o(i._ZN18mbed_cellular_util19get_dynamic_ip_portEv))
<BR><BR>[Called By]<UL><LI><a href="#[16f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularStack::socket_open(void**, nsapi_protocol)
</UL>

<P><STRONG><a name="[330]"></a>NetworkStackWrapper::_stack_api()</STRONG> (Thumb, 14 bytes, Stack size 8 bytes, .\build\networkstack.o(i._ZN19NetworkStackWrapper10_stack_apiEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = NetworkStackWrapper::_stack_api()
</UL>
<BR>[Calls]<UL><LI><a href="#[331]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;NetworkStackWrapper::_stack()
</UL>
<BR>[Called By]<UL><LI><a href="#[136]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;NetworkStackWrapper::socket_recvfrom(void*, SocketAddress*, void*, unsigned)
<LI><a href="#[132]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;NetworkStackWrapper::socket_connect(void*, const SocketAddress&)
<LI><a href="#[12e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;NetworkStackWrapper::get_ip_address()
<LI><a href="#[135]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;NetworkStackWrapper::socket_sendto(void*, const SocketAddress&, const void*, unsigned)
<LI><a href="#[137]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;NetworkStackWrapper::socket_attach(void*, void(*)(void*), void*)
<LI><a href="#[12f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;NetworkStackWrapper::gethostbyname(const char*, SocketAddress*, nsapi_version)
<LI><a href="#[131]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;NetworkStackWrapper::socket_close(void*)
<LI><a href="#[133]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;NetworkStackWrapper::socket_send(void*, const void*, unsigned)
<LI><a href="#[134]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;NetworkStackWrapper::socket_recv(void*, void*, unsigned)
<LI><a href="#[130]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;NetworkStackWrapper::socket_open(void**, nsapi_protocol)
</UL>

<P><STRONG><a name="[130]"></a>NetworkStackWrapper::socket_open(void**, nsapi_protocol)</STRONG> (Thumb, 52 bytes, Stack size 24 bytes, .\build\networkstack.o(i._ZN19NetworkStackWrapper11socket_openEPPv14nsapi_protocol))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = NetworkStackWrapper::socket_open(void**, nsapi_protocol) &rArr; NetworkStackWrapper::_stack_api()
</UL>
<BR>[Calls]<UL><LI><a href="#[330]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;NetworkStackWrapper::_stack_api()
<LI><a href="#[331]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;NetworkStackWrapper::_stack()
</UL>
<BR>[Address Reference Count : 1]<UL><LI> networkstack.o(.constdata__ZTV19NetworkStackWrapper)
</UL>
<P><STRONG><a name="[134]"></a>NetworkStackWrapper::socket_recv(void*, void*, unsigned)</STRONG> (Thumb, 58 bytes, Stack size 32 bytes, .\build\networkstack.o(i._ZN19NetworkStackWrapper11socket_recvEPvS0_j))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = NetworkStackWrapper::socket_recv(void*, void*, unsigned) &rArr; NetworkStackWrapper::_stack_api()
</UL>
<BR>[Calls]<UL><LI><a href="#[330]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;NetworkStackWrapper::_stack_api()
<LI><a href="#[331]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;NetworkStackWrapper::_stack()
</UL>
<BR>[Address Reference Count : 1]<UL><LI> networkstack.o(.constdata__ZTV19NetworkStackWrapper)
</UL>
<P><STRONG><a name="[133]"></a>NetworkStackWrapper::socket_send(void*, const void*, unsigned)</STRONG> (Thumb, 58 bytes, Stack size 32 bytes, .\build\networkstack.o(i._ZN19NetworkStackWrapper11socket_sendEPvPKvj))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = NetworkStackWrapper::socket_send(void*, const void*, unsigned) &rArr; NetworkStackWrapper::_stack_api()
</UL>
<BR>[Calls]<UL><LI><a href="#[330]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;NetworkStackWrapper::_stack_api()
<LI><a href="#[331]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;NetworkStackWrapper::_stack()
</UL>
<BR>[Address Reference Count : 1]<UL><LI> networkstack.o(.constdata__ZTV19NetworkStackWrapper)
</UL>
<P><STRONG><a name="[131]"></a>NetworkStackWrapper::socket_close(void*)</STRONG> (Thumb, 48 bytes, Stack size 24 bytes, .\build\networkstack.o(i._ZN19NetworkStackWrapper12socket_closeEPv))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = NetworkStackWrapper::socket_close(void*) &rArr; NetworkStackWrapper::_stack_api()
</UL>
<BR>[Calls]<UL><LI><a href="#[330]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;NetworkStackWrapper::_stack_api()
<LI><a href="#[331]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;NetworkStackWrapper::_stack()
</UL>
<BR>[Address Reference Count : 1]<UL><LI> networkstack.o(.constdata__ZTV19NetworkStackWrapper)
</UL>
<P><STRONG><a name="[12f]"></a>NetworkStackWrapper::gethostbyname(const char*, SocketAddress*, nsapi_version)</STRONG> (Thumb, 106 bytes, Stack size 64 bytes, .\build\networkstack.o(i._ZN19NetworkStackWrapper13gethostbynameEPKcP13SocketAddress13nsapi_version))
<BR><BR>[Stack]<UL><LI>Max Depth = 1096 + Unknown Stack Size
<LI>Call Chain = NetworkStackWrapper::gethostbyname(const char*, SocketAddress*, nsapi_version) &rArr; NetworkStack::gethostbyname(const char*, SocketAddress*, nsapi_version) &rArr; nsapi_dns_query(NetworkStack*, const char*, SocketAddress*, nsapi_version) &rArr; nsapi_dns_query_multiple(NetworkStack*, const char*, nsapi_addr*, unsigned, nsapi_version) &rArr; UDPSocket::UDPSocket() &rArr; Socket::Socket__sub_object() &rArr; rtos::Mutex::Mutex() &rArr; rtos::Mutex::constructor(const char*) &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[304]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SocketAddress::set_addr(nsapi_addr)
<LI><a href="#[12d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;NetworkStack::gethostbyname(const char*, SocketAddress*, nsapi_version)
<LI><a href="#[330]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;NetworkStackWrapper::_stack_api()
<LI><a href="#[331]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;NetworkStackWrapper::_stack()
<LI><a href="#[23c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memclr4
</UL>
<BR>[Address Reference Count : 1]<UL><LI> networkstack.o(.constdata__ZTV19NetworkStackWrapper)
</UL>
<P><STRONG><a name="[137]"></a>NetworkStackWrapper::socket_attach(void*, void(*)(void*), void*)</STRONG> (Thumb, 58 bytes, Stack size 32 bytes, .\build\networkstack.o(i._ZN19NetworkStackWrapper13socket_attachEPvPFvS0_ES0_))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = NetworkStackWrapper::socket_attach(void*, void(*)(void*), void*) &rArr; NetworkStackWrapper::_stack_api()
</UL>
<BR>[Calls]<UL><LI><a href="#[330]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;NetworkStackWrapper::_stack_api()
<LI><a href="#[331]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;NetworkStackWrapper::_stack()
</UL>
<BR>[Address Reference Count : 1]<UL><LI> networkstack.o(.constdata__ZTV19NetworkStackWrapper)
</UL>
<P><STRONG><a name="[135]"></a>NetworkStackWrapper::socket_sendto(void*, const SocketAddress&, const void*, unsigned)</STRONG> (Thumb, 100 bytes, Stack size 80 bytes, .\build\networkstack.o(i._ZN19NetworkStackWrapper13socket_sendtoEPvRK13SocketAddressPKvj))
<BR><BR>[Stack]<UL><LI>Max Depth = 96<LI>Call Chain = NetworkStackWrapper::socket_sendto(void*, const SocketAddress&, const void*, unsigned) &rArr; SocketAddress::get_addr() const
</UL>
<BR>[Calls]<UL><LI><a href="#[332]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SocketAddress::get_port() const
<LI><a href="#[333]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SocketAddress::get_addr() const
<LI><a href="#[330]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;NetworkStackWrapper::_stack_api()
<LI><a href="#[331]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;NetworkStackWrapper::_stack()
<LI><a href="#[247]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy4
</UL>
<BR>[Address Reference Count : 1]<UL><LI> networkstack.o(.constdata__ZTV19NetworkStackWrapper)
</UL>
<P><STRONG><a name="[12e]"></a>NetworkStackWrapper::get_ip_address()</STRONG> (Thumb, 96 bytes, Stack size 56 bytes, .\build\networkstack.o(i._ZN19NetworkStackWrapper14get_ip_addressEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 224 + Unknown Stack Size
<LI>Call Chain = NetworkStackWrapper::get_ip_address() &rArr; SocketAddress::get_ip_address() const &rArr; ipv4_to_address(char*, const unsigned char*) &rArr; __2sprintf &rArr; _printf_char_common &rArr; __printf
</UL>
<BR>[Calls]<UL><LI><a href="#[2f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SocketAddress::SocketAddress(nsapi_addr, unsigned short)
<LI><a href="#[330]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;NetworkStackWrapper::_stack_api()
<LI><a href="#[334]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SocketAddress::get_ip_address() const
<LI><a href="#[331]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;NetworkStackWrapper::_stack()
</UL>
<BR>[Address Reference Count : 1]<UL><LI> networkstack.o(.constdata__ZTV19NetworkStackWrapper)
</UL>
<P><STRONG><a name="[132]"></a>NetworkStackWrapper::socket_connect(void*, const SocketAddress&)</STRONG> (Thumb, 88 bytes, Stack size 64 bytes, .\build\networkstack.o(i._ZN19NetworkStackWrapper14socket_connectEPvRK13SocketAddress))
<BR><BR>[Stack]<UL><LI>Max Depth = 80<LI>Call Chain = NetworkStackWrapper::socket_connect(void*, const SocketAddress&) &rArr; SocketAddress::get_addr() const
</UL>
<BR>[Calls]<UL><LI><a href="#[332]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SocketAddress::get_port() const
<LI><a href="#[333]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SocketAddress::get_addr() const
<LI><a href="#[330]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;NetworkStackWrapper::_stack_api()
<LI><a href="#[331]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;NetworkStackWrapper::_stack()
<LI><a href="#[247]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy4
</UL>
<BR>[Address Reference Count : 1]<UL><LI> networkstack.o(.constdata__ZTV19NetworkStackWrapper)
</UL>
<P><STRONG><a name="[136]"></a>NetworkStackWrapper::socket_recvfrom(void*, SocketAddress*, void*, unsigned)</STRONG> (Thumb, 122 bytes, Stack size 72 bytes, .\build\networkstack.o(i._ZN19NetworkStackWrapper15socket_recvfromEPvP13SocketAddressS0_j))
<BR><BR>[Stack]<UL><LI>Max Depth = 96<LI>Call Chain = NetworkStackWrapper::socket_recvfrom(void*, SocketAddress*, void*, unsigned) &rArr; SocketAddress::set_addr(nsapi_addr)
</UL>
<BR>[Calls]<UL><LI><a href="#[2f1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SocketAddress::set_port(unsigned short)
<LI><a href="#[304]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SocketAddress::set_addr(nsapi_addr)
<LI><a href="#[330]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;NetworkStackWrapper::_stack_api()
<LI><a href="#[331]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;NetworkStackWrapper::_stack()
<LI><a href="#[247]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy4
</UL>
<BR>[Address Reference Count : 1]<UL><LI> networkstack.o(.constdata__ZTV19NetworkStackWrapper)
</UL>
<P><STRONG><a name="[331]"></a>NetworkStackWrapper::_stack()</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, .\build\networkstack.o(i._ZN19NetworkStackWrapper6_stackEv))
<BR><BR>[Called By]<UL><LI><a href="#[330]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;NetworkStackWrapper::_stack_api()
<LI><a href="#[136]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;NetworkStackWrapper::socket_recvfrom(void*, SocketAddress*, void*, unsigned)
<LI><a href="#[132]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;NetworkStackWrapper::socket_connect(void*, const SocketAddress&)
<LI><a href="#[12e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;NetworkStackWrapper::get_ip_address()
<LI><a href="#[135]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;NetworkStackWrapper::socket_sendto(void*, const SocketAddress&, const void*, unsigned)
<LI><a href="#[137]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;NetworkStackWrapper::socket_attach(void*, void(*)(void*), void*)
<LI><a href="#[12f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;NetworkStackWrapper::gethostbyname(const char*, SocketAddress*, nsapi_version)
<LI><a href="#[131]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;NetworkStackWrapper::socket_close(void*)
<LI><a href="#[133]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;NetworkStackWrapper::socket_send(void*, const void*, unsigned)
<LI><a href="#[134]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;NetworkStackWrapper::socket_recv(void*, void*, unsigned)
<LI><a href="#[130]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;NetworkStackWrapper::socket_open(void**, nsapi_protocol)
</UL>

<P><STRONG><a name="[335]"></a>mbed::DigitalOut::DigitalOut(PinName)</STRONG> (Thumb, 24 bytes, Stack size 16 bytes, .\build\busout.o(i._ZN4mbed10DigitalOutC1E7PinName))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = mbed::DigitalOut::DigitalOut(PinName) &rArr; gpio_init_out &rArr;  gpio_init_out_ex (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[336]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;gpio_init_out
</UL>
<BR>[Called By]<UL><LI><a href="#[1d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__sti___8_main_cpp_led0
</UL>

<P><STRONG><a name="[74f]"></a>mbed::DigitalOut::DigitalOut__sub_object(PinName)</STRONG> (Thumb, 0 bytes, Stack size 16 bytes, .\build\busout.o(i._ZN4mbed10DigitalOutC1E7PinName), UNUSED)

<P><STRONG><a name="[12a]"></a>mbed::FileHandle::set_blocking(bool)</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, .\build\file.o(i._ZN4mbed10FileHandle12set_blockingEb))
<BR>[Address Reference Count : 5]<UL><LI> filehandle.o(.constdata__ZTVN4mbed10FileHandleE)
<LI> mbed_retarget.o(.constdata__ZTV12DirectSerial)
<LI> serial.o(.constdata__ZTVN4mbed6SerialE)
<LI> stream.o(.constdata__ZTVN4mbed8FileLikeE)
<LI> stream.o(.constdata__ZTVN4mbed6StreamE)
</UL>
<P><STRONG><a name="[141]"></a>mbed::FileHandle::size()</STRONG> (Thumb, 56 bytes, Stack size 16 bytes, .\build\filehandle.o(i._ZN4mbed10FileHandle4sizeEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = mbed::FileHandle::size()
</UL>
<BR>[Address Reference Count : 3]<UL><LI> filehandle.o(.constdata__ZTVN4mbed10FileHandleE)
<LI> stream.o(.constdata__ZTVN4mbed8FileLikeE)
<LI> uartserial.o(.constdata__ZTVN4mbed10UARTSerialE)
</UL>
<P><STRONG><a name="[12c]"></a>mbed::FileHandle::sigio(mbed::Callback&lang;void()&rang;)</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\file.o(i._ZN4mbed10FileHandle5sigioENS_8CallbackIFvvEEE))
<BR>[Address Reference Count : 5]<UL><LI> filehandle.o(.constdata__ZTVN4mbed10FileHandleE)
<LI> mbed_retarget.o(.constdata__ZTV12DirectSerial)
<LI> serial.o(.constdata__ZTVN4mbed6SerialE)
<LI> stream.o(.constdata__ZTVN4mbed8FileLikeE)
<LI> stream.o(.constdata__ZTVN4mbed6StreamE)
</UL>
<P><STRONG><a name="[140]"></a>mbed::FileHandle::isatty()</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, .\build\filehandle.o(i._ZN4mbed10FileHandle6isattyEv))
<BR>[Address Reference Count : 2]<UL><LI> filehandle.o(.constdata__ZTVN4mbed10FileHandleE)
<LI> stream.o(.constdata__ZTVN4mbed8FileLikeE)
</UL>
<P><STRONG><a name="[750]"></a>mbed::FileHandle::~FileHandle()</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, .\build\filehandle.o(i._ZN4mbed10FileHandleD2Ev), UNUSED)

<P><STRONG><a name="[13f]"></a>mbed::FileHandle::~FileHandle__sub_object()</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, .\build\filehandle.o(i._ZN4mbed10FileHandleD2Ev))
<BR><BR>[Called By]<UL><LI><a href="#[4f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DirectSerial::~DirectSerial()
</UL>
<BR>[Address Reference Count : 1]<UL><LI> filehandle.o(.constdata__ZTVN4mbed10FileHandleE)
</UL>
<P><STRONG><a name="[337]"></a>mbed::SerialBase::_base_getc()</STRONG> (Thumb, 14 bytes, Stack size 8 bytes, .\build\serialbase.o(i._ZN4mbed10SerialBase10_base_getcEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = mbed::SerialBase::_base_getc() &rArr; serial_getc
</UL>
<BR>[Calls]<UL><LI><a href="#[325]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_getc
</UL>
<BR>[Called By]<UL><LI><a href="#[199]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Serial::_getc()
<LI><a href="#[120]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::UARTSerial::rx_irq()
</UL>

<P><STRONG><a name="[338]"></a>mbed::SerialBase::_base_putc(int)</STRONG> (Thumb, 20 bytes, Stack size 16 bytes, .\build\serialbase.o(i._ZN4mbed10SerialBase10_base_putcEi))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = mbed::SerialBase::_base_putc(int) &rArr; serial_putc &rArr; LEUART_Tx
</UL>
<BR>[Calls]<UL><LI><a href="#[326]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_putc
</UL>
<BR>[Called By]<UL><LI><a href="#[19a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Serial::_putc(int)
<LI><a href="#[11f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::UARTSerial::tx_irq()
</UL>

<P><STRONG><a name="[52]"></a>mbed::SerialBase::_irq_handler(unsigned, SerialIrq)</STRONG> (Thumb, 74 bytes, Stack size 24 bytes, .\build\serialbase.o(i._ZN4mbed10SerialBase12_irq_handlerEj9SerialIrq))
<BR><BR>[Stack]<UL><LI>Max Depth = 552 + Unknown Stack Size
<LI>Call Chain = mbed::SerialBase::_irq_handler(unsigned, SerialIrq) &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[33a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_assert_internal
<LI><a href="#[339]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void()&rang;::operator bool() const
</UL>
<BR>[Address Reference Count : 1]<UL><LI> serialbase.o(i._ZN4mbed10SerialBaseC1E7PinNameS1_i)
</UL>
<P><STRONG><a name="[11d]"></a>mbed::SerialBase::interrupt_handler_asynch()</STRONG> (Thumb, 94 bytes, Stack size 24 bytes, .\build\serialbase.o(i._ZN4mbed10SerialBase24interrupt_handler_asynchEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 568 + Unknown Stack Size
<LI>Call Chain = mbed::SerialBase::interrupt_handler_asynch() &rArr; mbed::Callback&lang;void(int)&rang;::call(int) const &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[33e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sleep_manager_unlock_deep_sleep_internal
<LI><a href="#[33c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void(int)&rang;::operator bool() const
<LI><a href="#[33d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void(int)&rang;::call(int) const
<LI><a href="#[33b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_irq_handler_asynch
</UL>
<BR>[Address Reference Count : 1]<UL><LI> serialbase.o(.constdata)
</UL>
<P><STRONG><a name="[143]"></a>mbed::SerialBase::lock()</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\serialbase.o(i._ZN4mbed10SerialBase4lockEv))
<BR>[Address Reference Count : 1]<UL><LI> serialbase.o(.constdata__ZTVN4mbed10SerialBaseE)
</UL>
<P><STRONG><a name="[33f]"></a>mbed::SerialBase::attach(mbed::Callback&lang;void()&rang;, mbed::SerialBase::IrqType)</STRONG> (Thumb, 156 bytes, Stack size 40 bytes, .\build\serialbase.o(i._ZN4mbed10SerialBase6attachENS_8CallbackIFvvEEENS0_7IrqTypeE))
<BR><BR>[Stack]<UL><LI>Max Depth = 600 + Unknown Stack Size
<LI>Call Chain = mbed::SerialBase::attach(mbed::Callback&lang;void()&rang;, mbed::SerialBase::IrqType) &rArr; serial_irq_set &rArr; serial_get_tx_irq_index &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[311]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;core_util_critical_section_exit
<LI><a href="#[30c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;core_util_critical_section_enter
<LI><a href="#[53]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void()&rang;::~Callback()
<LI><a href="#[282]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void()&rang;::Callback(void(*)())
<LI><a href="#[340]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sleep_manager_lock_deep_sleep_internal
<LI><a href="#[339]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void()&rang;::operator bool() const
<LI><a href="#[33e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sleep_manager_unlock_deep_sleep_internal
<LI><a href="#[341]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void()&rang;::operator =(const mbed::Callback&lang;void()&rang;&)
<LI><a href="#[342]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_irq_set
</UL>
<BR>[Called By]<UL><LI><a href="#[35f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::UARTSerial::UARTSerial(PinName, PinName, int)
<LI><a href="#[145]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::SerialBase::~SerialBase()
<LI><a href="#[11f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::UARTSerial::tx_irq()
<LI><a href="#[120]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::UARTSerial::rx_irq()
<LI><a href="#[14b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::UARTSerial::write(const void*, unsigned)
<LI><a href="#[14c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::UARTSerial::read(void*, unsigned)
</UL>

<P><STRONG><a name="[144]"></a>mbed::SerialBase::unlock()</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\serialbase.o(i._ZN4mbed10SerialBase6unlockEv))
<BR>[Address Reference Count : 1]<UL><LI> serialbase.o(.constdata__ZTVN4mbed10SerialBaseE)
</UL>
<P><STRONG><a name="[343]"></a>mbed::SerialBase::readable()</STRONG> (Thumb, 34 bytes, Stack size 16 bytes, .\build\serialbase.o(i._ZN4mbed10SerialBase8readableEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = mbed::SerialBase::readable()
</UL>
<BR>[Calls]<UL><LI><a href="#[344]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_readable
</UL>
<BR>[Called By]<UL><LI><a href="#[120]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::UARTSerial::rx_irq()
</UL>

<P><STRONG><a name="[345]"></a>mbed::SerialBase::writeable()</STRONG> (Thumb, 34 bytes, Stack size 16 bytes, .\build\serialbase.o(i._ZN4mbed10SerialBase9writeableEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = mbed::SerialBase::writeable()
</UL>
<BR>[Calls]<UL><LI><a href="#[346]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_writable
</UL>
<BR>[Called By]<UL><LI><a href="#[11f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::UARTSerial::tx_irq()
</UL>

<P><STRONG><a name="[347]"></a>mbed::SerialBase::SerialBase(PinName, PinName, int)</STRONG> (Thumb, 200 bytes, Stack size 48 bytes, .\build\serialbase.o(i._ZN4mbed10SerialBaseC1E7PinNameS1_i))
<BR><BR>[Stack]<UL><LI>Max Depth = 256<LI>Call Chain = mbed::SerialBase::SerialBase(PinName, PinName, int) &rArr; serial_init &rArr; uart_init &rArr; serial_baud &rArr; serial_leuart_baud &rArr;  mbed_assert_internal (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[53]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void()&rang;::~Callback()
<LI><a href="#[282]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void()&rang;::Callback(void(*)())
<LI><a href="#[341]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void()&rang;::operator =(const mbed::Callback&lang;void()&rang;&)
<LI><a href="#[327]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_init
<LI><a href="#[328]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_baud
<LI><a href="#[348]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CThunk&lang;mbed::SerialBase&rang;::init(mbed::SerialBase*, void(mbed::SerialBase::*)(void*), void*)
<LI><a href="#[349]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void(int)&rang;::Callback(void(*)(int))
<LI><a href="#[34b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_irq_handler
<LI><a href="#[34a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_vec_ctor_nocookie_nodtor
<LI><a href="#[23c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memclr4
</UL>
<BR>[Called By]<UL><LI><a href="#[35f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::UARTSerial::UARTSerial(PinName, PinName, int)
<LI><a href="#[3e2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Serial::Serial(PinName, PinName, const char*, int)
</UL>

<P><STRONG><a name="[751]"></a>mbed::SerialBase::SerialBase__sub_object(PinName, PinName, int)</STRONG> (Thumb, 0 bytes, Stack size 48 bytes, .\build\serialbase.o(i._ZN4mbed10SerialBaseC1E7PinNameS1_i), UNUSED)

<P><STRONG><a name="[145]"></a>mbed::SerialBase::~SerialBase()</STRONG> (Thumb, 100 bytes, Stack size 32 bytes, .\build\serialbase.o(i._ZN4mbed10SerialBaseD1Ev))
<BR><BR>[Stack]<UL><LI>Max Depth = 632 + Unknown Stack Size
<LI>Call Chain = mbed::SerialBase::~SerialBase() &rArr; mbed::SerialBase::attach(mbed::Callback&lang;void()&rang;, mbed::SerialBase::IrqType) &rArr; serial_irq_set &rArr; serial_get_tx_irq_index &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[53]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void()&rang;::~Callback()
<LI><a href="#[282]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void()&rang;::Callback(void(*)())
<LI><a href="#[34d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void(int)&rang;::~Callback()
<LI><a href="#[33f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::SerialBase::attach(mbed::Callback&lang;void()&rang;, mbed::SerialBase::IrqType)
<LI><a href="#[34c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_vec_dtor
</UL>
<BR>[Called By]<UL><LI><a href="#[149]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::UARTSerial::~UARTSerial()
<LI><a href="#[5d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Serial::~Serial()
</UL>
<BR>[Address Reference Count : 1]<UL><LI> serialbase.o(.constdata__ZTVN4mbed10SerialBaseE)
</UL>
<P><STRONG><a name="[752]"></a>mbed::SerialBase::~SerialBase__sub_object()</STRONG> (Thumb, 0 bytes, Stack size 32 bytes, .\build\serialbase.o(i._ZN4mbed10SerialBaseD1Ev), UNUSED)

<P><STRONG><a name="[34e]"></a>mbed::TimerEvent::insert_absolute(unsigned long long)</STRONG> (Thumb, 26 bytes, Stack size 24 bytes, .\build\timerevent.o(i._ZN4mbed10TimerEvent15insert_absoluteEy))
<BR><BR>[Stack]<UL><LI>Max Depth = 192<LI>Call Chain = mbed::TimerEvent::insert_absolute(unsigned long long) &rArr; ticker_insert_event_us &rArr; schedule_interrupt &rArr; update_present_time &rArr; __aeabi_uldivmod
</UL>
<BR>[Calls]<UL><LI><a href="#[34f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ticker_insert_event_us
</UL>
<BR>[Called By]<UL><LI><a href="#[3e7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Ticker::setup(unsigned long long)
<LI><a href="#[2cb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::internal::SysTimer::schedule_tick(unsigned)
<LI><a href="#[1a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Ticker::handler()
</UL>

<P><STRONG><a name="[54]"></a>mbed::TimerEvent::irq(unsigned)</STRONG> (Thumb, 16 bytes, Stack size 16 bytes, .\build\timerevent.o(i._ZN4mbed10TimerEvent3irqEj))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = mbed::TimerEvent::irq(unsigned)
</UL>
<BR>[Address Reference Count : 2]<UL><LI> timerevent.o(i._ZN4mbed10TimerEventC2EPK13ticker_data_t)
<LI> timerevent.o(i._ZN4mbed10TimerEventC2Ev)
</UL>
<P><STRONG><a name="[350]"></a>mbed::TimerEvent::remove()</STRONG> (Thumb, 16 bytes, Stack size 8 bytes, .\build\timerevent.o(i._ZN4mbed10TimerEvent6removeEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 160<LI>Call Chain = mbed::TimerEvent::remove() &rArr; ticker_remove_event &rArr; schedule_interrupt &rArr; update_present_time &rArr; __aeabi_uldivmod
</UL>
<BR>[Calls]<UL><LI><a href="#[351]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ticker_remove_event
</UL>
<BR>[Called By]<UL><LI><a href="#[3e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Ticker::detach()
<LI><a href="#[3e7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Ticker::setup(unsigned long long)
<LI><a href="#[146]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::TimerEvent::~TimerEvent__sub_object()
<LI><a href="#[2cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::internal::SysTimer::cancel_tick()
</UL>

<P><STRONG><a name="[352]"></a>mbed::TimerEvent::TimerEvent__sub_object(const ticker_data_t*)</STRONG> (Thumb, 38 bytes, Stack size 16 bytes, .\build\timerevent.o(i._ZN4mbed10TimerEventC2EPK13ticker_data_t))
<BR><BR>[Stack]<UL><LI>Max Depth = 216<LI>Call Chain = mbed::TimerEvent::TimerEvent__sub_object(const ticker_data_t*) &rArr; ticker_set_handler &rArr; initialize &rArr;  mbed_assert_internal (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[353]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ticker_set_handler
</UL>
<BR>[Called By]<UL><LI><a href="#[2cd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::internal::SysTimer::SysTimer()
</UL>

<P><STRONG><a name="[307]"></a>mbed::TimerEvent::TimerEvent__sub_object()</STRONG> (Thumb, 40 bytes, Stack size 8 bytes, .\build\timerevent.o(i._ZN4mbed10TimerEventC2Ev))
<BR><BR>[Stack]<UL><LI>Max Depth = 208<LI>Call Chain = mbed::TimerEvent::TimerEvent__sub_object() &rArr; ticker_set_handler &rArr; initialize &rArr;  mbed_assert_internal (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[354]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;get_us_ticker_data
<LI><a href="#[353]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ticker_set_handler
</UL>
<BR>[Called By]<UL><LI><a href="#[1d5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__sti___17_arm_hal_timer_cpp_749a681d
<LI><a href="#[305]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_tick_init()
</UL>

<P><STRONG><a name="[753]"></a>mbed::TimerEvent::~TimerEvent()</STRONG> (Thumb, 0 bytes, Stack size 8 bytes, .\build\timerevent.o(i._ZN4mbed10TimerEventD2Ev), UNUSED)

<P><STRONG><a name="[146]"></a>mbed::TimerEvent::~TimerEvent__sub_object()</STRONG> (Thumb, 24 bytes, Stack size 8 bytes, .\build\timerevent.o(i._ZN4mbed10TimerEventD2Ev))
<BR><BR>[Stack]<UL><LI>Max Depth = 168<LI>Call Chain = mbed::TimerEvent::~TimerEvent__sub_object() &rArr; mbed::TimerEvent::remove() &rArr; ticker_remove_event &rArr; schedule_interrupt &rArr; update_present_time &rArr; __aeabi_uldivmod
</UL>
<BR>[Calls]<UL><LI><a href="#[350]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::TimerEvent::remove()
</UL>
<BR>[Called By]<UL><LI><a href="#[5a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Timeout::~Timeout()
</UL>
<BR>[Address Reference Count : 1]<UL><LI> timerevent.o(.constdata__ZTVN4mbed10TimerEventE)
</UL>
<P><STRONG><a name="[153]"></a>mbed::UARTSerial::api_unlock()</STRONG> (Thumb, 14 bytes, Stack size 8 bytes, .\build\uartserial.o(i._ZN4mbed10UARTSerial10api_unlockEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = mbed::UARTSerial::api_unlock() &rArr; rtos::Mutex::unlock() &rArr; osMutexRelease
</UL>
<BR>[Calls]<UL><LI><a href="#[2e9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Mutex::unlock()
</UL>
<BR>[Address Reference Count : 1]<UL><LI> uartserial.o(.constdata__ZTVN4mbed10UARTSerialE)
</UL>
<P><STRONG><a name="[150]"></a>mbed::UARTSerial::set_blocking(bool)</STRONG> (Thumb, 10 bytes, Stack size 0 bytes, .\build\uartserial.o(i._ZN4mbed10UARTSerial12set_blockingEb))
<BR><BR>[Called By]<UL><LI><a href="#[159]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;thunk{-212} to mbed::UARTSerial::set_blocking(bool)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> uartserial.o(.constdata__ZTVN4mbed10UARTSerialE)
</UL>
<P><STRONG><a name="[147]"></a>mbed::UARTSerial::lock()</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\uartserial.o(i._ZN4mbed10UARTSerial4lockEv))
<BR>[Address Reference Count : 1]<UL><LI> uartserial.o(.constdata__ZTVN4mbed10UARTSerialE)
</UL>
<P><STRONG><a name="[14c]"></a>mbed::UARTSerial::read(void*, unsigned)</STRONG> (Thumb, 202 bytes, Stack size 40 bytes, .\build\uartserial.o(i._ZN4mbed10UARTSerial4readEPvj))
<BR><BR>[Stack]<UL><LI>Max Depth = 672 + Unknown Stack Size
<LI>Call Chain = mbed::UARTSerial::read(void*, unsigned) &rArr; mbed::UARTSerial::rx_irq() &rArr; mbed::SerialBase::attach(mbed::Callback&lang;void()&rang;, mbed::SerialBase::IrqType) &rArr; serial_irq_set &rArr; serial_get_tx_irq_index &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[311]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;core_util_critical_section_exit
<LI><a href="#[30c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;core_util_critical_section_enter
<LI><a href="#[53]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void()&rang;::~Callback()
<LI><a href="#[33f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::SerialBase::attach(mbed::Callback&lang;void()&rang;, mbed::SerialBase::IrqType)
<LI><a href="#[356]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::CircularBuffer&lang;char, (unsigned)256, unsigned&rang;::empty() const
<LI><a href="#[358]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::CircularBuffer&lang;char, (unsigned)256, unsigned&rang;::full() const
<LI><a href="#[359]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;T3()&rang; mbed::callback&lang;mbed::UARTSerial, mbed::UARTSerial, void&rang;(T2*, T3(T1::*)())
<LI><a href="#[357]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::CircularBuffer&lang;char, (unsigned)256, unsigned&rang;::pop(char&)
<LI><a href="#[355]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::UARTSerial::wait_ms(unsigned)
<LI><a href="#[120]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::UARTSerial::rx_irq()
</UL>
<BR>[Called By]<UL><LI><a href="#[154]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;thunk{-212} to mbed::UARTSerial::read(void*, unsigned)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> uartserial.o(.constdata__ZTVN4mbed10UARTSerialE)
</UL>
<P><STRONG><a name="[14f]"></a>mbed::UARTSerial::seek(long, int)</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, .\build\uartserial.o(i._ZN4mbed10UARTSerial4seekEli))
<BR><BR>[Called By]<UL><LI><a href="#[156]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;thunk{-212} to mbed::UARTSerial::seek(long, int)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> uartserial.o(.constdata__ZTVN4mbed10UARTSerialE)
</UL>
<P><STRONG><a name="[35a]"></a>mbed::UARTSerial::wake()</STRONG> (Thumb, 24 bytes, Stack size 8 bytes, .\build\uartserial.o(i._ZN4mbed10UARTSerial4wakeEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 552 + Unknown Stack Size
<LI>Call Chain = mbed::UARTSerial::wake() &rArr; mbed::Callback&lang;void()&rang;::operator ()() const &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[339]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void()&rang;::operator bool() const
<LI><a href="#[35b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void()&rang;::operator ()() const
</UL>
<BR>[Called By]<UL><LI><a href="#[11e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::UARTSerial::dcd_irq()
<LI><a href="#[11f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::UARTSerial::tx_irq()
<LI><a href="#[120]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::UARTSerial::rx_irq()
</UL>

<P><STRONG><a name="[14d]"></a>mbed::UARTSerial::close()</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, .\build\uartserial.o(i._ZN4mbed10UARTSerial5closeEv))
<BR><BR>[Called By]<UL><LI><a href="#[157]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;thunk{-212} to mbed::UARTSerial::close()
</UL>
<BR>[Address Reference Count : 1]<UL><LI> uartserial.o(.constdata__ZTVN4mbed10UARTSerialE)
</UL>
<P><STRONG><a name="[151]"></a>mbed::UARTSerial::sigio(mbed::Callback&lang;void()&rang;)</STRONG> (Thumb, 112 bytes, Stack size 32 bytes, .\build\uartserial.o(i._ZN4mbed10UARTSerial5sigioENS_8CallbackIFvvEEE))
<BR><BR>[Stack]<UL><LI>Max Depth = 576 + Unknown Stack Size
<LI>Call Chain = mbed::UARTSerial::sigio(mbed::Callback&lang;void()&rang;) &rArr; mbed::Callback&lang;void()&rang;::operator ()() const &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[311]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;core_util_critical_section_exit
<LI><a href="#[30c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;core_util_critical_section_enter
<LI><a href="#[53]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void()&rang;::~Callback()
<LI><a href="#[339]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void()&rang;::operator bool() const
<LI><a href="#[35b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void()&rang;::operator ()() const
</UL>
<BR>[Called By]<UL><LI><a href="#[15b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;thunk{-212} to mbed::UARTSerial::sigio(mbed::Callback&lang;void()&rang;)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> uartserial.o(.constdata__ZTVN4mbed10UARTSerialE)
</UL>
<P><STRONG><a name="[14b]"></a>mbed::UARTSerial::write(const void*, unsigned)</STRONG> (Thumb, 216 bytes, Stack size 40 bytes, .\build\uartserial.o(i._ZN4mbed10UARTSerial5writeEPKvj))
<BR><BR>[Stack]<UL><LI>Max Depth = 672 + Unknown Stack Size
<LI>Call Chain = mbed::UARTSerial::write(const void*, unsigned) &rArr; mbed::UARTSerial::tx_irq() &rArr; mbed::SerialBase::attach(mbed::Callback&lang;void()&rang;, mbed::SerialBase::IrqType) &rArr; serial_irq_set &rArr; serial_get_tx_irq_index &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[311]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;core_util_critical_section_exit
<LI><a href="#[30c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;core_util_critical_section_enter
<LI><a href="#[53]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void()&rang;::~Callback()
<LI><a href="#[33f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::SerialBase::attach(mbed::Callback&lang;void()&rang;, mbed::SerialBase::IrqType)
<LI><a href="#[356]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::CircularBuffer&lang;char, (unsigned)256, unsigned&rang;::empty() const
<LI><a href="#[358]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::CircularBuffer&lang;char, (unsigned)256, unsigned&rang;::full() const
<LI><a href="#[359]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;T3()&rang; mbed::callback&lang;mbed::UARTSerial, mbed::UARTSerial, void&rang;(T2*, T3(T1::*)())
<LI><a href="#[35c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::CircularBuffer&lang;char, (unsigned)256, unsigned&rang;::push(const char&)
<LI><a href="#[355]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::UARTSerial::wait_ms(unsigned)
<LI><a href="#[11f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::UARTSerial::tx_irq()
</UL>
<BR>[Called By]<UL><LI><a href="#[155]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;thunk{-212} to mbed::UARTSerial::write(const void*, unsigned)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> uartserial.o(.constdata__ZTVN4mbed10UARTSerialE)
</UL>
<P><STRONG><a name="[14e]"></a>mbed::UARTSerial::isatty()</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, .\build\uartserial.o(i._ZN4mbed10UARTSerial6isattyEv))
<BR><BR>[Called By]<UL><LI><a href="#[158]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;thunk{-212} to mbed::UARTSerial::isatty()
</UL>
<BR>[Address Reference Count : 1]<UL><LI> uartserial.o(.constdata__ZTVN4mbed10UARTSerialE)
</UL>
<P><STRONG><a name="[120]"></a>mbed::UARTSerial::rx_irq()</STRONG> (Thumb, 128 bytes, Stack size 32 bytes, .\build\uartserial.o(i._ZN4mbed10UARTSerial6rx_irqEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 632 + Unknown Stack Size
<LI>Call Chain = mbed::UARTSerial::rx_irq() &rArr; mbed::SerialBase::attach(mbed::Callback&lang;void()&rang;, mbed::SerialBase::IrqType) &rArr; serial_irq_set &rArr; serial_get_tx_irq_index &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[53]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void()&rang;::~Callback()
<LI><a href="#[282]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void()&rang;::Callback(void(*)())
<LI><a href="#[337]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::SerialBase::_base_getc()
<LI><a href="#[343]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::SerialBase::readable()
<LI><a href="#[33f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::SerialBase::attach(mbed::Callback&lang;void()&rang;, mbed::SerialBase::IrqType)
<LI><a href="#[356]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::CircularBuffer&lang;char, (unsigned)256, unsigned&rang;::empty() const
<LI><a href="#[358]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::CircularBuffer&lang;char, (unsigned)256, unsigned&rang;::full() const
<LI><a href="#[35c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::CircularBuffer&lang;char, (unsigned)256, unsigned&rang;::push(const char&)
<LI><a href="#[35a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::UARTSerial::wake()
</UL>
<BR>[Called By]<UL><LI><a href="#[14c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::UARTSerial::read(void*, unsigned)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> uartserial.o(.constdata)
</UL>
<P><STRONG><a name="[11f]"></a>mbed::UARTSerial::tx_irq()</STRONG> (Thumb, 136 bytes, Stack size 32 bytes, .\build\uartserial.o(i._ZN4mbed10UARTSerial6tx_irqEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 632 + Unknown Stack Size
<LI>Call Chain = mbed::UARTSerial::tx_irq() &rArr; mbed::SerialBase::attach(mbed::Callback&lang;void()&rang;, mbed::SerialBase::IrqType) &rArr; serial_irq_set &rArr; serial_get_tx_irq_index &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[53]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void()&rang;::~Callback()
<LI><a href="#[282]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void()&rang;::Callback(void(*)())
<LI><a href="#[338]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::SerialBase::_base_putc(int)
<LI><a href="#[345]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::SerialBase::writeable()
<LI><a href="#[33f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::SerialBase::attach(mbed::Callback&lang;void()&rang;, mbed::SerialBase::IrqType)
<LI><a href="#[356]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::CircularBuffer&lang;char, (unsigned)256, unsigned&rang;::empty() const
<LI><a href="#[358]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::CircularBuffer&lang;char, (unsigned)256, unsigned&rang;::full() const
<LI><a href="#[357]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::CircularBuffer&lang;char, (unsigned)256, unsigned&rang;::pop(char&)
<LI><a href="#[35d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::UARTSerial::hup() const
<LI><a href="#[35a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::UARTSerial::wake()
</UL>
<BR>[Called By]<UL><LI><a href="#[14b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::UARTSerial::write(const void*, unsigned)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> uartserial.o(.constdata)
</UL>
<P><STRONG><a name="[148]"></a>mbed::UARTSerial::unlock()</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\uartserial.o(i._ZN4mbed10UARTSerial6unlockEv))
<BR>[Address Reference Count : 1]<UL><LI> uartserial.o(.constdata__ZTVN4mbed10UARTSerialE)
</UL>
<P><STRONG><a name="[11e]"></a>mbed::UARTSerial::dcd_irq()</STRONG> (Thumb, 12 bytes, Stack size 8 bytes, .\build\uartserial.o(i._ZN4mbed10UARTSerial7dcd_irqEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 560 + Unknown Stack Size
<LI>Call Chain = mbed::UARTSerial::dcd_irq() &rArr; mbed::UARTSerial::wake() &rArr; mbed::Callback&lang;void()&rang;::operator ()() const &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[35a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::UARTSerial::wake()
</UL>
<BR>[Address Reference Count : 1]<UL><LI> uartserial.o(.constdata)
</UL>
<P><STRONG><a name="[355]"></a>mbed::UARTSerial::wait_ms(unsigned)</STRONG> (Thumb, 14 bytes, Stack size 16 bytes, .\build\uartserial.o(i._ZN4mbed10UARTSerial7wait_msEj))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = mbed::UARTSerial::wait_ms(unsigned) &rArr; rtos::Thread::wait(unsigned) &rArr; osDelay
</UL>
<BR>[Calls]<UL><LI><a href="#[35e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Thread::wait(unsigned)
</UL>
<BR>[Called By]<UL><LI><a href="#[14b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::UARTSerial::write(const void*, unsigned)
<LI><a href="#[14c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::UARTSerial::read(void*, unsigned)
</UL>

<P><STRONG><a name="[152]"></a>mbed::UARTSerial::api_lock()</STRONG> (Thumb, 18 bytes, Stack size 8 bytes, .\build\uartserial.o(i._ZN4mbed10UARTSerial8api_lockEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = mbed::UARTSerial::api_lock() &rArr; rtos::Mutex::lock(unsigned) &rArr; osMutexAcquire
</UL>
<BR>[Calls]<UL><LI><a href="#[2e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Mutex::lock(unsigned)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> uartserial.o(.constdata__ZTVN4mbed10UARTSerialE)
</UL>
<P><STRONG><a name="[35f]"></a>mbed::UARTSerial::UARTSerial(PinName, PinName, int)</STRONG> (Thumb, 166 bytes, Stack size 40 bytes, .\build\uartserial.o(i._ZN4mbed10UARTSerialC1E7PinNameS1_i))
<BR><BR>[Stack]<UL><LI>Max Depth = 640 + Unknown Stack Size
<LI>Call Chain = mbed::UARTSerial::UARTSerial(PinName, PinName, int) &rArr; mbed::SerialBase::attach(mbed::Callback&lang;void()&rang;, mbed::SerialBase::IrqType) &rArr; serial_irq_set &rArr; serial_get_tx_irq_index &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[53]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void()&rang;::~Callback()
<LI><a href="#[282]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void()&rang;::Callback(void(*)())
<LI><a href="#[361]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Mutex::Mutex()
<LI><a href="#[347]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::SerialBase::SerialBase(PinName, PinName, int)
<LI><a href="#[33f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::SerialBase::attach(mbed::Callback&lang;void()&rang;, mbed::SerialBase::IrqType)
<LI><a href="#[359]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;T3()&rang; mbed::callback&lang;mbed::UARTSerial, mbed::UARTSerial, void&rang;(T2*, T3(T1::*)())
<LI><a href="#[360]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::CircularBuffer&lang;char, (unsigned)256, unsigned&rang;::CircularBuffer()
</UL>
<BR>[Called By]<UL><LI><a href="#[3d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::EasyCellularConnection::EasyCellularConnection(bool)
</UL>

<P><STRONG><a name="[754]"></a>mbed::UARTSerial::UARTSerial__sub_object(PinName, PinName, int)</STRONG> (Thumb, 0 bytes, Stack size 40 bytes, .\build\uartserial.o(i._ZN4mbed10UARTSerialC1E7PinNameS1_i), UNUSED)

<P><STRONG><a name="[149]"></a>mbed::UARTSerial::~UARTSerial()</STRONG> (Thumb, 108 bytes, Stack size 8 bytes, .\build\uartserial.o(i._ZN4mbed10UARTSerialD1Ev))
<BR><BR>[Stack]<UL><LI>Max Depth = 640 + Unknown Stack Size
<LI>Call Chain = mbed::UARTSerial::~UARTSerial() &rArr; mbed::SerialBase::~SerialBase() &rArr; mbed::SerialBase::attach(mbed::Callback&lang;void()&rang;, mbed::SerialBase::IrqType) &rArr; serial_irq_set &rArr; serial_get_tx_irq_index &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[53]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void()&rang;::~Callback()
<LI><a href="#[5f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Mutex::~Mutex()
<LI><a href="#[145]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::SerialBase::~SerialBase()
</UL>
<BR>[Called By]<UL><LI><a href="#[5e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::EasyCellularConnection::~EasyCellularConnection()
</UL>
<BR>[Address Reference Count : 1]<UL><LI> uartserial.o(.constdata__ZTVN4mbed10UARTSerialE)
</UL>
<P><STRONG><a name="[755]"></a>mbed::UARTSerial::~UARTSerial__sub_object()</STRONG> (Thumb, 0 bytes, Stack size 8 bytes, .\build\uartserial.o(i._ZN4mbed10UARTSerialD1Ev), UNUSED)

<P><STRONG><a name="[362]"></a>mbed::bind_to_fd(mbed::FileHandle*)</STRONG> (Thumb, 38 bytes, Stack size 16 bytes, .\build\mbed_retarget.o(i._ZN4mbed10bind_to_fdEPNS_10FileHandleE))
<BR><BR>[Stack]<UL><LI>Max Depth = 624 + Unknown Stack Size
<LI>Call Chain = mbed::bind_to_fd(mbed::FileHandle*) &rArr; reserve_filehandle() &rArr; SingletonPtr&lang;rtos::Mutex&rang;::operator -&rang;() &rArr; SingletonPtr&lang;rtos::Mutex&rang;::get() &rArr; rtos::Mutex::Mutex() &rArr; rtos::Mutex::constructor(const char*) &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[319]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;reserve_filehandle()
</UL>
<BR>[Called By]<UL><LI><a href="#[3e5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::fdopen(mbed::FileHandle*, const char*)
</UL>

<P><STRONG><a name="[364]"></a>mbed::InterruptIn::read()</STRONG> (Thumb, 12 bytes, Stack size 8 bytes, .\build\interruptin.o(i._ZN4mbed11InterruptIn4readEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = mbed::InterruptIn::read() &rArr; gpio_read &rArr; BUS_RegBitRead
</UL>
<BR>[Calls]<UL><LI><a href="#[365]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;gpio_read
</UL>
<BR>[Called By]<UL><LI><a href="#[35d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::UARTSerial::hup() const
</UL>

<P><STRONG><a name="[15c]"></a>mbed::QUECTEL_BG96::open_network(mbed::FileHandle*)</STRONG> (Thumb, 72 bytes, Stack size 24 bytes, .\build\quectel_bg96.o(i._ZN4mbed12QUECTEL_BG9612open_networkEPNS_10FileHandleE))
<BR><BR>[Stack]<UL><LI>Max Depth = 640 + Unknown Stack Size
<LI>Call Chain = mbed::QUECTEL_BG96::open_network(mbed::FileHandle*) &rArr; mbed::AT_CellularDevice::get_at_handler(mbed::FileHandle*) &rArr; mbed::ATHandler::ATHandler(mbed::FileHandle*, events::EventQueue&, int, const char*) &rArr; rtos::Mutex::Mutex() &rArr; rtos::Mutex::constructor(const char*) &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[367]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;operator new(unsigned)
<LI><a href="#[369]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularDevice::release_at_handler(mbed::ATHandler*)
<LI><a href="#[366]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularDevice::get_at_handler(mbed::FileHandle*)
<LI><a href="#[368]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::QUECTEL_BG96_CellularNetwork::QUECTEL_BG96_CellularNetwork(mbed::ATHandler&)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> quectel_bg96.o(.constdata__ZTVN4mbed12QUECTEL_BG96E)
</UL>
<P><STRONG><a name="[36a]"></a>mbed::QUECTEL_BG96::QUECTEL_BG96(events::EventQueue&)</STRONG> (Thumb, 24 bytes, Stack size 16 bytes, .\build\quectel_bg96.o(i._ZN4mbed12QUECTEL_BG96C1ERN6events10EventQueueE))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = mbed::QUECTEL_BG96::QUECTEL_BG96(events::EventQueue&)
</UL>
<BR>[Calls]<UL><LI><a href="#[36b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularDevice::AT_CellularDevice(events::EventQueue&)
</UL>
<BR>[Called By]<UL><LI><a href="#[3c5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::CellularConnectionFSM::CellularConnectionFSM()
</UL>

<P><STRONG><a name="[756]"></a>mbed::QUECTEL_BG96::QUECTEL_BG96__sub_object(events::EventQueue&)</STRONG> (Thumb, 0 bytes, Stack size 16 bytes, .\build\quectel_bg96.o(i._ZN4mbed12QUECTEL_BG96C1ERN6events10EventQueueE), UNUSED)

<P><STRONG><a name="[36c]"></a>mbed::transaction_t::transaction_t()</STRONG> (Thumb, 22 bytes, Stack size 8 bytes, .\build\spi.o(i._ZN4mbed13transaction_tC1Ev))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = mbed::transaction_t::transaction_t() &rArr; mbed::Callback&lang;void(int)&rang;::Callback(void(*)(int))
</UL>
<BR>[Calls]<UL><LI><a href="#[349]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void(int)&rang;::Callback(void(*)(int))
</UL>
<BR>[Called By]<UL><LI><a href="#[5b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Transaction&lang;mbed::SPI&rang;::Transaction()
</UL>

<P><STRONG><a name="[757]"></a>mbed::transaction_t::transaction_t__sub_object()</STRONG> (Thumb, 0 bytes, Stack size 8 bytes, .\build\spi.o(i._ZN4mbed13transaction_tC1Ev), UNUSED)

<P><STRONG><a name="[36d]"></a>mbed::transaction_t::~transaction_t()</STRONG> (Thumb, 20 bytes, Stack size 8 bytes, .\build\spi.o(i._ZN4mbed13transaction_tD1Ev))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = mbed::transaction_t::~transaction_t() &rArr; mbed::Callback&lang;void(int)&rang;::~Callback()
</UL>
<BR>[Calls]<UL><LI><a href="#[34d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void(int)&rang;::~Callback()
</UL>
<BR>[Called By]<UL><LI><a href="#[c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Transaction&lang;mbed::SPI&rang;::~Transaction()
</UL>

<P><STRONG><a name="[758]"></a>mbed::transaction_t::~transaction_t__sub_object()</STRONG> (Thumb, 0 bytes, Stack size 8 bytes, .\build\spi.o(i._ZN4mbed13transaction_tD1Ev), UNUSED)

<P><STRONG><a name="[166]"></a>mbed::AT_CellularSIM::get_sim_state(mbed::CellularSIM::SimState&)</STRONG> (Thumb, 158 bytes, Stack size 32 bytes, .\build\at_cellularsim.o(i._ZN4mbed14AT_CellularSIM13get_sim_stateERNS_11CellularSIM8SimStateE))
<BR><BR>[Stack]<UL><LI>Max Depth = 728 + Unknown Stack Size
<LI>Call Chain = mbed::AT_CellularSIM::get_sim_state(mbed::CellularSIM::SimState&) &rArr; mbed::ATHandler::resp_start(const char*, bool) &rArr; mbed::ATHandler::resp(const char*, bool) &rArr; mbed::ATHandler::match_error() &rArr; mbed::ATHandler::at_error(bool, mbed::DeviceErrorType) &rArr; mbed::ATHandler::read_int() &rArr; mbed::ATHandler::read_string(char*, unsigned, bool) &rArr; mbed::ATHandler::consume_char(char) &rArr; mbed::ATHandler::get_char() &rArr; mbed::ATHandler::fill_buffer() &rArr; mbed::Timer::~Timer() &rArr; sleep_manager_unlock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[374]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::resp_stop()
<LI><a href="#[370]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::cmd_start(const char*)
<LI><a href="#[371]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::cmd_stop()
<LI><a href="#[36e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::lock()
<LI><a href="#[375]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::unlock_return_error()
<LI><a href="#[373]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::read_string(char*, unsigned, bool)
<LI><a href="#[372]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::resp_start(const char*, bool)
<LI><a href="#[36f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::flush()
<LI><a href="#[323]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memcmp
</UL>
<BR>[Address Reference Count : 1]<UL><LI> at_cellularsim.o(.constdata__ZTVN4mbed14AT_CellularSIME)
</UL>
<P><STRONG><a name="[165]"></a>mbed::AT_CellularSIM::set_pin(const char*)</STRONG> (Thumb, 82 bytes, Stack size 16 bytes, .\build\at_cellularsim.o(i._ZN4mbed14AT_CellularSIM7set_pinEPKc))
<BR><BR>[Stack]<UL><LI>Max Depth = 712 + Unknown Stack Size
<LI>Call Chain = mbed::AT_CellularSIM::set_pin(const char*) &rArr; mbed::ATHandler::resp_start(const char*, bool) &rArr; mbed::ATHandler::resp(const char*, bool) &rArr; mbed::ATHandler::match_error() &rArr; mbed::ATHandler::at_error(bool, mbed::DeviceErrorType) &rArr; mbed::ATHandler::read_int() &rArr; mbed::ATHandler::read_string(char*, unsigned, bool) &rArr; mbed::ATHandler::consume_char(char) &rArr; mbed::ATHandler::get_char() &rArr; mbed::ATHandler::fill_buffer() &rArr; mbed::Timer::~Timer() &rArr; sleep_manager_unlock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[374]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::resp_stop()
<LI><a href="#[370]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::cmd_start(const char*)
<LI><a href="#[371]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::cmd_stop()
<LI><a href="#[36e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::lock()
<LI><a href="#[375]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::unlock_return_error()
<LI><a href="#[372]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::resp_start(const char*, bool)
<LI><a href="#[376]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::write_string(const char*, bool)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> at_cellularsim.o(.constdata__ZTVN4mbed14AT_CellularSIME)
</UL>
<P><STRONG><a name="[167]"></a>mbed::AT_CellularSIM::get_imsi(char*)</STRONG> (Thumb, 72 bytes, Stack size 16 bytes, .\build\at_cellularsim.o(i._ZN4mbed14AT_CellularSIM8get_imsiEPc))
<BR><BR>[Stack]<UL><LI>Max Depth = 712 + Unknown Stack Size
<LI>Call Chain = mbed::AT_CellularSIM::get_imsi(char*) &rArr; mbed::ATHandler::resp_start(const char*, bool) &rArr; mbed::ATHandler::resp(const char*, bool) &rArr; mbed::ATHandler::match_error() &rArr; mbed::ATHandler::at_error(bool, mbed::DeviceErrorType) &rArr; mbed::ATHandler::read_int() &rArr; mbed::ATHandler::read_string(char*, unsigned, bool) &rArr; mbed::ATHandler::consume_char(char) &rArr; mbed::ATHandler::get_char() &rArr; mbed::ATHandler::fill_buffer() &rArr; mbed::Timer::~Timer() &rArr; sleep_manager_unlock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[374]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::resp_stop()
<LI><a href="#[370]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::cmd_start(const char*)
<LI><a href="#[371]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::cmd_stop()
<LI><a href="#[36e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::lock()
<LI><a href="#[375]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::unlock_return_error()
<LI><a href="#[373]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::read_string(char*, unsigned, bool)
<LI><a href="#[372]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::resp_start(const char*, bool)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> at_cellularsim.o(.constdata__ZTVN4mbed14AT_CellularSIME)
</UL>
<P><STRONG><a name="[377]"></a>mbed::AT_CellularSIM::AT_CellularSIM(mbed::ATHandler&)</STRONG> (Thumb, 28 bytes, Stack size 16 bytes, .\build\at_cellularsim.o(i._ZN4mbed14AT_CellularSIMC1ERNS_9ATHandlerE))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = mbed::AT_CellularSIM::AT_CellularSIM(mbed::ATHandler&)
</UL>
<BR>[Calls]<UL><LI><a href="#[378]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularBase::AT_CellularBase(mbed::ATHandler&)
</UL>
<BR>[Called By]<UL><LI><a href="#[15e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularDevice::open_sim(mbed::FileHandle*)
</UL>

<P><STRONG><a name="[759]"></a>mbed::AT_CellularSIM::AT_CellularSIM__sub_object(mbed::ATHandler&)</STRONG> (Thumb, 0 bytes, Stack size 16 bytes, .\build\at_cellularsim.o(i._ZN4mbed14AT_CellularSIMC1ERNS_9ATHandlerE), UNUSED)

<P><STRONG><a name="[386]"></a>mbed::AT_CellularBase::get_at_handler()</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, .\build\at_cellularbase.o(i._ZN4mbed15AT_CellularBase14get_at_handlerEv))
<BR><BR>[Called By]<UL><LI><a href="#[160]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularDevice::close_network()
<LI><a href="#[161]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularDevice::close_power()
</UL>

<P><STRONG><a name="[378]"></a>mbed::AT_CellularBase::AT_CellularBase(mbed::ATHandler&)</STRONG> (Thumb, 4 bytes, Stack size 0 bytes, .\build\at_cellularbase.o(i._ZN4mbed15AT_CellularBaseC1ERNS_9ATHandlerE))
<BR><BR>[Called By]<UL><LI><a href="#[38d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularInformation::AT_CellularInformation(mbed::ATHandler&)
<LI><a href="#[388]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::AT_CellularNetwork(mbed::ATHandler&)
<LI><a href="#[37d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularPower::AT_CellularPower(mbed::ATHandler&)
<LI><a href="#[377]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularSIM::AT_CellularSIM(mbed::ATHandler&)
<LI><a href="#[385]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularStack::AT_CellularStack__sub_object(mbed::ATHandler&, int, nsapi_ip_stack)
</UL>

<P><STRONG><a name="[75a]"></a>mbed::AT_CellularBase::AT_CellularBase__sub_object(mbed::ATHandler&)</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, .\build\at_cellularbase.o(i._ZN4mbed15AT_CellularBaseC1ERNS_9ATHandlerE), UNUSED)

<P><STRONG><a name="[75b]"></a>mbed::CellularNetwork::~CellularNetwork()</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, .\build\at_cellularnetwork.o(i._ZN4mbed15CellularNetworkD2Ev), UNUSED)

<P><STRONG><a name="[168]"></a>mbed::CellularNetwork::~CellularNetwork__sub_object()</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, .\build\at_cellularnetwork.o(i._ZN4mbed15CellularNetworkD2Ev))
<BR><BR>[Called By]<UL><LI><a href="#[178]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::~AT_CellularNetwork()
</UL>
<BR>[Address Reference Count : 1]<UL><LI> at_cellularnetwork.o(.constdata__ZTVN4mbed15CellularNetworkE)
</UL>
<P><STRONG><a name="[16d]"></a>mbed::AT_CellularPower::set_at_mode()</STRONG> (Thumb, 84 bytes, Stack size 8 bytes, .\build\at_cellularpower.o(i._ZN4mbed16AT_CellularPower11set_at_modeEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 704 + Unknown Stack Size
<LI>Call Chain = mbed::AT_CellularPower::set_at_mode() &rArr; mbed::ATHandler::resp_start(const char*, bool) &rArr; mbed::ATHandler::resp(const char*, bool) &rArr; mbed::ATHandler::match_error() &rArr; mbed::ATHandler::at_error(bool, mbed::DeviceErrorType) &rArr; mbed::ATHandler::read_int() &rArr; mbed::ATHandler::read_string(char*, unsigned, bool) &rArr; mbed::ATHandler::consume_char(char) &rArr; mbed::ATHandler::get_char() &rArr; mbed::ATHandler::fill_buffer() &rArr; mbed::Timer::~Timer() &rArr; sleep_manager_unlock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[374]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::resp_stop()
<LI><a href="#[370]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::cmd_start(const char*)
<LI><a href="#[371]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::cmd_stop()
<LI><a href="#[36e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::lock()
<LI><a href="#[375]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::unlock_return_error()
<LI><a href="#[372]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::resp_start(const char*, bool)
<LI><a href="#[36f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::flush()
</UL>
<BR>[Address Reference Count : 1]<UL><LI> at_cellularpower.o(.constdata__ZTVN4mbed16AT_CellularPowerE)
</UL>
<P><STRONG><a name="[16b]"></a>mbed::AT_CellularPower::on()</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, .\build\at_cellularpower.o(i._ZN4mbed16AT_CellularPower2onEv))
<BR>[Address Reference Count : 1]<UL><LI> at_cellularpower.o(.constdata__ZTVN4mbed16AT_CellularPowerE)
</UL>
<P><STRONG><a name="[16c]"></a>mbed::AT_CellularPower::off()</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, .\build\at_cellularpower.o(i._ZN4mbed16AT_CellularPower3offEv))
<BR>[Address Reference Count : 1]<UL><LI> at_cellularpower.o(.constdata__ZTVN4mbed16AT_CellularPowerE)
</UL>
<P><STRONG><a name="[37d]"></a>mbed::AT_CellularPower::AT_CellularPower(mbed::ATHandler&)</STRONG> (Thumb, 28 bytes, Stack size 16 bytes, .\build\at_cellularpower.o(i._ZN4mbed16AT_CellularPowerC1ERNS_9ATHandlerE))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = mbed::AT_CellularPower::AT_CellularPower(mbed::ATHandler&)
</UL>
<BR>[Calls]<UL><LI><a href="#[378]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularBase::AT_CellularBase(mbed::ATHandler&)
</UL>
<BR>[Called By]<UL><LI><a href="#[15d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularDevice::open_power(mbed::FileHandle*)
</UL>

<P><STRONG><a name="[75c]"></a>mbed::AT_CellularPower::AT_CellularPower__sub_object(mbed::ATHandler&)</STRONG> (Thumb, 0 bytes, Stack size 16 bytes, .\build\at_cellularpower.o(i._ZN4mbed16AT_CellularPowerC1ERNS_9ATHandlerE), UNUSED)

<P><STRONG><a name="[16a]"></a>mbed::AT_CellularPower::~AT_CellularPower__deallocating()</STRONG> (Thumb, 18 bytes, Stack size 16 bytes, .\build\at_cellularpower.o(i._ZN4mbed16AT_CellularPowerD0Ev))
<BR><BR>[Stack]<UL><LI>Max Depth = 80<LI>Call Chain = mbed::AT_CellularPower::~AT_CellularPower__deallocating() &rArr; operator delete (void*) &rArr; free &rArr; _free_internal &rArr; _mutex_release &rArr; os_kernel_is_active &rArr; osKernelGetState &rArr; svcRtxKernelGetState
</UL>
<BR>[Calls]<UL><LI><a href="#[37e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;operator delete (void*)
<LI><a href="#[169]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularPower::~AT_CellularPower()
</UL>
<BR>[Address Reference Count : 1]<UL><LI> at_cellularpower.o(.constdata__ZTVN4mbed16AT_CellularPowerE)
</UL>
<P><STRONG><a name="[169]"></a>mbed::AT_CellularPower::~AT_CellularPower()</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, .\build\at_cellularpower.o(i._ZN4mbed16AT_CellularPowerD1Ev))
<BR><BR>[Called By]<UL><LI><a href="#[16a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularPower::~AT_CellularPower__deallocating()
</UL>
<BR>[Address Reference Count : 1]<UL><LI> at_cellularpower.o(.constdata__ZTVN4mbed16AT_CellularPowerE)
</UL>
<P><STRONG><a name="[75d]"></a>mbed::AT_CellularPower::~AT_CellularPower__sub_object()</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, .\build\at_cellularpower.o(i._ZN4mbed16AT_CellularPowerD1Ev), UNUSED)

<P><STRONG><a name="[16f]"></a>mbed::AT_CellularStack::socket_open(void**, nsapi_protocol)</STRONG> (Thumb, 288 bytes, Stack size 152 bytes, .\build\at_cellularstack.o(i._ZN4mbed16AT_CellularStack11socket_openEPPv14nsapi_protocol))
<BR><BR>[Stack]<UL><LI>Max Depth = 624 + Unknown Stack Size
<LI>Call Chain = mbed::AT_CellularStack::socket_open(void**, nsapi_protocol) &rArr; operator new(unsigned) &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[367]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;operator new(unsigned)
<LI><a href="#[37f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;operator new[] (unsigned)
<LI><a href="#[380]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_cellular_util::get_dynamic_ip_port()
<LI><a href="#[32d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SocketAddress::SocketAddress(const char*, unsigned short)
<LI><a href="#[2f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SocketAddress::SocketAddress(nsapi_addr, unsigned short)
<LI><a href="#[23c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memclr4
<LI><a href="#[249]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Address Reference Count : 2]<UL><LI> at_cellularstack.o(.constdata__ZTVN4mbed16AT_CellularStackE)
<LI> quectel_bg96_cellularstack.o(.constdata__ZTVN4mbed26QUECTEL_BG96_CellularStackE)
</UL>
<P><STRONG><a name="[173]"></a>mbed::AT_CellularStack::socket_recv(void*, void*, unsigned)</STRONG> (Thumb, 30 bytes, Stack size 24 bytes, .\build\at_cellularstack.o(i._ZN4mbed16AT_CellularStack11socket_recvEPvS1_j))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = mbed::AT_CellularStack::socket_recv(void*, void*, unsigned)
</UL>
<BR>[Address Reference Count : 2]<UL><LI> at_cellularstack.o(.constdata__ZTVN4mbed16AT_CellularStackE)
<LI> quectel_bg96_cellularstack.o(.constdata__ZTVN4mbed26QUECTEL_BG96_CellularStackE)
</UL>
<P><STRONG><a name="[172]"></a>mbed::AT_CellularStack::socket_send(void*, const void*, unsigned)</STRONG> (Thumb, 48 bytes, Stack size 32 bytes, .\build\at_cellularstack.o(i._ZN4mbed16AT_CellularStack11socket_sendEPvPKvj))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = mbed::AT_CellularStack::socket_send(void*, const void*, unsigned)
</UL>
<BR>[Address Reference Count : 2]<UL><LI> at_cellularstack.o(.constdata__ZTVN4mbed16AT_CellularStackE)
<LI> quectel_bg96_cellularstack.o(.constdata__ZTVN4mbed26QUECTEL_BG96_CellularStackE)
</UL>
<P><STRONG><a name="[170]"></a>mbed::AT_CellularStack::socket_close(void*)</STRONG> (Thumb, 128 bytes, Stack size 32 bytes, .\build\at_cellularstack.o(i._ZN4mbed16AT_CellularStack12socket_closeEPv))
<BR><BR>[Stack]<UL><LI>Max Depth = 688 + Unknown Stack Size
<LI>Call Chain = mbed::AT_CellularStack::socket_close(void*) &rArr; mbed::ATHandler::unlock() &rArr; int events::EventQueue::call&lang;mbed::Callback&lang;void()&rang;&rang;(T1) &rArr; equeue_post &rArr; equeue_tick &rArr; equeue_tick_init() &rArr; mbed::Ticker::attach_us(mbed::Callback&lang;void()&rang;, unsigned long long) &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[37e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;operator delete (void*)
<LI><a href="#[36e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::lock()
<LI><a href="#[381]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::unlock()
</UL>
<BR>[Address Reference Count : 2]<UL><LI> at_cellularstack.o(.constdata__ZTVN4mbed16AT_CellularStackE)
<LI> quectel_bg96_cellularstack.o(.constdata__ZTVN4mbed26QUECTEL_BG96_CellularStackE)
</UL>
<P><STRONG><a name="[176]"></a>mbed::AT_CellularStack::socket_attach(void*, void(*)(void*), void*)</STRONG> (Thumb, 22 bytes, Stack size 8 bytes, .\build\at_cellularstack.o(i._ZN4mbed16AT_CellularStack13socket_attachEPvPFvS1_ES1_))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = mbed::AT_CellularStack::socket_attach(void*, void(*)(void*), void*)
</UL>
<BR>[Address Reference Count : 2]<UL><LI> at_cellularstack.o(.constdata__ZTVN4mbed16AT_CellularStackE)
<LI> quectel_bg96_cellularstack.o(.constdata__ZTVN4mbed26QUECTEL_BG96_CellularStackE)
</UL>
<P><STRONG><a name="[174]"></a>mbed::AT_CellularStack::socket_sendto(void*, const SocketAddress&, const void*, unsigned)</STRONG> (Thumb, 128 bytes, Stack size 40 bytes, .\build\at_cellularstack.o(i._ZN4mbed16AT_CellularStack13socket_sendtoEPvRK13SocketAddressPKvj))
<BR><BR>[Stack]<UL><LI>Max Depth = 696 + Unknown Stack Size
<LI>Call Chain = mbed::AT_CellularStack::socket_sendto(void*, const SocketAddress&, const void*, unsigned) &rArr; mbed::ATHandler::unlock() &rArr; int events::EventQueue::call&lang;mbed::Callback&lang;void()&rang;&rang;(T1) &rArr; equeue_post &rArr; equeue_tick &rArr; equeue_tick_init() &rArr; mbed::Ticker::attach_us(mbed::Callback&lang;void()&rang;, unsigned long long) &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[36e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::lock()
<LI><a href="#[381]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::unlock()
<LI><a href="#[32a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SocketAddress::get_ip_version() const
</UL>
<BR>[Address Reference Count : 2]<UL><LI> at_cellularstack.o(.constdata__ZTVN4mbed16AT_CellularStackE)
<LI> quectel_bg96_cellularstack.o(.constdata__ZTVN4mbed26QUECTEL_BG96_CellularStackE)
</UL>
<P><STRONG><a name="[16e]"></a>mbed::AT_CellularStack::get_ip_address()</STRONG> (Thumb, 144 bytes, Stack size 16 bytes, .\build\at_cellularstack.o(i._ZN4mbed16AT_CellularStack14get_ip_addressEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 712 + Unknown Stack Size
<LI>Call Chain = mbed::AT_CellularStack::get_ip_address() &rArr; mbed::ATHandler::resp_start(const char*, bool) &rArr; mbed::ATHandler::resp(const char*, bool) &rArr; mbed::ATHandler::match_error() &rArr; mbed::ATHandler::at_error(bool, mbed::DeviceErrorType) &rArr; mbed::ATHandler::read_int() &rArr; mbed::ATHandler::read_string(char*, unsigned, bool) &rArr; mbed::ATHandler::consume_char(char) &rArr; mbed::ATHandler::get_char() &rArr; mbed::ATHandler::fill_buffer() &rArr; mbed::Timer::~Timer() &rArr; sleep_manager_unlock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[374]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::resp_stop()
<LI><a href="#[370]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::cmd_start(const char*)
<LI><a href="#[371]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::cmd_stop()
<LI><a href="#[36e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::lock()
<LI><a href="#[373]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::read_string(char*, unsigned, bool)
<LI><a href="#[372]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::resp_start(const char*, bool)
<LI><a href="#[382]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::write_int(int)
<LI><a href="#[383]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::info_resp()
<LI><a href="#[381]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::unlock()
<LI><a href="#[384]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::skip_param(unsigned)
<LI><a href="#[32e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_cellular_util::convert_ipv6(char*)
</UL>
<BR>[Address Reference Count : 2]<UL><LI> at_cellularstack.o(.constdata__ZTVN4mbed16AT_CellularStackE)
<LI> quectel_bg96_cellularstack.o(.constdata__ZTVN4mbed26QUECTEL_BG96_CellularStackE)
</UL>
<P><STRONG><a name="[171]"></a>mbed::AT_CellularStack::socket_connect(void*, const SocketAddress&)</STRONG> (Thumb, 38 bytes, Stack size 24 bytes, .\build\at_cellularstack.o(i._ZN4mbed16AT_CellularStack14socket_connectEPvRK13SocketAddress))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = mbed::AT_CellularStack::socket_connect(void*, const SocketAddress&)
</UL>
<BR>[Calls]<UL><LI><a href="#[249]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Address Reference Count : 2]<UL><LI> at_cellularstack.o(.constdata__ZTVN4mbed16AT_CellularStackE)
<LI> quectel_bg96_cellularstack.o(.constdata__ZTVN4mbed26QUECTEL_BG96_CellularStackE)
</UL>
<P><STRONG><a name="[175]"></a>mbed::AT_CellularStack::socket_recvfrom(void*, SocketAddress*, void*, unsigned)</STRONG> (Thumb, 102 bytes, Stack size 40 bytes, .\build\at_cellularstack.o(i._ZN4mbed16AT_CellularStack15socket_recvfromEPvP13SocketAddressS1_j))
<BR><BR>[Stack]<UL><LI>Max Depth = 696 + Unknown Stack Size
<LI>Call Chain = mbed::AT_CellularStack::socket_recvfrom(void*, SocketAddress*, void*, unsigned) &rArr; mbed::ATHandler::unlock() &rArr; int events::EventQueue::call&lang;mbed::Callback&lang;void()&rang;&rang;(T1) &rArr; equeue_post &rArr; equeue_tick &rArr; equeue_tick_init() &rArr; mbed::Ticker::attach_us(mbed::Callback&lang;void()&rang;, unsigned long long) &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[36e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::lock()
<LI><a href="#[381]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::unlock()
</UL>
<BR>[Address Reference Count : 2]<UL><LI> at_cellularstack.o(.constdata__ZTVN4mbed16AT_CellularStackE)
<LI> quectel_bg96_cellularstack.o(.constdata__ZTVN4mbed26QUECTEL_BG96_CellularStackE)
</UL>
<P><STRONG><a name="[385]"></a>mbed::AT_CellularStack::AT_CellularStack__sub_object(mbed::ATHandler&, int, nsapi_ip_stack)</STRONG> (Thumb, 58 bytes, Stack size 24 bytes, .\build\at_cellularstack.o(i._ZN4mbed16AT_CellularStackC2ERNS_9ATHandlerEi14nsapi_ip_stack))
<BR><BR>[Stack]<UL><LI>Max Depth = 28<LI>Call Chain = mbed::AT_CellularStack::AT_CellularStack__sub_object(mbed::ATHandler&, int, nsapi_ip_stack) &rArr; __aeabi_memclr4
</UL>
<BR>[Calls]<UL><LI><a href="#[378]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularBase::AT_CellularBase(mbed::ATHandler&)
<LI><a href="#[23c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memclr4
</UL>
<BR>[Called By]<UL><LI><a href="#[3db]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::QUECTEL_BG96_CellularStack::QUECTEL_BG96_CellularStack(mbed::ATHandler&, int, nsapi_ip_stack)
</UL>

<P><STRONG><a name="[15d]"></a>mbed::AT_CellularDevice::open_power(mbed::FileHandle*)</STRONG> (Thumb, 72 bytes, Stack size 24 bytes, .\build\at_cellulardevice.o(i._ZN4mbed17AT_CellularDevice10open_powerEPNS_10FileHandleE))
<BR><BR>[Stack]<UL><LI>Max Depth = 640 + Unknown Stack Size
<LI>Call Chain = mbed::AT_CellularDevice::open_power(mbed::FileHandle*) &rArr; mbed::AT_CellularDevice::get_at_handler(mbed::FileHandle*) &rArr; mbed::ATHandler::ATHandler(mbed::FileHandle*, events::EventQueue&, int, const char*) &rArr; rtos::Mutex::Mutex() &rArr; rtos::Mutex::constructor(const char*) &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[367]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;operator new(unsigned)
<LI><a href="#[37d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularPower::AT_CellularPower(mbed::ATHandler&)
<LI><a href="#[369]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularDevice::release_at_handler(mbed::ATHandler*)
<LI><a href="#[366]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularDevice::get_at_handler(mbed::FileHandle*)
</UL>
<BR>[Address Reference Count : 2]<UL><LI> at_cellulardevice.o(.constdata__ZTVN4mbed17AT_CellularDeviceE)
<LI> quectel_bg96.o(.constdata__ZTVN4mbed12QUECTEL_BG96E)
</UL>
<P><STRONG><a name="[161]"></a>mbed::AT_CellularDevice::close_power()</STRONG> (Thumb, 44 bytes, Stack size 16 bytes, .\build\at_cellulardevice.o(i._ZN4mbed17AT_CellularDevice11close_powerEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 128<LI>Call Chain = mbed::AT_CellularDevice::close_power() &rArr; mbed::AT_CellularDevice::release_at_handler(mbed::ATHandler*) &rArr; mbed::ATHandler::~ATHandler() &rArr; operator delete (void*) &rArr; free &rArr; _free_internal &rArr; _mutex_release &rArr; os_kernel_is_active &rArr; osKernelGetState &rArr; svcRtxKernelGetState
</UL>
<BR>[Calls]<UL><LI><a href="#[369]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularDevice::release_at_handler(mbed::ATHandler*)
<LI><a href="#[386]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularBase::get_at_handler()
</UL>
<BR>[Address Reference Count : 2]<UL><LI> at_cellulardevice.o(.constdata__ZTVN4mbed17AT_CellularDeviceE)
<LI> quectel_bg96.o(.constdata__ZTVN4mbed12QUECTEL_BG96E)
</UL>
<P><STRONG><a name="[162]"></a>mbed::AT_CellularDevice::set_timeout(int)</STRONG> (Thumb, 30 bytes, Stack size 16 bytes, .\build\at_cellulardevice.o(i._ZN4mbed17AT_CellularDevice11set_timeoutEi))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = mbed::AT_CellularDevice::set_timeout(int)
</UL>
<BR>[Calls]<UL><LI><a href="#[387]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::set_at_timeout(unsigned, bool)
</UL>
<BR>[Address Reference Count : 2]<UL><LI> at_cellulardevice.o(.constdata__ZTVN4mbed17AT_CellularDeviceE)
<LI> quectel_bg96.o(.constdata__ZTVN4mbed12QUECTEL_BG96E)
</UL>
<P><STRONG><a name="[177]"></a>mbed::AT_CellularDevice::open_network(mbed::FileHandle*)</STRONG> (Thumb, 72 bytes, Stack size 24 bytes, .\build\at_cellulardevice.o(i._ZN4mbed17AT_CellularDevice12open_networkEPNS_10FileHandleE))
<BR><BR>[Stack]<UL><LI>Max Depth = 640 + Unknown Stack Size
<LI>Call Chain = mbed::AT_CellularDevice::open_network(mbed::FileHandle*) &rArr; mbed::AT_CellularDevice::get_at_handler(mbed::FileHandle*) &rArr; mbed::ATHandler::ATHandler(mbed::FileHandle*, events::EventQueue&, int, const char*) &rArr; rtos::Mutex::Mutex() &rArr; rtos::Mutex::constructor(const char*) &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[367]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;operator new(unsigned)
<LI><a href="#[388]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::AT_CellularNetwork(mbed::ATHandler&)
<LI><a href="#[369]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularDevice::release_at_handler(mbed::ATHandler*)
<LI><a href="#[366]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularDevice::get_at_handler(mbed::FileHandle*)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> at_cellulardevice.o(.constdata__ZTVN4mbed17AT_CellularDeviceE)
</UL>
<P><STRONG><a name="[160]"></a>mbed::AT_CellularDevice::close_network()</STRONG> (Thumb, 44 bytes, Stack size 16 bytes, .\build\at_cellulardevice.o(i._ZN4mbed17AT_CellularDevice13close_networkEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 128<LI>Call Chain = mbed::AT_CellularDevice::close_network() &rArr; mbed::AT_CellularDevice::release_at_handler(mbed::ATHandler*) &rArr; mbed::ATHandler::~ATHandler() &rArr; operator delete (void*) &rArr; free &rArr; _free_internal &rArr; _mutex_release &rArr; os_kernel_is_active &rArr; osKernelGetState &rArr; svcRtxKernelGetState
</UL>
<BR>[Calls]<UL><LI><a href="#[369]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularDevice::release_at_handler(mbed::ATHandler*)
<LI><a href="#[386]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularBase::get_at_handler()
</UL>
<BR>[Address Reference Count : 2]<UL><LI> at_cellulardevice.o(.constdata__ZTVN4mbed17AT_CellularDeviceE)
<LI> quectel_bg96.o(.constdata__ZTVN4mbed12QUECTEL_BG96E)
</UL>
<P><STRONG><a name="[366]"></a>mbed::AT_CellularDevice::get_at_handler(mbed::FileHandle*)</STRONG> (Thumb, 104 bytes, Stack size 24 bytes, .\build\at_cellulardevice.o(i._ZN4mbed17AT_CellularDevice14get_at_handlerEPNS_10FileHandleE))
<BR><BR>[Stack]<UL><LI>Max Depth = 616 + Unknown Stack Size
<LI>Call Chain = mbed::AT_CellularDevice::get_at_handler(mbed::FileHandle*) &rArr; mbed::ATHandler::ATHandler(mbed::FileHandle*, events::EventQueue&, int, const char*) &rArr; rtos::Mutex::Mutex() &rArr; rtos::Mutex::constructor(const char*) &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[367]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;operator new(unsigned)
<LI><a href="#[38b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::ATHandler(mbed::FileHandle*, events::EventQueue&, int, const char*)
<LI><a href="#[389]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::get_file_handle()
<LI><a href="#[38a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::inc_ref_count()
<LI><a href="#[38c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::enable_debug(bool)
</UL>
<BR>[Called By]<UL><LI><a href="#[15e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularDevice::open_sim(mbed::FileHandle*)
<LI><a href="#[15f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularDevice::open_information(mbed::FileHandle*)
<LI><a href="#[177]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularDevice::open_network(mbed::FileHandle*)
<LI><a href="#[15d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularDevice::open_power(mbed::FileHandle*)
<LI><a href="#[15c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::QUECTEL_BG96::open_network(mbed::FileHandle*)
</UL>

<P><STRONG><a name="[163]"></a>mbed::AT_CellularDevice::modem_debug_on(bool)</STRONG> (Thumb, 32 bytes, Stack size 16 bytes, .\build\at_cellulardevice.o(i._ZN4mbed17AT_CellularDevice14modem_debug_onEb))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = mbed::AT_CellularDevice::modem_debug_on(bool)
</UL>
<BR>[Calls]<UL><LI><a href="#[38c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::enable_debug(bool)
</UL>
<BR>[Address Reference Count : 2]<UL><LI> at_cellulardevice.o(.constdata__ZTVN4mbed17AT_CellularDeviceE)
<LI> quectel_bg96.o(.constdata__ZTVN4mbed12QUECTEL_BG96E)
</UL>
<P><STRONG><a name="[15f]"></a>mbed::AT_CellularDevice::open_information(mbed::FileHandle*)</STRONG> (Thumb, 72 bytes, Stack size 24 bytes, .\build\at_cellulardevice.o(i._ZN4mbed17AT_CellularDevice16open_informationEPNS_10FileHandleE))
<BR><BR>[Stack]<UL><LI>Max Depth = 640 + Unknown Stack Size
<LI>Call Chain = mbed::AT_CellularDevice::open_information(mbed::FileHandle*) &rArr; mbed::AT_CellularDevice::get_at_handler(mbed::FileHandle*) &rArr; mbed::ATHandler::ATHandler(mbed::FileHandle*, events::EventQueue&, int, const char*) &rArr; rtos::Mutex::Mutex() &rArr; rtos::Mutex::constructor(const char*) &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[367]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;operator new(unsigned)
<LI><a href="#[38d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularInformation::AT_CellularInformation(mbed::ATHandler&)
<LI><a href="#[369]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularDevice::release_at_handler(mbed::ATHandler*)
<LI><a href="#[366]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularDevice::get_at_handler(mbed::FileHandle*)
</UL>
<BR>[Address Reference Count : 2]<UL><LI> at_cellulardevice.o(.constdata__ZTVN4mbed17AT_CellularDeviceE)
<LI> quectel_bg96.o(.constdata__ZTVN4mbed12QUECTEL_BG96E)
</UL>
<P><STRONG><a name="[369]"></a>mbed::AT_CellularDevice::release_at_handler(mbed::ATHandler*)</STRONG> (Thumb, 86 bytes, Stack size 24 bytes, .\build\at_cellulardevice.o(i._ZN4mbed17AT_CellularDevice18release_at_handlerEPNS_9ATHandlerE))
<BR><BR>[Stack]<UL><LI>Max Depth = 112<LI>Call Chain = mbed::AT_CellularDevice::release_at_handler(mbed::ATHandler*) &rArr; mbed::ATHandler::~ATHandler() &rArr; operator delete (void*) &rArr; free &rArr; _free_internal &rArr; _mutex_release &rArr; os_kernel_is_active &rArr; osKernelGetState &rArr; svcRtxKernelGetState
</UL>
<BR>[Calls]<UL><LI><a href="#[37e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;operator delete (void*)
<LI><a href="#[390]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::~ATHandler()
<LI><a href="#[38f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::get_ref_count()
<LI><a href="#[38e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::dec_ref_count()
</UL>
<BR>[Called By]<UL><LI><a href="#[15e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularDevice::open_sim(mbed::FileHandle*)
<LI><a href="#[15f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularDevice::open_information(mbed::FileHandle*)
<LI><a href="#[160]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularDevice::close_network()
<LI><a href="#[177]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularDevice::open_network(mbed::FileHandle*)
<LI><a href="#[161]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularDevice::close_power()
<LI><a href="#[15d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularDevice::open_power(mbed::FileHandle*)
<LI><a href="#[15c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::QUECTEL_BG96::open_network(mbed::FileHandle*)
</UL>

<P><STRONG><a name="[15e]"></a>mbed::AT_CellularDevice::open_sim(mbed::FileHandle*)</STRONG> (Thumb, 72 bytes, Stack size 24 bytes, .\build\at_cellulardevice.o(i._ZN4mbed17AT_CellularDevice8open_simEPNS_10FileHandleE))
<BR><BR>[Stack]<UL><LI>Max Depth = 640 + Unknown Stack Size
<LI>Call Chain = mbed::AT_CellularDevice::open_sim(mbed::FileHandle*) &rArr; mbed::AT_CellularDevice::get_at_handler(mbed::FileHandle*) &rArr; mbed::ATHandler::ATHandler(mbed::FileHandle*, events::EventQueue&, int, const char*) &rArr; rtos::Mutex::Mutex() &rArr; rtos::Mutex::constructor(const char*) &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[367]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;operator new(unsigned)
<LI><a href="#[377]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularSIM::AT_CellularSIM(mbed::ATHandler&)
<LI><a href="#[369]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularDevice::release_at_handler(mbed::ATHandler*)
<LI><a href="#[366]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularDevice::get_at_handler(mbed::FileHandle*)
</UL>
<BR>[Address Reference Count : 2]<UL><LI> at_cellulardevice.o(.constdata__ZTVN4mbed17AT_CellularDeviceE)
<LI> quectel_bg96.o(.constdata__ZTVN4mbed12QUECTEL_BG96E)
</UL>
<P><STRONG><a name="[164]"></a>mbed::AT_CellularDevice::get_stack()</STRONG> (Thumb, 22 bytes, Stack size 8 bytes, .\build\at_cellulardevice.o(i._ZN4mbed17AT_CellularDevice9get_stackEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = mbed::AT_CellularDevice::get_stack()
</UL>
<BR>[Address Reference Count : 2]<UL><LI> at_cellulardevice.o(.constdata__ZTVN4mbed17AT_CellularDeviceE)
<LI> quectel_bg96.o(.constdata__ZTVN4mbed12QUECTEL_BG96E)
</UL>
<P><STRONG><a name="[36b]"></a>mbed::AT_CellularDevice::AT_CellularDevice(events::EventQueue&)</STRONG> (Thumb, 36 bytes, Stack size 0 bytes, .\build\at_cellulardevice.o(i._ZN4mbed17AT_CellularDeviceC1ERN6events10EventQueueE))
<BR><BR>[Called By]<UL><LI><a href="#[36a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::QUECTEL_BG96::QUECTEL_BG96(events::EventQueue&)
</UL>

<P><STRONG><a name="[75e]"></a>mbed::AT_CellularDevice::AT_CellularDevice__sub_object(events::EventQueue&)</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, .\build\at_cellulardevice.o(i._ZN4mbed17AT_CellularDeviceC1ERN6events10EventQueueE), UNUSED)

<P><STRONG><a name="[391]"></a>mbed::nsapi_ppp_connect(mbed::FileHandle*, mbed::Callback&lang;void(nsapi_event, int)&rang;, const char*, const char*, nsapi_ip_stack)</STRONG> (Thumb, 150 bytes, Stack size 64 bytes, .\build\ppp_lwip.o(i._ZN4mbed17nsapi_ppp_connectEPNS_10FileHandleENS_8CallbackIFv11nsapi_eventiEEEPKcS7_14nsapi_ip_stack))
<BR><BR>[Stack]<UL><LI>Max Depth = 1344 + Unknown Stack Size
<LI>Call Chain = mbed::nsapi_ppp_connect(mbed::FileHandle*, mbed::Callback&lang;void(nsapi_event, int)&rang;, const char*, const char*, nsapi_ip_stack) &rArr; mbed_lwip_bringup_2 &rArr; ppp_lwip_if_init &rArr; pppos_create &rArr; ppp_new &rArr; netif_add &rArr; netif_set_addr &rArr; netif_set_ipaddr &rArr; tcp_netif_ip_addr_changed &rArr; tcp_netif_ip_addr_changed_pcblist &rArr; tcp_abort &rArr; tcp_abandon &rArr; tcp_pcb_remove &rArr; tcp_output &rArr; tcp_output_segment &rArr; ip4_output_if &rArr; ip4_output_if_opt &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[58]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void(nsapi_event, int)&rang;::~Callback()
<LI><a href="#[392]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_bringup_2
</UL>
<BR>[Called By]<UL><LI><a href="#[39d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::open_data_channel()
</UL>

<P><STRONG><a name="[393]"></a>mbed::remove_filehandle(mbed::FileHandle*)</STRONG> (Thumb, 62 bytes, Stack size 16 bytes, .\build\mbed_retarget.o(i._ZN4mbed17remove_filehandleEPNS_10FileHandleE))
<BR><BR>[Stack]<UL><LI>Max Depth = 608 + Unknown Stack Size
<LI>Call Chain = mbed::remove_filehandle(mbed::FileHandle*) &rArr; SingletonPtr&lang;rtos::Mutex&rang;::operator -&rang;() &rArr; SingletonPtr&lang;rtos::Mutex&rang;::get() &rArr; rtos::Mutex::Mutex() &rArr; rtos::Mutex::constructor(const char*) &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[2e9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Mutex::unlock()
<LI><a href="#[2e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Mutex::lock(unsigned)
<LI><a href="#[31a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SingletonPtr&lang;rtos::Mutex&rang;::operator -&rang;()
</UL>
<BR>[Called By]<UL><LI><a href="#[1aa]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::FileBase::~FileBase()
</UL>

<P><STRONG><a name="[180]"></a>mbed::AT_CellularNetwork::get_attach(mbed::CellularNetwork::AttachStatus&)</STRONG> (Thumb, 78 bytes, Stack size 16 bytes, .\build\at_cellularnetwork.o(i._ZN4mbed18AT_CellularNetwork10get_attachERNS_15CellularNetwork12AttachStatusE))
<BR><BR>[Stack]<UL><LI>Max Depth = 712 + Unknown Stack Size
<LI>Call Chain = mbed::AT_CellularNetwork::get_attach(mbed::CellularNetwork::AttachStatus&) &rArr; mbed::ATHandler::resp_start(const char*, bool) &rArr; mbed::ATHandler::resp(const char*, bool) &rArr; mbed::ATHandler::match_error() &rArr; mbed::ATHandler::at_error(bool, mbed::DeviceErrorType) &rArr; mbed::ATHandler::read_int() &rArr; mbed::ATHandler::read_string(char*, unsigned, bool) &rArr; mbed::ATHandler::consume_char(char) &rArr; mbed::ATHandler::get_char() &rArr; mbed::ATHandler::fill_buffer() &rArr; mbed::Timer::~Timer() &rArr; sleep_manager_unlock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[374]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::resp_stop()
<LI><a href="#[370]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::cmd_start(const char*)
<LI><a href="#[371]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::cmd_stop()
<LI><a href="#[36e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::lock()
<LI><a href="#[375]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::unlock_return_error()
<LI><a href="#[372]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::resp_start(const char*, bool)
<LI><a href="#[383]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::info_resp()
<LI><a href="#[394]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::read_int()
</UL>
<BR>[Address Reference Count : 2]<UL><LI> at_cellularnetwork.o(.constdata__ZTVN4mbed18AT_CellularNetworkE)
<LI> quectel_bg96_cellularnetwork.o(.constdata__ZTVN4mbed28QUECTEL_BG96_CellularNetworkE)
</UL>
<P><STRONG><a name="[17f]"></a>mbed::AT_CellularNetwork::set_attach(int)</STRONG> (Thumb, 92 bytes, Stack size 16 bytes, .\build\at_cellularnetwork.o(i._ZN4mbed18AT_CellularNetwork10set_attachEi))
<BR><BR>[Stack]<UL><LI>Max Depth = 712 + Unknown Stack Size
<LI>Call Chain = mbed::AT_CellularNetwork::set_attach(int) &rArr; mbed::ATHandler::resp_start(const char*, bool) &rArr; mbed::ATHandler::resp(const char*, bool) &rArr; mbed::ATHandler::match_error() &rArr; mbed::ATHandler::at_error(bool, mbed::DeviceErrorType) &rArr; mbed::ATHandler::read_int() &rArr; mbed::ATHandler::read_string(char*, unsigned, bool) &rArr; mbed::ATHandler::consume_char(char) &rArr; mbed::ATHandler::get_char() &rArr; mbed::ATHandler::fill_buffer() &rArr; mbed::Timer::~Timer() &rArr; sleep_manager_unlock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[374]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::resp_stop()
<LI><a href="#[370]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::cmd_start(const char*)
<LI><a href="#[371]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::cmd_stop()
<LI><a href="#[36e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::lock()
<LI><a href="#[375]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::unlock_return_error()
<LI><a href="#[372]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::resp_start(const char*, bool)
<LI><a href="#[394]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::read_int()
</UL>
<BR>[Address Reference Count : 2]<UL><LI> at_cellularnetwork.o(.constdata__ZTVN4mbed18AT_CellularNetworkE)
<LI> quectel_bg96_cellularnetwork.o(.constdata__ZTVN4mbed28QUECTEL_BG96_CellularNetworkE)
</UL>
<P><STRONG><a name="[395]"></a>mbed::AT_CellularNetwork::get_context()</STRONG> (Thumb, 368 bytes, Stack size 152 bytes, .\build\at_cellularnetwork.o(i._ZN4mbed18AT_CellularNetwork11get_contextEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 888 + Unknown Stack Size
<LI>Call Chain = mbed::AT_CellularNetwork::get_context() &rArr; mbed::AT_CellularNetwork::set_new_context(int) &rArr; mbed::ATHandler::resp_start(const char*, bool) &rArr; mbed::ATHandler::resp(const char*, bool) &rArr; mbed::ATHandler::match_error() &rArr; mbed::ATHandler::at_error(bool, mbed::DeviceErrorType) &rArr; mbed::ATHandler::read_int() &rArr; mbed::ATHandler::read_string(char*, unsigned, bool) &rArr; mbed::ATHandler::consume_char(char) &rArr; mbed::ATHandler::get_char() &rArr; mbed::ATHandler::fill_buffer() &rArr; mbed::Timer::~Timer() &rArr; sleep_manager_unlock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[374]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::resp_stop()
<LI><a href="#[370]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::cmd_start(const char*)
<LI><a href="#[371]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::cmd_stop()
<LI><a href="#[373]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::read_string(char*, unsigned, bool)
<LI><a href="#[372]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::resp_start(const char*, bool)
<LI><a href="#[383]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::info_resp()
<LI><a href="#[394]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::read_int()
<LI><a href="#[397]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::string_to_stack_type(const char*)
<LI><a href="#[398]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::set_new_context(int)
<LI><a href="#[396]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;strcmp
<LI><a href="#[249]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
<LI><a href="#[21d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;malloc
</UL>
<BR>[Called By]<UL><LI><a href="#[3a1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::set_context_to_be_activated()
</UL>

<P><STRONG><a name="[c4]"></a>mbed::AT_CellularNetwork::ppp_status_cb(nsapi_event, int)</STRONG> (Thumb, 36 bytes, Stack size 16 bytes, .\build\at_cellularnetwork.o(i._ZN4mbed18AT_CellularNetwork13ppp_status_cbE11nsapi_eventi))
<BR><BR>[Stack]<UL><LI>Max Depth = 576 + Unknown Stack Size
<LI>Call Chain = mbed::AT_CellularNetwork::ppp_status_cb(nsapi_event, int) &rArr; mbed::Callback&lang;void(nsapi_event, int)&rang;::operator ()(nsapi_event, int) const &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[37a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void(nsapi_event, int)&rang;::operator bool() const
<LI><a href="#[37b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void(nsapi_event, int)&rang;::operator ()(nsapi_event, int) const
</UL>
<BR>[Address Reference Count : 1]<UL><LI> at_cellularnetwork.o(.constdata)
</UL>
<P><STRONG><a name="[c5]"></a>mbed::AT_CellularNetwork::urc_no_carrier()</STRONG> (Thumb, 32 bytes, Stack size 8 bytes, .\build\at_cellularnetwork.o(i._ZN4mbed18AT_CellularNetwork14urc_no_carrierEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 568 + Unknown Stack Size
<LI>Call Chain = mbed::AT_CellularNetwork::urc_no_carrier() &rArr; mbed::Callback&lang;void(nsapi_event, int)&rang;::operator ()(nsapi_event, int) const &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[37a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void(nsapi_event, int)&rang;::operator bool() const
<LI><a href="#[37b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void(nsapi_event, int)&rang;::operator ()(nsapi_event, int) const
</UL>
<BR>[Address Reference Count : 1]<UL><LI> at_cellularnetwork.o(.constdata)
</UL>
<P><STRONG><a name="[17e]"></a>mbed::AT_CellularNetwork::set_credentials(const char*, const char*, const char*)</STRONG> (Thumb, 142 bytes, Stack size 24 bytes, .\build\at_cellularnetwork.o(i._ZN4mbed18AT_CellularNetwork15set_credentialsEPKcS2_S2_))
<BR><BR>[Stack]<UL><LI>Max Depth = 128<LI>Call Chain = mbed::AT_CellularNetwork::set_credentials(const char*, const char*, const char*) &rArr; malloc &rArr; _malloc_internal &rArr; __Heap_Full &rArr; __Heap_ProvideMemory &rArr; _free_internal &rArr; _mutex_release &rArr; os_kernel_is_active &rArr; osKernelGetState &rArr; svcRtxKernelGetState
</UL>
<BR>[Calls]<UL><LI><a href="#[249]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
<LI><a href="#[31d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;strlen
<LI><a href="#[21d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;malloc
</UL>
<BR>[Address Reference Count : 2]<UL><LI> at_cellularnetwork.o(.constdata__ZTVN4mbed18AT_CellularNetworkE)
<LI> quectel_bg96_cellularnetwork.o(.constdata__ZTVN4mbed28QUECTEL_BG96_CellularNetworkE)
</UL>
<P><STRONG><a name="[398]"></a>mbed::AT_CellularNetwork::set_new_context(int)</STRONG> (Thumb, 316 bytes, Stack size 40 bytes, .\build\at_cellularnetwork.o(i._ZN4mbed18AT_CellularNetwork15set_new_contextEi))
<BR><BR>[Stack]<UL><LI>Max Depth = 736 + Unknown Stack Size
<LI>Call Chain = mbed::AT_CellularNetwork::set_new_context(int) &rArr; mbed::ATHandler::resp_start(const char*, bool) &rArr; mbed::ATHandler::resp(const char*, bool) &rArr; mbed::ATHandler::match_error() &rArr; mbed::ATHandler::at_error(bool, mbed::DeviceErrorType) &rArr; mbed::ATHandler::read_int() &rArr; mbed::ATHandler::read_string(char*, unsigned, bool) &rArr; mbed::ATHandler::consume_char(char) &rArr; mbed::ATHandler::get_char() &rArr; mbed::ATHandler::fill_buffer() &rArr; mbed::Timer::~Timer() &rArr; sleep_manager_unlock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[374]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::resp_stop()
<LI><a href="#[370]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::cmd_start(const char*)
<LI><a href="#[371]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::cmd_stop()
<LI><a href="#[372]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::resp_start(const char*, bool)
<LI><a href="#[399]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::get_last_error() const
<LI><a href="#[382]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::write_int(int)
<LI><a href="#[376]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::write_string(const char*, bool)
<LI><a href="#[24d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;strncpy
</UL>
<BR>[Called By]<UL><LI><a href="#[395]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::get_context()
</UL>

<P><STRONG><a name="[39a]"></a>mbed::AT_CellularNetwork::free_credentials()</STRONG> (Thumb, 36 bytes, Stack size 8 bytes, .\build\at_cellularnetwork.o(i._ZN4mbed18AT_CellularNetwork16free_credentialsEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 64<LI>Call Chain = mbed::AT_CellularNetwork::free_credentials() &rArr; free &rArr; _free_internal &rArr; _mutex_release &rArr; os_kernel_is_active &rArr; osKernelGetState &rArr; svcRtxKernelGetState
</UL>
<BR>[Calls]<UL><LI><a href="#[220]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;free
</UL>
<BR>[Called By]<UL><LI><a href="#[178]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::~AT_CellularNetwork()
</UL>

<P><STRONG><a name="[182]"></a>mbed::AT_CellularNetwork::has_registration(mbed::CellularNetwork::RegistrationType)</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, .\build\at_cellularnetwork.o(i._ZN4mbed18AT_CellularNetwork16has_registrationENS_15CellularNetwork16RegistrationTypeE))
<BR>[Address Reference Count : 2]<UL><LI> at_cellularnetwork.o(.constdata__ZTVN4mbed18AT_CellularNetworkE)
<LI> quectel_bg96_cellularnetwork.o(.constdata__ZTVN4mbed28QUECTEL_BG96_CellularNetworkE)
</UL>
<P><STRONG><a name="[17c]"></a>mbed::AT_CellularNetwork::set_registration(const char*)</STRONG> (Thumb, 164 bytes, Stack size 24 bytes, .\build\at_cellularnetwork.o(i._ZN4mbed18AT_CellularNetwork16set_registrationEPKc))
<BR><BR>[Stack]<UL><LI>Max Depth = 736 + Unknown Stack Size
<LI>Call Chain = mbed::AT_CellularNetwork::set_registration(const char*) &rArr; mbed::AT_CellularNetwork::set_registration_urc(bool) &rArr; mbed::ATHandler::resp_start(const char*, bool) &rArr; mbed::ATHandler::resp(const char*, bool) &rArr; mbed::ATHandler::match_error() &rArr; mbed::ATHandler::at_error(bool, mbed::DeviceErrorType) &rArr; mbed::ATHandler::read_int() &rArr; mbed::ATHandler::read_string(char*, unsigned, bool) &rArr; mbed::ATHandler::consume_char(char) &rArr; mbed::ATHandler::get_char() &rArr; mbed::ATHandler::fill_buffer() &rArr; mbed::Timer::~Timer() &rArr; sleep_manager_unlock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[374]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::resp_stop()
<LI><a href="#[370]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::cmd_start(const char*)
<LI><a href="#[371]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::cmd_stop()
<LI><a href="#[36e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::lock()
<LI><a href="#[375]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::unlock_return_error()
<LI><a href="#[372]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::resp_start(const char*, bool)
<LI><a href="#[394]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::read_int()
<LI><a href="#[376]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::write_string(const char*, bool)
<LI><a href="#[39c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::clear_error()
<LI><a href="#[39b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::set_registration_urc(bool)
</UL>
<BR>[Address Reference Count : 2]<UL><LI> at_cellularnetwork.o(.constdata__ZTVN4mbed18AT_CellularNetworkE)
<LI> quectel_bg96_cellularnetwork.o(.constdata__ZTVN4mbed28QUECTEL_BG96_CellularNetworkE)
</UL>
<P><STRONG><a name="[39d]"></a>mbed::AT_CellularNetwork::open_data_channel()</STRONG> (Thumb, 102 bytes, Stack size 40 bytes, .\build\at_cellularnetwork.o(i._ZN4mbed18AT_CellularNetwork17open_data_channelEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 1384 + Unknown Stack Size
<LI>Call Chain = mbed::AT_CellularNetwork::open_data_channel() &rArr; mbed::nsapi_ppp_connect(mbed::FileHandle*, mbed::Callback&lang;void(nsapi_event, int)&rang;, const char*, const char*, nsapi_ip_stack) &rArr; mbed_lwip_bringup_2 &rArr; ppp_lwip_if_init &rArr; pppos_create &rArr; ppp_new &rArr; netif_add &rArr; netif_set_addr &rArr; netif_set_ipaddr &rArr; tcp_netif_ip_addr_changed &rArr; tcp_netif_ip_addr_changed_pcblist &rArr; tcp_abort &rArr; tcp_abandon &rArr; tcp_pcb_remove &rArr; tcp_output &rArr; tcp_output_segment &rArr; ip4_output_if &rArr; ip4_output_if_opt &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[389]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::get_file_handle()
<LI><a href="#[370]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::cmd_start(const char*)
<LI><a href="#[371]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::cmd_stop()
<LI><a href="#[372]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::resp_start(const char*, bool)
<LI><a href="#[39e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;T3(T4, T5)&rang; mbed::callback&lang;mbed::AT_CellularNetwork, mbed::AT_CellularNetwork, void, nsapi_event, int&rang;(T2*, T3(T1::*)(T4, T5))
<LI><a href="#[58]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void(nsapi_event, int)&rang;::~Callback()
<LI><a href="#[399]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::get_last_error() const
<LI><a href="#[382]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::write_int(int)
<LI><a href="#[391]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::nsapi_ppp_connect(mbed::FileHandle*, mbed::Callback&lang;void(nsapi_event, int)&rang;, const char*, const char*, nsapi_ip_stack)
</UL>
<BR>[Called By]<UL><LI><a href="#[17a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::connect()
</UL>

<P><STRONG><a name="[181]"></a>mbed::AT_CellularNetwork::get_modem_stack_type(nsapi_ip_stack)</STRONG> (Thumb, 16 bytes, Stack size 0 bytes, .\build\at_cellularnetwork.o(i._ZN4mbed18AT_CellularNetwork20get_modem_stack_typeE14nsapi_ip_stack))
<BR>[Address Reference Count : 1]<UL><LI> at_cellularnetwork.o(.constdata__ZTVN4mbed18AT_CellularNetworkE)
</UL>
<P><STRONG><a name="[39b]"></a>mbed::AT_CellularNetwork::set_registration_urc(bool)</STRONG> (Thumb, 134 bytes, Stack size 16 bytes, .\build\at_cellularnetwork.o(i._ZN4mbed18AT_CellularNetwork20set_registration_urcEb))
<BR><BR>[Stack]<UL><LI>Max Depth = 712 + Unknown Stack Size
<LI>Call Chain = mbed::AT_CellularNetwork::set_registration_urc(bool) &rArr; mbed::ATHandler::resp_start(const char*, bool) &rArr; mbed::ATHandler::resp(const char*, bool) &rArr; mbed::ATHandler::match_error() &rArr; mbed::ATHandler::at_error(bool, mbed::DeviceErrorType) &rArr; mbed::ATHandler::read_int() &rArr; mbed::ATHandler::read_string(char*, unsigned, bool) &rArr; mbed::ATHandler::consume_char(char) &rArr; mbed::ATHandler::get_char() &rArr; mbed::ATHandler::fill_buffer() &rArr; mbed::Timer::~Timer() &rArr; sleep_manager_unlock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[374]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::resp_stop()
<LI><a href="#[370]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::cmd_start(const char*)
<LI><a href="#[371]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::cmd_stop()
<LI><a href="#[372]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::resp_start(const char*, bool)
<LI><a href="#[399]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::get_last_error() const
<LI><a href="#[376]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::write_string(const char*, bool)
</UL>
<BR>[Called By]<UL><LI><a href="#[17c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::set_registration(const char*)
</UL>

<P><STRONG><a name="[397]"></a>mbed::AT_CellularNetwork::string_to_stack_type(const char*)</STRONG> (Thumb, 82 bytes, Stack size 24 bytes, .\build\at_cellularnetwork.o(i._ZN4mbed18AT_CellularNetwork20string_to_stack_typeEPKc))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = mbed::AT_CellularNetwork::string_to_stack_type(const char*) &rArr; strlen
</UL>
<BR>[Calls]<UL><LI><a href="#[31d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;strlen
<LI><a href="#[323]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memcmp
</UL>
<BR>[Called By]<UL><LI><a href="#[395]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::get_context()
</UL>

<P><STRONG><a name="[39f]"></a>mbed::AT_CellularNetwork::delete_current_context()</STRONG> (Thumb, 76 bytes, Stack size 8 bytes, .\build\at_cellularnetwork.o(i._ZN4mbed18AT_CellularNetwork22delete_current_contextEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 704 + Unknown Stack Size
<LI>Call Chain = mbed::AT_CellularNetwork::delete_current_context() &rArr; mbed::ATHandler::resp_start(const char*, bool) &rArr; mbed::ATHandler::resp(const char*, bool) &rArr; mbed::ATHandler::match_error() &rArr; mbed::ATHandler::at_error(bool, mbed::DeviceErrorType) &rArr; mbed::ATHandler::read_int() &rArr; mbed::ATHandler::read_string(char*, unsigned, bool) &rArr; mbed::ATHandler::consume_char(char) &rArr; mbed::ATHandler::get_char() &rArr; mbed::ATHandler::fill_buffer() &rArr; mbed::Timer::~Timer() &rArr; sleep_manager_unlock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[374]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::resp_stop()
<LI><a href="#[370]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::cmd_start(const char*)
<LI><a href="#[371]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::cmd_stop()
<LI><a href="#[372]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::resp_start(const char*, bool)
<LI><a href="#[399]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::get_last_error() const
<LI><a href="#[382]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::write_int(int)
<LI><a href="#[39c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::clear_error()
</UL>
<BR>[Called By]<UL><LI><a href="#[17a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::connect()
</UL>

<P><STRONG><a name="[17d]"></a>mbed::AT_CellularNetwork::get_registration_status(mbed::CellularNetwork::RegistrationType, mbed::CellularNetwork::RegistrationStatus&)</STRONG> (Thumb, 400 bytes, Stack size 80 bytes, .\build\at_cellularnetwork.o(i._ZN4mbed18AT_CellularNetwork23get_registration_statusENS_15CellularNetwork16RegistrationTypeERNS1_18RegistrationStatusE))
<BR><BR>[Stack]<UL><LI>Max Depth = 776 + Unknown Stack Size
<LI>Call Chain = mbed::AT_CellularNetwork::get_registration_status(mbed::CellularNetwork::RegistrationType, mbed::CellularNetwork::RegistrationStatus&) &rArr; mbed::ATHandler::resp_start(const char*, bool) &rArr; mbed::ATHandler::resp(const char*, bool) &rArr; mbed::ATHandler::match_error() &rArr; mbed::ATHandler::at_error(bool, mbed::DeviceErrorType) &rArr; mbed::ATHandler::read_int() &rArr; mbed::ATHandler::read_string(char*, unsigned, bool) &rArr; mbed::ATHandler::consume_char(char) &rArr; mbed::ATHandler::get_char() &rArr; mbed::ATHandler::fill_buffer() &rArr; mbed::Timer::~Timer() &rArr; sleep_manager_unlock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[33a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_assert_internal
<LI><a href="#[374]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::resp_stop()
<LI><a href="#[370]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::cmd_start(const char*)
<LI><a href="#[371]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::cmd_stop()
<LI><a href="#[36e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::lock()
<LI><a href="#[373]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::read_string(char*, unsigned, bool)
<LI><a href="#[372]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::resp_start(const char*, bool)
<LI><a href="#[399]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::get_last_error() const
<LI><a href="#[394]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::read_int()
<LI><a href="#[381]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::unlock()
<LI><a href="#[376]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::write_string(const char*, bool)
<LI><a href="#[3a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_cellular_util::hex_str_to_int(const char*, int)
<LI><a href="#[323]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memcmp
</UL>
<BR>[Address Reference Count : 2]<UL><LI> at_cellularnetwork.o(.constdata__ZTVN4mbed18AT_CellularNetworkE)
<LI> quectel_bg96_cellularnetwork.o(.constdata__ZTVN4mbed28QUECTEL_BG96_CellularNetworkE)
</UL>
<P><STRONG><a name="[3a1]"></a>mbed::AT_CellularNetwork::set_context_to_be_activated()</STRONG> (Thumb, 118 bytes, Stack size 8 bytes, .\build\at_cellularnetwork.o(i._ZN4mbed18AT_CellularNetwork27set_context_to_be_activatedEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 896 + Unknown Stack Size
<LI>Call Chain = mbed::AT_CellularNetwork::set_context_to_be_activated() &rArr; mbed::AT_CellularNetwork::get_context() &rArr; mbed::AT_CellularNetwork::set_new_context(int) &rArr; mbed::ATHandler::resp_start(const char*, bool) &rArr; mbed::ATHandler::resp(const char*, bool) &rArr; mbed::ATHandler::match_error() &rArr; mbed::ATHandler::at_error(bool, mbed::DeviceErrorType) &rArr; mbed::ATHandler::read_int() &rArr; mbed::ATHandler::read_string(char*, unsigned, bool) &rArr; mbed::ATHandler::consume_char(char) &rArr; mbed::ATHandler::get_char() &rArr; mbed::ATHandler::fill_buffer() &rArr; mbed::Timer::~Timer() &rArr; sleep_manager_unlock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[374]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::resp_stop()
<LI><a href="#[370]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::cmd_start(const char*)
<LI><a href="#[371]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::cmd_stop()
<LI><a href="#[372]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::resp_start(const char*, bool)
<LI><a href="#[399]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::get_last_error() const
<LI><a href="#[382]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::write_int(int)
<LI><a href="#[376]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::write_string(const char*, bool)
<LI><a href="#[395]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::get_context()
</UL>
<BR>[Called By]<UL><LI><a href="#[17a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::connect()
</UL>

<P><STRONG><a name="[17a]"></a>mbed::AT_CellularNetwork::connect()</STRONG> (Thumb, 150 bytes, Stack size 16 bytes, .\build\at_cellularnetwork.o(i._ZN4mbed18AT_CellularNetwork7connectEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 1400 + Unknown Stack Size
<LI>Call Chain = mbed::AT_CellularNetwork::connect() &rArr; mbed::AT_CellularNetwork::open_data_channel() &rArr; mbed::nsapi_ppp_connect(mbed::FileHandle*, mbed::Callback&lang;void(nsapi_event, int)&rang;, const char*, const char*, nsapi_ip_stack) &rArr; mbed_lwip_bringup_2 &rArr; ppp_lwip_if_init &rArr; pppos_create &rArr; ppp_new &rArr; netif_add &rArr; netif_set_addr &rArr; netif_set_ipaddr &rArr; tcp_netif_ip_addr_changed &rArr; tcp_netif_ip_addr_changed_pcblist &rArr; tcp_abort &rArr; tcp_abandon &rArr; tcp_pcb_remove &rArr; tcp_output &rArr; tcp_output_segment &rArr; ip4_output_if &rArr; ip4_output_if_opt &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[36e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::lock()
<LI><a href="#[37a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void(nsapi_event, int)&rang;::operator bool() const
<LI><a href="#[37b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void(nsapi_event, int)&rang;::operator ()(nsapi_event, int) const
<LI><a href="#[381]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::unlock()
<LI><a href="#[3a1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::set_context_to_be_activated()
<LI><a href="#[39f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::delete_current_context()
<LI><a href="#[39d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::open_data_channel()
</UL>
<BR>[Address Reference Count : 2]<UL><LI> at_cellularnetwork.o(.constdata__ZTVN4mbed18AT_CellularNetworkE)
<LI> quectel_bg96_cellularnetwork.o(.constdata__ZTVN4mbed28QUECTEL_BG96_CellularNetworkE)
</UL>
<P><STRONG><a name="[17b]"></a>mbed::AT_CellularNetwork::get_stack()</STRONG> (Thumb, 14 bytes, Stack size 8 bytes, .\build\at_cellularnetwork.o(i._ZN4mbed18AT_CellularNetwork9get_stackEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = mbed::AT_CellularNetwork::get_stack() &rArr; mbed::nsapi_ppp_get_stack()
</UL>
<BR>[Calls]<UL><LI><a href="#[3a2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::nsapi_ppp_get_stack()
</UL>
<BR>[Address Reference Count : 1]<UL><LI> at_cellularnetwork.o(.constdata__ZTVN4mbed18AT_CellularNetworkE)
</UL>
<P><STRONG><a name="[388]"></a>mbed::AT_CellularNetwork::AT_CellularNetwork(mbed::ATHandler&)</STRONG> (Thumb, 166 bytes, Stack size 32 bytes, .\build\at_cellularnetwork.o(i._ZN4mbed18AT_CellularNetworkC1ERNS_9ATHandlerE))
<BR><BR>[Stack]<UL><LI>Max Depth = 544 + Unknown Stack Size
<LI>Call Chain = mbed::AT_CellularNetwork::AT_CellularNetwork(mbed::ATHandler&) &rArr; mbed::ATHandler::set_urc_handler(const char*, mbed::Callback&lang;void()&rang;) &rArr; operator new(unsigned) &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[378]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularBase::AT_CellularBase(mbed::ATHandler&)
<LI><a href="#[3a3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;T3()&rang; mbed::callback&lang;mbed::AT_CellularNetwork, mbed::AT_CellularNetwork, void&rang;(T2*, T3(T1::*)())
<LI><a href="#[3a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::set_urc_handler(const char*, mbed::Callback&lang;void()&rang;)
</UL>
<BR>[Called By]<UL><LI><a href="#[177]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularDevice::open_network(mbed::FileHandle*)
<LI><a href="#[368]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::QUECTEL_BG96_CellularNetwork::QUECTEL_BG96_CellularNetwork(mbed::ATHandler&)
</UL>

<P><STRONG><a name="[75f]"></a>mbed::AT_CellularNetwork::AT_CellularNetwork__sub_object(mbed::ATHandler&)</STRONG> (Thumb, 0 bytes, Stack size 32 bytes, .\build\at_cellularnetwork.o(i._ZN4mbed18AT_CellularNetworkC1ERNS_9ATHandlerE), UNUSED)

<P><STRONG><a name="[179]"></a>mbed::AT_CellularNetwork::~AT_CellularNetwork__deallocating()</STRONG> (Thumb, 18 bytes, Stack size 16 bytes, .\build\at_cellularnetwork.o(i._ZN4mbed18AT_CellularNetworkD0Ev))
<BR><BR>[Stack]<UL><LI>Max Depth = 88<LI>Call Chain = mbed::AT_CellularNetwork::~AT_CellularNetwork__deallocating() &rArr; mbed::AT_CellularNetwork::~AT_CellularNetwork() &rArr; mbed::AT_CellularNetwork::free_credentials() &rArr; free &rArr; _free_internal &rArr; _mutex_release &rArr; os_kernel_is_active &rArr; osKernelGetState &rArr; svcRtxKernelGetState
</UL>
<BR>[Calls]<UL><LI><a href="#[37e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;operator delete (void*)
<LI><a href="#[178]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::~AT_CellularNetwork()
</UL>
<BR>[Address Reference Count : 1]<UL><LI> at_cellularnetwork.o(.constdata__ZTVN4mbed18AT_CellularNetworkE)
</UL>
<P><STRONG><a name="[178]"></a>mbed::AT_CellularNetwork::~AT_CellularNetwork()</STRONG> (Thumb, 38 bytes, Stack size 8 bytes, .\build\at_cellularnetwork.o(i._ZN4mbed18AT_CellularNetworkD1Ev))
<BR><BR>[Stack]<UL><LI>Max Depth = 72<LI>Call Chain = mbed::AT_CellularNetwork::~AT_CellularNetwork() &rArr; mbed::AT_CellularNetwork::free_credentials() &rArr; free &rArr; _free_internal &rArr; _mutex_release &rArr; os_kernel_is_active &rArr; osKernelGetState &rArr; svcRtxKernelGetState
</UL>
<BR>[Calls]<UL><LI><a href="#[58]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void(nsapi_event, int)&rang;::~Callback()
<LI><a href="#[168]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::CellularNetwork::~CellularNetwork__sub_object()
<LI><a href="#[39a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::free_credentials()
</UL>
<BR>[Called By]<UL><LI><a href="#[179]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::~AT_CellularNetwork__deallocating()
<LI><a href="#[193]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::QUECTEL_BG96_CellularNetwork::~QUECTEL_BG96_CellularNetwork()
</UL>
<BR>[Address Reference Count : 1]<UL><LI> at_cellularnetwork.o(.constdata__ZTVN4mbed18AT_CellularNetworkE)
</UL>
<P><STRONG><a name="[760]"></a>mbed::AT_CellularNetwork::~AT_CellularNetwork__sub_object()</STRONG> (Thumb, 0 bytes, Stack size 8 bytes, .\build\at_cellularnetwork.o(i._ZN4mbed18AT_CellularNetworkD1Ev), UNUSED)

<P><STRONG><a name="[3a2]"></a>mbed::nsapi_ppp_get_stack()</STRONG> (Thumb, 10 bytes, Stack size 8 bytes, .\build\ppp_lwip.o(i._ZN4mbed19nsapi_ppp_get_stackEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = mbed::nsapi_ppp_get_stack()
</UL>
<BR>[Calls]<UL><LI><a href="#[3a7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;nsapi_create_stack(nsapi_stack*)
</UL>
<BR>[Called By]<UL><LI><a href="#[17b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::get_stack()
</UL>

<P><STRONG><a name="[3cc]"></a>mbed::CellularConnectionFSM::get_device()</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, .\build\cellularconnectionfsm.o(i._ZN4mbed21CellularConnectionFSM10get_deviceEv))
<BR><BR>[Called By]<UL><LI><a href="#[3cb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::EasyCellularConnection::modem_debug_on(bool)
</UL>

<P><STRONG><a name="[3be]"></a>mbed::CellularConnectionFSM::open_power(mbed::FileHandle*)</STRONG> (Thumb, 78 bytes, Stack size 16 bytes, .\build\cellularconnectionfsm.o(i._ZN4mbed21CellularConnectionFSM10open_powerEPNS_10FileHandleE))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = mbed::CellularConnectionFSM::open_power(mbed::FileHandle*)
</UL>
<BR>[Called By]<UL><LI><a href="#[c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::CellularConnectionFSM::event()
</UL>

<P><STRONG><a name="[3cf]"></a>mbed::CellularConnectionFSM::set_serial(mbed::UARTSerial*)</STRONG> (Thumb, 4 bytes, Stack size 0 bytes, .\build\cellularconnectionfsm.o(i._ZN4mbed21CellularConnectionFSM10set_serialEPNS_10UARTSerialE))
<BR><BR>[Called By]<UL><LI><a href="#[3ca]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::EasyCellularConnection::init()
</UL>

<P><STRONG><a name="[3ce]"></a>mbed::CellularConnectionFSM::get_network()</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, .\build\cellularconnectionfsm.o(i._ZN4mbed21CellularConnectionFSM11get_networkEv))
<BR><BR>[Called By]<UL><LI><a href="#[187]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::EasyCellularConnection::connect()
<LI><a href="#[189]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::EasyCellularConnection::set_credentials(const char*, const char*, const char*)
</UL>

<P><STRONG><a name="[3af]"></a>mbed::CellularConnectionFSM::set_sim_pin(const char*)</STRONG> (Thumb, 20 bytes, Stack size 16 bytes, .\build\cellularconnectionfsm.o(i._ZN4mbed21CellularConnectionFSM11set_sim_pinEPKc))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = mbed::CellularConnectionFSM::set_sim_pin(const char*) &rArr; strncpy
</UL>
<BR>[Calls]<UL><LI><a href="#[24d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;strncpy
</UL>
<BR>[Called By]<UL><LI><a href="#[18a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::EasyCellularConnection::set_sim_pin(const char*)
</UL>

<P><STRONG><a name="[3bf]"></a>mbed::CellularConnectionFSM::device_ready()</STRONG> (Thumb, 94 bytes, Stack size 2064 bytes, .\build\cellularconnectionfsm.o(i._ZN4mbed21CellularConnectionFSM12device_readyEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 2064<LI>Call Chain = mbed::CellularConnectionFSM::device_ready()
</UL>
<BR>[Called By]<UL><LI><a href="#[c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::CellularConnectionFSM::event()
</UL>

<P><STRONG><a name="[3b0]"></a>mbed::CellularConnectionFSM::set_callback(mbed::Callback&lang;bool(int, int)&rang;)</STRONG> (Thumb, 66 bytes, Stack size 32 bytes, .\build\cellularconnectionfsm.o(i._ZN4mbed21CellularConnectionFSM12set_callbackENS_8CallbackIFbiiEEE))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = mbed::CellularConnectionFSM::set_callback(mbed::Callback&lang;bool(int, int)&rang;) &rArr; mbed::Callback&lang;bool(int, int)&rang;::~Callback()
</UL>
<BR>[Calls]<UL><LI><a href="#[3b1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;bool(int, int)&rang;::~Callback()
</UL>
<BR>[Called By]<UL><LI><a href="#[3ca]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::EasyCellularConnection::init()
</UL>

<P><STRONG><a name="[3b2]"></a>mbed::CellularConnectionFSM::report_failure(const char*)</STRONG> (Thumb, 30 bytes, Stack size 16 bytes, .\build\cellularconnectionfsm.o(i._ZN4mbed21CellularConnectionFSM14report_failureEPKc))
<BR><BR>[Stack]<UL><LI>Max Depth = 576 + Unknown Stack Size
<LI>Call Chain = mbed::CellularConnectionFSM::report_failure(const char*) &rArr; mbed::Callback&lang;bool(int, int)&rang;::operator ()(int, int) const &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[3b3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;bool(int, int)&rang;::operator bool() const
<LI><a href="#[3b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;bool(int, int)&rang;::operator ()(int, int) const
</UL>
<BR>[Called By]<UL><LI><a href="#[c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::CellularConnectionFSM::event()
</UL>

<P><STRONG><a name="[3b5]"></a>mbed::CellularConnectionFSM::start_dispatch()</STRONG> (Thumb, 144 bytes, Stack size 48 bytes, .\build\cellularconnectionfsm.o(i._ZN4mbed21CellularConnectionFSM14start_dispatchEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 656 + Unknown Stack Size
<LI>Call Chain = mbed::CellularConnectionFSM::start_dispatch() &rArr; rtos::Thread::Thread(osPriority_t, unsigned, unsigned char*, const char*) &rArr; rtos::Semaphore::Semaphore(int) &rArr; rtos::Semaphore::constructor(int, unsigned short) &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[33a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_assert_internal
<LI><a href="#[367]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;operator new(unsigned)
<LI><a href="#[53]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void()&rang;::~Callback()
<LI><a href="#[3ac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;T3()&rang; mbed::callback&lang;events::EventQueue, events::EventQueue, void&rang;(T2*, T3(T1::*)())
<LI><a href="#[3b6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Thread::Thread(osPriority_t, unsigned, unsigned char*, const char*)
<LI><a href="#[3ad]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Thread::start(mbed::Callback&lang;void()&rang;)
<LI><a href="#[3b7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::CellularConnectionFSM::stop()
</UL>
<BR>[Called By]<UL><LI><a href="#[3ca]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::EasyCellularConnection::init()
</UL>

<P><STRONG><a name="[3b8]"></a>mbed::CellularConnectionFSM::continue_to_state(mbed::CellularConnectionFSM::CellularState)</STRONG> (Thumb, 86 bytes, Stack size 40 bytes, .\build\cellularconnectionfsm.o(i._ZN4mbed21CellularConnectionFSM17continue_to_stateENS0_13CellularStateE))
<BR><BR>[Stack]<UL><LI>Max Depth = 680 + Unknown Stack Size
<LI>Call Chain = mbed::CellularConnectionFSM::continue_to_state(mbed::CellularConnectionFSM::CellularState) &rArr; int events::EventQueue::call_in&lang;mbed::Callback&lang;void()&rang;&rang;(int, T1) &rArr; equeue_post &rArr; equeue_tick &rArr; equeue_tick_init() &rArr; mbed::Ticker::attach_us(mbed::Callback&lang;void()&rang;, unsigned long long) &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[53]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void()&rang;::~Callback()
<LI><a href="#[3ba]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;int events::EventQueue::call_in&lang;mbed::Callback&lang;void()&rang;&rang;(int, T1)
<LI><a href="#[3b9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;T3()&rang; mbed::callback&lang;mbed::CellularConnectionFSM, mbed::CellularConnectionFSM, void&rang;(T2*, T3(T1::*)())
<LI><a href="#[3b7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::CellularConnectionFSM::stop()
</UL>
<BR>[Called By]<UL><LI><a href="#[187]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::EasyCellularConnection::connect()
</UL>

<P><STRONG><a name="[3c3]"></a>mbed::CellularConnectionFSM::get_attach_network(mbed::CellularNetwork::AttachStatus&)</STRONG> (Thumb, 28 bytes, Stack size 16 bytes, .\build\cellularconnectionfsm.o(i._ZN4mbed21CellularConnectionFSM18get_attach_networkERNS_15CellularNetwork12AttachStatusE))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = mbed::CellularConnectionFSM::get_attach_network(mbed::CellularNetwork::AttachStatus&)
</UL>
<BR>[Called By]<UL><LI><a href="#[c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::CellularConnectionFSM::event()
</UL>

<P><STRONG><a name="[3c4]"></a>mbed::CellularConnectionFSM::set_attach_network()</STRONG> (Thumb, 28 bytes, Stack size 16 bytes, .\build\cellularconnectionfsm.o(i._ZN4mbed21CellularConnectionFSM18set_attach_networkEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = mbed::CellularConnectionFSM::set_attach_network()
</UL>
<BR>[Called By]<UL><LI><a href="#[c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::CellularConnectionFSM::event()
</UL>

<P><STRONG><a name="[3c1]"></a>mbed::CellularConnectionFSM::get_network_registration(mbed::CellularNetwork::RegistrationType, mbed::CellularNetwork::RegistrationStatus&, bool&)</STRONG> (Thumb, 124 bytes, Stack size 32 bytes, .\build\cellularconnectionfsm.o(i._ZN4mbed21CellularConnectionFSM24get_network_registrationENS_15CellularNetwork16RegistrationTypeERNS1_18RegistrationStatusERb))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = mbed::CellularConnectionFSM::get_network_registration(mbed::CellularNetwork::RegistrationType, mbed::CellularNetwork::RegistrationStatus&, bool&)
</UL>
<BR>[Called By]<UL><LI><a href="#[c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::CellularConnectionFSM::event()
</UL>

<P><STRONG><a name="[3c2]"></a>mbed::CellularConnectionFSM::set_network_registration(char*)</STRONG> (Thumb, 26 bytes, Stack size 16 bytes, .\build\cellularconnectionfsm.o(i._ZN4mbed21CellularConnectionFSM24set_network_registrationEPc))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = mbed::CellularConnectionFSM::set_network_registration(char*)
</UL>
<BR>[Called By]<UL><LI><a href="#[c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::CellularConnectionFSM::event()
</UL>

<P><STRONG><a name="[3bb]"></a>mbed::CellularConnectionFSM::init()</STRONG> (Thumb, 140 bytes, Stack size 8 bytes, .\build\cellularconnectionfsm.o(i._ZN4mbed21CellularConnectionFSM4initEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 632 + Unknown Stack Size
<LI>Call Chain = mbed::CellularConnectionFSM::init() &rArr; events::EventQueue::chain(events::EventQueue*) &rArr; equeue_chain &rArr; equeue_background &rArr; equeue_tick &rArr; equeue_tick_init() &rArr; mbed::Ticker::attach_us(mbed::Callback&lang;void()&rang;, unsigned long long) &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[3bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;events::EventQueue::chain(events::EventQueue*)
<LI><a href="#[3b7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::CellularConnectionFSM::stop()
</UL>
<BR>[Called By]<UL><LI><a href="#[3ca]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::EasyCellularConnection::init()
</UL>

<P><STRONG><a name="[3b7]"></a>mbed::CellularConnectionFSM::stop()</STRONG> (Thumb, 44 bytes, Stack size 8 bytes, .\build\cellularconnectionfsm.o(i._ZN4mbed21CellularConnectionFSM4stopEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 80<LI>Call Chain = mbed::CellularConnectionFSM::stop() &rArr; rtos::Thread::terminate() &rArr; rtos::Semaphore::release() &rArr; osSemaphoreRelease &rArr; osRtxPostProcess &rArr; isr_queue_put
</UL>
<BR>[Calls]<UL><LI><a href="#[3bd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Thread::terminate()
</UL>
<BR>[Called By]<UL><LI><a href="#[183]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::CellularConnectionFSM::~CellularConnectionFSM()
<LI><a href="#[3bb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::CellularConnectionFSM::init()
<LI><a href="#[3b8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::CellularConnectionFSM::continue_to_state(mbed::CellularConnectionFSM::CellularState)
<LI><a href="#[3b5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::CellularConnectionFSM::start_dispatch()
<LI><a href="#[5e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::EasyCellularConnection::~EasyCellularConnection()
</UL>

<P><STRONG><a name="[c8]"></a>mbed::CellularConnectionFSM::event()</STRONG> (Thumb, 1024 bytes, Stack size 48 bytes, .\build\cellularconnectionfsm.o(i._ZN4mbed21CellularConnectionFSM5eventEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 2112 + Unknown Stack Size
<LI>Call Chain = mbed::CellularConnectionFSM::event() &rArr; mbed::CellularConnectionFSM::device_ready()
</UL>
<BR>[Calls]<UL><LI><a href="#[33a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_assert_internal
<LI><a href="#[53]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void()&rang;::~Callback()
<LI><a href="#[3b3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;bool(int, int)&rang;::operator bool() const
<LI><a href="#[3b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;bool(int, int)&rang;::operator ()(int, int) const
<LI><a href="#[3ba]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;int events::EventQueue::call_in&lang;mbed::Callback&lang;void()&rang;&rang;(int, T1)
<LI><a href="#[3b9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;T3()&rang; mbed::callback&lang;mbed::CellularConnectionFSM, mbed::CellularConnectionFSM, void&rang;(T2*, T3(T1::*)())
<LI><a href="#[3c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::CellularConnectionFSM::open_sim()
<LI><a href="#[3c2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::CellularConnectionFSM::set_network_registration(char*)
<LI><a href="#[3c1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::CellularConnectionFSM::get_network_registration(mbed::CellularNetwork::RegistrationType, mbed::CellularNetwork::RegistrationStatus&, bool&)
<LI><a href="#[3c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::CellularConnectionFSM::set_attach_network()
<LI><a href="#[3c3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::CellularConnectionFSM::get_attach_network(mbed::CellularNetwork::AttachStatus&)
<LI><a href="#[3b2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::CellularConnectionFSM::report_failure(const char*)
<LI><a href="#[3bf]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::CellularConnectionFSM::device_ready()
<LI><a href="#[3be]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::CellularConnectionFSM::open_power(mbed::FileHandle*)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> cellularconnectionfsm.o(.constdata)
</UL>
<P><STRONG><a name="[3d2]"></a>mbed::CellularConnectionFSM::get_sim()</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, .\build\cellularconnectionfsm.o(i._ZN4mbed21CellularConnectionFSM7get_simEv))
<BR><BR>[Called By]<UL><LI><a href="#[187]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::EasyCellularConnection::connect()
</UL>

<P><STRONG><a name="[3c0]"></a>mbed::CellularConnectionFSM::open_sim()</STRONG> (Thumb, 124 bytes, Stack size 24 bytes, .\build\cellularconnectionfsm.o(i._ZN4mbed21CellularConnectionFSM8open_simEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = mbed::CellularConnectionFSM::open_sim() &rArr; strlen
</UL>
<BR>[Calls]<UL><LI><a href="#[31d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;strlen
</UL>
<BR>[Called By]<UL><LI><a href="#[c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::CellularConnectionFSM::event()
</UL>

<P><STRONG><a name="[3d3]"></a>mbed::CellularConnectionFSM::get_stack()</STRONG> (Thumb, 16 bytes, Stack size 8 bytes, .\build\cellularconnectionfsm.o(i._ZN4mbed21CellularConnectionFSM9get_stackEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = mbed::CellularConnectionFSM::get_stack()
</UL>
<BR>[Called By]<UL><LI><a href="#[188]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::EasyCellularConnection::get_stack()
</UL>

<P><STRONG><a name="[3c5]"></a>mbed::CellularConnectionFSM::CellularConnectionFSM()</STRONG> (Thumb, 248 bytes, Stack size 16 bytes, .\build\cellularconnectionfsm.o(i._ZN4mbed21CellularConnectionFSMC1Ev))
<BR><BR>[Stack]<UL><LI>Max Depth = 656 + Unknown Stack Size
<LI>Call Chain = mbed::CellularConnectionFSM::CellularConnectionFSM() &rArr; events::EventQueue::EventQueue(unsigned, unsigned char*) &rArr; equeue_create &rArr; equeue_create_inplace &rArr; equeue_tick &rArr; equeue_tick_init() &rArr; mbed::Ticker::attach_us(mbed::Callback&lang;void()&rang;, unsigned long long) &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[367]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;operator new(unsigned)
<LI><a href="#[3a9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;events::EventQueue::EventQueue(unsigned, unsigned char*)
<LI><a href="#[36a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::QUECTEL_BG96::QUECTEL_BG96(events::EventQueue&)
<LI><a href="#[23c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memclr4
</UL>
<BR>[Called By]<UL><LI><a href="#[3d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::EasyCellularConnection::EasyCellularConnection(bool)
</UL>

<P><STRONG><a name="[761]"></a>mbed::CellularConnectionFSM::CellularConnectionFSM__sub_object()</STRONG> (Thumb, 0 bytes, Stack size 16 bytes, .\build\cellularconnectionfsm.o(i._ZN4mbed21CellularConnectionFSMC1Ev), UNUSED)

<P><STRONG><a name="[183]"></a>mbed::CellularConnectionFSM::~CellularConnectionFSM()</STRONG> (Thumb, 54 bytes, Stack size 8 bytes, .\build\cellularconnectionfsm.o(i._ZN4mbed21CellularConnectionFSMD1Ev))
<BR><BR>[Stack]<UL><LI>Max Depth = 88<LI>Call Chain = mbed::CellularConnectionFSM::~CellularConnectionFSM() &rArr; events::EventQueue::~EventQueue() &rArr; equeue_destroy &rArr; free &rArr; _free_internal &rArr; _mutex_release &rArr; os_kernel_is_active &rArr; osKernelGetState &rArr; svcRtxKernelGetState
</UL>
<BR>[Calls]<UL><LI><a href="#[3b1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;bool(int, int)&rang;::~Callback()
<LI><a href="#[3ae]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;events::EventQueue::~EventQueue()
<LI><a href="#[3b7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::CellularConnectionFSM::stop()
</UL>
<BR>[Called By]<UL><LI><a href="#[5e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::EasyCellularConnection::~EasyCellularConnection()
</UL>
<BR>[Address Reference Count : 1]<UL><LI> cellularconnectionfsm.o(.constdata__ZTVN4mbed21CellularConnectionFSME)
</UL>
<P><STRONG><a name="[762]"></a>mbed::CellularConnectionFSM::~CellularConnectionFSM__sub_object()</STRONG> (Thumb, 0 bytes, Stack size 8 bytes, .\build\cellularconnectionfsm.o(i._ZN4mbed21CellularConnectionFSMD1Ev), UNUSED)

<P><STRONG><a name="[2e1]"></a>mbed::mbed_override_console(int)</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, .\build\mbed_retarget.o(i._ZN4mbed21mbed_override_consoleEi))
<BR><BR>[Called By]<UL><LI><a href="#[2e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;get_console(int)
</UL>

<P><STRONG><a name="[186]"></a>mbed::AT_CellularInformation::get_revision(char*, unsigned)</STRONG> (Thumb, 22 bytes, Stack size 16 bytes, .\build\at_cellularinformation.o(i._ZN4mbed22AT_CellularInformation12get_revisionEPcj))
<BR><BR>[Stack]<UL><LI>Max Depth = 736 + Unknown Stack Size
<LI>Call Chain = mbed::AT_CellularInformation::get_revision(char*, unsigned) &rArr; mbed::AT_CellularInformation::get_info(const char*, char*, unsigned) &rArr; mbed::ATHandler::resp_start(const char*, bool) &rArr; mbed::ATHandler::resp(const char*, bool) &rArr; mbed::ATHandler::match_error() &rArr; mbed::ATHandler::at_error(bool, mbed::DeviceErrorType) &rArr; mbed::ATHandler::read_int() &rArr; mbed::ATHandler::read_string(char*, unsigned, bool) &rArr; mbed::ATHandler::consume_char(char) &rArr; mbed::ATHandler::get_char() &rArr; mbed::ATHandler::fill_buffer() &rArr; mbed::Timer::~Timer() &rArr; sleep_manager_unlock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[3c6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularInformation::get_info(const char*, char*, unsigned)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> at_cellularinformation.o(.constdata__ZTVN4mbed22AT_CellularInformationE)
</UL>
<P><STRONG><a name="[184]"></a>mbed::AT_CellularInformation::get_manufacturer(char*, unsigned)</STRONG> (Thumb, 22 bytes, Stack size 16 bytes, .\build\at_cellularinformation.o(i._ZN4mbed22AT_CellularInformation16get_manufacturerEPcj))
<BR><BR>[Stack]<UL><LI>Max Depth = 736 + Unknown Stack Size
<LI>Call Chain = mbed::AT_CellularInformation::get_manufacturer(char*, unsigned) &rArr; mbed::AT_CellularInformation::get_info(const char*, char*, unsigned) &rArr; mbed::ATHandler::resp_start(const char*, bool) &rArr; mbed::ATHandler::resp(const char*, bool) &rArr; mbed::ATHandler::match_error() &rArr; mbed::ATHandler::at_error(bool, mbed::DeviceErrorType) &rArr; mbed::ATHandler::read_int() &rArr; mbed::ATHandler::read_string(char*, unsigned, bool) &rArr; mbed::ATHandler::consume_char(char) &rArr; mbed::ATHandler::get_char() &rArr; mbed::ATHandler::fill_buffer() &rArr; mbed::Timer::~Timer() &rArr; sleep_manager_unlock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[3c6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularInformation::get_info(const char*, char*, unsigned)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> at_cellularinformation.o(.constdata__ZTVN4mbed22AT_CellularInformationE)
</UL>
<P><STRONG><a name="[3c6]"></a>mbed::AT_CellularInformation::get_info(const char*, char*, unsigned)</STRONG> (Thumb, 84 bytes, Stack size 24 bytes, .\build\at_cellularinformation.o(i._ZN4mbed22AT_CellularInformation8get_infoEPKcPcj))
<BR><BR>[Stack]<UL><LI>Max Depth = 720 + Unknown Stack Size
<LI>Call Chain = mbed::AT_CellularInformation::get_info(const char*, char*, unsigned) &rArr; mbed::ATHandler::resp_start(const char*, bool) &rArr; mbed::ATHandler::resp(const char*, bool) &rArr; mbed::ATHandler::match_error() &rArr; mbed::ATHandler::at_error(bool, mbed::DeviceErrorType) &rArr; mbed::ATHandler::read_int() &rArr; mbed::ATHandler::read_string(char*, unsigned, bool) &rArr; mbed::ATHandler::consume_char(char) &rArr; mbed::ATHandler::get_char() &rArr; mbed::ATHandler::fill_buffer() &rArr; mbed::Timer::~Timer() &rArr; sleep_manager_unlock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[374]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::resp_stop()
<LI><a href="#[370]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::cmd_start(const char*)
<LI><a href="#[371]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::cmd_stop()
<LI><a href="#[36e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::lock()
<LI><a href="#[3c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::set_default_delimiter()
<LI><a href="#[375]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::unlock_return_error()
<LI><a href="#[3c7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::set_delimiter(char)
<LI><a href="#[373]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::read_string(char*, unsigned, bool)
<LI><a href="#[372]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::resp_start(const char*, bool)
</UL>
<BR>[Called By]<UL><LI><a href="#[185]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularInformation::get_model(char*, unsigned)
<LI><a href="#[184]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularInformation::get_manufacturer(char*, unsigned)
<LI><a href="#[186]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularInformation::get_revision(char*, unsigned)
</UL>

<P><STRONG><a name="[185]"></a>mbed::AT_CellularInformation::get_model(char*, unsigned)</STRONG> (Thumb, 22 bytes, Stack size 16 bytes, .\build\at_cellularinformation.o(i._ZN4mbed22AT_CellularInformation9get_modelEPcj))
<BR><BR>[Stack]<UL><LI>Max Depth = 736 + Unknown Stack Size
<LI>Call Chain = mbed::AT_CellularInformation::get_model(char*, unsigned) &rArr; mbed::AT_CellularInformation::get_info(const char*, char*, unsigned) &rArr; mbed::ATHandler::resp_start(const char*, bool) &rArr; mbed::ATHandler::resp(const char*, bool) &rArr; mbed::ATHandler::match_error() &rArr; mbed::ATHandler::at_error(bool, mbed::DeviceErrorType) &rArr; mbed::ATHandler::read_int() &rArr; mbed::ATHandler::read_string(char*, unsigned, bool) &rArr; mbed::ATHandler::consume_char(char) &rArr; mbed::ATHandler::get_char() &rArr; mbed::ATHandler::fill_buffer() &rArr; mbed::Timer::~Timer() &rArr; sleep_manager_unlock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[3c6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularInformation::get_info(const char*, char*, unsigned)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> at_cellularinformation.o(.constdata__ZTVN4mbed22AT_CellularInformationE)
</UL>
<P><STRONG><a name="[38d]"></a>mbed::AT_CellularInformation::AT_CellularInformation(mbed::ATHandler&)</STRONG> (Thumb, 28 bytes, Stack size 16 bytes, .\build\at_cellularinformation.o(i._ZN4mbed22AT_CellularInformationC1ERNS_9ATHandlerE))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = mbed::AT_CellularInformation::AT_CellularInformation(mbed::ATHandler&)
</UL>
<BR>[Calls]<UL><LI><a href="#[378]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularBase::AT_CellularBase(mbed::ATHandler&)
</UL>
<BR>[Called By]<UL><LI><a href="#[15f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularDevice::open_information(mbed::FileHandle*)
</UL>

<P><STRONG><a name="[763]"></a>mbed::AT_CellularInformation::AT_CellularInformation__sub_object(mbed::ATHandler&)</STRONG> (Thumb, 0 bytes, Stack size 16 bytes, .\build\at_cellularinformation.o(i._ZN4mbed22AT_CellularInformationC1ERNS_9ATHandlerE), UNUSED)

<P><STRONG><a name="[18a]"></a>mbed::EasyCellularConnection::set_sim_pin(const char*)</STRONG> (Thumb, 20 bytes, Stack size 16 bytes, .\build\easycellularconnection.o(i._ZN4mbed22EasyCellularConnection11set_sim_pinEPKc))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = mbed::EasyCellularConnection::set_sim_pin(const char*) &rArr; mbed::CellularConnectionFSM::set_sim_pin(const char*) &rArr; strncpy
</UL>
<BR>[Calls]<UL><LI><a href="#[3af]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::CellularConnectionFSM::set_sim_pin(const char*)
</UL>
<BR>[Called By]<UL><LI><a href="#[281]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;$Super$$main
</UL>
<BR>[Address Reference Count : 1]<UL><LI> easycellularconnection.o(.constdata__ZTVN4mbed22EasyCellularConnectionE)
</UL>
<P><STRONG><a name="[18b]"></a>mbed::EasyCellularConnection::is_connected()</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, .\build\easycellularconnection.o(i._ZN4mbed22EasyCellularConnection12is_connectedEv))
<BR><BR>[Called By]<UL><LI><a href="#[70]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dot_event()
<LI><a href="#[2de]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;do_connect()
</UL>
<BR>[Address Reference Count : 1]<UL><LI> easycellularconnection.o(.constdata__ZTVN4mbed22EasyCellularConnectionE)
</UL>
<P><STRONG><a name="[3c9]"></a>mbed::EasyCellularConnection::check_connect()</STRONG> (Thumb, 42 bytes, Stack size 16 bytes, .\build\easycellularconnection.o(i._ZN4mbed22EasyCellularConnection13check_connectEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 704 + Unknown Stack Size
<LI>Call Chain = mbed::EasyCellularConnection::check_connect() &rArr; mbed::EasyCellularConnection::init() &rArr; mbed::CellularConnectionFSM::start_dispatch() &rArr; rtos::Thread::Thread(osPriority_t, unsigned, unsigned char*, const char*) &rArr; rtos::Semaphore::Semaphore(int) &rArr; rtos::Semaphore::constructor(int, unsigned short) &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[3ca]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::EasyCellularConnection::init()
</UL>
<BR>[Called By]<UL><LI><a href="#[187]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::EasyCellularConnection::connect()
</UL>

<P><STRONG><a name="[3cb]"></a>mbed::EasyCellularConnection::modem_debug_on(bool)</STRONG> (Thumb, 30 bytes, Stack size 16 bytes, .\build\easycellularconnection.o(i._ZN4mbed22EasyCellularConnection14modem_debug_onEb))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = mbed::EasyCellularConnection::modem_debug_on(bool)
</UL>
<BR>[Calls]<UL><LI><a href="#[3cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::CellularConnectionFSM::get_device()
</UL>
<BR>[Called By]<UL><LI><a href="#[3d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::EasyCellularConnection::EasyCellularConnection(bool)
<LI><a href="#[281]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;$Super$$main
</UL>

<P><STRONG><a name="[ca]"></a>mbed::EasyCellularConnection::cellular_status(int, int)</STRONG> (Thumb, 64 bytes, Stack size 16 bytes, .\build\easycellularconnection.o(i._ZN4mbed22EasyCellularConnection15cellular_statusEii))
<BR><BR>[Stack]<UL><LI>Max Depth = 544 + Unknown Stack Size
<LI>Call Chain = mbed::EasyCellularConnection::cellular_status(int, int) &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[33a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_assert_internal
<LI><a href="#[3cd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Semaphore::release()
</UL>
<BR>[Address Reference Count : 1]<UL><LI> easycellularconnection.o(.constdata)
</UL>
<P><STRONG><a name="[189]"></a>mbed::EasyCellularConnection::set_credentials(const char*, const char*, const char*)</STRONG> (Thumb, 94 bytes, Stack size 24 bytes, .\build\easycellularconnection.o(i._ZN4mbed22EasyCellularConnection15set_credentialsEPKcS2_S2_))
<BR><BR>[Stack]<UL><LI>Max Depth = 712 + Unknown Stack Size
<LI>Call Chain = mbed::EasyCellularConnection::set_credentials(const char*, const char*, const char*) &rArr; mbed::EasyCellularConnection::init() &rArr; mbed::CellularConnectionFSM::start_dispatch() &rArr; rtos::Thread::Thread(osPriority_t, unsigned, unsigned char*, const char*) &rArr; rtos::Semaphore::Semaphore(int) &rArr; rtos::Semaphore::constructor(int, unsigned short) &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[3ce]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::CellularConnectionFSM::get_network()
<LI><a href="#[3ca]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::EasyCellularConnection::init()
<LI><a href="#[31d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;strlen
</UL>
<BR>[Called By]<UL><LI><a href="#[281]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;$Super$$main
</UL>
<BR>[Address Reference Count : 1]<UL><LI> easycellularconnection.o(.constdata__ZTVN4mbed22EasyCellularConnectionE)
</UL>
<P><STRONG><a name="[3ca]"></a>mbed::EasyCellularConnection::init()</STRONG> (Thumb, 96 bytes, Stack size 32 bytes, .\build\easycellularconnection.o(i._ZN4mbed22EasyCellularConnection4initEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 688 + Unknown Stack Size
<LI>Call Chain = mbed::EasyCellularConnection::init() &rArr; mbed::CellularConnectionFSM::start_dispatch() &rArr; rtos::Thread::Thread(osPriority_t, unsigned, unsigned char*, const char*) &rArr; rtos::Semaphore::Semaphore(int) &rArr; rtos::Semaphore::constructor(int, unsigned short) &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[3bb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::CellularConnectionFSM::init()
<LI><a href="#[3b5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::CellularConnectionFSM::start_dispatch()
<LI><a href="#[3b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::CellularConnectionFSM::set_callback(mbed::Callback&lang;bool(int, int)&rang;)
<LI><a href="#[3cf]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::CellularConnectionFSM::set_serial(mbed::UARTSerial*)
<LI><a href="#[3d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;T3(T4, T5)&rang; mbed::callback&lang;mbed::EasyCellularConnection, mbed::EasyCellularConnection, bool, int, int&rang;(T2*, T3(T1::*)(T4, T5))
</UL>
<BR>[Called By]<UL><LI><a href="#[189]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::EasyCellularConnection::set_credentials(const char*, const char*, const char*)
<LI><a href="#[3c9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::EasyCellularConnection::check_connect()
</UL>

<P><STRONG><a name="[187]"></a>mbed::EasyCellularConnection::connect()</STRONG> (Thumb, 270 bytes, Stack size 56 bytes, .\build\easycellularconnection.o(i._ZN4mbed22EasyCellularConnection7connectEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 760 + Unknown Stack Size
<LI>Call Chain = mbed::EasyCellularConnection::connect() &rArr; mbed::EasyCellularConnection::check_connect() &rArr; mbed::EasyCellularConnection::init() &rArr; mbed::CellularConnectionFSM::start_dispatch() &rArr; rtos::Thread::Thread(osPriority_t, unsigned, unsigned char*, const char*) &rArr; rtos::Semaphore::Semaphore(int) &rArr; rtos::Semaphore::constructor(int, unsigned short) &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[3d2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::CellularConnectionFSM::get_sim()
<LI><a href="#[3b8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::CellularConnectionFSM::continue_to_state(mbed::CellularConnectionFSM::CellularState)
<LI><a href="#[3ce]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::CellularConnectionFSM::get_network()
<LI><a href="#[3d1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Semaphore::wait(unsigned)
<LI><a href="#[322]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;apnconfig(const char*)
<LI><a href="#[324]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;wait
<LI><a href="#[3c9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::EasyCellularConnection::check_connect()
<LI><a href="#[31d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;strlen
</UL>
<BR>[Called By]<UL><LI><a href="#[2de]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;do_connect()
</UL>
<BR>[Address Reference Count : 1]<UL><LI> easycellularconnection.o(.constdata__ZTVN4mbed22EasyCellularConnectionE)
</UL>
<P><STRONG><a name="[188]"></a>mbed::EasyCellularConnection::get_stack()</STRONG> (Thumb, 14 bytes, Stack size 8 bytes, .\build\easycellularconnection.o(i._ZN4mbed22EasyCellularConnection9get_stackEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = mbed::EasyCellularConnection::get_stack() &rArr; mbed::CellularConnectionFSM::get_stack()
</UL>
<BR>[Calls]<UL><LI><a href="#[3d3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::CellularConnectionFSM::get_stack()
</UL>
<BR>[Address Reference Count : 1]<UL><LI> easycellularconnection.o(.constdata__ZTVN4mbed22EasyCellularConnectionE)
</UL>
<P><STRONG><a name="[3d4]"></a>mbed::EasyCellularConnection::EasyCellularConnection(bool)</STRONG> (Thumb, 90 bytes, Stack size 16 bytes, .\build\easycellularconnection.o(i._ZN4mbed22EasyCellularConnectionC1Eb))
<BR><BR>[Stack]<UL><LI>Max Depth = 672 + Unknown Stack Size
<LI>Call Chain = mbed::EasyCellularConnection::EasyCellularConnection(bool) &rArr; mbed::CellularConnectionFSM::CellularConnectionFSM() &rArr; events::EventQueue::EventQueue(unsigned, unsigned char*) &rArr; equeue_create &rArr; equeue_create_inplace &rArr; equeue_tick &rArr; equeue_tick_init() &rArr; mbed::Ticker::attach_us(mbed::Callback&lang;void()&rang;, unsigned long long) &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[3aa]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Semaphore::Semaphore(int)
<LI><a href="#[3c5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::CellularConnectionFSM::CellularConnectionFSM()
<LI><a href="#[35f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::UARTSerial::UARTSerial(PinName, PinName, int)
<LI><a href="#[3cb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::EasyCellularConnection::modem_debug_on(bool)
</UL>
<BR>[Called By]<UL><LI><a href="#[1d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__sti___8_main_cpp_led0
</UL>

<P><STRONG><a name="[764]"></a>mbed::EasyCellularConnection::EasyCellularConnection__sub_object(bool)</STRONG> (Thumb, 0 bytes, Stack size 16 bytes, .\build\easycellularconnection.o(i._ZN4mbed22EasyCellularConnectionC1Eb), UNUSED)

<P><STRONG><a name="[5e]"></a>mbed::EasyCellularConnection::~EasyCellularConnection()</STRONG> (Thumb, 64 bytes, Stack size 8 bytes, .\build\easycellularconnection.o(i._ZN4mbed22EasyCellularConnectionD1Ev))
<BR><BR>[Stack]<UL><LI>Max Depth = 648 + Unknown Stack Size
<LI>Call Chain = mbed::EasyCellularConnection::~EasyCellularConnection() &rArr; mbed::UARTSerial::~UARTSerial() &rArr; mbed::SerialBase::~SerialBase() &rArr; mbed::SerialBase::attach(mbed::Callback&lang;void()&rang;, mbed::SerialBase::IrqType) &rArr; serial_irq_set &rArr; serial_get_tx_irq_index &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[183]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::CellularConnectionFSM::~CellularConnectionFSM()
<LI><a href="#[3b7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::CellularConnectionFSM::stop()
<LI><a href="#[3d5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Semaphore::~Semaphore()
<LI><a href="#[121]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CellularBase::~CellularBase__sub_object()
<LI><a href="#[149]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::UARTSerial::~UARTSerial()
</UL>
<BR>[Address Reference Count : 2]<UL><LI> easycellularconnection.o(.constdata__ZTVN4mbed22EasyCellularConnectionE)
<LI> main.o(i.__sti___8_main_cpp_led0)
</UL>
<P><STRONG><a name="[765]"></a>mbed::EasyCellularConnection::~EasyCellularConnection__sub_object()</STRONG> (Thumb, 0 bytes, Stack size 8 bytes, .\build\easycellularconnection.o(i._ZN4mbed22EasyCellularConnectionD1Ev), UNUSED)

<P><STRONG><a name="[18f]"></a>mbed::QUECTEL_BG96_CellularStack::socket_close_impl(int)</STRONG> (Thumb, 52 bytes, Stack size 16 bytes, .\build\quectel_bg96_cellularstack.o(i._ZN4mbed26QUECTEL_BG96_CellularStack17socket_close_implEi))
<BR><BR>[Stack]<UL><LI>Max Depth = 712 + Unknown Stack Size
<LI>Call Chain = mbed::QUECTEL_BG96_CellularStack::socket_close_impl(int) &rArr; mbed::ATHandler::resp_start(const char*, bool) &rArr; mbed::ATHandler::resp(const char*, bool) &rArr; mbed::ATHandler::match_error() &rArr; mbed::ATHandler::at_error(bool, mbed::DeviceErrorType) &rArr; mbed::ATHandler::read_int() &rArr; mbed::ATHandler::read_string(char*, unsigned, bool) &rArr; mbed::ATHandler::consume_char(char) &rArr; mbed::ATHandler::get_char() &rArr; mbed::ATHandler::fill_buffer() &rArr; mbed::Timer::~Timer() &rArr; sleep_manager_unlock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[374]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::resp_stop()
<LI><a href="#[370]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::cmd_start(const char*)
<LI><a href="#[371]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::cmd_stop()
<LI><a href="#[372]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::resp_start(const char*, bool)
<LI><a href="#[399]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::get_last_error() const
<LI><a href="#[382]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::write_int(int)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> quectel_bg96_cellularstack.o(.constdata__ZTVN4mbed26QUECTEL_BG96_CellularStackE)
</UL>
<P><STRONG><a name="[190]"></a>mbed::QUECTEL_BG96_CellularStack::create_socket_impl(mbed::AT_CellularStack::CellularSocket*)</STRONG> (Thumb, 592 bytes, Stack size 40 bytes, .\build\quectel_bg96_cellularstack.o(i._ZN4mbed26QUECTEL_BG96_CellularStack18create_socket_implEPNS_16AT_CellularStack14CellularSocketE))
<BR><BR>[Stack]<UL><LI>Max Depth = 752 + Unknown Stack Size
<LI>Call Chain = mbed::QUECTEL_BG96_CellularStack::create_socket_impl(mbed::AT_CellularStack::CellularSocket*) &rArr; mbed::QUECTEL_BG96_CellularStack::handle_open_socket_response(int&, int&) &rArr; mbed::ATHandler::resp_start(const char*, bool) &rArr; mbed::ATHandler::resp(const char*, bool) &rArr; mbed::ATHandler::match_error() &rArr; mbed::ATHandler::at_error(bool, mbed::DeviceErrorType) &rArr; mbed::ATHandler::read_int() &rArr; mbed::ATHandler::read_string(char*, unsigned, bool) &rArr; mbed::ATHandler::consume_char(char) &rArr; mbed::ATHandler::get_char() &rArr; mbed::ATHandler::fill_buffer() &rArr; mbed::Timer::~Timer() &rArr; sleep_manager_unlock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[374]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::resp_stop()
<LI><a href="#[370]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::cmd_start(const char*)
<LI><a href="#[371]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::cmd_stop()
<LI><a href="#[372]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::resp_start(const char*, bool)
<LI><a href="#[399]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::get_last_error() const
<LI><a href="#[382]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::write_int(int)
<LI><a href="#[376]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::write_string(const char*, bool)
<LI><a href="#[332]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SocketAddress::get_port() const
<LI><a href="#[334]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SocketAddress::get_ip_address() const
<LI><a href="#[3d6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::QUECTEL_BG96_CellularStack::handle_open_socket_response(int&, int&)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> quectel_bg96_cellularstack.o(.constdata__ZTVN4mbed26QUECTEL_BG96_CellularStackE)
</UL>
<P><STRONG><a name="[191]"></a>mbed::QUECTEL_BG96_CellularStack::socket_sendto_impl(mbed::AT_CellularStack::CellularSocket*, const SocketAddress&, const void*, unsigned)</STRONG> (Thumb, 266 bytes, Stack size 40 bytes, .\build\quectel_bg96_cellularstack.o(i._ZN4mbed26QUECTEL_BG96_CellularStack18socket_sendto_implEPNS_16AT_CellularStack14CellularSocketERK13SocketAddressPKvj))
<BR><BR>[Stack]<UL><LI>Max Depth = 736 + Unknown Stack Size
<LI>Call Chain = mbed::QUECTEL_BG96_CellularStack::socket_sendto_impl(mbed::AT_CellularStack::CellularSocket*, const SocketAddress&, const void*, unsigned) &rArr; mbed::ATHandler::resp_start(const char*, bool) &rArr; mbed::ATHandler::resp(const char*, bool) &rArr; mbed::ATHandler::match_error() &rArr; mbed::ATHandler::at_error(bool, mbed::DeviceErrorType) &rArr; mbed::ATHandler::read_int() &rArr; mbed::ATHandler::read_string(char*, unsigned, bool) &rArr; mbed::ATHandler::consume_char(char) &rArr; mbed::ATHandler::get_char() &rArr; mbed::ATHandler::fill_buffer() &rArr; mbed::Timer::~Timer() &rArr; sleep_manager_unlock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[374]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::resp_stop()
<LI><a href="#[370]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::cmd_start(const char*)
<LI><a href="#[371]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::cmd_stop()
<LI><a href="#[372]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::resp_start(const char*, bool)
<LI><a href="#[399]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::get_last_error() const
<LI><a href="#[382]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::write_int(int)
<LI><a href="#[394]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::read_int()
<LI><a href="#[376]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::write_string(const char*, bool)
<LI><a href="#[332]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SocketAddress::get_port() const
<LI><a href="#[3d7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::write_bytes(const unsigned char*, unsigned)
<LI><a href="#[3d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::set_stop_tag(const char*)
<LI><a href="#[334]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SocketAddress::get_ip_address() const
</UL>
<BR>[Address Reference Count : 1]<UL><LI> quectel_bg96_cellularstack.o(.constdata__ZTVN4mbed26QUECTEL_BG96_CellularStackE)
</UL>
<P><STRONG><a name="[18d]"></a>mbed::QUECTEL_BG96_CellularStack::get_max_packet_size()</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, .\build\quectel_bg96_cellularstack.o(i._ZN4mbed26QUECTEL_BG96_CellularStack19get_max_packet_sizeEv))
<BR>[Address Reference Count : 1]<UL><LI> quectel_bg96_cellularstack.o(.constdata__ZTVN4mbed26QUECTEL_BG96_CellularStackE)
</UL>
<P><STRONG><a name="[18c]"></a>mbed::QUECTEL_BG96_CellularStack::get_max_socket_count()</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, .\build\quectel_bg96_cellularstack.o(i._ZN4mbed26QUECTEL_BG96_CellularStack20get_max_socket_countEv))
<BR>[Address Reference Count : 1]<UL><LI> quectel_bg96_cellularstack.o(.constdata__ZTVN4mbed26QUECTEL_BG96_CellularStackE)
</UL>
<P><STRONG><a name="[192]"></a>mbed::QUECTEL_BG96_CellularStack::socket_recvfrom_impl(mbed::AT_CellularStack::CellularSocket*, SocketAddress*, void*, unsigned)</STRONG> (Thumb, 138 bytes, Stack size 80 bytes, .\build\quectel_bg96_cellularstack.o(i._ZN4mbed26QUECTEL_BG96_CellularStack20socket_recvfrom_implEPNS_16AT_CellularStack14CellularSocketEP13SocketAddressPvj))
<BR><BR>[Stack]<UL><LI>Max Depth = 776 + Unknown Stack Size
<LI>Call Chain = mbed::QUECTEL_BG96_CellularStack::socket_recvfrom_impl(mbed::AT_CellularStack::CellularSocket*, SocketAddress*, void*, unsigned) &rArr; mbed::ATHandler::resp_start(const char*, bool) &rArr; mbed::ATHandler::resp(const char*, bool) &rArr; mbed::ATHandler::match_error() &rArr; mbed::ATHandler::at_error(bool, mbed::DeviceErrorType) &rArr; mbed::ATHandler::read_int() &rArr; mbed::ATHandler::read_string(char*, unsigned, bool) &rArr; mbed::ATHandler::consume_char(char) &rArr; mbed::ATHandler::get_char() &rArr; mbed::ATHandler::fill_buffer() &rArr; mbed::Timer::~Timer() &rArr; sleep_manager_unlock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[374]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::resp_stop()
<LI><a href="#[370]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::cmd_start(const char*)
<LI><a href="#[371]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::cmd_stop()
<LI><a href="#[373]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::read_string(char*, unsigned, bool)
<LI><a href="#[372]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::resp_start(const char*, bool)
<LI><a href="#[399]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::get_last_error() const
<LI><a href="#[382]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::write_int(int)
<LI><a href="#[394]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::read_int()
<LI><a href="#[2f1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SocketAddress::set_port(unsigned short)
<LI><a href="#[3d9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::read_bytes(unsigned char*, unsigned)
<LI><a href="#[329]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SocketAddress::set_ip_address(const char*)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> quectel_bg96_cellularstack.o(.constdata__ZTVN4mbed26QUECTEL_BG96_CellularStackE)
</UL>
<P><STRONG><a name="[18e]"></a>mbed::QUECTEL_BG96_CellularStack::is_protocol_supported(nsapi_protocol)</STRONG> (Thumb, 14 bytes, Stack size 0 bytes, .\build\quectel_bg96_cellularstack.o(i._ZN4mbed26QUECTEL_BG96_CellularStack21is_protocol_supportedE14nsapi_protocol))
<BR>[Address Reference Count : 1]<UL><LI> quectel_bg96_cellularstack.o(.constdata__ZTVN4mbed26QUECTEL_BG96_CellularStackE)
</UL>
<P><STRONG><a name="[3d6]"></a>mbed::QUECTEL_BG96_CellularStack::handle_open_socket_response(int&, int&)</STRONG> (Thumb, 68 bytes, Stack size 16 bytes, .\build\quectel_bg96_cellularstack.o(i._ZN4mbed26QUECTEL_BG96_CellularStack27handle_open_socket_responseERiS1_))
<BR><BR>[Stack]<UL><LI>Max Depth = 712 + Unknown Stack Size
<LI>Call Chain = mbed::QUECTEL_BG96_CellularStack::handle_open_socket_response(int&, int&) &rArr; mbed::ATHandler::resp_start(const char*, bool) &rArr; mbed::ATHandler::resp(const char*, bool) &rArr; mbed::ATHandler::match_error() &rArr; mbed::ATHandler::at_error(bool, mbed::DeviceErrorType) &rArr; mbed::ATHandler::read_int() &rArr; mbed::ATHandler::read_string(char*, unsigned, bool) &rArr; mbed::ATHandler::consume_char(char) &rArr; mbed::ATHandler::get_char() &rArr; mbed::ATHandler::fill_buffer() &rArr; mbed::Timer::~Timer() &rArr; sleep_manager_unlock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[387]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::set_at_timeout(unsigned, bool)
<LI><a href="#[374]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::resp_stop()
<LI><a href="#[372]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::resp_start(const char*, bool)
<LI><a href="#[394]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::read_int()
<LI><a href="#[3da]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::restore_at_timeout()
</UL>
<BR>[Called By]<UL><LI><a href="#[190]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::QUECTEL_BG96_CellularStack::create_socket_impl(mbed::AT_CellularStack::CellularSocket*)
</UL>

<P><STRONG><a name="[11c]"></a>mbed::QUECTEL_BG96_CellularStack::urc_qiurc()</STRONG> (Thumb, 88 bytes, Stack size 24 bytes, .\build\quectel_bg96_cellularstack.o(i._ZN4mbed26QUECTEL_BG96_CellularStack9urc_qiurcEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 680 + Unknown Stack Size
<LI>Call Chain = mbed::QUECTEL_BG96_CellularStack::urc_qiurc() &rArr; mbed::ATHandler::unlock() &rArr; int events::EventQueue::call&lang;mbed::Callback&lang;void()&rang;&rang;(T1) &rArr; equeue_post &rArr; equeue_tick &rArr; equeue_tick_init() &rArr; mbed::Ticker::attach_us(mbed::Callback&lang;void()&rang;, unsigned long long) &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[36e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::lock()
<LI><a href="#[394]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::read_int()
<LI><a href="#[381]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::unlock()
<LI><a href="#[384]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::skip_param(unsigned)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> quectel_bg96_cellularstack.o(.constdata)
</UL>
<P><STRONG><a name="[3db]"></a>mbed::QUECTEL_BG96_CellularStack::QUECTEL_BG96_CellularStack(mbed::ATHandler&, int, nsapi_ip_stack)</STRONG> (Thumb, 80 bytes, Stack size 40 bytes, .\build\quectel_bg96_cellularstack.o(i._ZN4mbed26QUECTEL_BG96_CellularStackC1ERNS_9ATHandlerEi14nsapi_ip_stack))
<BR><BR>[Stack]<UL><LI>Max Depth = 552 + Unknown Stack Size
<LI>Call Chain = mbed::QUECTEL_BG96_CellularStack::QUECTEL_BG96_CellularStack(mbed::ATHandler&, int, nsapi_ip_stack) &rArr; mbed::ATHandler::set_urc_handler(const char*, mbed::Callback&lang;void()&rang;) &rArr; operator new(unsigned) &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[3a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::set_urc_handler(const char*, mbed::Callback&lang;void()&rang;)
<LI><a href="#[385]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularStack::AT_CellularStack__sub_object(mbed::ATHandler&, int, nsapi_ip_stack)
<LI><a href="#[3dc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void()&rang;::Callback&lang;mbed::QUECTEL_BG96_CellularStack, mbed::QUECTEL_BG96_CellularStack&rang;(T2*, void(T1::*)())
</UL>
<BR>[Called By]<UL><LI><a href="#[195]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::QUECTEL_BG96_CellularNetwork::get_stack()
</UL>

<P><STRONG><a name="[766]"></a>mbed::QUECTEL_BG96_CellularStack::QUECTEL_BG96_CellularStack__sub_object(mbed::ATHandler&, int, nsapi_ip_stack)</STRONG> (Thumb, 0 bytes, Stack size 40 bytes, .\build\quectel_bg96_cellularstack.o(i._ZN4mbed26QUECTEL_BG96_CellularStackC1ERNS_9ATHandlerEi14nsapi_ip_stack), UNUSED)

<P><STRONG><a name="[3dd]"></a>mbed::mbed_set_unbuffered_stream(std::__FILE*)</STRONG> (Thumb, 14 bytes, Stack size 8 bytes, .\build\mbed_retarget.o(i._ZN4mbed26mbed_set_unbuffered_streamEPSt6__FILE))
<BR><BR>[Stack]<UL><LI>Max Depth = 72<LI>Call Chain = mbed::mbed_set_unbuffered_stream(std::__FILE*) &rArr; setbuf &rArr; setvbuf &rArr; _mutex_release &rArr; os_kernel_is_active &rArr; osKernelGetState &rArr; svcRtxKernelGetState
</UL>
<BR>[Calls]<UL><LI><a href="#[237]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;setbuf
</UL>
<BR>[Called By]<UL><LI><a href="#[3e9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fdopen
<LI><a href="#[3e3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Stream::Stream__sub_object(const char*)
</UL>

<P><STRONG><a name="[196]"></a>mbed::QUECTEL_BG96_CellularNetwork::get_modem_stack_type(nsapi_ip_stack)</STRONG> (Thumb, 22 bytes, Stack size 0 bytes, .\build\quectel_bg96_cellularnetwork.o(i._ZN4mbed28QUECTEL_BG96_CellularNetwork20get_modem_stack_typeE14nsapi_ip_stack))
<BR>[Address Reference Count : 1]<UL><LI> quectel_bg96_cellularnetwork.o(.constdata__ZTVN4mbed28QUECTEL_BG96_CellularNetworkE)
</UL>
<P><STRONG><a name="[195]"></a>mbed::QUECTEL_BG96_CellularNetwork::get_stack()</STRONG> (Thumb, 44 bytes, Stack size 16 bytes, .\build\quectel_bg96_cellularnetwork.o(i._ZN4mbed28QUECTEL_BG96_CellularNetwork9get_stackEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 568 + Unknown Stack Size
<LI>Call Chain = mbed::QUECTEL_BG96_CellularNetwork::get_stack() &rArr; mbed::QUECTEL_BG96_CellularStack::QUECTEL_BG96_CellularStack(mbed::ATHandler&, int, nsapi_ip_stack) &rArr; mbed::ATHandler::set_urc_handler(const char*, mbed::Callback&lang;void()&rang;) &rArr; operator new(unsigned) &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[367]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;operator new(unsigned)
<LI><a href="#[3db]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::QUECTEL_BG96_CellularStack::QUECTEL_BG96_CellularStack(mbed::ATHandler&, int, nsapi_ip_stack)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> quectel_bg96_cellularnetwork.o(.constdata__ZTVN4mbed28QUECTEL_BG96_CellularNetworkE)
</UL>
<P><STRONG><a name="[368]"></a>mbed::QUECTEL_BG96_CellularNetwork::QUECTEL_BG96_CellularNetwork(mbed::ATHandler&)</STRONG> (Thumb, 24 bytes, Stack size 16 bytes, .\build\quectel_bg96_cellularnetwork.o(i._ZN4mbed28QUECTEL_BG96_CellularNetworkC1ERNS_9ATHandlerE))
<BR><BR>[Stack]<UL><LI>Max Depth = 560 + Unknown Stack Size
<LI>Call Chain = mbed::QUECTEL_BG96_CellularNetwork::QUECTEL_BG96_CellularNetwork(mbed::ATHandler&) &rArr; mbed::AT_CellularNetwork::AT_CellularNetwork(mbed::ATHandler&) &rArr; mbed::ATHandler::set_urc_handler(const char*, mbed::Callback&lang;void()&rang;) &rArr; operator new(unsigned) &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[388]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::AT_CellularNetwork(mbed::ATHandler&)
</UL>
<BR>[Called By]<UL><LI><a href="#[15c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::QUECTEL_BG96::open_network(mbed::FileHandle*)
</UL>

<P><STRONG><a name="[767]"></a>mbed::QUECTEL_BG96_CellularNetwork::QUECTEL_BG96_CellularNetwork__sub_object(mbed::ATHandler&)</STRONG> (Thumb, 0 bytes, Stack size 16 bytes, .\build\quectel_bg96_cellularnetwork.o(i._ZN4mbed28QUECTEL_BG96_CellularNetworkC1ERNS_9ATHandlerE), UNUSED)

<P><STRONG><a name="[194]"></a>mbed::QUECTEL_BG96_CellularNetwork::~QUECTEL_BG96_CellularNetwork__deallocating()</STRONG> (Thumb, 18 bytes, Stack size 16 bytes, .\build\quectel_bg96_cellularnetwork.o(i._ZN4mbed28QUECTEL_BG96_CellularNetworkD0Ev))
<BR><BR>[Stack]<UL><LI>Max Depth = 96<LI>Call Chain = mbed::QUECTEL_BG96_CellularNetwork::~QUECTEL_BG96_CellularNetwork__deallocating() &rArr; mbed::QUECTEL_BG96_CellularNetwork::~QUECTEL_BG96_CellularNetwork() &rArr; mbed::AT_CellularNetwork::~AT_CellularNetwork() &rArr; mbed::AT_CellularNetwork::free_credentials() &rArr; free &rArr; _free_internal &rArr; _mutex_release &rArr; os_kernel_is_active &rArr; osKernelGetState &rArr; svcRtxKernelGetState
</UL>
<BR>[Calls]<UL><LI><a href="#[37e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;operator delete (void*)
<LI><a href="#[193]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::QUECTEL_BG96_CellularNetwork::~QUECTEL_BG96_CellularNetwork()
</UL>
<BR>[Address Reference Count : 1]<UL><LI> quectel_bg96_cellularnetwork.o(.constdata__ZTVN4mbed28QUECTEL_BG96_CellularNetworkE)
</UL>
<P><STRONG><a name="[193]"></a>mbed::QUECTEL_BG96_CellularNetwork::~QUECTEL_BG96_CellularNetwork()</STRONG> (Thumb, 16 bytes, Stack size 8 bytes, .\build\quectel_bg96_cellularnetwork.o(i._ZN4mbed28QUECTEL_BG96_CellularNetworkD1Ev))
<BR><BR>[Stack]<UL><LI>Max Depth = 80<LI>Call Chain = mbed::QUECTEL_BG96_CellularNetwork::~QUECTEL_BG96_CellularNetwork() &rArr; mbed::AT_CellularNetwork::~AT_CellularNetwork() &rArr; mbed::AT_CellularNetwork::free_credentials() &rArr; free &rArr; _free_internal &rArr; _mutex_release &rArr; os_kernel_is_active &rArr; osKernelGetState &rArr; svcRtxKernelGetState
</UL>
<BR>[Calls]<UL><LI><a href="#[178]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::~AT_CellularNetwork()
</UL>
<BR>[Called By]<UL><LI><a href="#[194]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::QUECTEL_BG96_CellularNetwork::~QUECTEL_BG96_CellularNetwork__deallocating()
</UL>
<BR>[Address Reference Count : 1]<UL><LI> quectel_bg96_cellularnetwork.o(.constdata__ZTVN4mbed28QUECTEL_BG96_CellularNetworkE)
</UL>
<P><STRONG><a name="[768]"></a>mbed::QUECTEL_BG96_CellularNetwork::~QUECTEL_BG96_CellularNetwork__sub_object()</STRONG> (Thumb, 0 bytes, Stack size 8 bytes, .\build\quectel_bg96_cellularnetwork.o(i._ZN4mbed28QUECTEL_BG96_CellularNetworkD1Ev), UNUSED)

<P><STRONG><a name="[2e2]"></a>mbed::mbed_target_override_console(int)</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, .\build\mbed_retarget.o(i._ZN4mbed28mbed_target_override_consoleEi))
<BR><BR>[Called By]<UL><LI><a href="#[2e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;get_console(int)
</UL>

<P><STRONG><a name="[363]"></a>mbed::poll(mbed::pollfh*, unsigned, int)</STRONG> (Thumb, 156 bytes, Stack size 72 bytes, .\build\mbed_poll.o(i._ZN4mbed4pollEPNS_6pollfhEji))
<BR><BR>[Stack]<UL><LI>Max Depth = 544 + Unknown Stack Size
<LI>Call Chain = mbed::poll(mbed::pollfh*, unsigned, int) &rArr; mbed::Timer::~Timer() &rArr; sleep_manager_unlock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[59]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Timer::~Timer()
<LI><a href="#[306]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Timer::Timer()
<LI><a href="#[316]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Timer::read_ms()
<LI><a href="#[308]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Timer::start()
<LI><a href="#[35e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Thread::wait(unsigned)
</UL>
<BR>[Called By]<UL><LI><a href="#[405]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::write(const void*, unsigned)
<LI><a href="#[55]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ppp_input()
<LI><a href="#[a3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ppp_output(ppp_pcb_s*, unsigned char*, unsigned, void*)
</UL>

<P><STRONG><a name="[3de]"></a>mbed::Timer::read_high_resolution_us()</STRONG> (Thumb, 34 bytes, Stack size 16 bytes, .\build\timer.o(i._ZN4mbed5Timer23read_high_resolution_usEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 224<LI>Call Chain = mbed::Timer::read_high_resolution_us() &rArr; mbed::Timer::slicetime() &rArr; ticker_read_us &rArr; initialize &rArr;  mbed_assert_internal (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[311]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;core_util_critical_section_exit
<LI><a href="#[30c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;core_util_critical_section_enter
<LI><a href="#[3df]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Timer::slicetime()
</UL>
<BR>[Called By]<UL><LI><a href="#[316]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Timer::read_ms()
</UL>

<P><STRONG><a name="[317]"></a>mbed::Timer::reset()</STRONG> (Thumb, 30 bytes, Stack size 8 bytes, .\build\timer.o(i._ZN4mbed5Timer5resetEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 200<LI>Call Chain = mbed::Timer::reset() &rArr; ticker_read_us &rArr; initialize &rArr;  mbed_assert_internal (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[311]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;core_util_critical_section_exit
<LI><a href="#[30c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;core_util_critical_section_enter
<LI><a href="#[3e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ticker_read_us
</UL>
<BR>[Called By]<UL><LI><a href="#[306]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Timer::Timer()
<LI><a href="#[50]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_tick_update()
</UL>

<P><STRONG><a name="[308]"></a>mbed::Timer::start()</STRONG> (Thumb, 40 bytes, Stack size 8 bytes, .\build\timer.o(i._ZN4mbed5Timer5startEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 472 + Unknown Stack Size
<LI>Call Chain = mbed::Timer::start() &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[311]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;core_util_critical_section_exit
<LI><a href="#[30c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;core_util_critical_section_enter
<LI><a href="#[340]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sleep_manager_lock_deep_sleep_internal
<LI><a href="#[3e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ticker_read_us
</UL>
<BR>[Called By]<UL><LI><a href="#[363]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::poll(mbed::pollfh*, unsigned, int)
<LI><a href="#[c6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::process_oob()
<LI><a href="#[3f6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::fill_buffer()
<LI><a href="#[305]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_tick_init()
</UL>

<P><STRONG><a name="[316]"></a>mbed::Timer::read_ms()</STRONG> (Thumb, 24 bytes, Stack size 16 bytes, .\build\timer.o(i._ZN4mbed5Timer7read_msEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 240<LI>Call Chain = mbed::Timer::read_ms() &rArr; mbed::Timer::read_high_resolution_us() &rArr; mbed::Timer::slicetime() &rArr; ticker_read_us &rArr; initialize &rArr;  mbed_assert_internal (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[3de]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Timer::read_high_resolution_us()
<LI><a href="#[3e1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_uldivmod
</UL>
<BR>[Called By]<UL><LI><a href="#[363]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::poll(mbed::pollfh*, unsigned, int)
<LI><a href="#[c6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::process_oob()
<LI><a href="#[3f6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::fill_buffer()
<LI><a href="#[50]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_tick_update()
<LI><a href="#[49d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_tick
</UL>

<P><STRONG><a name="[3df]"></a>mbed::Timer::slicetime()</STRONG> (Thumb, 44 bytes, Stack size 16 bytes, .\build\timer.o(i._ZN4mbed5Timer9slicetimeEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 208<LI>Call Chain = mbed::Timer::slicetime() &rArr; ticker_read_us &rArr; initialize &rArr;  mbed_assert_internal (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[311]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;core_util_critical_section_exit
<LI><a href="#[30c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;core_util_critical_section_enter
<LI><a href="#[3e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ticker_read_us
</UL>
<BR>[Called By]<UL><LI><a href="#[3de]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Timer::read_high_resolution_us()
</UL>

<P><STRONG><a name="[306]"></a>mbed::Timer::Timer()</STRONG> (Thumb, 44 bytes, Stack size 8 bytes, .\build\timer.o(i._ZN4mbed5TimerC1Ev))
<BR><BR>[Stack]<UL><LI>Max Depth = 208<LI>Call Chain = mbed::Timer::Timer() &rArr; mbed::Timer::reset() &rArr; ticker_read_us &rArr; initialize &rArr;  mbed_assert_internal (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[317]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Timer::reset()
<LI><a href="#[354]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;get_us_ticker_data
</UL>
<BR>[Called By]<UL><LI><a href="#[1d5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__sti___17_arm_hal_timer_cpp_749a681d
<LI><a href="#[363]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::poll(mbed::pollfh*, unsigned, int)
<LI><a href="#[c6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::process_oob()
<LI><a href="#[3f6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::fill_buffer()
<LI><a href="#[305]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_tick_init()
</UL>

<P><STRONG><a name="[769]"></a>mbed::Timer::Timer__sub_object()</STRONG> (Thumb, 0 bytes, Stack size 8 bytes, .\build\timer.o(i._ZN4mbed5TimerC1Ev), UNUSED)

<P><STRONG><a name="[59]"></a>mbed::Timer::~Timer()</STRONG> (Thumb, 38 bytes, Stack size 8 bytes, .\build\timer.o(i._ZN4mbed5TimerD1Ev))
<BR><BR>[Stack]<UL><LI>Max Depth = 472 + Unknown Stack Size
<LI>Call Chain = mbed::Timer::~Timer() &rArr; sleep_manager_unlock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[311]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;core_util_critical_section_exit
<LI><a href="#[30c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;core_util_critical_section_enter
<LI><a href="#[33e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sleep_manager_unlock_deep_sleep_internal
</UL>
<BR>[Called By]<UL><LI><a href="#[363]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::poll(mbed::pollfh*, unsigned, int)
<LI><a href="#[c6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::process_oob()
<LI><a href="#[3f6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::fill_buffer()
</UL>
<BR>[Address Reference Count : 1]<UL><LI> arm_hal_timer.o(i.__sti___17_arm_hal_timer_cpp_749a681d)
</UL>
<P><STRONG><a name="[76a]"></a>mbed::Timer::~Timer__sub_object()</STRONG> (Thumb, 0 bytes, Stack size 8 bytes, .\build\timer.o(i._ZN4mbed5TimerD1Ev), UNUSED)

<P><STRONG><a name="[197]"></a>mbed::Serial::lock()</STRONG> (Thumb, 18 bytes, Stack size 8 bytes, .\build\serial.o(i._ZN4mbed6Serial4lockEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = mbed::Serial::lock() &rArr; rtos::Mutex::lock(unsigned) &rArr; osMutexAcquire
</UL>
<BR>[Calls]<UL><LI><a href="#[2e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Mutex::lock(unsigned)
</UL>
<BR>[Called By]<UL><LI><a href="#[1a3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;thunk{-212} to mbed::Serial::lock()
</UL>
<BR>[Address Reference Count : 1]<UL><LI> serial.o(.constdata__ZTVN4mbed6SerialE)
</UL>
<P><STRONG><a name="[199]"></a>mbed::Serial::_getc()</STRONG> (Thumb, 12 bytes, Stack size 8 bytes, .\build\serial.o(i._ZN4mbed6Serial5_getcEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = mbed::Serial::_getc() &rArr; mbed::SerialBase::_base_getc() &rArr; serial_getc
</UL>
<BR>[Calls]<UL><LI><a href="#[337]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::SerialBase::_base_getc()
</UL>
<BR>[Called By]<UL><LI><a href="#[1a2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;thunk{-212} to mbed::Serial::_getc()
</UL>
<BR>[Address Reference Count : 1]<UL><LI> serial.o(.constdata__ZTVN4mbed6SerialE)
</UL>
<P><STRONG><a name="[19a]"></a>mbed::Serial::_putc(int)</STRONG> (Thumb, 16 bytes, Stack size 16 bytes, .\build\serial.o(i._ZN4mbed6Serial5_putcEi))
<BR><BR>[Stack]<UL><LI>Max Depth = 64<LI>Call Chain = mbed::Serial::_putc(int) &rArr; mbed::SerialBase::_base_putc(int) &rArr; serial_putc &rArr; LEUART_Tx
</UL>
<BR>[Calls]<UL><LI><a href="#[338]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::SerialBase::_base_putc(int)
</UL>
<BR>[Called By]<UL><LI><a href="#[1a1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;thunk{-212} to mbed::Serial::_putc(int)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> serial.o(.constdata__ZTVN4mbed6SerialE)
</UL>
<P><STRONG><a name="[198]"></a>mbed::Serial::unlock()</STRONG> (Thumb, 14 bytes, Stack size 8 bytes, .\build\serial.o(i._ZN4mbed6Serial6unlockEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = mbed::Serial::unlock() &rArr; rtos::Mutex::unlock() &rArr; osMutexRelease
</UL>
<BR>[Calls]<UL><LI><a href="#[2e9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Mutex::unlock()
</UL>
<BR>[Called By]<UL><LI><a href="#[1a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;thunk{-212} to mbed::Serial::unlock()
</UL>
<BR>[Address Reference Count : 1]<UL><LI> serial.o(.constdata__ZTVN4mbed6SerialE)
</UL>
<P><STRONG><a name="[3e2]"></a>mbed::Serial::Serial(PinName, PinName, const char*, int)</STRONG> (Thumb, 84 bytes, Stack size 24 bytes, .\build\serial.o(i._ZN4mbed6SerialC1E7PinNameS1_PKci))
<BR><BR>[Stack]<UL><LI>Max Depth = 848 + Unknown Stack Size
<LI>Call Chain = mbed::Serial::Serial(PinName, PinName, const char*, int) &rArr; mbed::Stream::Stream__sub_object(const char*) &rArr; mbed::fdopen(mbed::FileHandle*, const char*) &rArr; fdopen &rArr; fopen &rArr; _freopen_locked &rArr; _sys_open &rArr; open &rArr; mbed::FilePath::FilePath(const char*) &rArr; mbed::FileBase::lookup(const char*, unsigned) &rArr; SingletonPtr&lang;rtos::Mutex&rang;::operator -&rang;() &rArr; SingletonPtr&lang;rtos::Mutex&rang;::get() &rArr; rtos::Mutex::Mutex() &rArr; rtos::Mutex::constructor(const char*) &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[361]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Mutex::Mutex()
<LI><a href="#[347]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::SerialBase::SerialBase(PinName, PinName, int)
<LI><a href="#[3e3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Stream::Stream__sub_object(const char*)
</UL>
<BR>[Called By]<UL><LI><a href="#[1d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__sti___8_main_cpp_led0
</UL>

<P><STRONG><a name="[76b]"></a>mbed::Serial::Serial__sub_object(PinName, PinName, const char*, int)</STRONG> (Thumb, 0 bytes, Stack size 24 bytes, .\build\serial.o(i._ZN4mbed6SerialC1E7PinNameS1_PKci), UNUSED)

<P><STRONG><a name="[5d]"></a>mbed::Serial::~Serial()</STRONG> (Thumb, 58 bytes, Stack size 8 bytes, .\build\serial.o(i._ZN4mbed6SerialD1Ev))
<BR><BR>[Stack]<UL><LI>Max Depth = 648 + Unknown Stack Size
<LI>Call Chain = mbed::Serial::~Serial() &rArr; mbed::Stream::~Stream__sub_object() &rArr; mbed::FileLike::~FileLike__sub_object() &rArr; mbed::FileBase::~FileBase() &rArr; mbed::remove_filehandle(mbed::FileHandle*) &rArr; SingletonPtr&lang;rtos::Mutex&rang;::operator -&rang;() &rArr; SingletonPtr&lang;rtos::Mutex&rang;::get() &rArr; rtos::Mutex::Mutex() &rArr; rtos::Mutex::constructor(const char*) &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[5f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Mutex::~Mutex()
<LI><a href="#[145]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::SerialBase::~SerialBase()
<LI><a href="#[1a5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Stream::~Stream__sub_object()
</UL>
<BR>[Address Reference Count : 2]<UL><LI> serial.o(.constdata__ZTVN4mbed6SerialE)
<LI> main.o(i.__sti___8_main_cpp_led0)
</UL>
<P><STRONG><a name="[76c]"></a>mbed::Serial::~Serial__sub_object()</STRONG> (Thumb, 0 bytes, Stack size 8 bytes, .\build\serial.o(i._ZN4mbed6SerialD1Ev), UNUSED)

<P><STRONG><a name="[1a6]"></a>mbed::Stream::lock()</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\stream.o(i._ZN4mbed6Stream4lockEv))
<BR>[Address Reference Count : 1]<UL><LI> stream.o(.constdata__ZTVN4mbed6StreamE)
</UL>
<P><STRONG><a name="[19b]"></a>mbed::Stream::read(void*, unsigned)</STRONG> (Thumb, 70 bytes, Stack size 32 bytes, .\build\stream.o(i._ZN4mbed6Stream4readEPvj))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = mbed::Stream::read(void*, unsigned)
</UL>
<BR>[Address Reference Count : 2]<UL><LI> serial.o(.constdata__ZTVN4mbed6SerialE)
<LI> stream.o(.constdata__ZTVN4mbed6StreamE)
</UL>
<P><STRONG><a name="[19d]"></a>mbed::Stream::seek(long, int)</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, .\build\stream.o(i._ZN4mbed6Stream4seekEli))
<BR>[Address Reference Count : 2]<UL><LI> serial.o(.constdata__ZTVN4mbed6SerialE)
<LI> stream.o(.constdata__ZTVN4mbed6StreamE)
</UL>
<P><STRONG><a name="[1a0]"></a>mbed::Stream::size()</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, .\build\stream.o(i._ZN4mbed6Stream4sizeEv))
<BR>[Address Reference Count : 2]<UL><LI> serial.o(.constdata__ZTVN4mbed6SerialE)
<LI> stream.o(.constdata__ZTVN4mbed6StreamE)
</UL>
<P><STRONG><a name="[19e]"></a>mbed::Stream::close()</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, .\build\stream.o(i._ZN4mbed6Stream5closeEv))
<BR>[Address Reference Count : 2]<UL><LI> serial.o(.constdata__ZTVN4mbed6SerialE)
<LI> stream.o(.constdata__ZTVN4mbed6StreamE)
</UL>
<P><STRONG><a name="[19c]"></a>mbed::Stream::write(const void*, unsigned)</STRONG> (Thumb, 64 bytes, Stack size 24 bytes, .\build\stream.o(i._ZN4mbed6Stream5writeEPKvj))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = mbed::Stream::write(const void*, unsigned)
</UL>
<BR>[Address Reference Count : 2]<UL><LI> serial.o(.constdata__ZTVN4mbed6SerialE)
<LI> stream.o(.constdata__ZTVN4mbed6StreamE)
</UL>
<P><STRONG><a name="[19f]"></a>mbed::Stream::isatty()</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, .\build\stream.o(i._ZN4mbed6Stream6isattyEv))
<BR>[Address Reference Count : 2]<UL><LI> serial.o(.constdata__ZTVN4mbed6SerialE)
<LI> stream.o(.constdata__ZTVN4mbed6StreamE)
</UL>
<P><STRONG><a name="[1a7]"></a>mbed::Stream::unlock()</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\stream.o(i._ZN4mbed6Stream6unlockEv))
<BR>[Address Reference Count : 1]<UL><LI> stream.o(.constdata__ZTVN4mbed6StreamE)
</UL>
<P><STRONG><a name="[3e3]"></a>mbed::Stream::Stream__sub_object(const char*)</STRONG> (Thumb, 106 bytes, Stack size 16 bytes, .\build\stream.o(i._ZN4mbed6StreamC2EPKc))
<BR><BR>[Stack]<UL><LI>Max Depth = 824 + Unknown Stack Size
<LI>Call Chain = mbed::Stream::Stream__sub_object(const char*) &rArr; mbed::fdopen(mbed::FileHandle*, const char*) &rArr; fdopen &rArr; fopen &rArr; _freopen_locked &rArr; _sys_open &rArr; open &rArr; mbed::FilePath::FilePath(const char*) &rArr; mbed::FileBase::lookup(const char*, unsigned) &rArr; SingletonPtr&lang;rtos::Mutex&rang;::operator -&rang;() &rArr; SingletonPtr&lang;rtos::Mutex&rang;::get() &rArr; rtos::Mutex::Mutex() &rArr; rtos::Mutex::constructor(const char*) &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[3e6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;error
<LI><a href="#[3e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::FileBase::FileBase(const char*, mbed::PathType)
<LI><a href="#[3e5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::fdopen(mbed::FileHandle*, const char*)
<LI><a href="#[3dd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::mbed_set_unbuffered_stream(std::__FILE*)
<LI><a href="#[218]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_errno_addr
</UL>
<BR>[Called By]<UL><LI><a href="#[3e2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Serial::Serial(PinName, PinName, const char*, int)
</UL>

<P><STRONG><a name="[76d]"></a>mbed::Stream::~Stream()</STRONG> (Thumb, 0 bytes, Stack size 8 bytes, .\build\stream.o(i._ZN4mbed6StreamD2Ev), UNUSED)

<P><STRONG><a name="[1a5]"></a>mbed::Stream::~Stream__sub_object()</STRONG> (Thumb, 36 bytes, Stack size 8 bytes, .\build\stream.o(i._ZN4mbed6StreamD2Ev))
<BR><BR>[Stack]<UL><LI>Max Depth = 640 + Unknown Stack Size
<LI>Call Chain = mbed::Stream::~Stream__sub_object() &rArr; mbed::FileLike::~FileLike__sub_object() &rArr; mbed::FileBase::~FileBase() &rArr; mbed::remove_filehandle(mbed::FileHandle*) &rArr; SingletonPtr&lang;rtos::Mutex&rang;::operator -&rang;() &rArr; SingletonPtr&lang;rtos::Mutex&rang;::get() &rArr; rtos::Mutex::Mutex() &rArr; rtos::Mutex::constructor(const char*) &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[1ab]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::FileLike::~FileLike__sub_object()
<LI><a href="#[23d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fclose
</UL>
<BR>[Called By]<UL><LI><a href="#[5d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Serial::~Serial()
</UL>
<BR>[Address Reference Count : 1]<UL><LI> stream.o(.constdata__ZTVN4mbed6StreamE)
</UL>
<P><STRONG><a name="[3e7]"></a>mbed::Ticker::setup(unsigned long long)</STRONG> (Thumb, 54 bytes, Stack size 24 bytes, .\build\ticker.o(i._ZN4mbed6Ticker5setupEy))
<BR><BR>[Stack]<UL><LI>Max Depth = 216<LI>Call Chain = mbed::Ticker::setup(unsigned long long) &rArr; ticker_read_us &rArr; initialize &rArr;  mbed_assert_internal (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[311]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;core_util_critical_section_exit
<LI><a href="#[30c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;core_util_critical_section_enter
<LI><a href="#[3e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ticker_read_us
<LI><a href="#[350]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::TimerEvent::remove()
<LI><a href="#[34e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::TimerEvent::insert_absolute(unsigned long long)
</UL>
<BR>[Called By]<UL><LI><a href="#[309]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Ticker::attach_us(mbed::Callback&lang;void()&rang;, unsigned long long)
</UL>

<P><STRONG><a name="[3e8]"></a>mbed::Ticker::detach()</STRONG> (Thumb, 158 bytes, Stack size 48 bytes, .\build\ticker.o(i._ZN4mbed6Ticker6detachEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 512 + Unknown Stack Size
<LI>Call Chain = mbed::Ticker::detach() &rArr; sleep_manager_unlock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[311]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;core_util_critical_section_exit
<LI><a href="#[30c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;core_util_critical_section_enter
<LI><a href="#[53]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void()&rang;::~Callback()
<LI><a href="#[339]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void()&rang;::operator bool() const
<LI><a href="#[33e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sleep_manager_unlock_deep_sleep_internal
<LI><a href="#[350]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::TimerEvent::remove()
</UL>
<BR>[Called By]<UL><LI><a href="#[5a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Timeout::~Timeout()
<LI><a href="#[1a9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Timeout::handler()
</UL>

<P><STRONG><a name="[1a8]"></a>mbed::Ticker::handler()</STRONG> (Thumb, 78 bytes, Stack size 16 bytes, .\build\ticker.o(i._ZN4mbed6Ticker7handlerEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 544 + Unknown Stack Size
<LI>Call Chain = mbed::Ticker::handler() &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[33a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_assert_internal
<LI><a href="#[339]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void()&rang;::operator bool() const
<LI><a href="#[34e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::TimerEvent::insert_absolute(unsigned long long)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> ticker.o(.constdata__ZTVN4mbed6TickerE)
</UL>
<P><STRONG><a name="[309]"></a>mbed::Ticker::attach_us(mbed::Callback&lang;void()&rang;, unsigned long long)</STRONG> (Thumb, 110 bytes, Stack size 48 bytes, .\build\arm_hal_timer.o(i._ZN4mbed6Ticker9attach_usENS_8CallbackIFvvEEEy))
<BR><BR>[Stack]<UL><LI>Max Depth = 512 + Unknown Stack Size
<LI>Call Chain = mbed::Ticker::attach_us(mbed::Callback&lang;void()&rang;, unsigned long long) &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[311]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;core_util_critical_section_exit
<LI><a href="#[30c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;core_util_critical_section_enter
<LI><a href="#[3e7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Ticker::setup(unsigned long long)
<LI><a href="#[53]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void()&rang;::~Callback()
<LI><a href="#[340]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sleep_manager_lock_deep_sleep_internal
</UL>
<BR>[Called By]<UL><LI><a href="#[305]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_tick_init()
</UL>

<P><STRONG><a name="[3e5]"></a>mbed::fdopen(mbed::FileHandle*, const char*)</STRONG> (Thumb, 48 bytes, Stack size 24 bytes, .\build\mbed_retarget.o(i._ZN4mbed6fdopenEPNS_10FileHandleEPKc))
<BR><BR>[Stack]<UL><LI>Max Depth = 808 + Unknown Stack Size
<LI>Call Chain = mbed::fdopen(mbed::FileHandle*, const char*) &rArr; fdopen &rArr; fopen &rArr; _freopen_locked &rArr; _sys_open &rArr; open &rArr; mbed::FilePath::FilePath(const char*) &rArr; mbed::FileBase::lookup(const char*, unsigned) &rArr; SingletonPtr&lang;rtos::Mutex&rang;::operator -&rang;() &rArr; SingletonPtr&lang;rtos::Mutex&rang;::get() &rArr; rtos::Mutex::Mutex() &rArr; rtos::Mutex::constructor(const char*) &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[2f7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;unbind_from_fd(int, mbed::FileHandle*)
<LI><a href="#[3e9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fdopen
<LI><a href="#[362]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::bind_to_fd(mbed::FileHandle*)
</UL>
<BR>[Called By]<UL><LI><a href="#[3e3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Stream::Stream__sub_object(const char*)
</UL>

<P><STRONG><a name="[1a9]"></a>mbed::Timeout::handler()</STRONG> (Thumb, 78 bytes, Stack size 32 bytes, .\build\timeout.o(i._ZN4mbed7Timeout7handlerEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 560 + Unknown Stack Size
<LI>Call Chain = mbed::Timeout::handler() &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[33a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_assert_internal
<LI><a href="#[3e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Ticker::detach()
<LI><a href="#[53]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void()&rang;::~Callback()
</UL>
<BR>[Address Reference Count : 1]<UL><LI> timeout.o(.constdata__ZTVN4mbed7TimeoutE)
</UL>
<P><STRONG><a name="[5a]"></a>mbed::Timeout::~Timeout()</STRONG> (Thumb, 56 bytes, Stack size 16 bytes, .\build\arm_hal_timer.o(i._ZN4mbed7TimeoutD1Ev))
<BR><BR>[Stack]<UL><LI>Max Depth = 528 + Unknown Stack Size
<LI>Call Chain = mbed::Timeout::~Timeout() &rArr; mbed::Ticker::detach() &rArr; sleep_manager_unlock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[3e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Ticker::detach()
<LI><a href="#[146]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::TimerEvent::~TimerEvent__sub_object()
<LI><a href="#[53]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void()&rang;::~Callback()
</UL>
<BR>[Address Reference Count : 2]<UL><LI> arm_hal_timer.o(i.__sti___17_arm_hal_timer_cpp_749a681d)
<LI> timeout.o(.constdata__ZTVN4mbed7TimeoutE)
</UL>
<P><STRONG><a name="[76e]"></a>mbed::Timeout::~Timeout__sub_object()</STRONG> (Thumb, 0 bytes, Stack size 16 bytes, .\build\arm_hal_timer.o(i._ZN4mbed7TimeoutD1Ev), UNUSED)

<P><STRONG><a name="[3ec]"></a>mbed::FileBase::getPathType()</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, .\build\filebase.o(i._ZN4mbed8FileBase11getPathTypeEv))
<BR><BR>[Called By]<UL><LI><a href="#[3f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::FilePath::isFile()
<LI><a href="#[3ee]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::FilePath::isFileSystem()
<LI><a href="#[1aa]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::FileBase::~FileBase()
</UL>

<P><STRONG><a name="[3ea]"></a>mbed::FileBase::lookup(const char*, unsigned)</STRONG> (Thumb, 96 bytes, Stack size 24 bytes, .\build\filebase.o(i._ZN4mbed8FileBase6lookupEPKcj))
<BR><BR>[Stack]<UL><LI>Max Depth = 616 + Unknown Stack Size
<LI>Call Chain = mbed::FileBase::lookup(const char*, unsigned) &rArr; SingletonPtr&lang;rtos::Mutex&rang;::operator -&rang;() &rArr; SingletonPtr&lang;rtos::Mutex&rang;::get() &rArr; rtos::Mutex::Mutex() &rArr; rtos::Mutex::constructor(const char*) &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[2e9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Mutex::unlock()
<LI><a href="#[2e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Mutex::lock(unsigned)
<LI><a href="#[31a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SingletonPtr&lang;rtos::Mutex&rang;::operator -&rang;()
<LI><a href="#[3eb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;strncmp
<LI><a href="#[31d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;strlen
</UL>
<BR>[Called By]<UL><LI><a href="#[3f1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::FilePath::FilePath(const char*)
</UL>

<P><STRONG><a name="[3e4]"></a>mbed::FileBase::FileBase(const char*, mbed::PathType)</STRONG> (Thumb, 78 bytes, Stack size 24 bytes, .\build\filebase.o(i._ZN4mbed8FileBaseC1EPKcNS_8PathTypeE))
<BR><BR>[Stack]<UL><LI>Max Depth = 616 + Unknown Stack Size
<LI>Call Chain = mbed::FileBase::FileBase(const char*, mbed::PathType) &rArr; SingletonPtr&lang;rtos::Mutex&rang;::operator -&rang;() &rArr; SingletonPtr&lang;rtos::Mutex&rang;::get() &rArr; rtos::Mutex::Mutex() &rArr; rtos::Mutex::constructor(const char*) &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[2e9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Mutex::unlock()
<LI><a href="#[2e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Mutex::lock(unsigned)
<LI><a href="#[31a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SingletonPtr&lang;rtos::Mutex&rang;::operator -&rang;()
</UL>
<BR>[Called By]<UL><LI><a href="#[3e3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Stream::Stream__sub_object(const char*)
</UL>

<P><STRONG><a name="[76f]"></a>mbed::FileBase::FileBase__sub_object(const char*, mbed::PathType)</STRONG> (Thumb, 0 bytes, Stack size 24 bytes, .\build\filebase.o(i._ZN4mbed8FileBaseC1EPKcNS_8PathTypeE), UNUSED)

<P><STRONG><a name="[1aa]"></a>mbed::FileBase::~FileBase()</STRONG> (Thumb, 100 bytes, Stack size 16 bytes, .\build\filebase.o(i._ZN4mbed8FileBaseD1Ev))
<BR><BR>[Stack]<UL><LI>Max Depth = 624 + Unknown Stack Size
<LI>Call Chain = mbed::FileBase::~FileBase() &rArr; mbed::remove_filehandle(mbed::FileHandle*) &rArr; SingletonPtr&lang;rtos::Mutex&rang;::operator -&rang;() &rArr; SingletonPtr&lang;rtos::Mutex&rang;::get() &rArr; rtos::Mutex::Mutex() &rArr; rtos::Mutex::constructor(const char*) &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[2e9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Mutex::unlock()
<LI><a href="#[2e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Mutex::lock(unsigned)
<LI><a href="#[393]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::remove_filehandle(mbed::FileHandle*)
<LI><a href="#[3ec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::FileBase::getPathType()
<LI><a href="#[31a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SingletonPtr&lang;rtos::Mutex&rang;::operator -&rang;()
</UL>
<BR>[Called By]<UL><LI><a href="#[1ab]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::FileLike::~FileLike__sub_object()
</UL>
<BR>[Address Reference Count : 1]<UL><LI> filebase.o(.constdata__ZTVN4mbed8FileBaseE)
</UL>
<P><STRONG><a name="[770]"></a>mbed::FileBase::~FileBase__sub_object()</STRONG> (Thumb, 0 bytes, Stack size 16 bytes, .\build\filebase.o(i._ZN4mbed8FileBaseD1Ev), UNUSED)

<P><STRONG><a name="[771]"></a>mbed::FileLike::~FileLike()</STRONG> (Thumb, 0 bytes, Stack size 8 bytes, .\build\stream.o(i._ZN4mbed8FileLikeD2Ev), UNUSED)

<P><STRONG><a name="[1ab]"></a>mbed::FileLike::~FileLike__sub_object()</STRONG> (Thumb, 34 bytes, Stack size 8 bytes, .\build\stream.o(i._ZN4mbed8FileLikeD2Ev))
<BR><BR>[Stack]<UL><LI>Max Depth = 632 + Unknown Stack Size
<LI>Call Chain = mbed::FileLike::~FileLike__sub_object() &rArr; mbed::FileBase::~FileBase() &rArr; mbed::remove_filehandle(mbed::FileHandle*) &rArr; SingletonPtr&lang;rtos::Mutex&rang;::operator -&rang;() &rArr; SingletonPtr&lang;rtos::Mutex&rang;::get() &rArr; rtos::Mutex::Mutex() &rArr; rtos::Mutex::constructor(const char*) &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[1aa]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::FileBase::~FileBase()
</UL>
<BR>[Called By]<UL><LI><a href="#[1a5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Stream::~Stream__sub_object()
</UL>
<BR>[Address Reference Count : 1]<UL><LI> stream.o(.constdata__ZTVN4mbed8FileLikeE)
</UL>
<P><STRONG><a name="[3ed]"></a>mbed::FilePath::fileSystem()</STRONG> (Thumb, 30 bytes, Stack size 8 bytes, .\build\filepath.o(i._ZN4mbed8FilePath10fileSystemEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = mbed::FilePath::fileSystem() &rArr; mbed::FilePath::isFileSystem()
</UL>
<BR>[Calls]<UL><LI><a href="#[3ee]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::FilePath::isFileSystem()
</UL>
<BR>[Called By]<UL><LI><a href="#[44c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;open
</UL>

<P><STRONG><a name="[3ee]"></a>mbed::FilePath::isFileSystem()</STRONG> (Thumb, 28 bytes, Stack size 8 bytes, .\build\filepath.o(i._ZN4mbed8FilePath12isFileSystemEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = mbed::FilePath::isFileSystem()
</UL>
<BR>[Calls]<UL><LI><a href="#[3ec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::FileBase::getPathType()
</UL>
<BR>[Called By]<UL><LI><a href="#[3ed]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::FilePath::fileSystem()
</UL>

<P><STRONG><a name="[3ef]"></a>mbed::FilePath::file()</STRONG> (Thumb, 30 bytes, Stack size 8 bytes, .\build\filepath.o(i._ZN4mbed8FilePath4fileEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = mbed::FilePath::file() &rArr; mbed::FilePath::isFile()
</UL>
<BR>[Calls]<UL><LI><a href="#[3f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::FilePath::isFile()
</UL>
<BR>[Called By]<UL><LI><a href="#[44c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;open
</UL>

<P><STRONG><a name="[5ad]"></a>mbed::FilePath::exists()</STRONG> (Thumb, 14 bytes, Stack size 0 bytes, .\build\filepath.o(i._ZN4mbed8FilePath6existsEv))
<BR><BR>[Called By]<UL><LI><a href="#[44c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;open
</UL>

<P><STRONG><a name="[3f0]"></a>mbed::FilePath::isFile()</STRONG> (Thumb, 28 bytes, Stack size 8 bytes, .\build\filepath.o(i._ZN4mbed8FilePath6isFileEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = mbed::FilePath::isFile()
</UL>
<BR>[Calls]<UL><LI><a href="#[3ec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::FileBase::getPathType()
</UL>
<BR>[Called By]<UL><LI><a href="#[3ef]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::FilePath::file()
<LI><a href="#[44c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;open
</UL>

<P><STRONG><a name="[5ae]"></a>mbed::FilePath::fileName()</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, .\build\filepath.o(i._ZN4mbed8FilePath8fileNameEv))
<BR><BR>[Called By]<UL><LI><a href="#[44c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;open
</UL>

<P><STRONG><a name="[3f1]"></a>mbed::FilePath::FilePath(const char*)</STRONG> (Thumb, 98 bytes, Stack size 24 bytes, .\build\filepath.o(i._ZN4mbed8FilePathC1EPKc))
<BR><BR>[Stack]<UL><LI>Max Depth = 640 + Unknown Stack Size
<LI>Call Chain = mbed::FilePath::FilePath(const char*) &rArr; mbed::FileBase::lookup(const char*, unsigned) &rArr; SingletonPtr&lang;rtos::Mutex&rang;::operator -&rang;() &rArr; SingletonPtr&lang;rtos::Mutex&rang;::get() &rArr; rtos::Mutex::Mutex() &rArr; rtos::Mutex::constructor(const char*) &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[33a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_assert_internal
<LI><a href="#[3ea]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::FileBase::lookup(const char*, unsigned)
<LI><a href="#[3f2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;strspn
</UL>
<BR>[Called By]<UL><LI><a href="#[44c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;open
</UL>

<P><STRONG><a name="[772]"></a>mbed::FilePath::FilePath__sub_object(const char*)</STRONG> (Thumb, 0 bytes, Stack size 24 bytes, .\build\filepath.o(i._ZN4mbed8FilePathC1EPKc), UNUSED)

<P><STRONG><a name="[3d9]"></a>mbed::ATHandler::read_bytes(unsigned char*, unsigned)</STRONG> (Thumb, 68 bytes, Stack size 24 bytes, .\build\athandler.o(i._ZN4mbed9ATHandler10read_bytesEPhj))
<BR><BR>[Stack]<UL><LI>Max Depth = 560 + Unknown Stack Size
<LI>Call Chain = mbed::ATHandler::read_bytes(unsigned char*, unsigned) &rArr; mbed::ATHandler::get_char() &rArr; mbed::ATHandler::fill_buffer() &rArr; mbed::Timer::~Timer() &rArr; sleep_manager_unlock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[3f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::set_error(int)
<LI><a href="#[3f3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::get_char()
</UL>
<BR>[Called By]<UL><LI><a href="#[192]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::QUECTEL_BG96_CellularStack::socket_recvfrom_impl(mbed::AT_CellularStack::CellularSocket*, SocketAddress*, void*, unsigned)
</UL>

<P><STRONG><a name="[372]"></a>mbed::ATHandler::resp_start(const char*, bool)</STRONG> (Thumb, 106 bytes, Stack size 16 bytes, .\build\athandler.o(i._ZN4mbed9ATHandler10resp_startEPKcb))
<BR><BR>[Stack]<UL><LI>Max Depth = 696 + Unknown Stack Size
<LI>Call Chain = mbed::ATHandler::resp_start(const char*, bool) &rArr; mbed::ATHandler::resp(const char*, bool) &rArr; mbed::ATHandler::match_error() &rArr; mbed::ATHandler::at_error(bool, mbed::DeviceErrorType) &rArr; mbed::ATHandler::read_int() &rArr; mbed::ATHandler::read_string(char*, unsigned, bool) &rArr; mbed::ATHandler::consume_char(char) &rArr; mbed::ATHandler::get_char() &rArr; mbed::ATHandler::fill_buffer() &rArr; mbed::Timer::~Timer() &rArr; sleep_manager_unlock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[33a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_assert_internal
<LI><a href="#[3f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::set_scope(mbed::ATHandler::ScopeType)
<LI><a href="#[3f9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::resp(const char*, bool)
<LI><a href="#[3f5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::rewind_buffer()
<LI><a href="#[3f6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::fill_buffer()
<LI><a href="#[31d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;strlen
<LI><a href="#[3f7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;strcpy
</UL>
<BR>[Called By]<UL><LI><a href="#[3c6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularInformation::get_info(const char*, char*, unsigned)
<LI><a href="#[167]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularSIM::get_imsi(char*)
<LI><a href="#[165]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularSIM::set_pin(const char*)
<LI><a href="#[166]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularSIM::get_sim_state(mbed::CellularSIM::SimState&)
<LI><a href="#[16d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularPower::set_at_mode()
<LI><a href="#[3a1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::set_context_to_be_activated()
<LI><a href="#[17d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::get_registration_status(mbed::CellularNetwork::RegistrationType, mbed::CellularNetwork::RegistrationStatus&)
<LI><a href="#[39f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::delete_current_context()
<LI><a href="#[39b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::set_registration_urc(bool)
<LI><a href="#[39d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::open_data_channel()
<LI><a href="#[17c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::set_registration(const char*)
<LI><a href="#[398]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::set_new_context(int)
<LI><a href="#[395]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::get_context()
<LI><a href="#[17f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::set_attach(int)
<LI><a href="#[180]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::get_attach(mbed::CellularNetwork::AttachStatus&)
<LI><a href="#[16e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularStack::get_ip_address()
<LI><a href="#[3d6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::QUECTEL_BG96_CellularStack::handle_open_socket_response(int&, int&)
<LI><a href="#[192]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::QUECTEL_BG96_CellularStack::socket_recvfrom_impl(mbed::AT_CellularStack::CellularSocket*, SocketAddress*, void*, unsigned)
<LI><a href="#[191]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::QUECTEL_BG96_CellularStack::socket_sendto_impl(mbed::AT_CellularStack::CellularSocket*, const SocketAddress&, const void*, unsigned)
<LI><a href="#[190]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::QUECTEL_BG96_CellularStack::create_socket_impl(mbed::AT_CellularStack::CellularSocket*)
<LI><a href="#[18f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::QUECTEL_BG96_CellularStack::socket_close_impl(int)
</UL>

<P><STRONG><a name="[3fa]"></a>mbed::ATHandler::set_string(char*, const char*, unsigned)</STRONG> (Thumb, 30 bytes, Stack size 24 bytes, .\build\athandler.o(i._ZN4mbed9ATHandler10set_stringEPcPKcj))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = mbed::ATHandler::set_string(char*, const char*, unsigned)
</UL>
<BR>[Calls]<UL><LI><a href="#[249]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Called By]<UL><LI><a href="#[406]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::set_tag(mbed::ATHandler::tag_t*, const char*)
</UL>

<P><STRONG><a name="[384]"></a>mbed::ATHandler::skip_param(unsigned)</STRONG> (Thumb, 144 bytes, Stack size 24 bytes, .\build\athandler.o(i._ZN4mbed9ATHandler10skip_paramEj))
<BR><BR>[Stack]<UL><LI>Max Depth = 560 + Unknown Stack Size
<LI>Call Chain = mbed::ATHandler::skip_param(unsigned) &rArr; mbed::ATHandler::get_char() &rArr; mbed::ATHandler::fill_buffer() &rArr; mbed::Timer::~Timer() &rArr; sleep_manager_unlock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[3f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::set_error(int)
<LI><a href="#[3f3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::get_char()
</UL>
<BR>[Called By]<UL><LI><a href="#[16e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularStack::get_ip_address()
<LI><a href="#[11c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::QUECTEL_BG96_CellularStack::urc_qiurc()
</UL>

<P><STRONG><a name="[39c]"></a>mbed::ATHandler::clear_error()</STRONG> (Thumb, 16 bytes, Stack size 0 bytes, .\build\athandler.o(i._ZN4mbed9ATHandler11clear_errorEv))
<BR><BR>[Called By]<UL><LI><a href="#[38b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::ATHandler(mbed::FileHandle*, events::EventQueue&, int, const char*)
<LI><a href="#[36e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::lock()
<LI><a href="#[39f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::delete_current_context()
<LI><a href="#[17c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::set_registration(const char*)
</UL>

<P><STRONG><a name="[3f6]"></a>mbed::ATHandler::fill_buffer()</STRONG> (Thumb, 134 bytes, Stack size 56 bytes, .\build\athandler.o(i._ZN4mbed9ATHandler11fill_bufferEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 528 + Unknown Stack Size
<LI>Call Chain = mbed::ATHandler::fill_buffer() &rArr; mbed::Timer::~Timer() &rArr; sleep_manager_unlock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[59]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Timer::~Timer()
<LI><a href="#[306]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Timer::Timer()
<LI><a href="#[3fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Thread::yield()
<LI><a href="#[316]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Timer::read_ms()
<LI><a href="#[308]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Timer::start()
<LI><a href="#[3f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::set_error(int)
<LI><a href="#[3fb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::reset_buffer()
</UL>
<BR>[Called By]<UL><LI><a href="#[372]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::resp_start(const char*, bool)
<LI><a href="#[36f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::flush()
<LI><a href="#[3f3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::get_char()
<LI><a href="#[3f9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::resp(const char*, bool)
<LI><a href="#[c6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::process_oob()
</UL>

<P><STRONG><a name="[3fd]"></a>mbed::ATHandler::match_error()</STRONG> (Thumb, 92 bytes, Stack size 8 bytes, .\build\athandler.o(i._ZN4mbed9ATHandler11match_errorEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 656 + Unknown Stack Size
<LI>Call Chain = mbed::ATHandler::match_error() &rArr; mbed::ATHandler::at_error(bool, mbed::DeviceErrorType) &rArr; mbed::ATHandler::read_int() &rArr; mbed::ATHandler::read_string(char*, unsigned, bool) &rArr; mbed::ATHandler::consume_char(char) &rArr; mbed::ATHandler::get_char() &rArr; mbed::ATHandler::fill_buffer() &rArr; mbed::Timer::~Timer() &rArr; sleep_manager_unlock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[3ff]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::at_error(bool, mbed::DeviceErrorType)
<LI><a href="#[3fe]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::match(const char*, unsigned)
</UL>
<BR>[Called By]<UL><LI><a href="#[3f9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::resp(const char*, bool)
</UL>

<P><STRONG><a name="[c6]"></a>mbed::ATHandler::process_oob()</STRONG> (Thumb, 170 bytes, Stack size 48 bytes, .\build\athandler.o(i._ZN4mbed9ATHandler11process_oobEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 704 + Unknown Stack Size
<LI>Call Chain = mbed::ATHandler::process_oob() &rArr; mbed::ATHandler::unlock() &rArr; int events::EventQueue::call&lang;mbed::Callback&lang;void()&rang;&rang;(T1) &rArr; equeue_post &rArr; equeue_tick &rArr; equeue_tick_init() &rArr; mbed::Ticker::attach_us(mbed::Callback&lang;void()&rang;, unsigned long long) &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[59]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Timer::~Timer()
<LI><a href="#[306]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Timer::Timer()
<LI><a href="#[36e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::lock()
<LI><a href="#[36f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::flush()
<LI><a href="#[381]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::unlock()
<LI><a href="#[400]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::FileHandle::readable() const
<LI><a href="#[3fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Thread::yield()
<LI><a href="#[316]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Timer::read_ms()
<LI><a href="#[308]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Timer::start()
<LI><a href="#[401]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::match_urc()
<LI><a href="#[402]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::mem_str(const char*, unsigned, const char*, unsigned)
<LI><a href="#[403]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::consume_to_tag(const char*, bool)
<LI><a href="#[3f6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::fill_buffer()
</UL>
<BR>[Address Reference Count : 1]<UL><LI> athandler.o(.constdata)
</UL>
<P><STRONG><a name="[373]"></a>mbed::ATHandler::read_string(char*, unsigned, bool)</STRONG> (Thumb, 210 bytes, Stack size 40 bytes, .\build\athandler.o(i._ZN4mbed9ATHandler11read_stringEPcjb))
<BR><BR>[Stack]<UL><LI>Max Depth = 592 + Unknown Stack Size
<LI>Call Chain = mbed::ATHandler::read_string(char*, unsigned, bool) &rArr; mbed::ATHandler::consume_char(char) &rArr; mbed::ATHandler::get_char() &rArr; mbed::ATHandler::fill_buffer() &rArr; mbed::Timer::~Timer() &rArr; sleep_manager_unlock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[3f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::set_error(int)
<LI><a href="#[3f3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::get_char()
<LI><a href="#[404]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::consume_char(char)
</UL>
<BR>[Called By]<UL><LI><a href="#[3c6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularInformation::get_info(const char*, char*, unsigned)
<LI><a href="#[167]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularSIM::get_imsi(char*)
<LI><a href="#[166]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularSIM::get_sim_state(mbed::CellularSIM::SimState&)
<LI><a href="#[394]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::read_int()
<LI><a href="#[17d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::get_registration_status(mbed::CellularNetwork::RegistrationType, mbed::CellularNetwork::RegistrationStatus&)
<LI><a href="#[395]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::get_context()
<LI><a href="#[16e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularStack::get_ip_address()
<LI><a href="#[192]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::QUECTEL_BG96_CellularStack::socket_recvfrom_impl(mbed::AT_CellularStack::CellularSocket*, SocketAddress*, void*, unsigned)
</UL>

<P><STRONG><a name="[3d7]"></a>mbed::ATHandler::write_bytes(const unsigned char*, unsigned)</STRONG> (Thumb, 44 bytes, Stack size 24 bytes, .\build\athandler.o(i._ZN4mbed9ATHandler11write_bytesEPKhj))
<BR><BR>[Stack]<UL><LI>Max Depth = 600 + Unknown Stack Size
<LI>Call Chain = mbed::ATHandler::write_bytes(const unsigned char*, unsigned) &rArr; mbed::ATHandler::write(const void*, unsigned) &rArr; mbed::poll(mbed::pollfh*, unsigned, int) &rArr; mbed::Timer::~Timer() &rArr; sleep_manager_unlock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[405]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::write(const void*, unsigned)
</UL>
<BR>[Called By]<UL><LI><a href="#[191]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::QUECTEL_BG96_CellularStack::socket_sendto_impl(mbed::AT_CellularStack::CellularSocket*, const SocketAddress&, const void*, unsigned)
</UL>

<P><STRONG><a name="[404]"></a>mbed::ATHandler::consume_char(char)</STRONG> (Thumb, 36 bytes, Stack size 16 bytes, .\build\athandler.o(i._ZN4mbed9ATHandler12consume_charEc))
<BR><BR>[Stack]<UL><LI>Max Depth = 552 + Unknown Stack Size
<LI>Call Chain = mbed::ATHandler::consume_char(char) &rArr; mbed::ATHandler::get_char() &rArr; mbed::ATHandler::fill_buffer() &rArr; mbed::Timer::~Timer() &rArr; sleep_manager_unlock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[3f3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::get_char()
</UL>
<BR>[Called By]<UL><LI><a href="#[373]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::read_string(char*, unsigned, bool)
<LI><a href="#[3f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::set_scope(mbed::ATHandler::ScopeType)
</UL>

<P><STRONG><a name="[38c]"></a>mbed::ATHandler::enable_debug(bool)</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, .\build\athandler.o(i._ZN4mbed9ATHandler12enable_debugEb))
<BR><BR>[Called By]<UL><LI><a href="#[163]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularDevice::modem_debug_on(bool)
<LI><a href="#[366]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularDevice::get_at_handler(mbed::FileHandle*)
</UL>

<P><STRONG><a name="[3fb]"></a>mbed::ATHandler::reset_buffer()</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, .\build\athandler.o(i._ZN4mbed9ATHandler12reset_bufferEv))
<BR><BR>[Called By]<UL><LI><a href="#[38b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::ATHandler(mbed::FileHandle*, events::EventQueue&, int, const char*)
<LI><a href="#[36f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::flush()
<LI><a href="#[3f3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::get_char()
<LI><a href="#[3f6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::fill_buffer()
</UL>

<P><STRONG><a name="[3d8]"></a>mbed::ATHandler::set_stop_tag(const char*)</STRONG> (Thumb, 34 bytes, Stack size 16 bytes, .\build\athandler.o(i._ZN4mbed9ATHandler12set_stop_tagEPKc))
<BR><BR>[Stack]<UL><LI>Max Depth = 64<LI>Call Chain = mbed::ATHandler::set_stop_tag(const char*) &rArr; mbed::ATHandler::set_tag(mbed::ATHandler::tag_t*, const char*) &rArr; mbed::ATHandler::set_string(char*, const char*, unsigned)
</UL>
<BR>[Calls]<UL><LI><a href="#[406]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::set_tag(mbed::ATHandler::tag_t*, const char*)
</UL>
<BR>[Called By]<UL><LI><a href="#[191]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::QUECTEL_BG96_CellularStack::socket_sendto_impl(mbed::AT_CellularStack::CellularSocket*, const SocketAddress&, const void*, unsigned)
</UL>

<P><STRONG><a name="[376]"></a>mbed::ATHandler::write_string(const char*, bool)</STRONG> (Thumb, 74 bytes, Stack size 24 bytes, .\build\athandler.o(i._ZN4mbed9ATHandler12write_stringEPKcb))
<BR><BR>[Stack]<UL><LI>Max Depth = 608 + Unknown Stack Size
<LI>Call Chain = mbed::ATHandler::write_string(const char*, bool) &rArr; mbed::ATHandler::check_cmd_send() &rArr; mbed::ATHandler::write(const void*, unsigned) &rArr; mbed::poll(mbed::pollfh*, unsigned, int) &rArr; mbed::Timer::~Timer() &rArr; sleep_manager_unlock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[405]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::write(const void*, unsigned)
<LI><a href="#[407]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::check_cmd_send()
<LI><a href="#[31d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;strlen
</UL>
<BR>[Called By]<UL><LI><a href="#[165]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularSIM::set_pin(const char*)
<LI><a href="#[3a1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::set_context_to_be_activated()
<LI><a href="#[17d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::get_registration_status(mbed::CellularNetwork::RegistrationType, mbed::CellularNetwork::RegistrationStatus&)
<LI><a href="#[39b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::set_registration_urc(bool)
<LI><a href="#[17c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::set_registration(const char*)
<LI><a href="#[398]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::set_new_context(int)
<LI><a href="#[191]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::QUECTEL_BG96_CellularStack::socket_sendto_impl(mbed::AT_CellularStack::CellularSocket*, const SocketAddress&, const void*, unsigned)
<LI><a href="#[190]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::QUECTEL_BG96_CellularStack::create_socket_impl(mbed::AT_CellularStack::CellularSocket*)
</UL>

<P><STRONG><a name="[38e]"></a>mbed::ATHandler::dec_ref_count()</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, .\build\athandler.o(i._ZN4mbed9ATHandler13dec_ref_countEv))
<BR><BR>[Called By]<UL><LI><a href="#[369]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularDevice::release_at_handler(mbed::ATHandler*)
</UL>

<P><STRONG><a name="[38f]"></a>mbed::ATHandler::get_ref_count()</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, .\build\athandler.o(i._ZN4mbed9ATHandler13get_ref_countEv))
<BR><BR>[Called By]<UL><LI><a href="#[369]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularDevice::release_at_handler(mbed::ATHandler*)
</UL>

<P><STRONG><a name="[38a]"></a>mbed::ATHandler::inc_ref_count()</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, .\build\athandler.o(i._ZN4mbed9ATHandler13inc_ref_countEv))
<BR><BR>[Called By]<UL><LI><a href="#[366]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularDevice::get_at_handler(mbed::FileHandle*)
</UL>

<P><STRONG><a name="[3f5]"></a>mbed::ATHandler::rewind_buffer()</STRONG> (Thumb, 44 bytes, Stack size 8 bytes, .\build\athandler.o(i._ZN4mbed9ATHandler13rewind_bufferEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = mbed::ATHandler::rewind_buffer()
</UL>
<BR>[Calls]<UL><LI><a href="#[315]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memmove
</UL>
<BR>[Called By]<UL><LI><a href="#[372]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::resp_start(const char*, bool)
<LI><a href="#[401]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::match_urc()
<LI><a href="#[3fe]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::match(const char*, unsigned)
</UL>

<P><STRONG><a name="[3c7]"></a>mbed::ATHandler::set_delimiter(char)</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, .\build\athandler.o(i._ZN4mbed9ATHandler13set_delimiterEc))
<BR><BR>[Called By]<UL><LI><a href="#[3c6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularInformation::get_info(const char*, char*, unsigned)
</UL>

<P><STRONG><a name="[407]"></a>mbed::ATHandler::check_cmd_send()</STRONG> (Thumb, 50 bytes, Stack size 8 bytes, .\build\athandler.o(i._ZN4mbed9ATHandler14check_cmd_sendEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 584 + Unknown Stack Size
<LI>Call Chain = mbed::ATHandler::check_cmd_send() &rArr; mbed::ATHandler::write(const void*, unsigned) &rArr; mbed::poll(mbed::pollfh*, unsigned, int) &rArr; mbed::Timer::~Timer() &rArr; sleep_manager_unlock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[405]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::write(const void*, unsigned)
</UL>
<BR>[Called By]<UL><LI><a href="#[382]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::write_int(int)
<LI><a href="#[376]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::write_string(const char*, bool)
</UL>

<P><STRONG><a name="[403]"></a>mbed::ATHandler::consume_to_tag(const char*, bool)</STRONG> (Thumb, 82 bytes, Stack size 24 bytes, .\build\athandler.o(i._ZN4mbed9ATHandler14consume_to_tagEPKcb))
<BR><BR>[Stack]<UL><LI>Max Depth = 560 + Unknown Stack Size
<LI>Call Chain = mbed::ATHandler::consume_to_tag(const char*, bool) &rArr; mbed::ATHandler::get_char() &rArr; mbed::ATHandler::fill_buffer() &rArr; mbed::Timer::~Timer() &rArr; sleep_manager_unlock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[3f3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::get_char()
<LI><a href="#[31d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;strlen
</UL>
<BR>[Called By]<UL><LI><a href="#[409]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::consume_to_stop_tag()
<LI><a href="#[3f9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::resp(const char*, bool)
<LI><a href="#[c6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::process_oob()
</UL>

<P><STRONG><a name="[40f]"></a>mbed::ATHandler::set_3gpp_error(int, mbed::DeviceErrorType)</STRONG> (Thumb, 58 bytes, Stack size 8 bytes, .\build\athandler.o(i._ZN4mbed9ATHandler14set_3gpp_errorEiNS_15DeviceErrorTypeE))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = mbed::ATHandler::set_3gpp_error(int, mbed::DeviceErrorType)
</UL>
<BR>[Called By]<UL><LI><a href="#[3ff]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::at_error(bool, mbed::DeviceErrorType)
</UL>

<P><STRONG><a name="[387]"></a>mbed::ATHandler::set_at_timeout(unsigned, bool)</STRONG> (Thumb, 22 bytes, Stack size 0 bytes, .\build\athandler.o(i._ZN4mbed9ATHandler14set_at_timeoutEjb))
<BR><BR>[Called By]<UL><LI><a href="#[162]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularDevice::set_timeout(int)
<LI><a href="#[3d6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::QUECTEL_BG96_CellularStack::handle_open_socket_response(int&, int&)
</UL>

<P><STRONG><a name="[389]"></a>mbed::ATHandler::get_file_handle()</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, .\build\athandler.o(i._ZN4mbed9ATHandler15get_file_handleEv))
<BR><BR>[Called By]<UL><LI><a href="#[366]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularDevice::get_at_handler(mbed::FileHandle*)
<LI><a href="#[39d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::open_data_channel()
</UL>

<P><STRONG><a name="[3a4]"></a>mbed::ATHandler::set_urc_handler(const char*, mbed::Callback&lang;void()&rang;)</STRONG> (Thumb, 196 bytes, Stack size 40 bytes, .\build\athandler.o(i._ZN4mbed9ATHandler15set_urc_handlerEPKcNS_8CallbackIFvvEEE))
<BR><BR>[Stack]<UL><LI>Max Depth = 512 + Unknown Stack Size
<LI>Call Chain = mbed::ATHandler::set_urc_handler(const char*, mbed::Callback&lang;void()&rang;) &rArr; operator new(unsigned) &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[367]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;operator new(unsigned)
<LI><a href="#[53]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void()&rang;::~Callback()
<LI><a href="#[408]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void()&rang;::Callback(const mbed::Callback&lang;void()&rang;&)
<LI><a href="#[31d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;strlen
</UL>
<BR>[Called By]<UL><LI><a href="#[388]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::AT_CellularNetwork(mbed::ATHandler&)
<LI><a href="#[3db]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::QUECTEL_BG96_CellularStack::QUECTEL_BG96_CellularStack(mbed::ATHandler&, int, nsapi_ip_stack)
</UL>

<P><STRONG><a name="[3da]"></a>mbed::ATHandler::restore_at_timeout()</STRONG> (Thumb, 14 bytes, Stack size 0 bytes, .\build\athandler.o(i._ZN4mbed9ATHandler18restore_at_timeoutEv))
<BR><BR>[Called By]<UL><LI><a href="#[3d6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::QUECTEL_BG96_CellularStack::handle_open_socket_response(int&, int&)
</UL>

<P><STRONG><a name="[409]"></a>mbed::ATHandler::consume_to_stop_tag()</STRONG> (Thumb, 64 bytes, Stack size 8 bytes, .\build\athandler.o(i._ZN4mbed9ATHandler19consume_to_stop_tagEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 568 + Unknown Stack Size
<LI>Call Chain = mbed::ATHandler::consume_to_stop_tag() &rArr; mbed::ATHandler::consume_to_tag(const char*, bool) &rArr; mbed::ATHandler::get_char() &rArr; mbed::ATHandler::fill_buffer() &rArr; mbed::Timer::~Timer() &rArr; sleep_manager_unlock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[3f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::set_error(int)
<LI><a href="#[403]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::consume_to_tag(const char*, bool)
</UL>
<BR>[Called By]<UL><LI><a href="#[374]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::resp_stop()
<LI><a href="#[40d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::information_response_element_stop()
<LI><a href="#[40c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::information_response_stop()
</UL>

<P><STRONG><a name="[375]"></a>mbed::ATHandler::unlock_return_error()</STRONG> (Thumb, 16 bytes, Stack size 16 bytes, .\build\athandler.o(i._ZN4mbed9ATHandler19unlock_return_errorEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 672 + Unknown Stack Size
<LI>Call Chain = mbed::ATHandler::unlock_return_error() &rArr; mbed::ATHandler::unlock() &rArr; int events::EventQueue::call&lang;mbed::Callback&lang;void()&rang;&rang;(T1) &rArr; equeue_post &rArr; equeue_tick &rArr; equeue_tick_init() &rArr; mbed::Ticker::attach_us(mbed::Callback&lang;void()&rang;, unsigned long long) &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[381]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::unlock()
</UL>
<BR>[Called By]<UL><LI><a href="#[3c6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularInformation::get_info(const char*, char*, unsigned)
<LI><a href="#[167]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularSIM::get_imsi(char*)
<LI><a href="#[165]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularSIM::set_pin(const char*)
<LI><a href="#[166]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularSIM::get_sim_state(mbed::CellularSIM::SimState&)
<LI><a href="#[16d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularPower::set_at_mode()
<LI><a href="#[17c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::set_registration(const char*)
<LI><a href="#[17f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::set_attach(int)
<LI><a href="#[180]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::get_attach(mbed::CellularNetwork::AttachStatus&)
</UL>

<P><STRONG><a name="[40a]"></a>mbed::ATHandler::set_filehandle_sigio()</STRONG> (Thumb, 54 bytes, Stack size 32 bytes, .\build\athandler.o(i._ZN4mbed9ATHandler20set_filehandle_sigioEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 88<LI>Call Chain = mbed::ATHandler::set_filehandle_sigio() &rArr; mbed::Callback&lang;void()&rang;::Callback&lang;mbed::ATHandler, mbed::ATHandler&rang;(T2*, void(T1::*)())
</UL>
<BR>[Calls]<UL><LI><a href="#[53]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void()&rang;::~Callback()
<LI><a href="#[40b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void()&rang;::Callback&lang;mbed::ATHandler, mbed::ATHandler&rang;(T2*, void(T1::*)())
</UL>
<BR>[Called By]<UL><LI><a href="#[38b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::ATHandler(mbed::FileHandle*, events::EventQueue&, int, const char*)
</UL>

<P><STRONG><a name="[3c8]"></a>mbed::ATHandler::set_default_delimiter()</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, .\build\athandler.o(i._ZN4mbed9ATHandler21set_default_delimiterEv))
<BR><BR>[Called By]<UL><LI><a href="#[3c6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularInformation::get_info(const char*, char*, unsigned)
</UL>

<P><STRONG><a name="[40c]"></a>mbed::ATHandler::information_response_stop()</STRONG> (Thumb, 22 bytes, Stack size 8 bytes, .\build\athandler.o(i._ZN4mbed9ATHandler25information_response_stopEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 576 + Unknown Stack Size
<LI>Call Chain = mbed::ATHandler::information_response_stop() &rArr; mbed::ATHandler::consume_to_stop_tag() &rArr; mbed::ATHandler::consume_to_tag(const char*, bool) &rArr; mbed::ATHandler::get_char() &rArr; mbed::ATHandler::fill_buffer() &rArr; mbed::Timer::~Timer() &rArr; sleep_manager_unlock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[409]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::consume_to_stop_tag()
<LI><a href="#[3f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::set_scope(mbed::ATHandler::ScopeType)
</UL>
<BR>[Called By]<UL><LI><a href="#[374]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::resp_stop()
<LI><a href="#[383]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::info_resp()
<LI><a href="#[401]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::match_urc()
</UL>

<P><STRONG><a name="[40d]"></a>mbed::ATHandler::information_response_element_stop()</STRONG> (Thumb, 22 bytes, Stack size 8 bytes, .\build\athandler.o(i._ZN4mbed9ATHandler33information_response_element_stopEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 576 + Unknown Stack Size
<LI>Call Chain = mbed::ATHandler::information_response_element_stop() &rArr; mbed::ATHandler::consume_to_stop_tag() &rArr; mbed::ATHandler::consume_to_tag(const char*, bool) &rArr; mbed::ATHandler::get_char() &rArr; mbed::ATHandler::fill_buffer() &rArr; mbed::Timer::~Timer() &rArr; sleep_manager_unlock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[409]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::consume_to_stop_tag()
<LI><a href="#[3f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::set_scope(mbed::ATHandler::ScopeType)
</UL>
<BR>[Called By]<UL><LI><a href="#[374]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::resp_stop()
</UL>

<P><STRONG><a name="[36e]"></a>mbed::ATHandler::lock()</STRONG> (Thumb, 28 bytes, Stack size 8 bytes, .\build\athandler.o(i._ZN4mbed9ATHandler4lockEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = mbed::ATHandler::lock() &rArr; rtos::Mutex::lock(unsigned) &rArr; osMutexAcquire
</UL>
<BR>[Calls]<UL><LI><a href="#[39c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::clear_error()
<LI><a href="#[2e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Mutex::lock(unsigned)
</UL>
<BR>[Called By]<UL><LI><a href="#[3c6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularInformation::get_info(const char*, char*, unsigned)
<LI><a href="#[167]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularSIM::get_imsi(char*)
<LI><a href="#[165]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularSIM::set_pin(const char*)
<LI><a href="#[166]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularSIM::get_sim_state(mbed::CellularSIM::SimState&)
<LI><a href="#[16d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularPower::set_at_mode()
<LI><a href="#[17a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::connect()
<LI><a href="#[17d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::get_registration_status(mbed::CellularNetwork::RegistrationType, mbed::CellularNetwork::RegistrationStatus&)
<LI><a href="#[17c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::set_registration(const char*)
<LI><a href="#[17f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::set_attach(int)
<LI><a href="#[180]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::get_attach(mbed::CellularNetwork::AttachStatus&)
<LI><a href="#[175]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularStack::socket_recvfrom(void*, SocketAddress*, void*, unsigned)
<LI><a href="#[16e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularStack::get_ip_address()
<LI><a href="#[174]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularStack::socket_sendto(void*, const SocketAddress&, const void*, unsigned)
<LI><a href="#[170]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularStack::socket_close(void*)
<LI><a href="#[c6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::process_oob()
<LI><a href="#[11c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::QUECTEL_BG96_CellularStack::urc_qiurc()
</UL>

<P><STRONG><a name="[3f9]"></a>mbed::ATHandler::resp(const char*, bool)</STRONG> (Thumb, 218 bytes, Stack size 24 bytes, .\build\athandler.o(i._ZN4mbed9ATHandler4respEPKcb))
<BR><BR>[Stack]<UL><LI>Max Depth = 680 + Unknown Stack Size
<LI>Call Chain = mbed::ATHandler::resp(const char*, bool) &rArr; mbed::ATHandler::match_error() &rArr; mbed::ATHandler::at_error(bool, mbed::DeviceErrorType) &rArr; mbed::ATHandler::read_int() &rArr; mbed::ATHandler::read_string(char*, unsigned, bool) &rArr; mbed::ATHandler::consume_char(char) &rArr; mbed::ATHandler::get_char() &rArr; mbed::ATHandler::fill_buffer() &rArr; mbed::Timer::~Timer() &rArr; sleep_manager_unlock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[399]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::get_last_error() const
<LI><a href="#[3f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::set_scope(mbed::ATHandler::ScopeType)
<LI><a href="#[401]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::match_urc()
<LI><a href="#[402]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::mem_str(const char*, unsigned, const char*, unsigned)
<LI><a href="#[3fe]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::match(const char*, unsigned)
<LI><a href="#[403]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::consume_to_tag(const char*, bool)
<LI><a href="#[3fd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::match_error()
<LI><a href="#[3f6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::fill_buffer()
<LI><a href="#[31d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;strlen
</UL>
<BR>[Called By]<UL><LI><a href="#[372]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::resp_start(const char*, bool)
<LI><a href="#[383]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::info_resp()
</UL>

<P><STRONG><a name="[c7]"></a>mbed::ATHandler::event()</STRONG> (Thumb, 50 bytes, Stack size 32 bytes, .\build\athandler.o(i._ZN4mbed9ATHandler5eventEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 656 + Unknown Stack Size
<LI>Call Chain = mbed::ATHandler::event() &rArr; int events::EventQueue::call&lang;mbed::Callback&lang;void()&rang;&rang;(T1) &rArr; equeue_post &rArr; equeue_tick &rArr; equeue_tick_init() &rArr; mbed::Ticker::attach_us(mbed::Callback&lang;void()&rang;, unsigned long long) &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[53]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void()&rang;::~Callback()
<LI><a href="#[40e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;int events::EventQueue::call&lang;mbed::Callback&lang;void()&rang;&rang;(T1)
<LI><a href="#[40b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void()&rang;::Callback&lang;mbed::ATHandler, mbed::ATHandler&rang;(T2*, void(T1::*)())
</UL>
<BR>[Address Reference Count : 1]<UL><LI> athandler.o(.constdata)
</UL>
<P><STRONG><a name="[36f]"></a>mbed::ATHandler::flush()</STRONG> (Thumb, 36 bytes, Stack size 8 bytes, .\build\athandler.o(i._ZN4mbed9ATHandler5flushEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 536 + Unknown Stack Size
<LI>Call Chain = mbed::ATHandler::flush() &rArr; mbed::ATHandler::fill_buffer() &rArr; mbed::Timer::~Timer() &rArr; sleep_manager_unlock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[400]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::FileHandle::readable() const
<LI><a href="#[3fb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::reset_buffer()
<LI><a href="#[3f6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::fill_buffer()
</UL>
<BR>[Called By]<UL><LI><a href="#[166]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularSIM::get_sim_state(mbed::CellularSIM::SimState&)
<LI><a href="#[16d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularPower::set_at_mode()
<LI><a href="#[c6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::process_oob()
</UL>

<P><STRONG><a name="[3fe]"></a>mbed::ATHandler::match(const char*, unsigned)</STRONG> (Thumb, 62 bytes, Stack size 16 bytes, .\build\athandler.o(i._ZN4mbed9ATHandler5matchEPKcj))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = mbed::ATHandler::match(const char*, unsigned) &rArr; mbed::ATHandler::rewind_buffer()
</UL>
<BR>[Calls]<UL><LI><a href="#[3f5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::rewind_buffer()
<LI><a href="#[323]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memcmp
</UL>
<BR>[Called By]<UL><LI><a href="#[401]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::match_urc()
<LI><a href="#[3f9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::resp(const char*, bool)
<LI><a href="#[3fd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::match_error()
</UL>

<P><STRONG><a name="[405]"></a>mbed::ATHandler::write(const void*, unsigned)</STRONG> (Thumb, 88 bytes, Stack size 32 bytes, .\build\athandler.o(i._ZN4mbed9ATHandler5writeEPKvj))
<BR><BR>[Stack]<UL><LI>Max Depth = 576 + Unknown Stack Size
<LI>Call Chain = mbed::ATHandler::write(const void*, unsigned) &rArr; mbed::poll(mbed::pollfh*, unsigned, int) &rArr; mbed::Timer::~Timer() &rArr; sleep_manager_unlock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[363]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::poll(mbed::pollfh*, unsigned, int)
<LI><a href="#[3f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::set_error(int)
</UL>
<BR>[Called By]<UL><LI><a href="#[370]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::cmd_start(const char*)
<LI><a href="#[371]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::cmd_stop()
<LI><a href="#[382]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::write_int(int)
<LI><a href="#[376]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::write_string(const char*, bool)
<LI><a href="#[3d7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::write_bytes(const unsigned char*, unsigned)
<LI><a href="#[407]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::check_cmd_send()
</UL>

<P><STRONG><a name="[381]"></a>mbed::ATHandler::unlock()</STRONG> (Thumb, 66 bytes, Stack size 32 bytes, .\build\athandler.o(i._ZN4mbed9ATHandler6unlockEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 656 + Unknown Stack Size
<LI>Call Chain = mbed::ATHandler::unlock() &rArr; int events::EventQueue::call&lang;mbed::Callback&lang;void()&rang;&rang;(T1) &rArr; equeue_post &rArr; equeue_tick &rArr; equeue_tick_init() &rArr; mbed::Ticker::attach_us(mbed::Callback&lang;void()&rang;, unsigned long long) &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[53]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void()&rang;::~Callback()
<LI><a href="#[400]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::FileHandle::readable() const
<LI><a href="#[40e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;int events::EventQueue::call&lang;mbed::Callback&lang;void()&rang;&rang;(T1)
<LI><a href="#[40b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void()&rang;::Callback&lang;mbed::ATHandler, mbed::ATHandler&rang;(T2*, void(T1::*)())
<LI><a href="#[2e9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Mutex::unlock()
</UL>
<BR>[Called By]<UL><LI><a href="#[375]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::unlock_return_error()
<LI><a href="#[17a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::connect()
<LI><a href="#[17d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::get_registration_status(mbed::CellularNetwork::RegistrationType, mbed::CellularNetwork::RegistrationStatus&)
<LI><a href="#[175]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularStack::socket_recvfrom(void*, SocketAddress*, void*, unsigned)
<LI><a href="#[16e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularStack::get_ip_address()
<LI><a href="#[174]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularStack::socket_sendto(void*, const SocketAddress&, const void*, unsigned)
<LI><a href="#[170]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularStack::socket_close(void*)
<LI><a href="#[c6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::process_oob()
<LI><a href="#[11c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::QUECTEL_BG96_CellularStack::urc_qiurc()
</UL>

<P><STRONG><a name="[402]"></a>mbed::ATHandler::mem_str(const char*, unsigned, const char*, unsigned)</STRONG> (Thumb, 54 bytes, Stack size 32 bytes, .\build\athandler.o(i._ZN4mbed9ATHandler7mem_strEPKcjS2_j))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = mbed::ATHandler::mem_str(const char*, unsigned, const char*, unsigned) &rArr; memcmp
</UL>
<BR>[Calls]<UL><LI><a href="#[323]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memcmp
</UL>
<BR>[Called By]<UL><LI><a href="#[3f9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::resp(const char*, bool)
<LI><a href="#[c6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::process_oob()
</UL>

<P><STRONG><a name="[406]"></a>mbed::ATHandler::set_tag(mbed::ATHandler::tag_t*, const char*)</STRONG> (Thumb, 50 bytes, Stack size 24 bytes, .\build\athandler.o(i._ZN4mbed9ATHandler7set_tagEPNS0_5tag_tEPKc))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = mbed::ATHandler::set_tag(mbed::ATHandler::tag_t*, const char*) &rArr; mbed::ATHandler::set_string(char*, const char*, unsigned)
</UL>
<BR>[Calls]<UL><LI><a href="#[3fa]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::set_string(char*, const char*, unsigned)
<LI><a href="#[31d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;strlen
</UL>
<BR>[Called By]<UL><LI><a href="#[38b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::ATHandler(mbed::FileHandle*, events::EventQueue&, int, const char*)
<LI><a href="#[374]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::resp_stop()
<LI><a href="#[3d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::set_stop_tag(const char*)
</UL>

<P><STRONG><a name="[3ff]"></a>mbed::ATHandler::at_error(bool, mbed::DeviceErrorType)</STRONG> (Thumb, 72 bytes, Stack size 24 bytes, .\build\athandler.o(i._ZN4mbed9ATHandler8at_errorEbNS_15DeviceErrorTypeE))
<BR><BR>[Stack]<UL><LI>Max Depth = 648 + Unknown Stack Size
<LI>Call Chain = mbed::ATHandler::at_error(bool, mbed::DeviceErrorType) &rArr; mbed::ATHandler::read_int() &rArr; mbed::ATHandler::read_string(char*, unsigned, bool) &rArr; mbed::ATHandler::consume_char(char) &rArr; mbed::ATHandler::get_char() &rArr; mbed::ATHandler::fill_buffer() &rArr; mbed::Timer::~Timer() &rArr; sleep_manager_unlock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[394]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::read_int()
<LI><a href="#[3f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::set_scope(mbed::ATHandler::ScopeType)
<LI><a href="#[40f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::set_3gpp_error(int, mbed::DeviceErrorType)
</UL>
<BR>[Called By]<UL><LI><a href="#[3fd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::match_error()
</UL>

<P><STRONG><a name="[371]"></a>mbed::ATHandler::cmd_stop()</STRONG> (Thumb, 26 bytes, Stack size 8 bytes, .\build\athandler.o(i._ZN4mbed9ATHandler8cmd_stopEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 584 + Unknown Stack Size
<LI>Call Chain = mbed::ATHandler::cmd_stop() &rArr; mbed::ATHandler::write(const void*, unsigned) &rArr; mbed::poll(mbed::pollfh*, unsigned, int) &rArr; mbed::Timer::~Timer() &rArr; sleep_manager_unlock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[405]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::write(const void*, unsigned)
</UL>
<BR>[Called By]<UL><LI><a href="#[3c6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularInformation::get_info(const char*, char*, unsigned)
<LI><a href="#[167]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularSIM::get_imsi(char*)
<LI><a href="#[165]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularSIM::set_pin(const char*)
<LI><a href="#[166]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularSIM::get_sim_state(mbed::CellularSIM::SimState&)
<LI><a href="#[16d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularPower::set_at_mode()
<LI><a href="#[3a1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::set_context_to_be_activated()
<LI><a href="#[17d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::get_registration_status(mbed::CellularNetwork::RegistrationType, mbed::CellularNetwork::RegistrationStatus&)
<LI><a href="#[39f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::delete_current_context()
<LI><a href="#[39b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::set_registration_urc(bool)
<LI><a href="#[39d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::open_data_channel()
<LI><a href="#[17c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::set_registration(const char*)
<LI><a href="#[398]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::set_new_context(int)
<LI><a href="#[395]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::get_context()
<LI><a href="#[17f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::set_attach(int)
<LI><a href="#[180]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::get_attach(mbed::CellularNetwork::AttachStatus&)
<LI><a href="#[16e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularStack::get_ip_address()
<LI><a href="#[192]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::QUECTEL_BG96_CellularStack::socket_recvfrom_impl(mbed::AT_CellularStack::CellularSocket*, SocketAddress*, void*, unsigned)
<LI><a href="#[191]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::QUECTEL_BG96_CellularStack::socket_sendto_impl(mbed::AT_CellularStack::CellularSocket*, const SocketAddress&, const void*, unsigned)
<LI><a href="#[190]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::QUECTEL_BG96_CellularStack::create_socket_impl(mbed::AT_CellularStack::CellularSocket*)
<LI><a href="#[18f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::QUECTEL_BG96_CellularStack::socket_close_impl(int)
</UL>

<P><STRONG><a name="[3f3]"></a>mbed::ATHandler::get_char()</STRONG> (Thumb, 52 bytes, Stack size 8 bytes, .\build\athandler.o(i._ZN4mbed9ATHandler8get_charEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 536 + Unknown Stack Size
<LI>Call Chain = mbed::ATHandler::get_char() &rArr; mbed::ATHandler::fill_buffer() &rArr; mbed::Timer::~Timer() &rArr; sleep_manager_unlock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[399]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::get_last_error() const
<LI><a href="#[3fb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::reset_buffer()
<LI><a href="#[3f6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::fill_buffer()
</UL>
<BR>[Called By]<UL><LI><a href="#[373]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::read_string(char*, unsigned, bool)
<LI><a href="#[384]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::skip_param(unsigned)
<LI><a href="#[403]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::consume_to_tag(const char*, bool)
<LI><a href="#[404]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::consume_char(char)
<LI><a href="#[3d9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::read_bytes(unsigned char*, unsigned)
</UL>

<P><STRONG><a name="[394]"></a>mbed::ATHandler::read_int()</STRONG> (Thumb, 64 bytes, Stack size 32 bytes, .\build\athandler.o(i._ZN4mbed9ATHandler8read_intEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 624 + Unknown Stack Size
<LI>Call Chain = mbed::ATHandler::read_int() &rArr; mbed::ATHandler::read_string(char*, unsigned, bool) &rArr; mbed::ATHandler::consume_char(char) &rArr; mbed::ATHandler::get_char() &rArr; mbed::ATHandler::fill_buffer() &rArr; mbed::Timer::~Timer() &rArr; sleep_manager_unlock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[373]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::read_string(char*, unsigned, bool)
<LI><a href="#[235]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;strtol
</UL>
<BR>[Called By]<UL><LI><a href="#[17d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::get_registration_status(mbed::CellularNetwork::RegistrationType, mbed::CellularNetwork::RegistrationStatus&)
<LI><a href="#[17c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::set_registration(const char*)
<LI><a href="#[395]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::get_context()
<LI><a href="#[17f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::set_attach(int)
<LI><a href="#[180]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::get_attach(mbed::CellularNetwork::AttachStatus&)
<LI><a href="#[3ff]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::at_error(bool, mbed::DeviceErrorType)
<LI><a href="#[11c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::QUECTEL_BG96_CellularStack::urc_qiurc()
<LI><a href="#[3d6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::QUECTEL_BG96_CellularStack::handle_open_socket_response(int&, int&)
<LI><a href="#[192]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::QUECTEL_BG96_CellularStack::socket_recvfrom_impl(mbed::AT_CellularStack::CellularSocket*, SocketAddress*, void*, unsigned)
<LI><a href="#[191]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::QUECTEL_BG96_CellularStack::socket_sendto_impl(mbed::AT_CellularStack::CellularSocket*, const SocketAddress&, const void*, unsigned)
</UL>

<P><STRONG><a name="[370]"></a>mbed::ATHandler::cmd_start(const char*)</STRONG> (Thumb, 40 bytes, Stack size 16 bytes, .\build\athandler.o(i._ZN4mbed9ATHandler9cmd_startEPKc))
<BR><BR>[Stack]<UL><LI>Max Depth = 592 + Unknown Stack Size
<LI>Call Chain = mbed::ATHandler::cmd_start(const char*) &rArr; mbed::ATHandler::write(const void*, unsigned) &rArr; mbed::poll(mbed::pollfh*, unsigned, int) &rArr; mbed::Timer::~Timer() &rArr; sleep_manager_unlock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[405]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::write(const void*, unsigned)
<LI><a href="#[31d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;strlen
</UL>
<BR>[Called By]<UL><LI><a href="#[3c6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularInformation::get_info(const char*, char*, unsigned)
<LI><a href="#[167]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularSIM::get_imsi(char*)
<LI><a href="#[165]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularSIM::set_pin(const char*)
<LI><a href="#[166]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularSIM::get_sim_state(mbed::CellularSIM::SimState&)
<LI><a href="#[16d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularPower::set_at_mode()
<LI><a href="#[3a1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::set_context_to_be_activated()
<LI><a href="#[17d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::get_registration_status(mbed::CellularNetwork::RegistrationType, mbed::CellularNetwork::RegistrationStatus&)
<LI><a href="#[39f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::delete_current_context()
<LI><a href="#[39b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::set_registration_urc(bool)
<LI><a href="#[39d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::open_data_channel()
<LI><a href="#[17c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::set_registration(const char*)
<LI><a href="#[398]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::set_new_context(int)
<LI><a href="#[395]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::get_context()
<LI><a href="#[17f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::set_attach(int)
<LI><a href="#[180]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::get_attach(mbed::CellularNetwork::AttachStatus&)
<LI><a href="#[16e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularStack::get_ip_address()
<LI><a href="#[192]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::QUECTEL_BG96_CellularStack::socket_recvfrom_impl(mbed::AT_CellularStack::CellularSocket*, SocketAddress*, void*, unsigned)
<LI><a href="#[191]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::QUECTEL_BG96_CellularStack::socket_sendto_impl(mbed::AT_CellularStack::CellularSocket*, const SocketAddress&, const void*, unsigned)
<LI><a href="#[190]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::QUECTEL_BG96_CellularStack::create_socket_impl(mbed::AT_CellularStack::CellularSocket*)
<LI><a href="#[18f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::QUECTEL_BG96_CellularStack::socket_close_impl(int)
</UL>

<P><STRONG><a name="[410]"></a>mbed::ATHandler::get_scope()</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, .\build\athandler.o(i._ZN4mbed9ATHandler9get_scopeEv))
<BR><BR>[Called By]<UL><LI><a href="#[383]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::info_resp()
</UL>

<P><STRONG><a name="[383]"></a>mbed::ATHandler::info_resp()</STRONG> (Thumb, 98 bytes, Stack size 8 bytes, .\build\athandler.o(i._ZN4mbed9ATHandler9info_respEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 688 + Unknown Stack Size
<LI>Call Chain = mbed::ATHandler::info_resp() &rArr; mbed::ATHandler::resp(const char*, bool) &rArr; mbed::ATHandler::match_error() &rArr; mbed::ATHandler::at_error(bool, mbed::DeviceErrorType) &rArr; mbed::ATHandler::read_int() &rArr; mbed::ATHandler::read_string(char*, unsigned, bool) &rArr; mbed::ATHandler::consume_char(char) &rArr; mbed::ATHandler::get_char() &rArr; mbed::ATHandler::fill_buffer() &rArr; mbed::Timer::~Timer() &rArr; sleep_manager_unlock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[3f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::set_scope(mbed::ATHandler::ScopeType)
<LI><a href="#[410]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::get_scope()
<LI><a href="#[3f9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::resp(const char*, bool)
<LI><a href="#[40c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::information_response_stop()
</UL>
<BR>[Called By]<UL><LI><a href="#[395]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::get_context()
<LI><a href="#[180]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::get_attach(mbed::CellularNetwork::AttachStatus&)
<LI><a href="#[16e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularStack::get_ip_address()
</UL>

<P><STRONG><a name="[401]"></a>mbed::ATHandler::match_urc()</STRONG> (Thumb, 92 bytes, Stack size 16 bytes, .\build\athandler.o(i._ZN4mbed9ATHandler9match_urcEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 592 + Unknown Stack Size
<LI>Call Chain = mbed::ATHandler::match_urc() &rArr; mbed::ATHandler::information_response_stop() &rArr; mbed::ATHandler::consume_to_stop_tag() &rArr; mbed::ATHandler::consume_to_tag(const char*, bool) &rArr; mbed::ATHandler::get_char() &rArr; mbed::ATHandler::fill_buffer() &rArr; mbed::Timer::~Timer() &rArr; sleep_manager_unlock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[35b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void()&rang;::operator ()() const
<LI><a href="#[3f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::set_scope(mbed::ATHandler::ScopeType)
<LI><a href="#[3fe]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::match(const char*, unsigned)
<LI><a href="#[40c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::information_response_stop()
<LI><a href="#[3f5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::rewind_buffer()
<LI><a href="#[31d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;strlen
</UL>
<BR>[Called By]<UL><LI><a href="#[3f9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::resp(const char*, bool)
<LI><a href="#[c6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::process_oob()
</UL>

<P><STRONG><a name="[374]"></a>mbed::ATHandler::resp_stop()</STRONG> (Thumb, 86 bytes, Stack size 8 bytes, .\build\athandler.o(i._ZN4mbed9ATHandler9resp_stopEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 584 + Unknown Stack Size
<LI>Call Chain = mbed::ATHandler::resp_stop() &rArr; mbed::ATHandler::information_response_element_stop() &rArr; mbed::ATHandler::consume_to_stop_tag() &rArr; mbed::ATHandler::consume_to_tag(const char*, bool) &rArr; mbed::ATHandler::get_char() &rArr; mbed::ATHandler::fill_buffer() &rArr; mbed::Timer::~Timer() &rArr; sleep_manager_unlock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[409]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::consume_to_stop_tag()
<LI><a href="#[3f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::set_scope(mbed::ATHandler::ScopeType)
<LI><a href="#[406]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::set_tag(mbed::ATHandler::tag_t*, const char*)
<LI><a href="#[40d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::information_response_element_stop()
<LI><a href="#[40c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::information_response_stop()
</UL>
<BR>[Called By]<UL><LI><a href="#[3c6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularInformation::get_info(const char*, char*, unsigned)
<LI><a href="#[167]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularSIM::get_imsi(char*)
<LI><a href="#[165]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularSIM::set_pin(const char*)
<LI><a href="#[166]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularSIM::get_sim_state(mbed::CellularSIM::SimState&)
<LI><a href="#[16d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularPower::set_at_mode()
<LI><a href="#[3a1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::set_context_to_be_activated()
<LI><a href="#[17d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::get_registration_status(mbed::CellularNetwork::RegistrationType, mbed::CellularNetwork::RegistrationStatus&)
<LI><a href="#[39f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::delete_current_context()
<LI><a href="#[39b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::set_registration_urc(bool)
<LI><a href="#[17c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::set_registration(const char*)
<LI><a href="#[398]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::set_new_context(int)
<LI><a href="#[395]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::get_context()
<LI><a href="#[17f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::set_attach(int)
<LI><a href="#[180]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::get_attach(mbed::CellularNetwork::AttachStatus&)
<LI><a href="#[16e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularStack::get_ip_address()
<LI><a href="#[3d6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::QUECTEL_BG96_CellularStack::handle_open_socket_response(int&, int&)
<LI><a href="#[192]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::QUECTEL_BG96_CellularStack::socket_recvfrom_impl(mbed::AT_CellularStack::CellularSocket*, SocketAddress*, void*, unsigned)
<LI><a href="#[191]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::QUECTEL_BG96_CellularStack::socket_sendto_impl(mbed::AT_CellularStack::CellularSocket*, const SocketAddress&, const void*, unsigned)
<LI><a href="#[190]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::QUECTEL_BG96_CellularStack::create_socket_impl(mbed::AT_CellularStack::CellularSocket*)
<LI><a href="#[18f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::QUECTEL_BG96_CellularStack::socket_close_impl(int)
</UL>

<P><STRONG><a name="[3f4]"></a>mbed::ATHandler::set_error(int)</STRONG> (Thumb, 16 bytes, Stack size 0 bytes, .\build\athandler.o(i._ZN4mbed9ATHandler9set_errorEi))
<BR><BR>[Called By]<UL><LI><a href="#[373]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::read_string(char*, unsigned, bool)
<LI><a href="#[384]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::skip_param(unsigned)
<LI><a href="#[409]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::consume_to_stop_tag()
<LI><a href="#[405]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::write(const void*, unsigned)
<LI><a href="#[3f6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::fill_buffer()
<LI><a href="#[3d9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::read_bytes(unsigned char*, unsigned)
</UL>

<P><STRONG><a name="[3f8]"></a>mbed::ATHandler::set_scope(mbed::ATHandler::ScopeType)</STRONG> (Thumb, 116 bytes, Stack size 16 bytes, .\build\athandler.o(i._ZN4mbed9ATHandler9set_scopeENS0_9ScopeTypeE))
<BR><BR>[Stack]<UL><LI>Max Depth = 568 + Unknown Stack Size
<LI>Call Chain = mbed::ATHandler::set_scope(mbed::ATHandler::ScopeType) &rArr; mbed::ATHandler::consume_char(char) &rArr; mbed::ATHandler::get_char() &rArr; mbed::ATHandler::fill_buffer() &rArr; mbed::Timer::~Timer() &rArr; sleep_manager_unlock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[404]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::consume_char(char)
</UL>
<BR>[Called By]<UL><LI><a href="#[374]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::resp_stop()
<LI><a href="#[372]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::resp_start(const char*, bool)
<LI><a href="#[383]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::info_resp()
<LI><a href="#[401]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::match_urc()
<LI><a href="#[3ff]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::at_error(bool, mbed::DeviceErrorType)
<LI><a href="#[3f9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::resp(const char*, bool)
<LI><a href="#[40d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::information_response_element_stop()
<LI><a href="#[40c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::information_response_stop()
</UL>

<P><STRONG><a name="[382]"></a>mbed::ATHandler::write_int(int)</STRONG> (Thumb, 64 bytes, Stack size 40 bytes, .\build\athandler.o(i._ZN4mbed9ATHandler9write_intEi))
<BR><BR>[Stack]<UL><LI>Max Depth = 624 + Unknown Stack Size
<LI>Call Chain = mbed::ATHandler::write_int(int) &rArr; mbed::ATHandler::check_cmd_send() &rArr; mbed::ATHandler::write(const void*, unsigned) &rArr; mbed::poll(mbed::pollfh*, unsigned, int) &rArr; mbed::Timer::~Timer() &rArr; sleep_manager_unlock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[405]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::write(const void*, unsigned)
<LI><a href="#[407]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::check_cmd_send()
<LI><a href="#[31d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;strlen
<LI><a href="#[225]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__2sprintf
</UL>
<BR>[Called By]<UL><LI><a href="#[3a1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::set_context_to_be_activated()
<LI><a href="#[39f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::delete_current_context()
<LI><a href="#[39d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::open_data_channel()
<LI><a href="#[398]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::set_new_context(int)
<LI><a href="#[16e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularStack::get_ip_address()
<LI><a href="#[192]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::QUECTEL_BG96_CellularStack::socket_recvfrom_impl(mbed::AT_CellularStack::CellularSocket*, SocketAddress*, void*, unsigned)
<LI><a href="#[191]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::QUECTEL_BG96_CellularStack::socket_sendto_impl(mbed::AT_CellularStack::CellularSocket*, const SocketAddress&, const void*, unsigned)
<LI><a href="#[190]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::QUECTEL_BG96_CellularStack::create_socket_impl(mbed::AT_CellularStack::CellularSocket*)
<LI><a href="#[18f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::QUECTEL_BG96_CellularStack::socket_close_impl(int)
</UL>

<P><STRONG><a name="[38b]"></a>mbed::ATHandler::ATHandler(mbed::FileHandle*, events::EventQueue&, int, const char*)</STRONG> (Thumb, 248 bytes, Stack size 24 bytes, .\build\athandler.o(i._ZN4mbed9ATHandlerC1EPNS_10FileHandleERN6events10EventQueueEiPKc))
<BR><BR>[Stack]<UL><LI>Max Depth = 592 + Unknown Stack Size
<LI>Call Chain = mbed::ATHandler::ATHandler(mbed::FileHandle*, events::EventQueue&, int, const char*) &rArr; rtos::Mutex::Mutex() &rArr; rtos::Mutex::constructor(const char*) &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[39c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::clear_error()
<LI><a href="#[37f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;operator new[] (unsigned)
<LI><a href="#[361]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Mutex::Mutex()
<LI><a href="#[406]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::set_tag(mbed::ATHandler::tag_t*, const char*)
<LI><a href="#[40a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::set_filehandle_sigio()
<LI><a href="#[3fb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::reset_buffer()
<LI><a href="#[31d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;strlen
</UL>
<BR>[Called By]<UL><LI><a href="#[366]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularDevice::get_at_handler(mbed::FileHandle*)
</UL>

<P><STRONG><a name="[773]"></a>mbed::ATHandler::ATHandler__sub_object(mbed::FileHandle*, events::EventQueue&, int, const char*)</STRONG> (Thumb, 0 bytes, Stack size 24 bytes, .\build\athandler.o(i._ZN4mbed9ATHandlerC1EPNS_10FileHandleERN6events10EventQueueEiPKc), UNUSED)

<P><STRONG><a name="[390]"></a>mbed::ATHandler::~ATHandler()</STRONG> (Thumb, 68 bytes, Stack size 24 bytes, .\build\athandler.o(i._ZN4mbed9ATHandlerD1Ev))
<BR><BR>[Stack]<UL><LI>Max Depth = 88<LI>Call Chain = mbed::ATHandler::~ATHandler() &rArr; operator delete (void*) &rArr; free &rArr; _free_internal &rArr; _mutex_release &rArr; os_kernel_is_active &rArr; osKernelGetState &rArr; svcRtxKernelGetState
</UL>
<BR>[Calls]<UL><LI><a href="#[37e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;operator delete (void*)
<LI><a href="#[53]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void()&rang;::~Callback()
<LI><a href="#[411]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;operator delete[] (void*)
<LI><a href="#[5f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Mutex::~Mutex()
</UL>
<BR>[Called By]<UL><LI><a href="#[369]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularDevice::release_at_handler(mbed::ATHandler*)
</UL>

<P><STRONG><a name="[774]"></a>mbed::ATHandler::~ATHandler__sub_object()</STRONG> (Thumb, 0 bytes, Stack size 24 bytes, .\build\athandler.o(i._ZN4mbed9ATHandlerD1Ev), UNUSED)

<P><STRONG><a name="[412]"></a>mbed::DigitalIn::DigitalIn(PinName)</STRONG> (Thumb, 24 bytes, Stack size 16 bytes, .\build\busin.o(i._ZN4mbed9DigitalInC1E7PinName))
<BR><BR>[Stack]<UL><LI>Max Depth = 664 + Unknown Stack Size
<LI>Call Chain = mbed::DigitalIn::DigitalIn(PinName) &rArr; gpio_init_in &rArr; gpio_init_in_ex &rArr; _gpio_init_in &rArr; gpio_dir &rArr; gpio_mode &rArr; pin_mode &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[413]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;gpio_init_in
</UL>
<BR>[Called By]<UL><LI><a href="#[1d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__sti___8_main_cpp_led0
</UL>

<P><STRONG><a name="[775]"></a>mbed::DigitalIn::DigitalIn__sub_object(PinName)</STRONG> (Thumb, 0 bytes, Stack size 16 bytes, .\build\busin.o(i._ZN4mbed9DigitalInC1E7PinName), UNUSED)

<P><STRONG><a name="[414]"></a>mbed::DigitalIn::DigitalIn(PinName, PinMode)</STRONG> (Thumb, 28 bytes, Stack size 16 bytes, .\build\main.o(i._ZN4mbed9DigitalInC1E7PinName7PinMode))
<BR><BR>[Stack]<UL><LI>Max Depth = 648 + Unknown Stack Size
<LI>Call Chain = mbed::DigitalIn::DigitalIn(PinName, PinMode) &rArr; gpio_init_in_ex &rArr; _gpio_init_in &rArr; gpio_dir &rArr; gpio_mode &rArr; pin_mode &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[415]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;gpio_init_in_ex
</UL>
<BR>[Called By]<UL><LI><a href="#[1d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__sti___8_main_cpp_led0
</UL>

<P><STRONG><a name="[776]"></a>mbed::DigitalIn::DigitalIn__sub_object(PinName, PinMode)</STRONG> (Thumb, 0 bytes, Stack size 16 bytes, .\build\main.o(i._ZN4mbed9DigitalInC1E7PinName7PinMode), UNUSED)

<P><STRONG><a name="[418]"></a>rtos::EventFlags::constructor(const char*)</STRONG> (Thumb, 62 bytes, Stack size 32 bytes, .\build\eventflags.o(i._ZN4rtos10EventFlags11constructorEPKc))
<BR><BR>[Stack]<UL><LI>Max Depth = 560 + Unknown Stack Size
<LI>Call Chain = rtos::EventFlags::constructor(const char*) &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[33a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_assert_internal
<LI><a href="#[419]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osEventFlagsNew
</UL>
<BR>[Called By]<UL><LI><a href="#[41f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::EventFlags::EventFlags()
</UL>

<P><STRONG><a name="[41a]"></a>rtos::EventFlags::set(unsigned)</STRONG> (Thumb, 16 bytes, Stack size 16 bytes, .\build\eventflags.o(i._ZN4rtos10EventFlags3setEj))
<BR><BR>[Stack]<UL><LI>Max Depth = 80<LI>Call Chain = rtos::EventFlags::set(unsigned) &rArr; osEventFlagsSet &rArr; osRtxPostProcess &rArr; isr_queue_put
</UL>
<BR>[Calls]<UL><LI><a href="#[41b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osEventFlagsSet
</UL>
<BR>[Called By]<UL><LI><a href="#[13b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TCPSocket::event()
<LI><a href="#[13e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;UDPSocket::event()
</UL>

<P><STRONG><a name="[41c]"></a>rtos::EventFlags::wait(unsigned, unsigned, unsigned, bool)</STRONG> (Thumb, 42 bytes, Stack size 24 bytes, .\build\eventflags.o(i._ZN4rtos10EventFlags4waitEjjjb))
<BR><BR>[Stack]<UL><LI>Max Depth = 104<LI>Call Chain = rtos::EventFlags::wait(unsigned, unsigned, unsigned, bool) &rArr; osEventFlagsWait &rArr; isrRtxEventFlagsWait &rArr; EventFlagsCheck
</UL>
<BR>[Calls]<UL><LI><a href="#[41d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osEventFlagsWait
</UL>
<BR>[Called By]<UL><LI><a href="#[41e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::EventFlags::wait_any(unsigned, unsigned, bool)
</UL>

<P><STRONG><a name="[41e]"></a>rtos::EventFlags::wait_any(unsigned, unsigned, bool)</STRONG> (Thumb, 26 bytes, Stack size 24 bytes, .\build\eventflags.o(i._ZN4rtos10EventFlags8wait_anyEjjb))
<BR><BR>[Stack]<UL><LI>Max Depth = 128<LI>Call Chain = rtos::EventFlags::wait_any(unsigned, unsigned, bool) &rArr; rtos::EventFlags::wait(unsigned, unsigned, unsigned, bool) &rArr; osEventFlagsWait &rArr; isrRtxEventFlagsWait &rArr; EventFlagsCheck
</UL>
<BR>[Calls]<UL><LI><a href="#[41c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::EventFlags::wait(unsigned, unsigned, unsigned, bool)
</UL>
<BR>[Called By]<UL><LI><a href="#[320]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;UDPSocket::recvfrom(SocketAddress*, void*, unsigned)
<LI><a href="#[31f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;UDPSocket::sendto(const SocketAddress&, const void*, unsigned)
<LI><a href="#[2f3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TCPSocket::connect(const SocketAddress&)
<LI><a href="#[2f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TCPSocket::send(const void*, unsigned)
<LI><a href="#[2f5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TCPSocket::recv(void*, unsigned)
</UL>

<P><STRONG><a name="[41f]"></a>rtos::EventFlags::EventFlags()</STRONG> (Thumb, 22 bytes, Stack size 8 bytes, .\build\eventflags.o(i._ZN4rtos10EventFlagsC1Ev))
<BR><BR>[Stack]<UL><LI>Max Depth = 568 + Unknown Stack Size
<LI>Call Chain = rtos::EventFlags::EventFlags() &rArr; rtos::EventFlags::constructor(const char*) &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[418]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::EventFlags::constructor(const char*)
</UL>
<BR>[Called By]<UL><LI><a href="#[31e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;UDPSocket::UDPSocket()
<LI><a href="#[2ed]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TCPSocket::TCPSocket()
</UL>

<P><STRONG><a name="[777]"></a>rtos::EventFlags::EventFlags__sub_object()</STRONG> (Thumb, 0 bytes, Stack size 8 bytes, .\build\eventflags.o(i._ZN4rtos10EventFlagsC1Ev), UNUSED)

<P><STRONG><a name="[420]"></a>rtos::EventFlags::~EventFlags()</STRONG> (Thumb, 20 bytes, Stack size 8 bytes, .\build\eventflags.o(i._ZN4rtos10EventFlagsD1Ev))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = rtos::EventFlags::~EventFlags() &rArr; osEventFlagsDelete
</UL>
<BR>[Calls]<UL><LI><a href="#[421]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osEventFlagsDelete
</UL>
<BR>[Called By]<UL><LI><a href="#[13c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;UDPSocket::~UDPSocket()
<LI><a href="#[139]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TCPSocket::~TCPSocket()
</UL>

<P><STRONG><a name="[778]"></a>rtos::EventFlags::~EventFlags__sub_object()</STRONG> (Thumb, 0 bytes, Stack size 8 bytes, .\build\eventflags.o(i._ZN4rtos10EventFlagsD1Ev), UNUSED)

<P><STRONG><a name="[422]"></a>rtos::Mutex::constructor(const char*)</STRONG> (Thumb, 74 bytes, Stack size 32 bytes, .\build\mutex.o(i._ZN4rtos5Mutex11constructorEPKc))
<BR><BR>[Stack]<UL><LI>Max Depth = 560 + Unknown Stack Size
<LI>Call Chain = rtos::Mutex::constructor(const char*) &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[423]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osMutexNew
<LI><a href="#[33a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_assert_internal
<LI><a href="#[23c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memclr4
</UL>
<BR>[Called By]<UL><LI><a href="#[361]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Mutex::Mutex()
</UL>

<P><STRONG><a name="[2e8]"></a>rtos::Mutex::lock(unsigned)</STRONG> (Thumb, 28 bytes, Stack size 16 bytes, .\build\mutex.o(i._ZN4rtos5Mutex4lockEj))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = rtos::Mutex::lock(unsigned) &rArr; osMutexAcquire
</UL>
<BR>[Calls]<UL><LI><a href="#[2eb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osMutexAcquire
</UL>
<BR>[Called By]<UL><LI><a href="#[36e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::lock()
<LI><a href="#[3bd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Thread::terminate()
<LI><a href="#[3ad]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Thread::start(mbed::Callback&lang;void()&rang;)
<LI><a href="#[393]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::remove_filehandle(mbed::FileHandle*)
<LI><a href="#[3e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::FileBase::FileBase(const char*, mbed::PathType)
<LI><a href="#[3ea]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::FileBase::lookup(const char*, unsigned)
<LI><a href="#[1aa]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::FileBase::~FileBase()
<LI><a href="#[319]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;reserve_filehandle()
<LI><a href="#[320]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;UDPSocket::recvfrom(SocketAddress*, void*, unsigned)
<LI><a href="#[31f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;UDPSocket::sendto(const SocketAddress&, const void*, unsigned)
<LI><a href="#[2f6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Socket::close()
<LI><a href="#[2ef]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Socket::open(NetworkStack*)
<LI><a href="#[2f2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Socket::set_timeout(int)
<LI><a href="#[197]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Serial::lock()
<LI><a href="#[2f3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TCPSocket::connect(const SocketAddress&)
<LI><a href="#[2f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TCPSocket::send(const void*, unsigned)
<LI><a href="#[2f5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TCPSocket::recv(void*, unsigned)
<LI><a href="#[56]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Thread::_thunk(void*)
<LI><a href="#[152]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::UARTSerial::api_lock()
<LI><a href="#[2df]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;print_function(const char*)
</UL>

<P><STRONG><a name="[2e9]"></a>rtos::Mutex::unlock()</STRONG> (Thumb, 18 bytes, Stack size 8 bytes, .\build\mutex.o(i._ZN4rtos5Mutex6unlockEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = rtos::Mutex::unlock() &rArr; osMutexRelease
</UL>
<BR>[Calls]<UL><LI><a href="#[30b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osMutexRelease
</UL>
<BR>[Called By]<UL><LI><a href="#[381]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::unlock()
<LI><a href="#[3bd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Thread::terminate()
<LI><a href="#[3ad]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Thread::start(mbed::Callback&lang;void()&rang;)
<LI><a href="#[393]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::remove_filehandle(mbed::FileHandle*)
<LI><a href="#[3e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::FileBase::FileBase(const char*, mbed::PathType)
<LI><a href="#[3ea]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::FileBase::lookup(const char*, unsigned)
<LI><a href="#[1aa]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::FileBase::~FileBase()
<LI><a href="#[319]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;reserve_filehandle()
<LI><a href="#[320]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;UDPSocket::recvfrom(SocketAddress*, void*, unsigned)
<LI><a href="#[31f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;UDPSocket::sendto(const SocketAddress&, const void*, unsigned)
<LI><a href="#[2f6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Socket::close()
<LI><a href="#[2ef]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Socket::open(NetworkStack*)
<LI><a href="#[2f2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Socket::set_timeout(int)
<LI><a href="#[198]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Serial::unlock()
<LI><a href="#[2f3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TCPSocket::connect(const SocketAddress&)
<LI><a href="#[2f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TCPSocket::send(const void*, unsigned)
<LI><a href="#[2f5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TCPSocket::recv(void*, unsigned)
<LI><a href="#[153]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::UARTSerial::api_unlock()
<LI><a href="#[2df]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;print_function(const char*)
</UL>

<P><STRONG><a name="[361]"></a>rtos::Mutex::Mutex()</STRONG> (Thumb, 26 bytes, Stack size 8 bytes, .\build\mutex.o(i._ZN4rtos5MutexC1Ev))
<BR><BR>[Stack]<UL><LI>Max Depth = 568 + Unknown Stack Size
<LI>Call Chain = rtos::Mutex::Mutex() &rArr; rtos::Mutex::constructor(const char*) &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[422]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Mutex::constructor(const char*)
</UL>
<BR>[Called By]<UL><LI><a href="#[38b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::ATHandler(mbed::FileHandle*, events::EventQueue&, int, const char*)
<LI><a href="#[3b6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Thread::Thread(osPriority_t, unsigned, unsigned char*, const char*)
<LI><a href="#[35f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::UARTSerial::UARTSerial(PinName, PinName, int)
<LI><a href="#[6cd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SingletonPtr&lang;rtos::Mutex&rang;::get()
<LI><a href="#[3a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::prepare_event_queue()
<LI><a href="#[3e2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Serial::Serial(PinName, PinName, const char*, int)
<LI><a href="#[434]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Socket::Socket__sub_object()
<LI><a href="#[1d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__sti___8_main_cpp_led0
</UL>

<P><STRONG><a name="[779]"></a>rtos::Mutex::Mutex__sub_object()</STRONG> (Thumb, 0 bytes, Stack size 8 bytes, .\build\mutex.o(i._ZN4rtos5MutexC1Ev), UNUSED)

<P><STRONG><a name="[5f]"></a>rtos::Mutex::~Mutex()</STRONG> (Thumb, 20 bytes, Stack size 8 bytes, .\build\mutex.o(i._ZN4rtos5MutexD1Ev))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = rtos::Mutex::~Mutex() &rArr; osMutexDelete
</UL>
<BR>[Calls]<UL><LI><a href="#[424]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osMutexDelete
</UL>
<BR>[Called By]<UL><LI><a href="#[390]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::~ATHandler()
<LI><a href="#[149]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::UARTSerial::~UARTSerial()
<LI><a href="#[60]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Thread::~Thread()
<LI><a href="#[5d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Serial::~Serial()
<LI><a href="#[138]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Socket::~Socket__sub_object()
</UL>
<BR>[Address Reference Count : 1]<UL><LI> main.o(i.__sti___8_main_cpp_led0)
</UL>
<P><STRONG><a name="[77a]"></a>rtos::Mutex::~Mutex__sub_object()</STRONG> (Thumb, 0 bytes, Stack size 8 bytes, .\build\mutex.o(i._ZN4rtos5MutexD1Ev), UNUSED)

<P><STRONG><a name="[3ab]"></a>rtos::Thread::constructor(osPriority_t, unsigned, unsigned char*, const char*)</STRONG> (Thumb, 126 bytes, Stack size 40 bytes, .\build\thread.o(i._ZN4rtos6Thread11constructorE12osPriority_tjPhPKc))
<BR><BR>[Stack]<UL><LI>Max Depth = 44<LI>Call Chain = rtos::Thread::constructor(osPriority_t, unsigned, unsigned char*, const char*) &rArr; __aeabi_memclr4
</UL>
<BR>[Calls]<UL><LI><a href="#[23c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memclr4
</UL>
<BR>[Called By]<UL><LI><a href="#[3b6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Thread::Thread(osPriority_t, unsigned, unsigned char*, const char*)
<LI><a href="#[3a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::prepare_event_queue()
<LI><a href="#[1d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__sti___8_main_cpp_led0
</UL>

<P><STRONG><a name="[35e]"></a>rtos::Thread::wait(unsigned)</STRONG> (Thumb, 12 bytes, Stack size 8 bytes, .\build\thread.o(i._ZN4rtos6Thread4waitEj))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = rtos::Thread::wait(unsigned) &rArr; osDelay
</UL>
<BR>[Calls]<UL><LI><a href="#[425]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osDelay
</UL>
<BR>[Called By]<UL><LI><a href="#[363]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::poll(mbed::pollfh*, unsigned, int)
<LI><a href="#[6ca]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;wait_us
<LI><a href="#[355]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::UARTSerial::wait_ms(unsigned)
</UL>

<P><STRONG><a name="[3ad]"></a>rtos::Thread::start(mbed::Callback&lang;void()&rang;)</STRONG> (Thumb, 224 bytes, Stack size 24 bytes, .\build\thread.o(i._ZN4rtos6Thread5startEN4mbed8CallbackIFvvEEE))
<BR><BR>[Stack]<UL><LI>Max Depth = 552 + Unknown Stack Size
<LI>Call Chain = rtos::Thread::start(mbed::Callback&lang;void()&rang;) &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[33a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_assert_internal
<LI><a href="#[53]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void()&rang;::~Callback()
<LI><a href="#[37f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;operator new[] (unsigned)
<LI><a href="#[411]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;operator delete[] (void*)
<LI><a href="#[408]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void()&rang;::Callback(const mbed::Callback&lang;void()&rang;&)
<LI><a href="#[2e9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Mutex::unlock()
<LI><a href="#[2e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Mutex::lock(unsigned)
<LI><a href="#[3cd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Semaphore::release()
<LI><a href="#[426]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osThreadNew
<LI><a href="#[23c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memclr4
</UL>
<BR>[Called By]<UL><LI><a href="#[3b5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::CellularConnectionFSM::start_dispatch()
<LI><a href="#[281]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;$Super$$main
<LI><a href="#[3a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::prepare_event_queue()
</UL>

<P><STRONG><a name="[3fc]"></a>rtos::Thread::yield()</STRONG> (Thumb, 8 bytes, Stack size 8 bytes, .\build\thread.o(i._ZN4rtos6Thread5yieldEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = rtos::Thread::yield() &rArr; osThreadYield
</UL>
<BR>[Calls]<UL><LI><a href="#[427]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osThreadYield
</UL>
<BR>[Called By]<UL><LI><a href="#[c6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::process_oob()
<LI><a href="#[3f6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::fill_buffer()
</UL>

<P><STRONG><a name="[56]"></a>rtos::Thread::_thunk(void*)</STRONG> (Thumb, 82 bytes, Stack size 24 bytes, .\build\thread.o(i._ZN4rtos6Thread6_thunkEPv))
<BR><BR>[Stack]<UL><LI>Max Depth = 552 + Unknown Stack Size
<LI>Call Chain = rtos::Thread::_thunk(void*) &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[33a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_assert_internal
<LI><a href="#[2e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Mutex::lock(unsigned)
<LI><a href="#[3cd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Semaphore::release()
</UL>
<BR>[Address Reference Count : 1]<UL><LI> thread.o(i._ZN4rtos6Thread5startEN4mbed8CallbackIFvvEEE)
</UL>
<P><STRONG><a name="[3bd]"></a>rtos::Thread::terminate()</STRONG> (Thumb, 64 bytes, Stack size 16 bytes, .\build\thread.o(i._ZN4rtos6Thread9terminateEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 72<LI>Call Chain = rtos::Thread::terminate() &rArr; rtos::Semaphore::release() &rArr; osSemaphoreRelease &rArr; osRtxPostProcess &rArr; isr_queue_put
</UL>
<BR>[Calls]<UL><LI><a href="#[2e9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Mutex::unlock()
<LI><a href="#[2e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Mutex::lock(unsigned)
<LI><a href="#[3cd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Semaphore::release()
<LI><a href="#[428]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osThreadTerminate
</UL>
<BR>[Called By]<UL><LI><a href="#[3b7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::CellularConnectionFSM::stop()
<LI><a href="#[60]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Thread::~Thread()
</UL>

<P><STRONG><a name="[3b6]"></a>rtos::Thread::Thread(osPriority_t, unsigned, unsigned char*, const char*)</STRONG> (Thumb, 138 bytes, Stack size 32 bytes, .\build\cellularconnectionfsm.o(i._ZN4rtos6ThreadC1E12osPriority_tjPhPKc))
<BR><BR>[Stack]<UL><LI>Max Depth = 608 + Unknown Stack Size
<LI>Call Chain = rtos::Thread::Thread(osPriority_t, unsigned, unsigned char*, const char*) &rArr; rtos::Semaphore::Semaphore(int) &rArr; rtos::Semaphore::constructor(int, unsigned short) &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[361]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Mutex::Mutex()
<LI><a href="#[3aa]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Semaphore::Semaphore(int)
<LI><a href="#[3ab]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Thread::constructor(osPriority_t, unsigned, unsigned char*, const char*)
</UL>
<BR>[Called By]<UL><LI><a href="#[3b5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::CellularConnectionFSM::start_dispatch()
</UL>

<P><STRONG><a name="[77b]"></a>rtos::Thread::Thread__sub_object(osPriority_t, unsigned, unsigned char*, const char*)</STRONG> (Thumb, 0 bytes, Stack size 32 bytes, .\build\cellularconnectionfsm.o(i._ZN4rtos6ThreadC1E12osPriority_tjPhPKc), UNUSED)

<P><STRONG><a name="[1ac]"></a>rtos::Thread::~Thread__deallocating()</STRONG> (Thumb, 18 bytes, Stack size 16 bytes, .\build\thread.o(i._ZN4rtos6ThreadD0Ev))
<BR><BR>[Stack]<UL><LI>Max Depth = 96<LI>Call Chain = rtos::Thread::~Thread__deallocating() &rArr; rtos::Thread::~Thread() &rArr; rtos::Thread::terminate() &rArr; rtos::Semaphore::release() &rArr; osSemaphoreRelease &rArr; osRtxPostProcess &rArr; isr_queue_put
</UL>
<BR>[Calls]<UL><LI><a href="#[37e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;operator delete (void*)
<LI><a href="#[60]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Thread::~Thread()
</UL>
<BR>[Address Reference Count : 1]<UL><LI> thread.o(.constdata__ZTVN4rtos6ThreadE)
</UL>
<P><STRONG><a name="[60]"></a>rtos::Thread::~Thread()</STRONG> (Thumb, 72 bytes, Stack size 8 bytes, .\build\thread.o(i._ZN4rtos6ThreadD1Ev))
<BR><BR>[Stack]<UL><LI>Max Depth = 80<LI>Call Chain = rtos::Thread::~Thread() &rArr; rtos::Thread::terminate() &rArr; rtos::Semaphore::release() &rArr; osSemaphoreRelease &rArr; osRtxPostProcess &rArr; isr_queue_put
</UL>
<BR>[Calls]<UL><LI><a href="#[53]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void()&rang;::~Callback()
<LI><a href="#[411]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;operator delete[] (void*)
<LI><a href="#[5f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Mutex::~Mutex()
<LI><a href="#[3bd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Thread::terminate()
<LI><a href="#[3d5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Semaphore::~Semaphore()
</UL>
<BR>[Called By]<UL><LI><a href="#[1ac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Thread::~Thread__deallocating()
</UL>
<BR>[Address Reference Count : 2]<UL><LI> thread.o(.constdata__ZTVN4rtos6ThreadE)
<LI> main.o(i.__sti___8_main_cpp_led0)
</UL>
<P><STRONG><a name="[77c]"></a>rtos::Thread::~Thread__sub_object()</STRONG> (Thumb, 0 bytes, Stack size 8 bytes, .\build\thread.o(i._ZN4rtos6ThreadD1Ev), UNUSED)

<P><STRONG><a name="[2cc]"></a>rtos::internal::SysTimer::cancel_tick()</STRONG> (Thumb, 12 bytes, Stack size 8 bytes, .\build\systimer.o(i._ZN4rtos8internal8SysTimer11cancel_tickEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 168<LI>Call Chain = rtos::internal::SysTimer::cancel_tick() &rArr; mbed::TimerEvent::remove() &rArr; ticker_remove_event &rArr; schedule_interrupt &rArr; update_present_time &rArr; __aeabi_uldivmod
</UL>
<BR>[Calls]<UL><LI><a href="#[350]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::TimerEvent::remove()
</UL>
<BR>[Called By]<UL><LI><a href="#[2b1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OS_Tick_Disable
<LI><a href="#[f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;default_idle_hook()
</UL>

<P><STRONG><a name="[30f]"></a>rtos::internal::SysTimer::update_tick()</STRONG> (Thumb, 88 bytes, Stack size 32 bytes, .\build\systimer.o(i._ZN4rtos8internal8SysTimer11update_tickEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 224<LI>Call Chain = rtos::internal::SysTimer::update_tick() &rArr; ticker_read_us &rArr; initialize &rArr;  mbed_assert_internal (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[3e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ticker_read_us
<LI><a href="#[3e1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_uldivmod
</UL>
<BR>[Called By]<UL><LI><a href="#[f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;default_idle_hook()
</UL>

<P><STRONG><a name="[2cb]"></a>rtos::internal::SysTimer::schedule_tick(unsigned)</STRONG> (Thumb, 70 bytes, Stack size 32 bytes, .\build\systimer.o(i._ZN4rtos8internal8SysTimer13schedule_tickEj))
<BR><BR>[Stack]<UL><LI>Max Depth = 224<LI>Call Chain = rtos::internal::SysTimer::schedule_tick(unsigned) &rArr; mbed::TimerEvent::insert_absolute(unsigned long long) &rArr; ticker_insert_event_us &rArr; schedule_interrupt &rArr; update_present_time &rArr; __aeabi_uldivmod
</UL>
<BR>[Calls]<UL><LI><a href="#[34e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::TimerEvent::insert_absolute(unsigned long long)
<LI><a href="#[3e1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_uldivmod
</UL>
<BR>[Called By]<UL><LI><a href="#[2b3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OS_Tick_Enable
<LI><a href="#[2ca]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OS_Tick_AcknowledgeIRQ
<LI><a href="#[f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;default_idle_hook()
</UL>

<P><STRONG><a name="[42a]"></a>rtos::internal::SysTimer::increment_tick()</STRONG> (Thumb, 18 bytes, Stack size 8 bytes, .\build\systimer.o(i._ZN4rtos8internal8SysTimer14increment_tickEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = rtos::internal::SysTimer::increment_tick()
</UL>
<BR>[Called By]<UL><LI><a href="#[1ad]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::internal::SysTimer::handler()
</UL>

<P><STRONG><a name="[429]"></a>rtos::internal::SysTimer::set_irq_pending()</STRONG> (Thumb, 10 bytes, Stack size 0 bytes, .\build\systimer.o(i._ZN4rtos8internal8SysTimer15set_irq_pendingEv))
<BR><BR>[Called By]<UL><LI><a href="#[1ad]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::internal::SysTimer::handler()
</UL>

<P><STRONG><a name="[1ad]"></a>rtos::internal::SysTimer::handler()</STRONG> (Thumb, 16 bytes, Stack size 8 bytes, .\build\systimer.o(i._ZN4rtos8internal8SysTimer7handlerEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = rtos::internal::SysTimer::handler() &rArr; rtos::internal::SysTimer::increment_tick()
</UL>
<BR>[Calls]<UL><LI><a href="#[429]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::internal::SysTimer::set_irq_pending()
<LI><a href="#[42a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::internal::SysTimer::increment_tick()
</UL>
<BR>[Address Reference Count : 1]<UL><LI> systimer.o(.constdata__ZTVN4rtos8internal8SysTimerE)
</UL>
<P><STRONG><a name="[2ce]"></a>rtos::internal::SysTimer::setup_irq()</STRONG> (Thumb, 14 bytes, Stack size 8 bytes, .\build\systimer.o(i._ZN4rtos8internal8SysTimer9setup_irqEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = rtos::internal::SysTimer::setup_irq() &rArr; OS_Tick_Setup
</UL>
<BR>[Calls]<UL><LI><a href="#[42b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OS_Tick_Setup
</UL>
<BR>[Called By]<UL><LI><a href="#[2b3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OS_Tick_Enable
</UL>

<P><STRONG><a name="[2cd]"></a>rtos::internal::SysTimer::SysTimer()</STRONG> (Thumb, 54 bytes, Stack size 16 bytes, .\build\systimer.o(i._ZN4rtos8internal8SysTimerC1Ev))
<BR><BR>[Stack]<UL><LI>Max Depth = 232<LI>Call Chain = rtos::internal::SysTimer::SysTimer() &rArr; mbed::TimerEvent::TimerEvent__sub_object(const ticker_data_t*) &rArr; ticker_set_handler &rArr; initialize &rArr;  mbed_assert_internal (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[42c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;get_lp_ticker_data
<LI><a href="#[3e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ticker_read_us
<LI><a href="#[352]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::TimerEvent::TimerEvent__sub_object(const ticker_data_t*)
</UL>
<BR>[Called By]<UL><LI><a href="#[2b3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OS_Tick_Enable
</UL>

<P><STRONG><a name="[77d]"></a>rtos::internal::SysTimer::SysTimer__sub_object()</STRONG> (Thumb, 0 bytes, Stack size 16 bytes, .\build\systimer.o(i._ZN4rtos8internal8SysTimerC1Ev), UNUSED)

<P><STRONG><a name="[42d]"></a>rtos::Semaphore::constructor(int, unsigned short)</STRONG> (Thumb, 66 bytes, Stack size 32 bytes, .\build\semaphore.o(i._ZN4rtos9Semaphore11constructorEit))
<BR><BR>[Stack]<UL><LI>Max Depth = 560 + Unknown Stack Size
<LI>Call Chain = rtos::Semaphore::constructor(int, unsigned short) &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[33a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_assert_internal
<LI><a href="#[42e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osSemaphoreNew
</UL>
<BR>[Called By]<UL><LI><a href="#[3aa]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Semaphore::Semaphore(int)
</UL>

<P><STRONG><a name="[3d1]"></a>rtos::Semaphore::wait(unsigned)</STRONG> (Thumb, 60 bytes, Stack size 16 bytes, .\build\semaphore.o(i._ZN4rtos9Semaphore4waitEj))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = rtos::Semaphore::wait(unsigned) &rArr; osSemaphoreAcquire &rArr; SemaphoreTokenDecrement
</UL>
<BR>[Calls]<UL><LI><a href="#[430]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osSemaphoreGetCount
<LI><a href="#[42f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osSemaphoreAcquire
</UL>
<BR>[Called By]<UL><LI><a href="#[187]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::EasyCellularConnection::connect()
</UL>

<P><STRONG><a name="[3cd]"></a>rtos::Semaphore::release()</STRONG> (Thumb, 12 bytes, Stack size 8 bytes, .\build\semaphore.o(i._ZN4rtos9Semaphore7releaseEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = rtos::Semaphore::release() &rArr; osSemaphoreRelease &rArr; osRtxPostProcess &rArr; isr_queue_put
</UL>
<BR>[Calls]<UL><LI><a href="#[431]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osSemaphoreRelease
</UL>
<BR>[Called By]<UL><LI><a href="#[3bd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Thread::terminate()
<LI><a href="#[3ad]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Thread::start(mbed::Callback&lang;void()&rang;)
<LI><a href="#[ca]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::EasyCellularConnection::cellular_status(int, int)
<LI><a href="#[56]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Thread::_thunk(void*)
</UL>

<P><STRONG><a name="[3aa]"></a>rtos::Semaphore::Semaphore(int)</STRONG> (Thumb, 28 bytes, Stack size 16 bytes, .\build\semaphore.o(i._ZN4rtos9SemaphoreC1Ei))
<BR><BR>[Stack]<UL><LI>Max Depth = 576 + Unknown Stack Size
<LI>Call Chain = rtos::Semaphore::Semaphore(int) &rArr; rtos::Semaphore::constructor(int, unsigned short) &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[42d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Semaphore::constructor(int, unsigned short)
</UL>
<BR>[Called By]<UL><LI><a href="#[3b6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Thread::Thread(osPriority_t, unsigned, unsigned char*, const char*)
<LI><a href="#[3d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::EasyCellularConnection::EasyCellularConnection(bool)
<LI><a href="#[3a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::prepare_event_queue()
<LI><a href="#[1d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__sti___8_main_cpp_led0
</UL>

<P><STRONG><a name="[77e]"></a>rtos::Semaphore::Semaphore__sub_object(int)</STRONG> (Thumb, 0 bytes, Stack size 16 bytes, .\build\semaphore.o(i._ZN4rtos9SemaphoreC1Ei), UNUSED)

<P><STRONG><a name="[3d5]"></a>rtos::Semaphore::~Semaphore()</STRONG> (Thumb, 20 bytes, Stack size 8 bytes, .\build\semaphore.o(i._ZN4rtos9SemaphoreD1Ev))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = rtos::Semaphore::~Semaphore() &rArr; osSemaphoreDelete
</UL>
<BR>[Calls]<UL><LI><a href="#[432]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osSemaphoreDelete
</UL>
<BR>[Called By]<UL><LI><a href="#[5e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::EasyCellularConnection::~EasyCellularConnection()
<LI><a href="#[60]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Thread::~Thread()
</UL>

<P><STRONG><a name="[77f]"></a>rtos::Semaphore::~Semaphore__sub_object()</STRONG> (Thumb, 0 bytes, Stack size 8 bytes, .\build\semaphore.o(i._ZN4rtos9SemaphoreD1Ev), UNUSED)

<P><STRONG><a name="[2f2]"></a>Socket::set_timeout(int)</STRONG> (Thumb, 42 bytes, Stack size 16 bytes, .\build\socket.o(i._ZN6Socket11set_timeoutEi))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = Socket::set_timeout(int) &rArr; rtos::Mutex::lock(unsigned) &rArr; osMutexAcquire
</UL>
<BR>[Calls]<UL><LI><a href="#[2e9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Mutex::unlock()
<LI><a href="#[2e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Mutex::lock(unsigned)
</UL>
<BR>[Called By]<UL><LI><a href="#[303]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;nsapi_dns_query_multiple(NetworkStack*, const char*, nsapi_addr*, unsigned, nsapi_version)
<LI><a href="#[2ec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;test_send_recv()
</UL>

<P><STRONG><a name="[2ef]"></a>Socket::open(NetworkStack*)</STRONG> (Thumb, 150 bytes, Stack size 48 bytes, .\build\socket.o(i._ZN6Socket4openEP12NetworkStack))
<BR><BR>[Stack]<UL><LI>Max Depth = 136<LI>Call Chain = Socket::open(NetworkStack*) &rArr; mbed::Callback&lang;T3()&rang; mbed::callback&lang;Socket, Socket, void&rang;(T2*, T3(T1::*)()) &rArr; mbed::Callback&lang;void()&rang;::Callback&lang;Socket, Socket&rang;(T2*, void(T1::*)())
</UL>
<BR>[Calls]<UL><LI><a href="#[53]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void()&rang;::~Callback()
<LI><a href="#[2e9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Mutex::unlock()
<LI><a href="#[2e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Mutex::lock(unsigned)
<LI><a href="#[341]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void()&rang;::operator =(const mbed::Callback&lang;void()&rang;&)
<LI><a href="#[433]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;T3()&rang; mbed::callback&lang;Socket, Socket, void&rang;(T2*, T3(T1::*)())
</UL>
<BR>[Called By]<UL><LI><a href="#[303]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;nsapi_dns_query_multiple(NetworkStack*, const char*, nsapi_addr*, unsigned, nsapi_version)
<LI><a href="#[2ec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;test_send_recv()
</UL>

<P><STRONG><a name="[2f6]"></a>Socket::close()</STRONG> (Thumb, 84 bytes, Stack size 24 bytes, .\build\socket.o(i._ZN6Socket5closeEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = Socket::close() &rArr; rtos::Mutex::lock(unsigned) &rArr; osMutexAcquire
</UL>
<BR>[Calls]<UL><LI><a href="#[2e9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Mutex::unlock()
<LI><a href="#[2e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Mutex::lock(unsigned)
</UL>
<BR>[Called By]<UL><LI><a href="#[13c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;UDPSocket::~UDPSocket()
<LI><a href="#[303]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;nsapi_dns_query_multiple(NetworkStack*, const char*, nsapi_addr*, unsigned, nsapi_version)
<LI><a href="#[139]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TCPSocket::~TCPSocket()
<LI><a href="#[2ec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;test_send_recv()
</UL>

<P><STRONG><a name="[434]"></a>Socket::Socket__sub_object()</STRONG> (Thumb, 62 bytes, Stack size 8 bytes, .\build\socket.o(i._ZN6SocketC2Ev))
<BR><BR>[Stack]<UL><LI>Max Depth = 576 + Unknown Stack Size
<LI>Call Chain = Socket::Socket__sub_object() &rArr; rtos::Mutex::Mutex() &rArr; rtos::Mutex::constructor(const char*) &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[282]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void()&rang;::Callback(void(*)())
<LI><a href="#[361]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Mutex::Mutex()
</UL>
<BR>[Called By]<UL><LI><a href="#[31e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;UDPSocket::UDPSocket()
<LI><a href="#[2ed]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TCPSocket::TCPSocket()
</UL>

<P><STRONG><a name="[780]"></a>Socket::~Socket()</STRONG> (Thumb, 0 bytes, Stack size 8 bytes, .\build\socket.o(i._ZN6SocketD2Ev), UNUSED)

<P><STRONG><a name="[138]"></a>Socket::~Socket__sub_object()</STRONG> (Thumb, 48 bytes, Stack size 8 bytes, .\build\socket.o(i._ZN6SocketD2Ev))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = Socket::~Socket__sub_object() &rArr; rtos::Mutex::~Mutex() &rArr; osMutexDelete
</UL>
<BR>[Calls]<UL><LI><a href="#[53]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void()&rang;::~Callback()
<LI><a href="#[5f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Mutex::~Mutex()
</UL>
<BR>[Called By]<UL><LI><a href="#[13c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;UDPSocket::~UDPSocket()
<LI><a href="#[139]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TCPSocket::~TCPSocket()
</UL>
<BR>[Address Reference Count : 1]<UL><LI> socket.o(.constdata__ZTV6Socket)
</UL>
<P><STRONG><a name="[c9]"></a>events::EventQueue::dispatch_forever()</STRONG> (Thumb, 16 bytes, Stack size 8 bytes, .\build\cellularconnectionfsm.o(i._ZN6events10EventQueue16dispatch_foreverEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 632 + Unknown Stack Size
<LI>Call Chain = events::EventQueue::dispatch_forever() &rArr; events::EventQueue::dispatch(int) &rArr; equeue_dispatch &rArr; equeue_tick &rArr; equeue_tick_init() &rArr; mbed::Ticker::attach_us(mbed::Callback&lang;void()&rang;, unsigned long long) &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[435]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;events::EventQueue::dispatch(int)
</UL>
<BR>[Address Reference Count : 2]<UL><LI> cellularconnectionfsm.o(.constdata)
<LI> ppp_lwip.o(.constdata)
</UL>
<P><STRONG><a name="[3bc]"></a>events::EventQueue::chain(events::EventQueue*)</STRONG> (Thumb, 28 bytes, Stack size 16 bytes, .\build\eventqueue.o(i._ZN6events10EventQueue5chainEPS0_))
<BR><BR>[Stack]<UL><LI>Max Depth = 624 + Unknown Stack Size
<LI>Call Chain = events::EventQueue::chain(events::EventQueue*) &rArr; equeue_chain &rArr; equeue_background &rArr; equeue_tick &rArr; equeue_tick_init() &rArr; mbed::Ticker::attach_us(mbed::Callback&lang;void()&rang;, unsigned long long) &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[436]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_chain
</UL>
<BR>[Called By]<UL><LI><a href="#[3bb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::CellularConnectionFSM::init()
</UL>

<P><STRONG><a name="[435]"></a>events::EventQueue::dispatch(int)</STRONG> (Thumb, 16 bytes, Stack size 16 bytes, .\build\eventqueue.o(i._ZN6events10EventQueue8dispatchEi))
<BR><BR>[Stack]<UL><LI>Max Depth = 624 + Unknown Stack Size
<LI>Call Chain = events::EventQueue::dispatch(int) &rArr; equeue_dispatch &rArr; equeue_tick &rArr; equeue_tick_init() &rArr; mbed::Ticker::attach_us(mbed::Callback&lang;void()&rang;, unsigned long long) &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[437]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_dispatch
</UL>
<BR>[Called By]<UL><LI><a href="#[c9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;events::EventQueue::dispatch_forever()
</UL>

<P><STRONG><a name="[3a9]"></a>events::EventQueue::EventQueue(unsigned, unsigned char*)</STRONG> (Thumb, 100 bytes, Stack size 24 bytes, .\build\eventqueue.o(i._ZN6events10EventQueueC1EjPh))
<BR><BR>[Stack]<UL><LI>Max Depth = 640 + Unknown Stack Size
<LI>Call Chain = events::EventQueue::EventQueue(unsigned, unsigned char*) &rArr; equeue_create &rArr; equeue_create_inplace &rArr; equeue_tick &rArr; equeue_tick_init() &rArr; mbed::Ticker::attach_us(mbed::Callback&lang;void()&rang;, unsigned long long) &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[439]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_create_inplace
<LI><a href="#[438]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_create
</UL>
<BR>[Called By]<UL><LI><a href="#[3c5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::CellularConnectionFSM::CellularConnectionFSM()
<LI><a href="#[3a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::prepare_event_queue()
</UL>

<P><STRONG><a name="[781]"></a>events::EventQueue::EventQueue__sub_object(unsigned, unsigned char*)</STRONG> (Thumb, 0 bytes, Stack size 24 bytes, .\build\eventqueue.o(i._ZN6events10EventQueueC1EjPh), UNUSED)

<P><STRONG><a name="[3ae]"></a>events::EventQueue::~EventQueue()</STRONG> (Thumb, 32 bytes, Stack size 8 bytes, .\build\eventqueue.o(i._ZN6events10EventQueueD1Ev))
<BR><BR>[Stack]<UL><LI>Max Depth = 80<LI>Call Chain = events::EventQueue::~EventQueue() &rArr; equeue_destroy &rArr; free &rArr; _free_internal &rArr; _mutex_release &rArr; os_kernel_is_active &rArr; osKernelGetState &rArr; svcRtxKernelGetState
</UL>
<BR>[Calls]<UL><LI><a href="#[43a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_destroy
<LI><a href="#[34d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void(int)&rang;::~Callback()
</UL>
<BR>[Called By]<UL><LI><a href="#[183]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::CellularConnectionFSM::~CellularConnectionFSM()
<LI><a href="#[3a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::prepare_event_queue()
</UL>

<P><STRONG><a name="[782]"></a>events::EventQueue::~EventQueue__sub_object()</STRONG> (Thumb, 0 bytes, Stack size 8 bytes, .\build\eventqueue.o(i._ZN6events10EventQueueD1Ev), UNUSED)

<P><STRONG><a name="[2f5]"></a>TCPSocket::recv(void*, unsigned)</STRONG> (Thumb, 168 bytes, Stack size 24 bytes, .\build\tcpsocket.o(i._ZN9TCPSocket4recvEPvj))
<BR><BR>[Stack]<UL><LI>Max Depth = 552 + Unknown Stack Size
<LI>Call Chain = TCPSocket::recv(void*, unsigned) &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[33a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_assert_internal
<LI><a href="#[2e9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Mutex::unlock()
<LI><a href="#[2e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Mutex::lock(unsigned)
<LI><a href="#[41e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::EventFlags::wait_any(unsigned, unsigned, bool)
</UL>
<BR>[Called By]<UL><LI><a href="#[2ec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;test_send_recv()
</UL>

<P><STRONG><a name="[2f4]"></a>TCPSocket::send(const void*, unsigned)</STRONG> (Thumb, 212 bytes, Stack size 32 bytes, .\build\tcpsocket.o(i._ZN9TCPSocket4sendEPKvj))
<BR><BR>[Stack]<UL><LI>Max Depth = 560 + Unknown Stack Size
<LI>Call Chain = TCPSocket::send(const void*, unsigned) &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[33a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_assert_internal
<LI><a href="#[2e9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Mutex::unlock()
<LI><a href="#[2e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Mutex::lock(unsigned)
<LI><a href="#[41e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::EventFlags::wait_any(unsigned, unsigned, bool)
</UL>
<BR>[Called By]<UL><LI><a href="#[2ec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;test_send_recv()
</UL>

<P><STRONG><a name="[13b]"></a>TCPSocket::event()</STRONG> (Thumb, 84 bytes, Stack size 16 bytes, .\build\tcpsocket.o(i._ZN9TCPSocket5eventEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 544 + Unknown Stack Size
<LI>Call Chain = TCPSocket::event() &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[33a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_assert_internal
<LI><a href="#[41a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::EventFlags::set(unsigned)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> tcpsocket.o(.constdata__ZTV9TCPSocket)
</UL>
<P><STRONG><a name="[2f3]"></a>TCPSocket::connect(const SocketAddress&)</STRONG> (Thumb, 178 bytes, Stack size 24 bytes, .\build\tcpsocket.o(i._ZN9TCPSocket7connectERK13SocketAddress))
<BR><BR>[Stack]<UL><LI>Max Depth = 552 + Unknown Stack Size
<LI>Call Chain = TCPSocket::connect(const SocketAddress&) &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[33a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_assert_internal
<LI><a href="#[2e9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Mutex::unlock()
<LI><a href="#[2e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Mutex::lock(unsigned)
<LI><a href="#[41e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::EventFlags::wait_any(unsigned, unsigned, bool)
</UL>
<BR>[Called By]<UL><LI><a href="#[2ec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;test_send_recv()
</UL>

<P><STRONG><a name="[13a]"></a>TCPSocket::get_proto()</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, .\build\tcpsocket.o(i._ZN9TCPSocket9get_protoEv))
<BR>[Address Reference Count : 1]<UL><LI> tcpsocket.o(.constdata__ZTV9TCPSocket)
</UL>
<P><STRONG><a name="[2ed]"></a>TCPSocket::TCPSocket()</STRONG> (Thumb, 46 bytes, Stack size 8 bytes, .\build\tcpsocket.o(i._ZN9TCPSocketC1Ev))
<BR><BR>[Stack]<UL><LI>Max Depth = 584 + Unknown Stack Size
<LI>Call Chain = TCPSocket::TCPSocket() &rArr; Socket::Socket__sub_object() &rArr; rtos::Mutex::Mutex() &rArr; rtos::Mutex::constructor(const char*) &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[41f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::EventFlags::EventFlags()
<LI><a href="#[434]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Socket::Socket__sub_object()
</UL>
<BR>[Called By]<UL><LI><a href="#[2ec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;test_send_recv()
</UL>

<P><STRONG><a name="[783]"></a>TCPSocket::TCPSocket__sub_object()</STRONG> (Thumb, 0 bytes, Stack size 8 bytes, .\build\tcpsocket.o(i._ZN9TCPSocketC1Ev), UNUSED)

<P><STRONG><a name="[139]"></a>TCPSocket::~TCPSocket()</STRONG> (Thumb, 38 bytes, Stack size 8 bytes, .\build\tcpsocket.o(i._ZN9TCPSocketD1Ev))
<BR><BR>[Stack]<UL><LI>Max Depth = 64<LI>Call Chain = TCPSocket::~TCPSocket() &rArr; Socket::close() &rArr; rtos::Mutex::lock(unsigned) &rArr; osMutexAcquire
</UL>
<BR>[Calls]<UL><LI><a href="#[420]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::EventFlags::~EventFlags()
<LI><a href="#[2f6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Socket::close()
<LI><a href="#[138]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Socket::~Socket__sub_object()
</UL>
<BR>[Called By]<UL><LI><a href="#[2ec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;test_send_recv()
</UL>
<BR>[Address Reference Count : 1]<UL><LI> tcpsocket.o(.constdata__ZTV9TCPSocket)
</UL>
<P><STRONG><a name="[784]"></a>TCPSocket::~TCPSocket__sub_object()</STRONG> (Thumb, 0 bytes, Stack size 8 bytes, .\build\tcpsocket.o(i._ZN9TCPSocketD1Ev), UNUSED)

<P><STRONG><a name="[13e]"></a>UDPSocket::event()</STRONG> (Thumb, 84 bytes, Stack size 16 bytes, .\build\udpsocket.o(i._ZN9UDPSocket5eventEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 544 + Unknown Stack Size
<LI>Call Chain = UDPSocket::event() &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[33a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_assert_internal
<LI><a href="#[41a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::EventFlags::set(unsigned)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> udpsocket.o(.constdata__ZTV9UDPSocket)
</UL>
<P><STRONG><a name="[31f]"></a>UDPSocket::sendto(const SocketAddress&, const void*, unsigned)</STRONG> (Thumb, 146 bytes, Stack size 40 bytes, .\build\udpsocket.o(i._ZN9UDPSocket6sendtoERK13SocketAddressPKvj))
<BR><BR>[Stack]<UL><LI>Max Depth = 168<LI>Call Chain = UDPSocket::sendto(const SocketAddress&, const void*, unsigned) &rArr; rtos::EventFlags::wait_any(unsigned, unsigned, bool) &rArr; rtos::EventFlags::wait(unsigned, unsigned, unsigned, bool) &rArr; osEventFlagsWait &rArr; isrRtxEventFlagsWait &rArr; EventFlagsCheck
</UL>
<BR>[Calls]<UL><LI><a href="#[2e9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Mutex::unlock()
<LI><a href="#[2e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Mutex::lock(unsigned)
<LI><a href="#[41e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::EventFlags::wait_any(unsigned, unsigned, bool)
</UL>
<BR>[Called By]<UL><LI><a href="#[303]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;nsapi_dns_query_multiple(NetworkStack*, const char*, nsapi_addr*, unsigned, nsapi_version)
</UL>

<P><STRONG><a name="[320]"></a>UDPSocket::recvfrom(SocketAddress*, void*, unsigned)</STRONG> (Thumb, 146 bytes, Stack size 40 bytes, .\build\udpsocket.o(i._ZN9UDPSocket8recvfromEP13SocketAddressPvj))
<BR><BR>[Stack]<UL><LI>Max Depth = 168<LI>Call Chain = UDPSocket::recvfrom(SocketAddress*, void*, unsigned) &rArr; rtos::EventFlags::wait_any(unsigned, unsigned, bool) &rArr; rtos::EventFlags::wait(unsigned, unsigned, unsigned, bool) &rArr; osEventFlagsWait &rArr; isrRtxEventFlagsWait &rArr; EventFlagsCheck
</UL>
<BR>[Calls]<UL><LI><a href="#[2e9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Mutex::unlock()
<LI><a href="#[2e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Mutex::lock(unsigned)
<LI><a href="#[41e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::EventFlags::wait_any(unsigned, unsigned, bool)
</UL>
<BR>[Called By]<UL><LI><a href="#[303]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;nsapi_dns_query_multiple(NetworkStack*, const char*, nsapi_addr*, unsigned, nsapi_version)
</UL>

<P><STRONG><a name="[13d]"></a>UDPSocket::get_proto()</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, .\build\udpsocket.o(i._ZN9UDPSocket9get_protoEv))
<BR>[Address Reference Count : 1]<UL><LI> udpsocket.o(.constdata__ZTV9UDPSocket)
</UL>
<P><STRONG><a name="[31e]"></a>UDPSocket::UDPSocket()</STRONG> (Thumb, 36 bytes, Stack size 8 bytes, .\build\udpsocket.o(i._ZN9UDPSocketC1Ev))
<BR><BR>[Stack]<UL><LI>Max Depth = 584 + Unknown Stack Size
<LI>Call Chain = UDPSocket::UDPSocket() &rArr; Socket::Socket__sub_object() &rArr; rtos::Mutex::Mutex() &rArr; rtos::Mutex::constructor(const char*) &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[41f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::EventFlags::EventFlags()
<LI><a href="#[434]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Socket::Socket__sub_object()
</UL>
<BR>[Called By]<UL><LI><a href="#[303]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;nsapi_dns_query_multiple(NetworkStack*, const char*, nsapi_addr*, unsigned, nsapi_version)
</UL>

<P><STRONG><a name="[785]"></a>UDPSocket::UDPSocket__sub_object()</STRONG> (Thumb, 0 bytes, Stack size 8 bytes, .\build\udpsocket.o(i._ZN9UDPSocketC1Ev), UNUSED)

<P><STRONG><a name="[13c]"></a>UDPSocket::~UDPSocket()</STRONG> (Thumb, 38 bytes, Stack size 8 bytes, .\build\udpsocket.o(i._ZN9UDPSocketD1Ev))
<BR><BR>[Stack]<UL><LI>Max Depth = 64<LI>Call Chain = UDPSocket::~UDPSocket() &rArr; Socket::close() &rArr; rtos::Mutex::lock(unsigned) &rArr; osMutexAcquire
</UL>
<BR>[Calls]<UL><LI><a href="#[420]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::EventFlags::~EventFlags()
<LI><a href="#[2f6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Socket::close()
<LI><a href="#[138]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Socket::~Socket__sub_object()
</UL>
<BR>[Called By]<UL><LI><a href="#[303]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;nsapi_dns_query_multiple(NetworkStack*, const char*, nsapi_addr*, unsigned, nsapi_version)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> udpsocket.o(.constdata__ZTV9UDPSocket)
</UL>
<P><STRONG><a name="[786]"></a>UDPSocket::~UDPSocket__sub_object()</STRONG> (Thumb, 0 bytes, Stack size 8 bytes, .\build\udpsocket.o(i._ZN9UDPSocketD1Ev), UNUSED)

<P><STRONG><a name="[12b]"></a>DirectSerial::poll(short) const</STRONG> (Thumb, 48 bytes, Stack size 16 bytes, .\build\mbed_retarget.o(i._ZNK12DirectSerial4pollEs))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = DirectSerial::poll(short) const
</UL>
<BR>[Calls]<UL><LI><a href="#[346]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_writable
<LI><a href="#[344]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_readable
</UL>
<BR>[Address Reference Count : 1]<UL><LI> mbed_retarget.o(.constdata__ZTV12DirectSerial)
</UL>
<P><STRONG><a name="[334]"></a>SocketAddress::get_ip_address() const</STRONG> (Thumb, 60 bytes, Stack size 8 bytes, .\build\socketaddress.o(i._ZNK13SocketAddress14get_ip_addressEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 168 + Unknown Stack Size
<LI>Call Chain = SocketAddress::get_ip_address() const &rArr; ipv4_to_address(char*, const unsigned char*) &rArr; __2sprintf &rArr; _printf_char_common &rArr; __printf
</UL>
<BR>[Calls]<UL><LI><a href="#[301]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ipv6_to_address(char*, const unsigned char*)
<LI><a href="#[2ff]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ipv4_to_address(char*, const unsigned char*)
</UL>
<BR>[Called By]<UL><LI><a href="#[12e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;NetworkStackWrapper::get_ip_address()
<LI><a href="#[191]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::QUECTEL_BG96_CellularStack::socket_sendto_impl(mbed::AT_CellularStack::CellularSocket*, const SocketAddress&, const void*, unsigned)
<LI><a href="#[190]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::QUECTEL_BG96_CellularStack::create_socket_impl(mbed::AT_CellularStack::CellularSocket*)
</UL>

<P><STRONG><a name="[32a]"></a>SocketAddress::get_ip_version() const</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, .\build\socketaddress.o(i._ZNK13SocketAddress14get_ip_versionEv))
<BR><BR>[Called By]<UL><LI><a href="#[12d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;NetworkStack::gethostbyname(const char*, SocketAddress*, nsapi_version)
<LI><a href="#[174]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularStack::socket_sendto(void*, const SocketAddress&, const void*, unsigned)
</UL>

<P><STRONG><a name="[333]"></a>SocketAddress::get_addr() const</STRONG> (Thumb, 20 bytes, Stack size 16 bytes, .\build\socketaddress.o(i._ZNK13SocketAddress8get_addrEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = SocketAddress::get_addr() const
</UL>
<BR>[Calls]<UL><LI><a href="#[249]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Called By]<UL><LI><a href="#[132]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;NetworkStackWrapper::socket_connect(void*, const SocketAddress&)
<LI><a href="#[135]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;NetworkStackWrapper::socket_sendto(void*, const SocketAddress&, const void*, unsigned)
</UL>

<P><STRONG><a name="[332]"></a>SocketAddress::get_port() const</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, .\build\socketaddress.o(i._ZNK13SocketAddress8get_portEv))
<BR><BR>[Called By]<UL><LI><a href="#[132]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;NetworkStackWrapper::socket_connect(void*, const SocketAddress&)
<LI><a href="#[135]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;NetworkStackWrapper::socket_sendto(void*, const SocketAddress&, const void*, unsigned)
<LI><a href="#[191]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::QUECTEL_BG96_CellularStack::socket_sendto_impl(mbed::AT_CellularStack::CellularSocket*, const SocketAddress&, const void*, unsigned)
<LI><a href="#[190]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::QUECTEL_BG96_CellularStack::create_socket_impl(mbed::AT_CellularStack::CellularSocket*)
</UL>

<P><STRONG><a name="[142]"></a>mbed::FileHandle::poll(short) const</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, .\build\file.o(i._ZNK4mbed10FileHandle4pollEs))
<BR>[Address Reference Count : 4]<UL><LI> filehandle.o(.constdata__ZTVN4mbed10FileHandleE)
<LI> serial.o(.constdata__ZTVN4mbed6SerialE)
<LI> stream.o(.constdata__ZTVN4mbed8FileLikeE)
<LI> stream.o(.constdata__ZTVN4mbed6StreamE)
</UL>
<P><STRONG><a name="[400]"></a>mbed::FileHandle::readable() const</STRONG> (Thumb, 20 bytes, Stack size 8 bytes, .\build\atcmdparser.o(i._ZNK4mbed10FileHandle8readableEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = mbed::FileHandle::readable() const
</UL>
<BR>[Called By]<UL><LI><a href="#[36f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::flush()
<LI><a href="#[381]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::unlock()
<LI><a href="#[c6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::process_oob()
</UL>

<P><STRONG><a name="[35d]"></a>mbed::UARTSerial::hup() const</STRONG> (Thumb, 28 bytes, Stack size 8 bytes, .\build\uartserial.o(i._ZNK4mbed10UARTSerial3hupEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = mbed::UARTSerial::hup() const &rArr; mbed::InterruptIn::read() &rArr; gpio_read &rArr; BUS_RegBitRead
</UL>
<BR>[Calls]<UL><LI><a href="#[364]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::InterruptIn::read()
</UL>
<BR>[Called By]<UL><LI><a href="#[14a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::UARTSerial::poll(short) const
<LI><a href="#[11f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::UARTSerial::tx_irq()
</UL>

<P><STRONG><a name="[14a]"></a>mbed::UARTSerial::poll(short) const</STRONG> (Thumb, 54 bytes, Stack size 16 bytes, .\build\uartserial.o(i._ZNK4mbed10UARTSerial4pollEs))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = mbed::UARTSerial::poll(short) const &rArr; mbed::UARTSerial::hup() const &rArr; mbed::InterruptIn::read() &rArr; gpio_read &rArr; BUS_RegBitRead
</UL>
<BR>[Calls]<UL><LI><a href="#[356]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::CircularBuffer&lang;char, (unsigned)256, unsigned&rang;::empty() const
<LI><a href="#[358]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::CircularBuffer&lang;char, (unsigned)256, unsigned&rang;::full() const
<LI><a href="#[35d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::UARTSerial::hup() const
</UL>
<BR>[Called By]<UL><LI><a href="#[15a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;thunk{-212} to mbed::UARTSerial::poll(short) const
</UL>
<BR>[Address Reference Count : 1]<UL><LI> uartserial.o(.constdata__ZTVN4mbed10UARTSerialE)
</UL>
<P><STRONG><a name="[399]"></a>mbed::ATHandler::get_last_error() const</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, .\build\athandler.o(i._ZNK4mbed9ATHandler14get_last_errorEv))
<BR><BR>[Called By]<UL><LI><a href="#[3a1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::set_context_to_be_activated()
<LI><a href="#[17d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::get_registration_status(mbed::CellularNetwork::RegistrationType, mbed::CellularNetwork::RegistrationStatus&)
<LI><a href="#[39f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::delete_current_context()
<LI><a href="#[39b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::set_registration_urc(bool)
<LI><a href="#[39d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::open_data_channel()
<LI><a href="#[398]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::set_new_context(int)
<LI><a href="#[3f3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::get_char()
<LI><a href="#[3f9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::resp(const char*, bool)
<LI><a href="#[192]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::QUECTEL_BG96_CellularStack::socket_recvfrom_impl(mbed::AT_CellularStack::CellularSocket*, SocketAddress*, void*, unsigned)
<LI><a href="#[191]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::QUECTEL_BG96_CellularStack::socket_sendto_impl(mbed::AT_CellularStack::CellularSocket*, const SocketAddress&, const void*, unsigned)
<LI><a href="#[190]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::QUECTEL_BG96_CellularStack::create_socket_impl(mbed::AT_CellularStack::CellularSocket*)
<LI><a href="#[18f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::QUECTEL_BG96_CellularStack::socket_close_impl(int)
</UL>

<P><STRONG><a name="[159]"></a>thunk{-212} to mbed::UARTSerial::set_blocking(bool)</STRONG> (Thumb, 18 bytes, Stack size 16 bytes, .\build\uartserial.o(i._ZThn212_N4mbed10UARTSerial12set_blockingEb))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = thunk{-212} to mbed::UARTSerial::set_blocking(bool)
</UL>
<BR>[Calls]<UL><LI><a href="#[150]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::UARTSerial::set_blocking(bool)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> uartserial.o(.constdata__ZTVN4mbed10UARTSerialE)
</UL>
<P><STRONG><a name="[154]"></a>thunk{-212} to mbed::UARTSerial::read(void*, unsigned)</STRONG> (Thumb, 22 bytes, Stack size 16 bytes, .\build\uartserial.o(i._ZThn212_N4mbed10UARTSerial4readEPvj))
<BR><BR>[Stack]<UL><LI>Max Depth = 688 + Unknown Stack Size
<LI>Call Chain = thunk{-212} to mbed::UARTSerial::read(void*, unsigned) &rArr; mbed::UARTSerial::read(void*, unsigned) &rArr; mbed::UARTSerial::rx_irq() &rArr; mbed::SerialBase::attach(mbed::Callback&lang;void()&rang;, mbed::SerialBase::IrqType) &rArr; serial_irq_set &rArr; serial_get_tx_irq_index &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[14c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::UARTSerial::read(void*, unsigned)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> uartserial.o(.constdata__ZTVN4mbed10UARTSerialE)
</UL>
<P><STRONG><a name="[156]"></a>thunk{-212} to mbed::UARTSerial::seek(long, int)</STRONG> (Thumb, 22 bytes, Stack size 16 bytes, .\build\uartserial.o(i._ZThn212_N4mbed10UARTSerial4seekEli))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = thunk{-212} to mbed::UARTSerial::seek(long, int)
</UL>
<BR>[Calls]<UL><LI><a href="#[14f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::UARTSerial::seek(long, int)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> uartserial.o(.constdata__ZTVN4mbed10UARTSerialE)
</UL>
<P><STRONG><a name="[157]"></a>thunk{-212} to mbed::UARTSerial::close()</STRONG> (Thumb, 14 bytes, Stack size 4 bytes, .\build\uartserial.o(i._ZThn212_N4mbed10UARTSerial5closeEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = thunk{-212} to mbed::UARTSerial::close()
</UL>
<BR>[Calls]<UL><LI><a href="#[14d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::UARTSerial::close()
</UL>
<BR>[Address Reference Count : 1]<UL><LI> uartserial.o(.constdata__ZTVN4mbed10UARTSerialE)
</UL>
<P><STRONG><a name="[15b]"></a>thunk{-212} to mbed::UARTSerial::sigio(mbed::Callback&lang;void()&rang;)</STRONG> (Thumb, 18 bytes, Stack size 16 bytes, .\build\uartserial.o(i._ZThn212_N4mbed10UARTSerial5sigioENS_8CallbackIFvvEEE))
<BR><BR>[Stack]<UL><LI>Max Depth = 592 + Unknown Stack Size
<LI>Call Chain = thunk{-212} to mbed::UARTSerial::sigio(mbed::Callback&lang;void()&rang;) &rArr; mbed::UARTSerial::sigio(mbed::Callback&lang;void()&rang;) &rArr; mbed::Callback&lang;void()&rang;::operator ()() const &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[151]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::UARTSerial::sigio(mbed::Callback&lang;void()&rang;)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> uartserial.o(.constdata__ZTVN4mbed10UARTSerialE)
</UL>
<P><STRONG><a name="[155]"></a>thunk{-212} to mbed::UARTSerial::write(const void*, unsigned)</STRONG> (Thumb, 22 bytes, Stack size 16 bytes, .\build\uartserial.o(i._ZThn212_N4mbed10UARTSerial5writeEPKvj))
<BR><BR>[Stack]<UL><LI>Max Depth = 688 + Unknown Stack Size
<LI>Call Chain = thunk{-212} to mbed::UARTSerial::write(const void*, unsigned) &rArr; mbed::UARTSerial::write(const void*, unsigned) &rArr; mbed::UARTSerial::tx_irq() &rArr; mbed::SerialBase::attach(mbed::Callback&lang;void()&rang;, mbed::SerialBase::IrqType) &rArr; serial_irq_set &rArr; serial_get_tx_irq_index &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[14b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::UARTSerial::write(const void*, unsigned)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> uartserial.o(.constdata__ZTVN4mbed10UARTSerialE)
</UL>
<P><STRONG><a name="[158]"></a>thunk{-212} to mbed::UARTSerial::isatty()</STRONG> (Thumb, 14 bytes, Stack size 4 bytes, .\build\uartserial.o(i._ZThn212_N4mbed10UARTSerial6isattyEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = thunk{-212} to mbed::UARTSerial::isatty()
</UL>
<BR>[Calls]<UL><LI><a href="#[14e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::UARTSerial::isatty()
</UL>
<BR>[Address Reference Count : 1]<UL><LI> uartserial.o(.constdata__ZTVN4mbed10UARTSerialE)
</UL>
<P><STRONG><a name="[1a3]"></a>thunk{-212} to mbed::Serial::lock()</STRONG> (Thumb, 14 bytes, Stack size 8 bytes, .\build\serial.o(i._ZThn212_N4mbed6Serial4lockEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = thunk{-212} to mbed::Serial::lock() &rArr; mbed::Serial::lock() &rArr; rtos::Mutex::lock(unsigned) &rArr; osMutexAcquire
</UL>
<BR>[Calls]<UL><LI><a href="#[197]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Serial::lock()
</UL>
<BR>[Address Reference Count : 1]<UL><LI> serial.o(.constdata__ZTVN4mbed6SerialE)
</UL>
<P><STRONG><a name="[1a2]"></a>thunk{-212} to mbed::Serial::_getc()</STRONG> (Thumb, 14 bytes, Stack size 8 bytes, .\build\serial.o(i._ZThn212_N4mbed6Serial5_getcEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = thunk{-212} to mbed::Serial::_getc() &rArr; mbed::Serial::_getc() &rArr; mbed::SerialBase::_base_getc() &rArr; serial_getc
</UL>
<BR>[Calls]<UL><LI><a href="#[199]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Serial::_getc()
</UL>
<BR>[Address Reference Count : 1]<UL><LI> serial.o(.constdata__ZTVN4mbed6SerialE)
</UL>
<P><STRONG><a name="[1a1]"></a>thunk{-212} to mbed::Serial::_putc(int)</STRONG> (Thumb, 18 bytes, Stack size 16 bytes, .\build\serial.o(i._ZThn212_N4mbed6Serial5_putcEi))
<BR><BR>[Stack]<UL><LI>Max Depth = 80<LI>Call Chain = thunk{-212} to mbed::Serial::_putc(int) &rArr; mbed::Serial::_putc(int) &rArr; mbed::SerialBase::_base_putc(int) &rArr; serial_putc &rArr; LEUART_Tx
</UL>
<BR>[Calls]<UL><LI><a href="#[19a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Serial::_putc(int)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> serial.o(.constdata__ZTVN4mbed6SerialE)
</UL>
<P><STRONG><a name="[1a4]"></a>thunk{-212} to mbed::Serial::unlock()</STRONG> (Thumb, 14 bytes, Stack size 8 bytes, .\build\serial.o(i._ZThn212_N4mbed6Serial6unlockEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = thunk{-212} to mbed::Serial::unlock() &rArr; mbed::Serial::unlock() &rArr; rtos::Mutex::unlock() &rArr; osMutexRelease
</UL>
<BR>[Calls]<UL><LI><a href="#[198]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Serial::unlock()
</UL>
<BR>[Address Reference Count : 1]<UL><LI> serial.o(.constdata__ZTVN4mbed6SerialE)
</UL>
<P><STRONG><a name="[15a]"></a>thunk{-212} to mbed::UARTSerial::poll(short) const</STRONG> (Thumb, 18 bytes, Stack size 16 bytes, .\build\uartserial.o(i._ZThn212_NK4mbed10UARTSerial4pollEs))
<BR><BR>[Stack]<UL><LI>Max Depth = 72<LI>Call Chain = thunk{-212} to mbed::UARTSerial::poll(short) const &rArr; mbed::UARTSerial::poll(short) const &rArr; mbed::UARTSerial::hup() const &rArr; mbed::InterruptIn::read() &rArr; gpio_read &rArr; BUS_RegBitRead
</UL>
<BR>[Calls]<UL><LI><a href="#[14a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::UARTSerial::poll(short) const
</UL>
<BR>[Address Reference Count : 1]<UL><LI> uartserial.o(.constdata__ZTVN4mbed10UARTSerialE)
</UL>
<P><STRONG><a name="[411]"></a>operator delete[] (void*)</STRONG> (Thumb, 12 bytes, Stack size 8 bytes, .\build\mbed_retarget.o(i._ZdaPv))
<BR><BR>[Stack]<UL><LI>Max Depth = 64<LI>Call Chain = operator delete[] (void*) &rArr; free &rArr; _free_internal &rArr; _mutex_release &rArr; os_kernel_is_active &rArr; osKernelGetState &rArr; svcRtxKernelGetState
</UL>
<BR>[Calls]<UL><LI><a href="#[220]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;free
</UL>
<BR>[Called By]<UL><LI><a href="#[390]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::~ATHandler()
<LI><a href="#[3ad]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Thread::start(mbed::Callback&lang;void()&rang;)
<LI><a href="#[60]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Thread::~Thread()
</UL>

<P><STRONG><a name="[37e]"></a>operator delete (void*)</STRONG> (Thumb, 12 bytes, Stack size 8 bytes, .\build\mbed_retarget.o(i._ZdlPv))
<BR><BR>[Stack]<UL><LI>Max Depth = 64<LI>Call Chain = operator delete (void*) &rArr; free &rArr; _free_internal &rArr; _mutex_release &rArr; os_kernel_is_active &rArr; osKernelGetState &rArr; svcRtxKernelGetState
</UL>
<BR>[Calls]<UL><LI><a href="#[220]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;free
</UL>
<BR>[Called By]<UL><LI><a href="#[390]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::~ATHandler()
<LI><a href="#[369]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularDevice::release_at_handler(mbed::ATHandler*)
<LI><a href="#[16a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularPower::~AT_CellularPower__deallocating()
<LI><a href="#[179]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::~AT_CellularNetwork__deallocating()
<LI><a href="#[170]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularStack::socket_close(void*)
<LI><a href="#[3a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::prepare_event_queue()
<LI><a href="#[194]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::QUECTEL_BG96_CellularNetwork::~QUECTEL_BG96_CellularNetwork__deallocating()
<LI><a href="#[1ac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Thread::~Thread__deallocating()
</UL>

<P><STRONG><a name="[37f]"></a>operator new[] (unsigned)</STRONG> (Thumb, 24 bytes, Stack size 16 bytes, .\build\mbed_retarget.o(i._Znaj))
<BR><BR>[Stack]<UL><LI>Max Depth = 472 + Unknown Stack Size
<LI>Call Chain = operator new[] (unsigned) &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[3e6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;error
<LI><a href="#[21d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;malloc
</UL>
<BR>[Called By]<UL><LI><a href="#[38b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::ATHandler(mbed::FileHandle*, events::EventQueue&, int, const char*)
<LI><a href="#[16f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularStack::socket_open(void**, nsapi_protocol)
<LI><a href="#[3ad]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Thread::start(mbed::Callback&lang;void()&rang;)
</UL>

<P><STRONG><a name="[367]"></a>operator new(unsigned)</STRONG> (Thumb, 24 bytes, Stack size 16 bytes, .\build\mbed_retarget.o(i._Znwj))
<BR><BR>[Stack]<UL><LI>Max Depth = 472 + Unknown Stack Size
<LI>Call Chain = operator new(unsigned) &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[3e6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;error
<LI><a href="#[21d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;malloc
</UL>
<BR>[Called By]<UL><LI><a href="#[15e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularDevice::open_sim(mbed::FileHandle*)
<LI><a href="#[15f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularDevice::open_information(mbed::FileHandle*)
<LI><a href="#[366]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularDevice::get_at_handler(mbed::FileHandle*)
<LI><a href="#[177]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularDevice::open_network(mbed::FileHandle*)
<LI><a href="#[15d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularDevice::open_power(mbed::FileHandle*)
<LI><a href="#[3a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::set_urc_handler(const char*, mbed::Callback&lang;void()&rang;)
<LI><a href="#[16f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularStack::socket_open(void**, nsapi_protocol)
<LI><a href="#[3c5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::CellularConnectionFSM::CellularConnectionFSM()
<LI><a href="#[3b5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::CellularConnectionFSM::start_dispatch()
<LI><a href="#[3a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::prepare_event_queue()
<LI><a href="#[195]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::QUECTEL_BG96_CellularNetwork::get_stack()
<LI><a href="#[15c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::QUECTEL_BG96::open_network(mbed::FileHandle*)
</UL>

<P><STRONG><a name="[25b]"></a>__ARM_fpclassify</STRONG> (Thumb, 48 bytes, Stack size 8 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\m_wm.l(fpclassify.o)(i.__ARM_fpclassify))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = __ARM_fpclassify
</UL>
<BR>[Called By]<UL><LI><a href="#[271]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_fp_hex_real
<LI><a href="#[25a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_fp_dec_real
</UL>

<P><STRONG><a name="[2fa]"></a>__aeabi_atexit</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, .\build\mbed_retarget.o(i.__aeabi_atexit))
<BR><BR>[Called By]<UL><LI><a href="#[1d5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__sti___17_arm_hal_timer_cpp_749a681d
<LI><a href="#[2e3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;default_console()
<LI><a href="#[1d6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__sti___12_ppp_lwip_cpp_b3a13e7c
<LI><a href="#[1d7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__sti___7_SPI_cpp_ab1f1164
<LI><a href="#[1d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__sti___8_main_cpp_led0
</UL>

<P><STRONG><a name="[34a]"></a>__aeabi_vec_ctor_nocookie_nodtor</STRONG> (Thumb, 36 bytes, Stack size 24 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\cpplib\cpprt_w.l(aeabi_vec_ctor_nocookie_nodtor.o)(i.__aeabi_vec_ctor_nocookie_nodtor))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = __aeabi_vec_ctor_nocookie_nodtor
</UL>
<BR>[Called By]<UL><LI><a href="#[347]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::SerialBase::SerialBase(PinName, PinName, int)
<LI><a href="#[1d7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__sti___7_SPI_cpp_ab1f1164
</UL>

<P><STRONG><a name="[2f8]"></a>__cxa_guard_acquire</STRONG> (Thumb, 78 bytes, Stack size 16 bytes, .\build\mbed_retarget.o(i.__cxa_guard_acquire))
<BR><BR>[Stack]<UL><LI>Max Depth = 40 + In Cycle
<LI>Call Chain = __cxa_guard_acquire &rArr;  mbed_assert_internal (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[33a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_assert_internal
<LI><a href="#[30a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;singleton_unlock()
<LI><a href="#[2ea]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;singleton_lock()
</UL>
<BR>[Called By]<UL><LI><a href="#[2e3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;default_console()
</UL>

<P><STRONG><a name="[2fb]"></a>__cxa_guard_release</STRONG> (Thumb, 48 bytes, Stack size 16 bytes, .\build\mbed_retarget.o(i.__cxa_guard_release))
<BR><BR>[Stack]<UL><LI>Max Depth = 32 + In Cycle
<LI>Call Chain = __cxa_guard_release &rArr;  mbed_assert_internal (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[33a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_assert_internal
<LI><a href="#[30a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;singleton_unlock()
</UL>
<BR>[Called By]<UL><LI><a href="#[2e3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;default_console()
</UL>

<P><STRONG><a name="[122]"></a>__cxa_pure_virtual</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\cpplib\cpprt_w.l(pure_virt.o)(i.__cxa_pure_virtual))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = __cxa_pure_virtual &rArr; __rt_SIGPVFN &rArr; __rt_SIGPVFN_inner &rArr; __default_signal_display &rArr; _ttywrch
</UL>
<BR>[Calls]<UL><LI><a href="#[26d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_SIGPVFN
</UL>
<BR>[Address Reference Count : 14]<UL><LI> at_cellularinformation.o(.constdata__ZTVN4mbed19CellularInformationE)
<LI> at_cellulardevice.o(.constdata__ZTVN4mbed14CellularDeviceE)
<LI> at_cellularpower.o(.constdata__ZTVN4mbed13CellularPowerE)
<LI> at_cellularnetwork.o(.constdata__ZTVN4mbed15CellularNetworkE)
<LI> at_cellularsim.o(.constdata__ZTVN4mbed11CellularSIME)
<LI> at_cellularstack.o(.constdata__ZTVN4mbed16AT_CellularStackE)
<LI> easycellularconnection.o(.constdata__ZTV12CellularBase)
<LI> filehandle.o(.constdata__ZTVN4mbed10FileHandleE)
<LI> networkinterface.o(.constdata__ZTV16NetworkInterface)
<LI> networkstack.o(.constdata__ZTV12NetworkStack)
<LI> timerevent.o(.constdata__ZTVN4mbed10TimerEventE)
<LI> socket.o(.constdata__ZTV6Socket)
<LI> stream.o(.constdata__ZTVN4mbed8FileLikeE)
<LI> stream.o(.constdata__ZTVN4mbed6StreamE)
</UL>
<P><STRONG><a name="[1de]"></a>__rt_entry</STRONG> (Thumb, 32 bytes, Stack size 24 bytes, .\build\mbed_boot.o(i.__rt_entry))
<BR><BR>[Stack]<UL><LI>Max Depth = 672 + Unknown Stack Size
<LI>Call Chain = __rt_entry &rArr; mbed_sdk_init &rArr; gpio_init_out_ex &rArr; _gpio_init_out &rArr; gpio_dir &rArr; gpio_mode &rArr; pin_mode &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[43e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_sdk_init
<LI><a href="#[43f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_platform_post_stackheap_init
<LI><a href="#[43b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__user_setup_stackheap
<LI><a href="#[440]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_start_main
<LI><a href="#[43c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_set_stack_heap
<LI><a href="#[43d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_cpy_nvic
</UL>
<BR>[Called By]<UL><LI><a href="#[1d9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__main
<LI><a href="#[1df]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__scatterload_rt2
</UL>

<P><STRONG><a name="[219]"></a>__user_perthread_libspace</STRONG> (Thumb, 98 bytes, Stack size 16 bytes, .\build\rtx_lib.o(i.__user_perthread_libspace))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = __user_perthread_libspace &rArr; os_kernel_is_active &rArr; osKernelGetState &rArr; svcRtxKernelGetState
</UL>
<BR>[Calls]<UL><LI><a href="#[2a6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osThreadGetId
<LI><a href="#[442]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxErrorNotify
<LI><a href="#[441]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;os_kernel_is_active
</UL>
<BR>[Called By]<UL><LI><a href="#[218]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_errno_addr
</UL>

<P><STRONG><a name="[43b]"></a>__user_setup_stackheap</STRONG> (Thumb, 34 bytes, Stack size 40 bytes, .\build\mbed_retarget.o(i.__user_setup_stackheap))
<BR><BR>[Stack]<UL><LI>Max Depth = 80<LI>Call Chain = __user_setup_stackheap &rArr; _mbed_user_setup_stackheap
</UL>
<BR>[Calls]<UL><LI><a href="#[443]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_mbed_user_setup_stackheap
</UL>
<BR>[Called By]<UL><LI><a href="#[1de]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_entry
</UL>

<P><STRONG><a name="[22f]"></a>_is_digit</STRONG> (Thumb, 14 bytes, Stack size 0 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(__printf_wp.o)(i._is_digit))
<BR><BR>[Called By]<UL><LI><a href="#[22e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__printf
</UL>

<P><STRONG><a name="[443]"></a>_mbed_user_setup_stackheap</STRONG> (Thumb, 36 bytes, Stack size 40 bytes, .\build\mbed_retarget.o(i._mbed_user_setup_stackheap))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = _mbed_user_setup_stackheap
</UL>
<BR>[Called By]<UL><LI><a href="#[43b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__user_setup_stackheap
</UL>

<P><STRONG><a name="[1da]"></a>_mutex_acquire</STRONG> (Thumb, 22 bytes, Stack size 8 bytes, .\build\rtx_lib.o(i._mutex_acquire))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = _mutex_acquire &rArr; os_kernel_is_active &rArr; osKernelGetState &rArr; svcRtxKernelGetState
</UL>
<BR>[Calls]<UL><LI><a href="#[2eb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osMutexAcquire
<LI><a href="#[441]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;os_kernel_is_active
</UL>
<BR>[Called By]<UL><LI><a href="#[224]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_char_file
<LI><a href="#[26c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_terminateio
<LI><a href="#[238]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;setvbuf
<LI><a href="#[244]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fopen
<LI><a href="#[243]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;freopen
<LI><a href="#[241]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_freopen_locked
<LI><a href="#[240]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fflush
<LI><a href="#[23e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_do_fflush
<LI><a href="#[23d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fclose
<LI><a href="#[21f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_free_internal
<LI><a href="#[21a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_malloc_internal
</UL>

<P><STRONG><a name="[245]"></a>_mutex_initialize</STRONG> (Thumb, 166 bytes, Stack size 32 bytes, .\build\mbed_boot.o(i._mutex_initialize))
<BR><BR>[Stack]<UL><LI>Max Depth = 136<LI>Call Chain = _mutex_initialize &rArr; malloc &rArr; _malloc_internal &rArr; __Heap_Full &rArr; __Heap_ProvideMemory &rArr; _free_internal &rArr; _mutex_release &rArr; os_kernel_is_active &rArr; osKernelGetState &rArr; svcRtxKernelGetState
</UL>
<BR>[Calls]<UL><LI><a href="#[423]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osMutexNew
<LI><a href="#[311]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;core_util_critical_section_exit
<LI><a href="#[30c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;core_util_critical_section_enter
<LI><a href="#[442]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxErrorNotify
<LI><a href="#[21d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;malloc
</UL>
<BR>[Called By]<UL><LI><a href="#[20c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_initio
<LI><a href="#[253]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__Heap_Initialize
<LI><a href="#[244]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fopen
</UL>

<P><STRONG><a name="[1db]"></a>_mutex_release</STRONG> (Thumb, 18 bytes, Stack size 8 bytes, .\build\rtx_lib.o(i._mutex_release))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = _mutex_release &rArr; os_kernel_is_active &rArr; osKernelGetState &rArr; svcRtxKernelGetState
</UL>
<BR>[Calls]<UL><LI><a href="#[30b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osMutexRelease
<LI><a href="#[441]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;os_kernel_is_active
</UL>
<BR>[Called By]<UL><LI><a href="#[224]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_char_file
<LI><a href="#[26c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_terminateio
<LI><a href="#[238]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;setvbuf
<LI><a href="#[244]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fopen
<LI><a href="#[243]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;freopen
<LI><a href="#[241]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_freopen_locked
<LI><a href="#[240]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fflush
<LI><a href="#[23e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_do_fflush
<LI><a href="#[23d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fclose
<LI><a href="#[21f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_free_internal
<LI><a href="#[21a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_malloc_internal
</UL>

<P><STRONG><a name="[43f]"></a>_platform_post_stackheap_init</STRONG> (Thumb, 8 bytes, Stack size 8 bytes, .\build\rtx_lib.o(i._platform_post_stackheap_init))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = _platform_post_stackheap_init &rArr; osKernelInitialize
</UL>
<BR>[Calls]<UL><LI><a href="#[44a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osKernelInitialize
</UL>
<BR>[Called By]<UL><LI><a href="#[1de]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_entry
</UL>

<P><STRONG><a name="[23b]"></a>_sys_close</STRONG> (Thumb, 12 bytes, Stack size 8 bytes, .\build\mbed_retarget.o(i._sys_close))
<BR><BR>[Stack]<UL><LI>Max Depth = 296<LI>Call Chain = _sys_close &rArr; close &rArr; get_fhc(int) &rArr; get_console(int) &rArr; default_console() &rArr; DirectSerial::DirectSerial(PinName, PinName, int) &rArr; serial_init &rArr; uart_init &rArr; serial_baud &rArr; serial_leuart_baud &rArr;  mbed_assert_internal (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[44b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;close
</UL>
<BR>[Called By]<UL><LI><a href="#[239]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_fclose_internal
</UL>

<P><STRONG><a name="[265]"></a>_sys_flen</STRONG> (Thumb, 62 bytes, Stack size 16 bytes, .\build\mbed_retarget.o(i._sys_flen))
<BR><BR>[Stack]<UL><LI>Max Depth = 288<LI>Call Chain = _sys_flen &rArr; get_fhc(int) &rArr; get_console(int) &rArr; default_console() &rArr; DirectSerial::DirectSerial(PinName, PinName, int) &rArr; serial_init &rArr; uart_init &rArr; serial_baud &rArr; serial_leuart_baud &rArr;  mbed_assert_internal (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[321]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;get_fhc(int)
<LI><a href="#[218]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_errno_addr
</UL>
<BR>[Called By]<UL><LI><a href="#[23f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_fseek
<LI><a href="#[262]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__flsbuf
</UL>

<P><STRONG><a name="[266]"></a>_sys_istty</STRONG> (Thumb, 12 bytes, Stack size 8 bytes, .\build\mbed_retarget.o(i._sys_istty))
<BR><BR>[Stack]<UL><LI>Max Depth = 296<LI>Call Chain = _sys_istty &rArr; isatty &rArr; get_fhc(int) &rArr; get_console(int) &rArr; default_console() &rArr; DirectSerial::DirectSerial(PinName, PinName, int) &rArr; serial_init &rArr; uart_init &rArr; serial_baud &rArr; serial_leuart_baud &rArr;  mbed_assert_internal (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[2e5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;isatty
</UL>
<BR>[Called By]<UL><LI><a href="#[23f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_fseek
<LI><a href="#[262]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__flsbuf
</UL>

<P><STRONG><a name="[242]"></a>_sys_open</STRONG> (Thumb, 146 bytes, Stack size 16 bytes, .\build\mbed_retarget.o(i._sys_open))
<BR><BR>[Stack]<UL><LI>Max Depth = 704 + Unknown Stack Size
<LI>Call Chain = _sys_open &rArr; open &rArr; mbed::FilePath::FilePath(const char*) &rArr; mbed::FileBase::lookup(const char*, unsigned) &rArr; SingletonPtr&lang;rtos::Mutex&rang;::operator -&rang;() &rArr; SingletonPtr&lang;rtos::Mutex&rang;::get() &rArr; rtos::Mutex::Mutex() &rArr; rtos::Mutex::constructor(const char*) &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[321]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;get_fhc(int)
<LI><a href="#[44c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;open
<LI><a href="#[396]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;strcmp
</UL>
<BR>[Called By]<UL><LI><a href="#[241]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_freopen_locked
</UL>

<P><STRONG><a name="[269]"></a>_sys_seek</STRONG> (Thumb, 30 bytes, Stack size 24 bytes, .\build\mbed_retarget.o(i._sys_seek))
<BR><BR>[Stack]<UL><LI>Max Depth = 320<LI>Call Chain = _sys_seek &rArr; lseek &rArr; get_fhc(int) &rArr; get_console(int) &rArr; default_console() &rArr; DirectSerial::DirectSerial(PinName, PinName, int) &rArr; serial_init &rArr; uart_init &rArr; serial_baud &rArr; serial_leuart_baud &rArr;  mbed_assert_internal (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[44d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lseek
</UL>
<BR>[Called By]<UL><LI><a href="#[267]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_writebuf
</UL>

<P><STRONG><a name="[26a]"></a>_sys_write</STRONG> (Thumb, 218 bytes, Stack size 40 bytes, .\build\mbed_retarget.o(i._sys_write))
<BR><BR>[Stack]<UL><LI>Max Depth = 336<LI>Call Chain = _sys_write &rArr; convert_crlf(int) &rArr; isatty &rArr; get_fhc(int) &rArr; get_console(int) &rArr; default_console() &rArr; DirectSerial::DirectSerial(PinName, PinName, int) &rArr; serial_init &rArr; uart_init &rArr; serial_baud &rArr; serial_leuart_baud &rArr;  mbed_assert_internal (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[2e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;convert_crlf(int)
<LI><a href="#[44e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;write
<LI><a href="#[218]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_errno_addr
</UL>
<BR>[Called By]<UL><LI><a href="#[267]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_writebuf
</UL>

<P><STRONG><a name="[649]"></a>_ticker_match_interval_passed</STRONG> (Thumb, 38 bytes, Stack size 0 bytes, .\build\mbed_ticker_api.o(i._ticker_match_interval_passed))
<BR><BR>[Called By]<UL><LI><a href="#[4f2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;schedule_interrupt
</UL>

<P><STRONG><a name="[459]"></a>add_dns_addr</STRONG> (Thumb, 76 bytes, Stack size 24 bytes, .\build\lwip_stack.o(i.add_dns_addr))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = add_dns_addr &rArr; mbed_lwip_get_ip_addr
</UL>
<BR>[Calls]<UL><LI><a href="#[379]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dns_getserver
<LI><a href="#[45a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_get_ip_addr
<LI><a href="#[45b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;get_ip_addr_type
<LI><a href="#[45c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;add_dns_addr_to_dns_list_index
</UL>
<BR>[Called By]<UL><LI><a href="#[392]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_bringup_2
<LI><a href="#[72]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_netif_status_irq
</UL>

<P><STRONG><a name="[642]"></a>arm_random_module_init</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\arm_hal_random.o(i.arm_random_module_init))
<BR><BR>[Called By]<UL><LI><a href="#[564]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;randLIB_seed_random
</UL>

<P><STRONG><a name="[643]"></a>arm_random_seed_get</STRONG> (Thumb, 4 bytes, Stack size 0 bytes, .\build\arm_hal_random.o(i.arm_random_seed_get))
<BR><BR>[Called By]<UL><LI><a href="#[564]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;randLIB_seed_random
</UL>

<P><STRONG><a name="[45e]"></a>auth_withpeer_fail</STRONG> (Thumb, 22 bytes, Stack size 16 bytes, .\build\lwip_auth.o(i.auth_withpeer_fail))
<BR><BR>[Stack]<UL><LI>Max Depth = 712 + Unknown Stack Size
<LI>Call Chain = auth_withpeer_fail &rArr; lcp_close &rArr; fsm_close &rArr; terminate_layer &rArr; fsm_sdata &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lcp_close
</UL>
<BR>[Called By]<UL><LI><a href="#[ce]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;chap_protrej
<LI><a href="#[465]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;chap_handle_status
</UL>

<P><STRONG><a name="[45f]"></a>auth_withpeer_success</STRONG> (Thumb, 90 bytes, Stack size 24 bytes, .\build\lwip_auth.o(i.auth_withpeer_success))
<BR><BR>[Stack]<UL><LI>Max Depth = 752 + Unknown Stack Size
<LI>Call Chain = auth_withpeer_success &rArr; network_phase &rArr; start_networks &rArr; continue_networks &rArr; lcp_close &rArr; fsm_close &rArr; terminate_layer &rArr; fsm_sdata &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[2be]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_warn
<LI><a href="#[2c3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_notice
<LI><a href="#[460]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;network_phase
</UL>
<BR>[Called By]<UL><LI><a href="#[465]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;chap_handle_status
</UL>

<P><STRONG><a name="[461]"></a>cdns</STRONG> (Thumb, 64 bytes, Stack size 24 bytes, .\build\lwip_ppp.o(i.cdns))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = cdns
</UL>
<BR>[Calls]<UL><LI><a href="#[45d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dns_setserver
<LI><a href="#[379]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dns_getserver
</UL>
<BR>[Called By]<UL><LI><a href="#[d9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ipcp_down
</UL>

<P><STRONG><a name="[462]"></a>chap_auth_with_peer</STRONG> (Thumb, 94 bytes, Stack size 24 bytes, .\build\lwip_chap-new.o(i.chap_auth_with_peer))
<BR><BR>[Stack]<UL><LI>Max Depth = 512<LI>Call Chain = chap_auth_with_peer &rArr; ppp_fatal &rArr; ppp_logit &rArr; ppp_vslprintf &rArr; ppp_slprintf &rArr;  ppp_vslprintf (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_fatal
<LI><a href="#[463]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_error
</UL>
<BR>[Called By]<UL><LI><a href="#[531]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;link_established
</UL>

<P><STRONG><a name="[470]"></a>cifaddr</STRONG> (Thumb, 24 bytes, Stack size 16 bytes, .\build\lwip_ppp.o(i.cifaddr))
<BR><BR>[Stack]<UL><LI>Max Depth = 1120 + Unknown Stack Size
<LI>Call Chain = cifaddr &rArr; netif_set_addr &rArr; netif_set_ipaddr &rArr; tcp_netif_ip_addr_changed &rArr; tcp_netif_ip_addr_changed_pcblist &rArr; tcp_abort &rArr; tcp_abandon &rArr; tcp_pcb_remove &rArr; tcp_output &rArr; tcp_output_segment &rArr; ip4_output_if &rArr; ip4_output_if_opt &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[471]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netif_set_addr
</UL>
<BR>[Called By]<UL><LI><a href="#[507]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ipcp_clear_addrs
</UL>

<P><STRONG><a name="[44b]"></a>close</STRONG> (Thumb, 68 bytes, Stack size 16 bytes, .\build\mbed_retarget.o(i.close))
<BR><BR>[Stack]<UL><LI>Max Depth = 288<LI>Call Chain = close &rArr; get_fhc(int) &rArr; get_console(int) &rArr; default_console() &rArr; DirectSerial::DirectSerial(PinName, PinName, int) &rArr; serial_init &rArr; uart_init &rArr; serial_baud &rArr; serial_leuart_baud &rArr;  mbed_assert_internal (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[321]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;get_fhc(int)
<LI><a href="#[218]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_errno_addr
</UL>
<BR>[Called By]<UL><LI><a href="#[23b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_sys_close
</UL>

<P><STRONG><a name="[473]"></a>continue_networks</STRONG> (Thumb, 64 bytes, Stack size 16 bytes, .\build\lwip_auth.o(i.continue_networks))
<BR><BR>[Stack]<UL><LI>Max Depth = 712 + Unknown Stack Size
<LI>Call Chain = continue_networks &rArr; lcp_close &rArr; fsm_close &rArr; terminate_layer &rArr; fsm_sdata &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lcp_close
</UL>
<BR>[Called By]<UL><LI><a href="#[5ac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;start_networks
</UL>

<P><STRONG><a name="[6cb]"></a>core_util_are_interrupts_enabled</STRONG> (Thumb, 16 bytes, Stack size 0 bytes, .\build\mbed_critical.o(i.core_util_are_interrupts_enabled))
<BR><BR>[Called By]<UL><LI><a href="#[6ca]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;wait_us
</UL>

<P><STRONG><a name="[673]"></a>core_util_atomic_decr_u16</STRONG> (Thumb, 22 bytes, Stack size 0 bytes, .\build\mbed_critical.o(i.core_util_atomic_decr_u16))
<BR><BR>[Called By]<UL><LI><a href="#[33e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sleep_manager_unlock_deep_sleep_internal
</UL>

<P><STRONG><a name="[670]"></a>core_util_atomic_incr_u16</STRONG> (Thumb, 22 bytes, Stack size 0 bytes, .\build\mbed_critical.o(i.core_util_atomic_incr_u16))
<BR><BR>[Called By]<UL><LI><a href="#[340]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sleep_manager_lock_deep_sleep_internal
</UL>

<P><STRONG><a name="[30c]"></a>core_util_critical_section_enter</STRONG> (Thumb, 40 bytes, Stack size 8 bytes, .\build\mbed_critical.o(i.core_util_critical_section_enter))
<BR><BR>[Stack]<UL><LI>Max Depth = 16 + In Cycle
<LI>Call Chain = core_util_critical_section_enter &rArr;  mbed_assert_internal (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[33a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_assert_internal
<LI><a href="#[476]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hal_critical_section_enter
</UL>
<BR>[Called By]<UL><LI><a href="#[33a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_assert_internal
<LI><a href="#[3e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Ticker::detach()
<LI><a href="#[3e7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Ticker::setup(unsigned long long)
<LI><a href="#[59]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Timer::~Timer()
<LI><a href="#[317]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Timer::reset()
<LI><a href="#[309]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Ticker::attach_us(mbed::Callback&lang;void()&rang;, unsigned long long)
<LI><a href="#[340]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sleep_manager_lock_deep_sleep_internal
<LI><a href="#[308]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Timer::start()
<LI><a href="#[49c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_mutex_lock
<LI><a href="#[33e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sleep_manager_unlock_deep_sleep_internal
<LI><a href="#[10e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lp_ticker_init
<LI><a href="#[e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ticker_irq_handler
<LI><a href="#[245]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_mutex_initialize
<LI><a href="#[4b1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_error_vfprintf
<LI><a href="#[30e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sleep_manager_sleep_auto
<LI><a href="#[f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;default_idle_hook()
<LI><a href="#[353]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ticker_set_handler
<LI><a href="#[351]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ticker_remove_event
<LI><a href="#[3e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ticker_read_us
<LI><a href="#[34f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ticker_insert_event_us
<LI><a href="#[33f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::SerialBase::attach(mbed::Callback&lang;void()&rang;, mbed::SerialBase::IrqType)
<LI><a href="#[3df]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Timer::slicetime()
<LI><a href="#[3de]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Timer::read_high_resolution_us()
<LI><a href="#[356]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::CircularBuffer&lang;char, (unsigned)256, unsigned&rang;::empty() const
<LI><a href="#[358]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::CircularBuffer&lang;char, (unsigned)256, unsigned&rang;::full() const
<LI><a href="#[35c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::CircularBuffer&lang;char, (unsigned)256, unsigned&rang;::push(const char&)
<LI><a href="#[357]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::CircularBuffer&lang;char, (unsigned)256, unsigned&rang;::pop(char&)
<LI><a href="#[14b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::UARTSerial::write(const void*, unsigned)
<LI><a href="#[151]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::UARTSerial::sigio(mbed::Callback&lang;void()&rang;)
<LI><a href="#[14c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::UARTSerial::read(void*, unsigned)
</UL>

<P><STRONG><a name="[311]"></a>core_util_critical_section_exit</STRONG> (Thumb, 34 bytes, Stack size 8 bytes, .\build\mbed_critical.o(i.core_util_critical_section_exit))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = core_util_critical_section_exit &rArr; hal_critical_section_exit &rArr;  mbed_assert_internal (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[477]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hal_critical_section_exit
</UL>
<BR>[Called By]<UL><LI><a href="#[3e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Ticker::detach()
<LI><a href="#[3e7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Ticker::setup(unsigned long long)
<LI><a href="#[59]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Timer::~Timer()
<LI><a href="#[317]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Timer::reset()
<LI><a href="#[309]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Ticker::attach_us(mbed::Callback&lang;void()&rang;, unsigned long long)
<LI><a href="#[340]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sleep_manager_lock_deep_sleep_internal
<LI><a href="#[308]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Timer::start()
<LI><a href="#[49f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_mutex_unlock
<LI><a href="#[33e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sleep_manager_unlock_deep_sleep_internal
<LI><a href="#[10e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lp_ticker_init
<LI><a href="#[e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ticker_irq_handler
<LI><a href="#[245]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_mutex_initialize
<LI><a href="#[4b1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_error_vfprintf
<LI><a href="#[30e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sleep_manager_sleep_auto
<LI><a href="#[f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;default_idle_hook()
<LI><a href="#[353]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ticker_set_handler
<LI><a href="#[351]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ticker_remove_event
<LI><a href="#[3e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ticker_read_us
<LI><a href="#[34f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ticker_insert_event_us
<LI><a href="#[33f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::SerialBase::attach(mbed::Callback&lang;void()&rang;, mbed::SerialBase::IrqType)
<LI><a href="#[3df]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Timer::slicetime()
<LI><a href="#[3de]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Timer::read_high_resolution_us()
<LI><a href="#[356]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::CircularBuffer&lang;char, (unsigned)256, unsigned&rang;::empty() const
<LI><a href="#[358]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::CircularBuffer&lang;char, (unsigned)256, unsigned&rang;::full() const
<LI><a href="#[35c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::CircularBuffer&lang;char, (unsigned)256, unsigned&rang;::push(const char&)
<LI><a href="#[357]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::CircularBuffer&lang;char, (unsigned)256, unsigned&rang;::pop(char&)
<LI><a href="#[14b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::UARTSerial::write(const void*, unsigned)
<LI><a href="#[151]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::UARTSerial::sigio(mbed::Callback&lang;void()&rang;)
<LI><a href="#[14c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::UARTSerial::read(void*, unsigned)
</UL>

<P><STRONG><a name="[666]"></a>dma_channel_free</STRONG> (Thumb, 24 bytes, Stack size 0 bytes, .\build\dma_api.o(i.dma_channel_free))
<BR><BR>[Called By]<UL><LI><a href="#[65a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_tx_abort_asynch_intern
<LI><a href="#[659]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_rx_abort_asynch_intern
</UL>

<P><STRONG><a name="[48a]"></a>dns_gethostbyname_addrtype</STRONG> (Thumb, 104 bytes, Stack size 32 bytes, .\build\lwip_dns.o(i.dns_gethostbyname_addrtype))
<BR><BR>[Stack]<UL><LI>Max Depth = 1104 + Unknown Stack Size
<LI>Call Chain = dns_gethostbyname_addrtype &rArr; dns_enqueue &rArr; dns_check_entry &rArr; dns_send &rArr; udp_sendto &rArr; udp_sendto_if &rArr; udp_sendto_if_src &rArr; ip4_output_if_src &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[48b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip4addr_aton
<LI><a href="#[48c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dns_lookup
<LI><a href="#[488]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dns_enqueue
<LI><a href="#[31d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;strlen
</UL>
<BR>[Called By]<UL><LI><a href="#[7b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_netconn_do_gethostbyname
</UL>

<P><STRONG><a name="[379]"></a>dns_getserver</STRONG> (Thumb, 18 bytes, Stack size 0 bytes, .\build\lwip_dns.o(i.dns_getserver))
<BR><BR>[Called By]<UL><LI><a href="#[461]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;cdns
<LI><a href="#[459]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;add_dns_addr
<LI><a href="#[fd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_add_dns_server
<LI><a href="#[a2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ppp_link_status(ppp_pcb_s*, int, void*)
</UL>

<P><STRONG><a name="[54b]"></a>dns_init</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\lwip_dns.o(i.dns_init))
<BR><BR>[Called By]<UL><LI><a href="#[543]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_init
</UL>

<P><STRONG><a name="[45d]"></a>dns_setserver</STRONG> (Thumb, 28 bytes, Stack size 0 bytes, .\build\lwip_dns.o(i.dns_setserver))
<BR><BR>[Called By]<UL><LI><a href="#[50c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sdns
<LI><a href="#[461]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;cdns
<LI><a href="#[fd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_add_dns_server
<LI><a href="#[45c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;add_dns_addr_to_dns_list_index
</UL>

<P><STRONG><a name="[10d]"></a>dns_tmr</STRONG> (Thumb, 8 bytes, Stack size 8 bytes, .\build\lwip_dns.o(i.dns_tmr))
<BR><BR>[Stack]<UL><LI>Max Depth = 1024 + Unknown Stack Size
<LI>Call Chain = dns_tmr &rArr; dns_check_entries &rArr; dns_check_entry &rArr; dns_send &rArr; udp_sendto &rArr; udp_sendto_if &rArr; udp_sendto_if_src &rArr; ip4_output_if_src &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[481]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dns_check_entries
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lwip_timeouts.o(.constdata)
</UL>
<P><STRONG><a name="[499]"></a>equeue_alloc</STRONG> (Thumb, 40 bytes, Stack size 16 bytes, .\build\equeue.o(i.equeue_alloc))
<BR><BR>[Stack]<UL><LI>Max Depth = 64<LI>Call Chain = equeue_alloc &rArr; equeue_mem_alloc &rArr; equeue_mutex_unlock &rArr; core_util_critical_section_exit &rArr; hal_critical_section_exit &rArr;  mbed_assert_internal (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[49a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_mem_alloc
</UL>
<BR>[Called By]<UL><LI><a href="#[40e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;int events::EventQueue::call&lang;mbed::Callback&lang;void()&rang;&rang;(T1)
<LI><a href="#[3ba]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;int events::EventQueue::call_in&lang;mbed::Callback&lang;void()&rang;&rang;(int, T1)
<LI><a href="#[436]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_chain
<LI><a href="#[4a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_call_in
</UL>

<P><STRONG><a name="[49b]"></a>equeue_background</STRONG> (Thumb, 88 bytes, Stack size 24 bytes, .\build\equeue.o(i.equeue_background))
<BR><BR>[Stack]<UL><LI>Max Depth = 592 + Unknown Stack Size
<LI>Call Chain = equeue_background &rArr; equeue_tick &rArr; equeue_tick_init() &rArr; mbed::Ticker::attach_us(mbed::Callback&lang;void()&rang;, unsigned long long) &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[49e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_clampdiff
<LI><a href="#[49d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_tick
<LI><a href="#[49f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_mutex_unlock
<LI><a href="#[49c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_mutex_lock
</UL>
<BR>[Called By]<UL><LI><a href="#[436]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_chain
</UL>

<P><STRONG><a name="[4a0]"></a>equeue_call_in</STRONG> (Thumb, 54 bytes, Stack size 24 bytes, .\build\equeue.o(i.equeue_call_in))
<BR><BR>[Stack]<UL><LI>Max Depth = 624 + Unknown Stack Size
<LI>Call Chain = equeue_call_in &rArr; equeue_post &rArr; equeue_tick &rArr; equeue_tick_init() &rArr; mbed::Ticker::attach_us(mbed::Callback&lang;void()&rang;, unsigned long long) &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[4a2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_post
<LI><a href="#[499]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_alloc
<LI><a href="#[4a1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_event_delay
</UL>
<BR>[Called By]<UL><LI><a href="#[64]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_chain_update
</UL>

<P><STRONG><a name="[4a3]"></a>equeue_cancel</STRONG> (Thumb, 36 bytes, Stack size 16 bytes, .\build\equeue.o(i.equeue_cancel))
<BR><BR>[Stack]<UL><LI>Max Depth = 72<LI>Call Chain = equeue_cancel &rArr; equeue_dealloc &rArr; equeue_mem_dealloc &rArr; equeue_mutex_unlock &rArr; core_util_critical_section_exit &rArr; hal_critical_section_exit &rArr;  mbed_assert_internal (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[4a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_unqueue
<LI><a href="#[4a5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_dealloc
</UL>
<BR>[Called By]<UL><LI><a href="#[64]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_chain_update
</UL>

<P><STRONG><a name="[436]"></a>equeue_chain</STRONG> (Thumb, 52 bytes, Stack size 16 bytes, .\build\equeue.o(i.equeue_chain))
<BR><BR>[Stack]<UL><LI>Max Depth = 608 + Unknown Stack Size
<LI>Call Chain = equeue_chain &rArr; equeue_background &rArr; equeue_tick &rArr; equeue_tick_init() &rArr; mbed::Ticker::attach_us(mbed::Callback&lang;void()&rang;, unsigned long long) &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[499]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_alloc
<LI><a href="#[49b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_background
</UL>
<BR>[Called By]<UL><LI><a href="#[3bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;events::EventQueue::chain(events::EventQueue*)
</UL>

<P><STRONG><a name="[438]"></a>equeue_create</STRONG> (Thumb, 44 bytes, Stack size 24 bytes, .\build\equeue.o(i.equeue_create))
<BR><BR>[Stack]<UL><LI>Max Depth = 616 + Unknown Stack Size
<LI>Call Chain = equeue_create &rArr; equeue_create_inplace &rArr; equeue_tick &rArr; equeue_tick_init() &rArr; mbed::Ticker::attach_us(mbed::Callback&lang;void()&rang;, unsigned long long) &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[439]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_create_inplace
<LI><a href="#[21d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;malloc
</UL>
<BR>[Called By]<UL><LI><a href="#[3a9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;events::EventQueue::EventQueue(unsigned, unsigned char*)
</UL>

<P><STRONG><a name="[439]"></a>equeue_create_inplace</STRONG> (Thumb, 124 bytes, Stack size 24 bytes, .\build\equeue.o(i.equeue_create_inplace))
<BR><BR>[Stack]<UL><LI>Max Depth = 592 + Unknown Stack Size
<LI>Call Chain = equeue_create_inplace &rArr; equeue_tick &rArr; equeue_tick_init() &rArr; mbed::Ticker::attach_us(mbed::Callback&lang;void()&rang;, unsigned long long) &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[49d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_tick
<LI><a href="#[4a7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_sema_create
<LI><a href="#[4a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_mutex_create
</UL>
<BR>[Called By]<UL><LI><a href="#[3a9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;events::EventQueue::EventQueue(unsigned, unsigned char*)
<LI><a href="#[438]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_create
</UL>

<P><STRONG><a name="[4a5]"></a>equeue_dealloc</STRONG> (Thumb, 32 bytes, Stack size 16 bytes, .\build\equeue.o(i.equeue_dealloc))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = equeue_dealloc &rArr; equeue_mem_dealloc &rArr; equeue_mutex_unlock &rArr; core_util_critical_section_exit &rArr; hal_critical_section_exit &rArr;  mbed_assert_internal (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[4a9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_mem_dealloc
</UL>
<BR>[Called By]<UL><LI><a href="#[64]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_chain_update
<LI><a href="#[437]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_dispatch
<LI><a href="#[4a3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_cancel
</UL>

<P><STRONG><a name="[43a]"></a>equeue_destroy</STRONG> (Thumb, 80 bytes, Stack size 16 bytes, .\build\equeue.o(i.equeue_destroy))
<BR><BR>[Stack]<UL><LI>Max Depth = 72<LI>Call Chain = equeue_destroy &rArr; free &rArr; _free_internal &rArr; _mutex_release &rArr; os_kernel_is_active &rArr; osKernelGetState &rArr; svcRtxKernelGetState
</UL>
<BR>[Calls]<UL><LI><a href="#[4ac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_sema_destroy
<LI><a href="#[4ab]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_mutex_destroy
<LI><a href="#[220]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;free
</UL>
<BR>[Called By]<UL><LI><a href="#[3ae]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;events::EventQueue::~EventQueue()
</UL>

<P><STRONG><a name="[437]"></a>equeue_dispatch</STRONG> (Thumb, 304 bytes, Stack size 40 bytes, .\build\equeue.o(i.equeue_dispatch))
<BR><BR>[Stack]<UL><LI>Max Depth = 608 + Unknown Stack Size
<LI>Call Chain = equeue_dispatch &rArr; equeue_tick &rArr; equeue_tick_init() &rArr; mbed::Ticker::attach_us(mbed::Callback&lang;void()&rang;, unsigned long long) &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[4a6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_tickdiff
<LI><a href="#[4ae]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_incid
<LI><a href="#[4ad]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_enqueue
<LI><a href="#[4aa]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_dequeue
<LI><a href="#[49e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_clampdiff
<LI><a href="#[49d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_tick
<LI><a href="#[4af]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_sema_wait
<LI><a href="#[49f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_mutex_unlock
<LI><a href="#[49c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_mutex_lock
<LI><a href="#[4a5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_dealloc
</UL>
<BR>[Called By]<UL><LI><a href="#[435]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;events::EventQueue::dispatch(int)
<LI><a href="#[65]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_chain_dispatch
</UL>

<P><STRONG><a name="[4a1]"></a>equeue_event_delay</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, .\build\equeue.o(i.equeue_event_delay))
<BR><BR>[Called By]<UL><LI><a href="#[3ba]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;int events::EventQueue::call_in&lang;mbed::Callback&lang;void()&rang;&rang;(int, T1)
<LI><a href="#[4a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_call_in
</UL>

<P><STRONG><a name="[6d6]"></a>equeue_event_dtor</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, .\build\equeue.o(i.equeue_event_dtor))
<BR><BR>[Called By]<UL><LI><a href="#[40e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;int events::EventQueue::call&lang;mbed::Callback&lang;void()&rang;&rang;(T1)
<LI><a href="#[3ba]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;int events::EventQueue::call_in&lang;mbed::Callback&lang;void()&rang;&rang;(int, T1)
</UL>

<P><STRONG><a name="[4a8]"></a>equeue_mutex_create</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, .\build\equeue_mbed.o(i.equeue_mutex_create))
<BR><BR>[Called By]<UL><LI><a href="#[439]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_create_inplace
</UL>

<P><STRONG><a name="[4ab]"></a>equeue_mutex_destroy</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\equeue_mbed.o(i.equeue_mutex_destroy))
<BR><BR>[Called By]<UL><LI><a href="#[43a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_destroy
</UL>

<P><STRONG><a name="[49c]"></a>equeue_mutex_lock</STRONG> (Thumb, 10 bytes, Stack size 8 bytes, .\build\equeue_mbed.o(i.equeue_mutex_lock))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = equeue_mutex_lock &rArr; core_util_critical_section_enter &rArr;  mbed_assert_internal (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[30c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;core_util_critical_section_enter
</UL>
<BR>[Called By]<UL><LI><a href="#[4a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_unqueue
<LI><a href="#[4a9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_mem_dealloc
<LI><a href="#[49a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_mem_alloc
<LI><a href="#[4ad]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_enqueue
<LI><a href="#[4aa]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_dequeue
<LI><a href="#[437]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_dispatch
<LI><a href="#[49b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_background
</UL>

<P><STRONG><a name="[49f]"></a>equeue_mutex_unlock</STRONG> (Thumb, 10 bytes, Stack size 8 bytes, .\build\equeue_mbed.o(i.equeue_mutex_unlock))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = equeue_mutex_unlock &rArr; core_util_critical_section_exit &rArr; hal_critical_section_exit &rArr;  mbed_assert_internal (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[311]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;core_util_critical_section_exit
</UL>
<BR>[Called By]<UL><LI><a href="#[4a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_unqueue
<LI><a href="#[4a9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_mem_dealloc
<LI><a href="#[49a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_mem_alloc
<LI><a href="#[4ad]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_enqueue
<LI><a href="#[4aa]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_dequeue
<LI><a href="#[437]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_dispatch
<LI><a href="#[49b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_background
</UL>

<P><STRONG><a name="[4a2]"></a>equeue_post</STRONG> (Thumb, 54 bytes, Stack size 32 bytes, .\build\equeue.o(i.equeue_post))
<BR><BR>[Stack]<UL><LI>Max Depth = 600 + Unknown Stack Size
<LI>Call Chain = equeue_post &rArr; equeue_tick &rArr; equeue_tick_init() &rArr; mbed::Ticker::attach_us(mbed::Callback&lang;void()&rang;, unsigned long long) &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[4ad]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_enqueue
<LI><a href="#[49d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_tick
<LI><a href="#[4b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_sema_signal
</UL>
<BR>[Called By]<UL><LI><a href="#[40e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;int events::EventQueue::call&lang;mbed::Callback&lang;void()&rang;&rang;(T1)
<LI><a href="#[3ba]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;int events::EventQueue::call_in&lang;mbed::Callback&lang;void()&rang;&rang;(int, T1)
<LI><a href="#[4a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_call_in
</UL>

<P><STRONG><a name="[4a7]"></a>equeue_sema_create</STRONG> (Thumb, 46 bytes, Stack size 24 bytes, .\build\equeue_mbed.o(i.equeue_sema_create))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = equeue_sema_create &rArr; osEventFlagsNew
</UL>
<BR>[Calls]<UL><LI><a href="#[419]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osEventFlagsNew
</UL>
<BR>[Called By]<UL><LI><a href="#[439]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_create_inplace
</UL>

<P><STRONG><a name="[4ac]"></a>equeue_sema_destroy</STRONG> (Thumb, 12 bytes, Stack size 8 bytes, .\build\equeue_mbed.o(i.equeue_sema_destroy))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = equeue_sema_destroy &rArr; osEventFlagsDelete
</UL>
<BR>[Calls]<UL><LI><a href="#[421]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osEventFlagsDelete
</UL>
<BR>[Called By]<UL><LI><a href="#[43a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_destroy
</UL>

<P><STRONG><a name="[4b0]"></a>equeue_sema_signal</STRONG> (Thumb, 14 bytes, Stack size 8 bytes, .\build\equeue_mbed.o(i.equeue_sema_signal))
<BR><BR>[Stack]<UL><LI>Max Depth = 72<LI>Call Chain = equeue_sema_signal &rArr; osEventFlagsSet &rArr; osRtxPostProcess &rArr; isr_queue_put
</UL>
<BR>[Calls]<UL><LI><a href="#[41b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osEventFlagsSet
</UL>
<BR>[Called By]<UL><LI><a href="#[4a2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_post
</UL>

<P><STRONG><a name="[4af]"></a>equeue_sema_wait</STRONG> (Thumb, 36 bytes, Stack size 16 bytes, .\build\equeue_mbed.o(i.equeue_sema_wait))
<BR><BR>[Stack]<UL><LI>Max Depth = 96<LI>Call Chain = equeue_sema_wait &rArr; osEventFlagsWait &rArr; isrRtxEventFlagsWait &rArr; EventFlagsCheck
</UL>
<BR>[Calls]<UL><LI><a href="#[41d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osEventFlagsWait
</UL>
<BR>[Called By]<UL><LI><a href="#[437]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_dispatch
</UL>

<P><STRONG><a name="[49d]"></a>equeue_tick</STRONG> (Thumb, 38 bytes, Stack size 16 bytes, .\build\equeue_mbed.o(i.equeue_tick))
<BR><BR>[Stack]<UL><LI>Max Depth = 568 + Unknown Stack Size
<LI>Call Chain = equeue_tick &rArr; equeue_tick_init() &rArr; mbed::Ticker::attach_us(mbed::Callback&lang;void()&rang;, unsigned long long) &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[316]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Timer::read_ms()
<LI><a href="#[305]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_tick_init()
</UL>
<BR>[Called By]<UL><LI><a href="#[4a2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_post
<LI><a href="#[437]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_dispatch
<LI><a href="#[439]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_create_inplace
<LI><a href="#[49b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_background
</UL>

<P><STRONG><a name="[3e6]"></a>error</STRONG> (Thumb, 44 bytes, Stack size 24 bytes, .\build\mbed_error.o(i.error))
<BR><BR>[Stack]<UL><LI>Max Depth = 456 + Unknown Stack Size
<LI>Call Chain = error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[4b2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;exit
<LI><a href="#[4b1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_error_vfprintf
</UL>
<BR>[Called By]<UL><LI><a href="#[62b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pinmap_peripheral
<LI><a href="#[628]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pin_location
<LI><a href="#[367]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;operator new(unsigned)
<LI><a href="#[340]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sleep_manager_lock_deep_sleep_internal
<LI><a href="#[37f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;operator new[] (unsigned)
<LI><a href="#[62a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pinmap_merge
<LI><a href="#[33e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sleep_manager_unlock_deep_sleep_internal
<LI><a href="#[552]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_mutex_unlock
<LI><a href="#[554]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_mutex_lock
<LI><a href="#[55c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_mbox_new
<LI><a href="#[57b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_sem_new
<LI><a href="#[457]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_mbox_free
<LI><a href="#[497]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_unprotect
<LI><a href="#[496]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_protect
<LI><a href="#[544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_init
<LI><a href="#[690]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_thread_new
<LI><a href="#[442]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxErrorNotify
<LI><a href="#[440]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_start_main
<LI><a href="#[3e3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Stream::Stream__sub_object(const char*)
</UL>

<P><STRONG><a name="[4b2]"></a>exit</STRONG> (Thumb, 24 bytes, Stack size 0 bytes, .\build\mbed_retarget.o(i.exit))
<BR><BR>[Stack]<UL><LI>Max Depth = 432 + In Cycle
<LI>Call Chain = exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[4b3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_die
<LI><a href="#[240]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fflush
</UL>
<BR>[Called By]<UL><LI><a href="#[3e6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;error
</UL>

<P><STRONG><a name="[4b4]"></a>fault_print_init</STRONG> (Thumb, 20 bytes, Stack size 8 bytes, .\build\mbed_rtx_fault_handler.o(i.fault_print_init))
<BR><BR>[Stack]<UL><LI>Max Depth = 216<LI>Call Chain = fault_print_init &rArr; serial_init &rArr; uart_init &rArr; serial_baud &rArr; serial_leuart_baud &rArr;  mbed_assert_internal (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[327]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_init
</UL>
<BR>[Called By]<UL><LI><a href="#[42]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_fault_handler
</UL>

<P><STRONG><a name="[4b5]"></a>fault_print_str</STRONG> (Thumb, 88 bytes, Stack size 40 bytes, .\build\mbed_rtx_fault_handler.o(i.fault_print_str))
<BR><BR>[Stack]<UL><LI>Max Depth = 72<LI>Call Chain = fault_print_str &rArr; serial_putc &rArr; LEUART_Tx
</UL>
<BR>[Calls]<UL><LI><a href="#[326]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_putc
<LI><a href="#[4b6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hex_to_str
</UL>
<BR>[Called By]<UL><LI><a href="#[42]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_fault_handler
<LI><a href="#[56d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;print_thread
<LI><a href="#[56c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;print_context_info
</UL>

<P><STRONG><a name="[3e9]"></a>fdopen</STRONG> (Thumb, 46 bytes, Stack size 24 bytes, .\build\mbed_retarget.o(i.fdopen))
<BR><BR>[Stack]<UL><LI>Max Depth = 784 + Unknown Stack Size
<LI>Call Chain = fdopen &rArr; fopen &rArr; _freopen_locked &rArr; _sys_open &rArr; open &rArr; mbed::FilePath::FilePath(const char*) &rArr; mbed::FileBase::lookup(const char*, unsigned) &rArr; SingletonPtr&lang;rtos::Mutex&rang;::operator -&rang;() &rArr; SingletonPtr&lang;rtos::Mutex&rang;::get() &rArr; rtos::Mutex::Mutex() &rArr; rtos::Mutex::constructor(const char*) &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[2e5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;isatty
<LI><a href="#[3dd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::mbed_set_unbuffered_stream(std::__FILE*)
<LI><a href="#[244]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fopen
</UL>
<BR>[Called By]<UL><LI><a href="#[3e5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::fdopen(mbed::FileHandle*, const char*)
</UL>

<P><STRONG><a name="[4d]"></a>_fputc$unlocked</STRONG> (Thumb, 26 bytes, Stack size 0 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(fputc.o)(i.fputc))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = _fputc$unlocked &rArr; __flsbuf_byte
</UL>
<BR>[Calls]<UL><LI><a href="#[4ba]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__flsbuf_byte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> _printf_char_file_locked.o(.text)
</UL>
<P><STRONG><a name="[4bb]"></a>fsm_close</STRONG> (Thumb, 96 bytes, Stack size 16 bytes, .\build\lwip_fsm.o(i.fsm_close))
<BR><BR>[Stack]<UL><LI>Max Depth = 672 + Unknown Stack Size
<LI>Call Chain = fsm_close &rArr; terminate_layer &rArr; fsm_sdata &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[4bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;terminate_layer
<LI><a href="#[31d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;strlen
</UL>
<BR>[Called By]<UL><LI><a href="#[f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lcp_close
<LI><a href="#[e1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ipcp_close
</UL>

<P><STRONG><a name="[50b]"></a>fsm_init</STRONG> (Thumb, 20 bytes, Stack size 0 bytes, .\build\lwip_fsm.o(i.fsm_init))
<BR><BR>[Called By]<UL><LI><a href="#[ee]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lcp_init
<LI><a href="#[db]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ipcp_init
</UL>

<P><STRONG><a name="[4bd]"></a>fsm_input</STRONG> (Thumb, 222 bytes, Stack size 40 bytes, .\build\lwip_fsm.o(i.fsm_input))
<BR><BR>[Stack]<UL><LI>Max Depth = 728 + Unknown Stack Size
<LI>Call Chain = fsm_input &rArr; fsm_rconfreq &rArr; fsm_sconfreq &rArr; sys_timeout &rArr; sys_now &rArr; us_ticker_read &rArr; us_ticker_init &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[2c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fsm_sdata
<LI><a href="#[4c1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fsm_rtermreq
<LI><a href="#[4c2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fsm_rtermack
<LI><a href="#[4be]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fsm_rconfreq
<LI><a href="#[4c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fsm_rconfnakrej
<LI><a href="#[4bf]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fsm_rconfack
<LI><a href="#[4c3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fsm_rcoderej
</UL>
<BR>[Called By]<UL><LI><a href="#[ef]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lcp_input
<LI><a href="#[dc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ipcp_input
</UL>

<P><STRONG><a name="[4c4]"></a>fsm_lowerdown</STRONG> (Thumb, 110 bytes, Stack size 8 bytes, .\build\lwip_fsm.o(i.fsm_lowerdown))
<BR><BR>[Stack]<UL><LI>Max Depth = 536 + Unknown Stack Size
<LI>Call Chain = fsm_lowerdown &rArr; sys_untimeout &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[2bf]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_untimeout
</UL>
<BR>[Called By]<UL><LI><a href="#[f2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lcp_lowerdown
<LI><a href="#[4c7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fsm_open
<LI><a href="#[dd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ipcp_protrej
<LI><a href="#[df]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ipcp_lowerdown
</UL>

<P><STRONG><a name="[4c5]"></a>fsm_lowerup</STRONG> (Thumb, 54 bytes, Stack size 8 bytes, .\build\lwip_fsm.o(i.fsm_lowerup))
<BR><BR>[Stack]<UL><LI>Max Depth = 648 + Unknown Stack Size
<LI>Call Chain = fsm_lowerup &rArr; fsm_sconfreq &rArr; sys_timeout &rArr; sys_now &rArr; us_ticker_read &rArr; us_ticker_init &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[4c6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fsm_sconfreq
</UL>
<BR>[Called By]<UL><LI><a href="#[4c7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fsm_open
<LI><a href="#[ef]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lcp_input
<LI><a href="#[68]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lcp_delayed_up
<LI><a href="#[de]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ipcp_lowerup
<LI><a href="#[f1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lcp_lowerup
</UL>

<P><STRONG><a name="[4c7]"></a>fsm_open</STRONG> (Thumb, 108 bytes, Stack size 8 bytes, .\build\lwip_fsm.o(i.fsm_open))
<BR><BR>[Stack]<UL><LI>Max Depth = 656 + Unknown Stack Size
<LI>Call Chain = fsm_open &rArr; fsm_lowerup &rArr; fsm_sconfreq &rArr; sys_timeout &rArr; sys_now &rArr; us_ticker_read &rArr; us_ticker_init &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[4c5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fsm_lowerup
<LI><a href="#[4c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fsm_lowerdown
<LI><a href="#[4c6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fsm_sconfreq
</UL>
<BR>[Called By]<UL><LI><a href="#[e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ipcp_open
<LI><a href="#[f3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lcp_open
</UL>

<P><STRONG><a name="[4c8]"></a>fsm_protreject</STRONG> (Thumb, 106 bytes, Stack size 8 bytes, .\build\lwip_fsm.o(i.fsm_protreject))
<BR><BR>[Stack]<UL><LI>Max Depth = 664 + Unknown Stack Size
<LI>Call Chain = fsm_protreject &rArr; terminate_layer &rArr; fsm_sdata &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[2bf]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_untimeout
<LI><a href="#[4bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;terminate_layer
</UL>
<BR>[Called By]<UL><LI><a href="#[f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lcp_protrej
</UL>

<P><STRONG><a name="[2c4]"></a>fsm_sdata</STRONG> (Thumb, 148 bytes, Stack size 56 bytes, .\build\lwip_fsm.o(i.fsm_sdata))
<BR><BR>[Stack]<UL><LI>Max Depth = 632 + Unknown Stack Size
<LI>Call Chain = fsm_sdata &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[46f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_write
<LI><a href="#[46a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_alloc
<LI><a href="#[46b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_free
<LI><a href="#[249]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Called By]<UL><LI><a href="#[4bd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fsm_input
<LI><a href="#[4bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;terminate_layer
<LI><a href="#[66]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fsm_timeout
<LI><a href="#[4c1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fsm_rtermreq
<LI><a href="#[4be]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fsm_rconfreq
<LI><a href="#[4c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fsm_rconfnakrej
<LI><a href="#[4bf]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fsm_rconfack
<LI><a href="#[ed]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lcp_extcode
<LI><a href="#[2bd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LcpSendEchoRequest
<LI><a href="#[52e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lcp_sprotrej
</UL>

<P><STRONG><a name="[42c]"></a>get_lp_ticker_data</STRONG> (Thumb, 4 bytes, Stack size 0 bytes, .\build\mbed_lp_ticker_api.o(i.get_lp_ticker_data))
<BR><BR>[Called By]<UL><LI><a href="#[2cd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::internal::SysTimer::SysTimer()
</UL>

<P><STRONG><a name="[50d]"></a>get_mask</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, .\build\lwip_ppp.o(i.get_mask))
<BR><BR>[Called By]<UL><LI><a href="#[d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ipcp_up
</UL>

<P><STRONG><a name="[46d]"></a>get_secret</STRONG> (Thumb, 88 bytes, Stack size 32 bytes, .\build\lwip_auth.o(i.get_secret))
<BR><BR>[Stack]<UL><LI>Max Depth = 520<LI>Call Chain = get_secret &rArr; ppp_error &rArr; ppp_logit &rArr; ppp_vslprintf &rArr; ppp_slprintf &rArr;  ppp_vslprintf (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[463]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_error
<LI><a href="#[396]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;strcmp
<LI><a href="#[249]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
<LI><a href="#[31d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;strlen
</UL>
<BR>[Called By]<UL><LI><a href="#[466]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;chap_respond
</UL>

<P><STRONG><a name="[354]"></a>get_us_ticker_data</STRONG> (Thumb, 4 bytes, Stack size 0 bytes, .\build\mbed_us_ticker_api.o(i.get_us_ticker_data))
<BR><BR>[Called By]<UL><LI><a href="#[306]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Timer::Timer()
<LI><a href="#[307]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::TimerEvent::TimerEvent__sub_object()
<LI><a href="#[6ca]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;wait_us
</UL>

<P><STRONG><a name="[446]"></a>gpio_dir</STRONG> (Thumb, 40 bytes, Stack size 16 bytes, .\build\gpio_api.o(i.gpio_dir))
<BR><BR>[Stack]<UL><LI>Max Depth = 600 + Unknown Stack Size
<LI>Call Chain = gpio_dir &rArr; gpio_mode &rArr; pin_mode &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[447]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;gpio_mode
</UL>
<BR>[Called By]<UL><LI><a href="#[448]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_gpio_init_out
<LI><a href="#[444]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_gpio_init_in
</UL>

<P><STRONG><a name="[445]"></a>gpio_init</STRONG> (Thumb, 44 bytes, Stack size 16 bytes, .\build\gpio_api.o(i.gpio_init))
<BR><BR>[Stack]<UL><LI>Max Depth = 544 + Unknown Stack Size
<LI>Call Chain = gpio_init &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[33a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_assert_internal
<LI><a href="#[28b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CMU_ClockEnable
</UL>
<BR>[Called By]<UL><LI><a href="#[448]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_gpio_init_out
<LI><a href="#[444]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_gpio_init_in
</UL>

<P><STRONG><a name="[413]"></a>gpio_init_in</STRONG> (Thumb, 18 bytes, Stack size 16 bytes, .\build\mbed_gpio.o(i.gpio_init_in))
<BR><BR>[Stack]<UL><LI>Max Depth = 648 + Unknown Stack Size
<LI>Call Chain = gpio_init_in &rArr; gpio_init_in_ex &rArr; _gpio_init_in &rArr; gpio_dir &rArr; gpio_mode &rArr; pin_mode &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[415]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;gpio_init_in_ex
</UL>
<BR>[Called By]<UL><LI><a href="#[412]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::DigitalIn::DigitalIn(PinName)
</UL>

<P><STRONG><a name="[415]"></a>gpio_init_in_ex</STRONG> (Thumb, 20 bytes, Stack size 16 bytes, .\build\mbed_gpio.o(i.gpio_init_in_ex))
<BR><BR>[Stack]<UL><LI>Max Depth = 632 + Unknown Stack Size
<LI>Call Chain = gpio_init_in_ex &rArr; _gpio_init_in &rArr; gpio_dir &rArr; gpio_mode &rArr; pin_mode &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[444]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_gpio_init_in
</UL>
<BR>[Called By]<UL><LI><a href="#[413]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;gpio_init_in
<LI><a href="#[414]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::DigitalIn::DigitalIn(PinName, PinMode)
</UL>

<P><STRONG><a name="[336]"></a>gpio_init_out</STRONG> (Thumb, 18 bytes, Stack size 16 bytes, .\build\mbed_gpio.o(i.gpio_init_out))
<BR><BR>[Stack]<UL><LI>Max Depth = 16 + In Cycle
<LI>Call Chain = gpio_init_out &rArr;  gpio_init_out_ex (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[4ca]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;gpio_init_out_ex
</UL>
<BR>[Called By]<UL><LI><a href="#[335]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::DigitalOut::DigitalOut(PinName)
<LI><a href="#[4b3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_die
</UL>

<P><STRONG><a name="[4ca]"></a>gpio_init_out_ex</STRONG> (Thumb, 22 bytes, Stack size 16 bytes, .\build\mbed_gpio.o(i.gpio_init_out_ex))
<BR><BR>[Stack]<UL><LI>Max Depth = 640 + Unknown Stack Size
<LI>Call Chain = gpio_init_out_ex &rArr; _gpio_init_out &rArr; gpio_dir &rArr; gpio_mode &rArr; pin_mode &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[448]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_gpio_init_out
</UL>
<BR>[Called By]<UL><LI><a href="#[336]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;gpio_init_out
<LI><a href="#[43e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_sdk_init
</UL>

<P><STRONG><a name="[447]"></a>gpio_mode</STRONG> (Thumb, 138 bytes, Stack size 24 bytes, .\build\gpio_api.o(i.gpio_mode))
<BR><BR>[Stack]<UL><LI>Max Depth = 584 + Unknown Stack Size
<LI>Call Chain = gpio_mode &rArr; pin_mode &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[4cb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pin_mode
</UL>
<BR>[Called By]<UL><LI><a href="#[446]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;gpio_dir
<LI><a href="#[448]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_gpio_init_out
<LI><a href="#[444]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_gpio_init_in
</UL>

<P><STRONG><a name="[365]"></a>gpio_read</STRONG> (Thumb, 74 bytes, Stack size 16 bytes, .\build\gpio_api.o(i.gpio_read))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = gpio_read &rArr; BUS_RegBitRead
</UL>
<BR>[Calls]<UL><LI><a href="#[4cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BUS_RegBitRead
</UL>
<BR>[Called By]<UL><LI><a href="#[364]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::InterruptIn::read()
</UL>

<P><STRONG><a name="[449]"></a>gpio_write</STRONG> (Thumb, 66 bytes, Stack size 16 bytes, .\build\gpio_api.o(i.gpio_write))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = gpio_write
</UL>
<BR>[Called By]<UL><LI><a href="#[4b3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_die
<LI><a href="#[448]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_gpio_init_out
</UL>

<P><STRONG><a name="[476]"></a>hal_critical_section_enter</STRONG> (Thumb, 34 bytes, Stack size 8 bytes, .\build\mbed_critical_section_api.o(i.hal_critical_section_enter))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = hal_critical_section_enter
</UL>
<BR>[Calls]<UL><LI><a href="#[4cd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;are_interrupts_enabled
</UL>
<BR>[Called By]<UL><LI><a href="#[30c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;core_util_critical_section_enter
</UL>

<P><STRONG><a name="[477]"></a>hal_critical_section_exit</STRONG> (Thumb, 40 bytes, Stack size 8 bytes, .\build\mbed_critical_section_api.o(i.hal_critical_section_exit))
<BR><BR>[Stack]<UL><LI>Max Depth = 8 + In Cycle
<LI>Call Chain = hal_critical_section_exit &rArr;  mbed_assert_internal (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[33a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_assert_internal
<LI><a href="#[4cd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;are_interrupts_enabled
</UL>
<BR>[Called By]<UL><LI><a href="#[311]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;core_util_critical_section_exit
</UL>

<P><STRONG><a name="[4ce]"></a>hal_deepsleep</STRONG> (Thumb, 10 bytes, Stack size 8 bytes, .\build\sleep.o(i.hal_deepsleep))
<BR><BR>[Stack]<UL><LI>Max Depth = 144<LI>Call Chain = hal_deepsleep &rArr; EMU_EnterEM2 &rArr; emState &rArr; CMU_ClockSelectSet &rArr; CMU_ClockFreqGet &rArr; lfClkGet &rArr; getHfLeConfig &rArr; BUS_RegBitRead
</UL>
<BR>[Calls]<UL><LI><a href="#[299]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EMU_EnterEM2
</UL>
<BR>[Called By]<UL><LI><a href="#[30e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sleep_manager_sleep_auto
</UL>

<P><STRONG><a name="[672]"></a>hal_sleep</STRONG> (Thumb, 20 bytes, Stack size 0 bytes, .\build\sleep.o(i.hal_sleep))
<BR><BR>[Called By]<UL><LI><a href="#[30e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sleep_manager_sleep_auto
</UL>

<P><STRONG><a name="[4b6]"></a>hex_to_str</STRONG> (Thumb, 50 bytes, Stack size 32 bytes, .\build\mbed_rtx_fault_handler.o(i.hex_to_str))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = hex_to_str
</UL>
<BR>[Called By]<UL><LI><a href="#[4b5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fault_print_str
</UL>

<P><STRONG><a name="[4cf]"></a>icmp_dest_unreach</STRONG> (Thumb, 18 bytes, Stack size 16 bytes, .\build\lwip_icmp.o(i.icmp_dest_unreach))
<BR><BR>[Stack]<UL><LI>Max Depth = 920 + Unknown Stack Size
<LI>Call Chain = icmp_dest_unreach &rArr; icmp_send_response &rArr; ip4_output_if &rArr; ip4_output_if_opt &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[4d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;icmp_send_response
</UL>
<BR>[Called By]<UL><LI><a href="#[4fb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_input
<LI><a href="#[4f9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip4_input
</UL>

<P><STRONG><a name="[4d1]"></a>icmp_input</STRONG> (Thumb, 432 bytes, Stack size 56 bytes, .\build\lwip_icmp.o(i.icmp_input))
<BR><BR>[Stack]<UL><LI>Max Depth = 912 + Unknown Stack Size
<LI>Call Chain = icmp_input &rArr; ip4_output_if &rArr; ip4_output_if_opt &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[46a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_alloc
<LI><a href="#[4d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_header
<LI><a href="#[4d5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_copy
<LI><a href="#[4d7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip4_output_if
<LI><a href="#[4d2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip4_addr_isbroadcast_u32
<LI><a href="#[4d3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;inet_chksum_pbuf
<LI><a href="#[4d6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;inet_chksum
<LI><a href="#[46b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_free
<LI><a href="#[249]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Called By]<UL><LI><a href="#[4f9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip4_input
</UL>

<P><STRONG><a name="[4d9]"></a>icmp_time_exceeded</STRONG> (Thumb, 18 bytes, Stack size 16 bytes, .\build\lwip_icmp.o(i.icmp_time_exceeded))
<BR><BR>[Stack]<UL><LI>Max Depth = 920 + Unknown Stack Size
<LI>Call Chain = icmp_time_exceeded &rArr; icmp_send_response &rArr; ip4_output_if &rArr; ip4_output_if_opt &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[4d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;icmp_send_response
</UL>
<BR>[Called By]<UL><LI><a href="#[506]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip_reass_free_complete_datagram
</UL>

<P><STRONG><a name="[54a]"></a>igmp_init</STRONG> (Thumb, 14 bytes, Stack size 0 bytes, .\build\lwip_igmp.o(i.igmp_init))
<BR><BR>[Called By]<UL><LI><a href="#[543]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_init
</UL>

<P><STRONG><a name="[4dc]"></a>igmp_input</STRONG> (Thumb, 214 bytes, Stack size 32 bytes, .\build\lwip_igmp.o(i.igmp_input))
<BR><BR>[Stack]<UL><LI>Max Depth = 568 + Unknown Stack Size
<LI>Call Chain = igmp_input &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[4dd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;igmp_lookfor_group
<LI><a href="#[4da]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;igmp_delaying_member
<LI><a href="#[4d6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;inet_chksum
<LI><a href="#[46b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_free
</UL>
<BR>[Called By]<UL><LI><a href="#[4f9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip4_input
</UL>

<P><STRONG><a name="[4e0]"></a>igmp_joingroup</STRONG> (Thumb, 108 bytes, Stack size 24 bytes, .\build\lwip_igmp.o(i.igmp_joingroup))
<BR><BR>[Stack]<UL><LI>Max Depth = 920 + Unknown Stack Size
<LI>Call Chain = igmp_joingroup &rArr; igmp_joingroup_netif &rArr; igmp_send &rArr; igmp_ip_output_if &rArr; ip4_output_if_opt &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[4e1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;igmp_joingroup_netif
</UL>
<BR>[Called By]<UL><LI><a href="#[109]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_setsockopt
</UL>

<P><STRONG><a name="[4e1]"></a>igmp_joingroup_netif</STRONG> (Thumb, 138 bytes, Stack size 16 bytes, .\build\lwip_igmp.o(i.igmp_joingroup_netif))
<BR><BR>[Stack]<UL><LI>Max Depth = 896 + Unknown Stack Size
<LI>Call Chain = igmp_joingroup_netif &rArr; igmp_send &rArr; igmp_ip_output_if &rArr; ip4_output_if_opt &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[4db]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;igmp_start_timer
<LI><a href="#[4e3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;igmp_send
<LI><a href="#[4e2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;igmp_lookup_group
</UL>
<BR>[Called By]<UL><LI><a href="#[4e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;igmp_joingroup
</UL>

<P><STRONG><a name="[4e4]"></a>igmp_leavegroup</STRONG> (Thumb, 108 bytes, Stack size 24 bytes, .\build\lwip_igmp.o(i.igmp_leavegroup))
<BR><BR>[Stack]<UL><LI>Max Depth = 920 + Unknown Stack Size
<LI>Call Chain = igmp_leavegroup &rArr; igmp_leavegroup_netif &rArr; igmp_send &rArr; igmp_ip_output_if &rArr; ip4_output_if_opt &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[4e5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;igmp_leavegroup_netif
</UL>
<BR>[Called By]<UL><LI><a href="#[109]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_setsockopt
</UL>

<P><STRONG><a name="[4e5]"></a>igmp_leavegroup_netif</STRONG> (Thumb, 146 bytes, Stack size 16 bytes, .\build\lwip_igmp.o(i.igmp_leavegroup_netif))
<BR><BR>[Stack]<UL><LI>Max Depth = 896 + Unknown Stack Size
<LI>Call Chain = igmp_leavegroup_netif &rArr; igmp_send &rArr; igmp_ip_output_if &rArr; ip4_output_if_opt &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[4dd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;igmp_lookfor_group
<LI><a href="#[4e3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;igmp_send
<LI><a href="#[4e6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;igmp_remove_group
<LI><a href="#[4e7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memp_free
</UL>
<BR>[Called By]<UL><LI><a href="#[4e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;igmp_leavegroup
</UL>

<P><STRONG><a name="[4dd]"></a>igmp_lookfor_group</STRONG> (Thumb, 32 bytes, Stack size 8 bytes, .\build\lwip_igmp.o(i.igmp_lookfor_group))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = igmp_lookfor_group
</UL>
<BR>[Called By]<UL><LI><a href="#[4e5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;igmp_leavegroup_netif
<LI><a href="#[4dc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;igmp_input
<LI><a href="#[4e2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;igmp_lookup_group
<LI><a href="#[4f9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip4_input
</UL>

<P><STRONG><a name="[4e9]"></a>igmp_report_groups</STRONG> (Thumb, 28 bytes, Stack size 16 bytes, .\build\lwip_igmp.o(i.igmp_report_groups))
<BR><BR>[Stack]<UL><LI>Max Depth = 128<LI>Call Chain = igmp_report_groups &rArr; igmp_delaying_member &rArr; igmp_start_timer &rArr; lwip_get_random &rArr; randLIB_get_32bit &rArr; randLIB_get_64bit &rArr; rol
</UL>
<BR>[Calls]<UL><LI><a href="#[4da]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;igmp_delaying_member
</UL>
<BR>[Called By]<UL><LI><a href="#[5a5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netif_issue_reports
</UL>

<P><STRONG><a name="[4ea]"></a>igmp_start</STRONG> (Thumb, 50 bytes, Stack size 16 bytes, .\build\lwip_igmp.o(i.igmp_start))
<BR><BR>[Stack]<UL><LI>Max Depth = 536 + Unknown Stack Size
<LI>Call Chain = igmp_start &rArr; igmp_lookup_group &rArr; memp_malloc &rArr; do_memp_malloc_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[4e2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;igmp_lookup_group
</UL>
<BR>[Called By]<UL><LI><a href="#[5a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netif_add
</UL>

<P><STRONG><a name="[10c]"></a>igmp_tmr</STRONG> (Thumb, 52 bytes, Stack size 16 bytes, .\build\lwip_igmp.o(i.igmp_tmr))
<BR><BR>[Stack]<UL><LI>Max Depth = 912 + Unknown Stack Size
<LI>Call Chain = igmp_tmr &rArr; igmp_timeout &rArr; igmp_send &rArr; igmp_ip_output_if &rArr; ip4_output_if_opt &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[4eb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;igmp_timeout
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lwip_timeouts.o(.constdata)
</UL>
<P><STRONG><a name="[4d6]"></a>inet_chksum</STRONG> (Thumb, 20 bytes, Stack size 16 bytes, .\build\lwip_inet_chksum.o(i.inet_chksum))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = inet_chksum &rArr; lwip_standard_chksum
</UL>
<BR>[Calls]<UL><LI><a href="#[4ec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_standard_chksum
</UL>
<BR>[Called By]<UL><LI><a href="#[4dc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;igmp_input
<LI><a href="#[4e3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;igmp_send
<LI><a href="#[4d1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;icmp_input
<LI><a href="#[4d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;icmp_send_response
<LI><a href="#[4fa]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip4_reass
<LI><a href="#[4f3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip4_frag
<LI><a href="#[4f9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip4_input
</UL>

<P><STRONG><a name="[4d3]"></a>inet_chksum_pbuf</STRONG> (Thumb, 86 bytes, Stack size 24 bytes, .\build\lwip_inet_chksum.o(i.inet_chksum_pbuf))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = inet_chksum_pbuf &rArr; lwip_standard_chksum
</UL>
<BR>[Calls]<UL><LI><a href="#[4ec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_standard_chksum
</UL>
<BR>[Called By]<UL><LI><a href="#[4d1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;icmp_input
</UL>

<P><STRONG><a name="[4ed]"></a>inet_chksum_pseudo</STRONG> (Thumb, 76 bytes, Stack size 32 bytes, .\build\lwip_inet_chksum.o(i.inet_chksum_pseudo))
<BR><BR>[Stack]<UL><LI>Max Depth = 88<LI>Call Chain = inet_chksum_pseudo &rArr; inet_cksum_pseudo_base &rArr; lwip_standard_chksum
</UL>
<BR>[Calls]<UL><LI><a href="#[4ee]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;inet_cksum_pseudo_base
</UL>
<BR>[Called By]<UL><LI><a href="#[505]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip_chksum_pseudo
</UL>

<P><STRONG><a name="[4d2]"></a>ip4_addr_isbroadcast_u32</STRONG> (Thumb, 78 bytes, Stack size 12 bytes, .\build\lwip_ip4_addr.o(i.ip4_addr_isbroadcast_u32))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = ip4_addr_isbroadcast_u32
</UL>
<BR>[Called By]<UL><LI><a href="#[4d1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;icmp_input
<LI><a href="#[4fb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_input
<LI><a href="#[4fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_input
<LI><a href="#[4f9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip4_input
</UL>

<P><STRONG><a name="[4f3]"></a>ip4_frag</STRONG> (Thumb, 442 bytes, Stack size 96 bytes, .\build\lwip_ip4_frag.o(i.ip4_frag))
<BR><BR>[Stack]<UL><LI>Max Depth = 672 + Unknown Stack Size
<LI>Call Chain = ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[48e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_htons
<LI><a href="#[46a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_alloc
<LI><a href="#[4d6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;inet_chksum
<LI><a href="#[46b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_free
<LI><a href="#[4f7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_ref
<LI><a href="#[4f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_cat
<LI><a href="#[4f5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_alloced_custom
<LI><a href="#[4f6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip_frag_free_pbuf_custom_ref
<LI><a href="#[4f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip_frag_alloc_pbuf_custom_ref
<LI><a href="#[249]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Called By]<UL><LI><a href="#[4fe]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip4_output_if_opt_src
</UL>

<P><STRONG><a name="[4f9]"></a>ip4_input</STRONG> (Thumb, 530 bytes, Stack size 40 bytes, .\build\lwip_ip4.o(i.ip4_input))
<BR><BR>[Stack]<UL><LI>Max Depth = 1176 + Unknown Stack Size
<LI>Call Chain = ip4_input &rArr; tcp_input &rArr; tcp_listen_input &rArr; tcp_alloc &rArr; tcp_kill_prio &rArr; tcp_abort &rArr; tcp_abandon &rArr; tcp_pcb_remove &rArr; tcp_output &rArr; tcp_output_segment &rArr; ip4_output_if &rArr; ip4_output_if_opt &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[48e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_htons
<LI><a href="#[46e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_realloc
<LI><a href="#[4dd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;igmp_lookfor_group
<LI><a href="#[4dc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;igmp_input
<LI><a href="#[4d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_header
<LI><a href="#[4d2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip4_addr_isbroadcast_u32
<LI><a href="#[4d6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;inet_chksum
<LI><a href="#[4d1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;icmp_input
<LI><a href="#[4cf]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;icmp_dest_unreach
<LI><a href="#[46b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_free
<LI><a href="#[4fb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_input
<LI><a href="#[4fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_input
<LI><a href="#[4fd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_header_force
<LI><a href="#[4fa]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip4_reass
</UL>
<BR>[Called By]<UL><LI><a href="#[62f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_input
</UL>

<P><STRONG><a name="[4d7]"></a>ip4_output_if</STRONG> (Thumb, 52 bytes, Stack size 56 bytes, .\build\lwip_ip4.o(i.ip4_output_if))
<BR><BR>[Stack]<UL><LI>Max Depth = 856 + Unknown Stack Size
<LI>Call Chain = ip4_output_if &rArr; ip4_output_if_opt &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[4df]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip4_output_if_opt
</UL>
<BR>[Called By]<UL><LI><a href="#[4d1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;icmp_input
<LI><a href="#[4d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;icmp_send_response
<LI><a href="#[6b3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_output_segment
<LI><a href="#[6ac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_send_empty_ack
<LI><a href="#[6bb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_zero_window_probe
<LI><a href="#[696]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_rst
<LI><a href="#[6ae]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_keepalive
</UL>

<P><STRONG><a name="[4df]"></a>ip4_output_if_opt</STRONG> (Thumb, 68 bytes, Stack size 64 bytes, .\build\lwip_ip4.o(i.ip4_output_if_opt))
<BR><BR>[Stack]<UL><LI>Max Depth = 800 + Unknown Stack Size
<LI>Call Chain = ip4_output_if_opt &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[4fe]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip4_output_if_opt_src
</UL>
<BR>[Called By]<UL><LI><a href="#[4de]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;igmp_ip_output_if
<LI><a href="#[4d7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip4_output_if
</UL>

<P><STRONG><a name="[4fe]"></a>ip4_output_if_opt_src</STRONG> (Thumb, 390 bytes, Stack size 64 bytes, .\build\lwip_ip4.o(i.ip4_output_if_opt_src))
<BR><BR>[Stack]<UL><LI>Max Depth = 736 + Unknown Stack Size
<LI>Call Chain = ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[48e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_htons
<LI><a href="#[4d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_header
<LI><a href="#[4f3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip4_frag
<LI><a href="#[24e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memclr
<LI><a href="#[249]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Called By]<UL><LI><a href="#[4df]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip4_output_if_opt
<LI><a href="#[4ff]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip4_output_if_src
</UL>

<P><STRONG><a name="[4ff]"></a>ip4_output_if_src</STRONG> (Thumb, 52 bytes, Stack size 56 bytes, .\build\lwip_ip4.o(i.ip4_output_if_src))
<BR><BR>[Stack]<UL><LI>Max Depth = 792 + Unknown Stack Size
<LI>Call Chain = ip4_output_if_src &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[4fe]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip4_output_if_opt_src
</UL>
<BR>[Called By]<UL><LI><a href="#[6c3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_sendto_if_src
</UL>

<P><STRONG><a name="[4fa]"></a>ip4_reass</STRONG> (Thumb, 418 bytes, Stack size 40 bytes, .\build\lwip_ip4_frag.o(i.ip4_reass))
<BR><BR>[Stack]<UL><LI>Max Depth = 1048 + Unknown Stack Size
<LI>Call Chain = ip4_reass &rArr; ip_reass_enqueue_new_datagram &rArr; ip_reass_remove_oldest_datagram &rArr; ip_reass_free_complete_datagram &rArr; icmp_time_exceeded &rArr; icmp_send_response &rArr; ip4_output_if &rArr; ip4_output_if_opt &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[48e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_htons
<LI><a href="#[4d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_header
<LI><a href="#[4d6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;inet_chksum
<LI><a href="#[46b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_free
<LI><a href="#[500]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_clen
<LI><a href="#[4f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_cat
<LI><a href="#[501]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip_reass_remove_oldest_datagram
<LI><a href="#[502]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip_reass_enqueue_new_datagram
<LI><a href="#[504]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip_reass_dequeue_datagram
<LI><a href="#[503]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip_reass_chain_frag_into_datagram_and_validate
<LI><a href="#[249]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Called By]<UL><LI><a href="#[4f9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip4_input
</UL>

<P><STRONG><a name="[4d8]"></a>ip4_route</STRONG> (Thumb, 156 bytes, Stack size 8 bytes, .\build\lwip_ip4.o(i.ip4_route))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = ip4_route
</UL>
<BR>[Called By]<UL><LI><a href="#[494]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_sendto
<LI><a href="#[4d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;icmp_send_response
<LI><a href="#[562]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_output
<LI><a href="#[55a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_connect
<LI><a href="#[6ac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_send_empty_ack
<LI><a href="#[6bb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_zero_window_probe
<LI><a href="#[696]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_rst
<LI><a href="#[6ae]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_keepalive
<LI><a href="#[6a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_eff_send_mss_impl
</UL>

<P><STRONG><a name="[48b]"></a>ip4addr_aton</STRONG> (Thumb, 392 bytes, Stack size 48 bytes, .\build\lwip_ip4_addr.o(i.ip4addr_aton))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = ip4addr_aton
</UL>
<BR>[Calls]<UL><LI><a href="#[490]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_htonl
</UL>
<BR>[Called By]<UL><LI><a href="#[392]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_bringup_2
<LI><a href="#[48a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dns_gethostbyname_addrtype
</UL>

<P><STRONG><a name="[505]"></a>ip_chksum_pseudo</STRONG> (Thumb, 36 bytes, Stack size 32 bytes, .\build\lwip_inet_chksum.o(i.ip_chksum_pseudo))
<BR><BR>[Stack]<UL><LI>Max Depth = 120<LI>Call Chain = ip_chksum_pseudo &rArr; inet_chksum_pseudo &rArr; inet_cksum_pseudo_base &rArr; lwip_standard_chksum
</UL>
<BR>[Calls]<UL><LI><a href="#[4ed]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;inet_chksum_pseudo
</UL>
<BR>[Called By]<UL><LI><a href="#[4fb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_input
<LI><a href="#[4fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_input
<LI><a href="#[6b3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_output_segment
<LI><a href="#[6ac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_send_empty_ack
<LI><a href="#[6bb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_zero_window_probe
<LI><a href="#[696]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_rst
<LI><a href="#[6ae]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_keepalive
<LI><a href="#[6c3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_sendto_if_src
</UL>

<P><STRONG><a name="[10b]"></a>ip_reass_tmr</STRONG> (Thumb, 48 bytes, Stack size 16 bytes, .\build\lwip_ip4_frag.o(i.ip_reass_tmr))
<BR><BR>[Stack]<UL><LI>Max Depth = 968 + Unknown Stack Size
<LI>Call Chain = ip_reass_tmr &rArr; ip_reass_free_complete_datagram &rArr; icmp_time_exceeded &rArr; icmp_send_response &rArr; ip4_output_if &rArr; ip4_output_if_opt &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[506]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip_reass_free_complete_datagram
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lwip_timeouts.o(.constdata)
</UL>
<P><STRONG><a name="[2e5]"></a>isatty</STRONG> (Thumb, 56 bytes, Stack size 16 bytes, .\build\mbed_retarget.o(i.isatty))
<BR><BR>[Stack]<UL><LI>Max Depth = 288<LI>Call Chain = isatty &rArr; get_fhc(int) &rArr; get_console(int) &rArr; default_console() &rArr; DirectSerial::DirectSerial(PinName, PinName, int) &rArr; serial_init &rArr; uart_init &rArr; serial_baud &rArr; serial_leuart_baud &rArr;  mbed_assert_internal (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[321]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;get_fhc(int)
<LI><a href="#[218]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_errno_addr
</UL>
<BR>[Called By]<UL><LI><a href="#[2e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;convert_crlf(int)
<LI><a href="#[3e9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fdopen
<LI><a href="#[266]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_sys_istty
</UL>

<P><STRONG><a name="[4c]"></a>isspace</STRONG> (Thumb, 18 bytes, Stack size 8 bytes, .\build\greentea_test_env.o(i.isspace))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = isspace &rArr; __rt_ctype_table &rArr; __rt_locale
</UL>
<BR>[Calls]<UL><LI><a href="#[217]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_ctype_table
</UL>
<BR>[Address Reference Count : 1]<UL><LI> scanf_char.o(.text)
</UL>
<P><STRONG><a name="[f4]"></a>lcp_close</STRONG> (Thumb, 86 bytes, Stack size 24 bytes, .\build\lwip_lcp.o(i.lcp_close))
<BR><BR>[Stack]<UL><LI>Max Depth = 696 + Unknown Stack Size
<LI>Call Chain = lcp_close &rArr; fsm_close &rArr; terminate_layer &rArr; fsm_sdata &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[523]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;new_phase
<LI><a href="#[2bf]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_untimeout
<LI><a href="#[4bb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fsm_close
<LI><a href="#[ec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lcp_finished
</UL>
<BR>[Called By]<UL><LI><a href="#[50a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;np_finished
<LI><a href="#[473]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;continue_networks
<LI><a href="#[45e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;auth_withpeer_fail
<LI><a href="#[e6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lcp_nakci
<LI><a href="#[2c1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LcpLinkFailure
<LI><a href="#[3a6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_close
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lwip_lcp.o(.constdata)
</UL>
<P><STRONG><a name="[f2]"></a>lcp_lowerdown</STRONG> (Thumb, 42 bytes, Stack size 16 bytes, .\build\lwip_lcp.o(i.lcp_lowerdown))
<BR><BR>[Stack]<UL><LI>Max Depth = 552 + Unknown Stack Size
<LI>Call Chain = lcp_lowerdown &rArr; fsm_lowerdown &rArr; sys_untimeout &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[2bf]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_untimeout
<LI><a href="#[4c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fsm_lowerdown
</UL>
<BR>[Called By]<UL><LI><a href="#[52b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;link_terminated
<LI><a href="#[3a6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_close
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lwip_lcp.o(.constdata)
</UL>
<P><STRONG><a name="[f1]"></a>lcp_lowerup</STRONG> (Thumb, 134 bytes, Stack size 24 bytes, .\build\lwip_lcp.o(i.lcp_lowerup))
<BR><BR>[Stack]<UL><LI>Max Depth = 672 + Unknown Stack Size
<LI>Call Chain = lcp_lowerup &rArr; fsm_lowerup &rArr; fsm_sconfreq &rArr; sys_timeout &rArr; sys_now &rArr; us_ticker_read &rArr; us_ticker_init &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[2bf]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_untimeout
<LI><a href="#[2c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_timeout
<LI><a href="#[4c5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fsm_lowerup
<LI><a href="#[526]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_send_config
<LI><a href="#[527]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_recv_config
</UL>
<BR>[Called By]<UL><LI><a href="#[638]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_start
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lwip_lcp.o(.constdata)
</UL>
<P><STRONG><a name="[f3]"></a>lcp_open</STRONG> (Thumb, 60 bytes, Stack size 16 bytes, .\build\lwip_lcp.o(i.lcp_open))
<BR><BR>[Stack]<UL><LI>Max Depth = 672 + Unknown Stack Size
<LI>Call Chain = lcp_open &rArr; fsm_open &rArr; fsm_lowerup &rArr; fsm_sconfreq &rArr; sys_timeout &rArr; sys_now &rArr; us_ticker_read &rArr; us_ticker_init &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[4c7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fsm_open
</UL>
<BR>[Called By]<UL><LI><a href="#[638]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_start
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lwip_lcp.o(.constdata)
</UL>
<P><STRONG><a name="[52e]"></a>lcp_sprotrej</STRONG> (Thumb, 36 bytes, Stack size 24 bytes, .\build\lwip_lcp.o(i.lcp_sprotrej))
<BR><BR>[Stack]<UL><LI>Max Depth = 656 + Unknown Stack Size
<LI>Call Chain = lcp_sprotrej &rArr; fsm_sdata &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[2c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fsm_sdata
</UL>
<BR>[Called By]<UL><LI><a href="#[62f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_input
</UL>

<P><STRONG><a name="[525]"></a>link_down</STRONG> (Thumb, 26 bytes, Stack size 8 bytes, .\build\lwip_auth.o(i.link_down))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = link_down &rArr; upper_layers_down
</UL>
<BR>[Calls]<UL><LI><a href="#[523]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;new_phase
<LI><a href="#[538]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;upper_layers_down
</UL>
<BR>[Called By]<UL><LI><a href="#[ea]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lcp_down
</UL>

<P><STRONG><a name="[531]"></a>link_established</STRONG> (Thumb, 114 bytes, Stack size 24 bytes, .\build\lwip_auth.o(i.link_established))
<BR><BR>[Stack]<UL><LI>Max Depth = 752 + Unknown Stack Size
<LI>Call Chain = link_established &rArr; network_phase &rArr; start_networks &rArr; continue_networks &rArr; lcp_close &rArr; fsm_close &rArr; terminate_layer &rArr; fsm_sdata &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[523]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;new_phase
<LI><a href="#[462]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;chap_auth_with_peer
<LI><a href="#[460]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;network_phase
</UL>
<BR>[Called By]<UL><LI><a href="#[e9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lcp_up
</UL>

<P><STRONG><a name="[52f]"></a>link_required</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\lwip_auth.o(i.link_required))
<BR><BR>[Called By]<UL><LI><a href="#[eb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lcp_starting
</UL>

<P><STRONG><a name="[52b]"></a>link_terminated</STRONG> (Thumb, 42 bytes, Stack size 8 bytes, .\build\lwip_auth.o(i.link_terminated))
<BR><BR>[Stack]<UL><LI>Max Depth = 560 + Unknown Stack Size
<LI>Call Chain = link_terminated &rArr; lcp_lowerdown &rArr; fsm_lowerdown &rArr; sys_untimeout &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[2c3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_notice
<LI><a href="#[539]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_link_terminated
<LI><a href="#[523]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;new_phase
<LI><a href="#[f2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lcp_lowerdown
</UL>
<BR>[Called By]<UL><LI><a href="#[ec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lcp_finished
<LI><a href="#[3a6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_close
</UL>

<P><STRONG><a name="[111]"></a>lp_ticker_clear_interrupt</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\lp_ticker.o(i.lp_ticker_clear_interrupt))
<BR>[Address Reference Count : 1]<UL><LI> mbed_lp_ticker_api.o(.constdata)
</UL>
<P><STRONG><a name="[110]"></a>lp_ticker_disable_interrupt</STRONG> (Thumb, 10 bytes, Stack size 8 bytes, .\build\lp_ticker.o(i.lp_ticker_disable_interrupt))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = lp_ticker_disable_interrupt &rArr; rtc_enable_comp0
</UL>
<BR>[Calls]<UL><LI><a href="#[53a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtc_enable_comp0
</UL>
<BR>[Address Reference Count : 1]<UL><LI> mbed_lp_ticker_api.o(.constdata)
</UL>
<P><STRONG><a name="[113]"></a>lp_ticker_fire_interrupt</STRONG> (Thumb, 8 bytes, Stack size 8 bytes, .\build\lp_ticker.o(i.lp_ticker_fire_interrupt))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = lp_ticker_fire_interrupt
</UL>
<BR>[Calls]<UL><LI><a href="#[53b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtc_force_comp0
</UL>
<BR>[Address Reference Count : 1]<UL><LI> mbed_lp_ticker_api.o(.constdata)
</UL>
<P><STRONG><a name="[114]"></a>lp_ticker_get_info</STRONG> (Thumb, 4 bytes, Stack size 0 bytes, .\build\mbed_retarget.o(i.lp_ticker_get_info))
<BR>[Address Reference Count : 1]<UL><LI> mbed_lp_ticker_api.o(.constdata)
</UL>
<P><STRONG><a name="[10e]"></a>lp_ticker_init</STRONG> (Thumb, 36 bytes, Stack size 8 bytes, .\build\lp_ticker.o(i.lp_ticker_init))
<BR><BR>[Stack]<UL><LI>Max Depth = 112<LI>Call Chain = lp_ticker_init &rArr; rtc_init_real &rArr; CMU_ClockEnable &rArr; CMU_ClockFreqGet &rArr; lfClkGet &rArr; getHfLeConfig &rArr; BUS_RegBitRead
</UL>
<BR>[Calls]<UL><LI><a href="#[311]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;core_util_critical_section_exit
<LI><a href="#[30c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;core_util_critical_section_enter
<LI><a href="#[53d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtc_set_comp0_handler
<LI><a href="#[53c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtc_init_real
</UL>
<BR>[Called By]<UL><LI><a href="#[10f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lp_ticker_read
</UL>
<BR>[Address Reference Count : 1]<UL><LI> mbed_lp_ticker_api.o(.constdata)
</UL>
<P><STRONG><a name="[69]"></a>lp_ticker_irq_handler</STRONG> (Thumb, 18 bytes, Stack size 8 bytes, .\build\mbed_lp_ticker_api.o(i.lp_ticker_irq_handler))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = lp_ticker_irq_handler
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lp_ticker.o(i.lp_ticker_init)
</UL>
<P><STRONG><a name="[10f]"></a>lp_ticker_read</STRONG> (Thumb, 56 bytes, Stack size 32 bytes, .\build\lp_ticker.o(i.lp_ticker_read))
<BR><BR>[Stack]<UL><LI>Max Depth = 144<LI>Call Chain = lp_ticker_read &rArr; lp_ticker_init &rArr; rtc_init_real &rArr; CMU_ClockEnable &rArr; CMU_ClockFreqGet &rArr; lfClkGet &rArr; getHfLeConfig &rArr; BUS_RegBitRead
</UL>
<BR>[Calls]<UL><LI><a href="#[53e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtc_get_full
<LI><a href="#[10e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lp_ticker_init
<LI><a href="#[3e1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_uldivmod
</UL>
<BR>[Called By]<UL><LI><a href="#[112]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lp_ticker_set_interrupt
</UL>
<BR>[Address Reference Count : 1]<UL><LI> mbed_lp_ticker_api.o(.constdata)
</UL>
<P><STRONG><a name="[112]"></a>lp_ticker_set_interrupt</STRONG> (Thumb, 90 bytes, Stack size 40 bytes, .\build\lp_ticker.o(i.lp_ticker_set_interrupt))
<BR><BR>[Stack]<UL><LI>Max Depth = 184<LI>Call Chain = lp_ticker_set_interrupt &rArr; lp_ticker_read &rArr; lp_ticker_init &rArr; rtc_init_real &rArr; CMU_ClockEnable &rArr; CMU_ClockFreqGet &rArr; lfClkGet &rArr; getHfLeConfig &rArr; BUS_RegBitRead
</UL>
<BR>[Calls]<UL><LI><a href="#[53f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtc_set_comp0_value
<LI><a href="#[53e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtc_get_full
<LI><a href="#[10f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lp_ticker_read
<LI><a href="#[3e1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_uldivmod
</UL>
<BR>[Address Reference Count : 1]<UL><LI> mbed_lp_ticker_api.o(.constdata)
</UL>
<P><STRONG><a name="[44d]"></a>lseek</STRONG> (Thumb, 72 bytes, Stack size 24 bytes, .\build\mbed_retarget.o(i.lseek))
<BR><BR>[Stack]<UL><LI>Max Depth = 296<LI>Call Chain = lseek &rArr; get_fhc(int) &rArr; get_console(int) &rArr; default_console() &rArr; DirectSerial::DirectSerial(PinName, PinName, int) &rArr; serial_init &rArr; uart_init &rArr; serial_baud &rArr; serial_leuart_baud &rArr;  mbed_assert_internal (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[321]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;get_fhc(int)
<LI><a href="#[218]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_errno_addr
</UL>
<BR>[Called By]<UL><LI><a href="#[269]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_sys_seek
</UL>

<P><STRONG><a name="[47c]"></a>lwip_get_random</STRONG> (Thumb, 8 bytes, Stack size 8 bytes, .\build\lwip_random.o(i.lwip_get_random))
<BR><BR>[Stack]<UL><LI>Max Depth = 80<LI>Call Chain = lwip_get_random &rArr; randLIB_get_32bit &rArr; randLIB_get_64bit &rArr; rol
</UL>
<BR>[Calls]<UL><LI><a href="#[540]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;randLIB_get_32bit
</UL>
<BR>[Called By]<UL><LI><a href="#[483]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dns_create_txid
<LI><a href="#[47a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dns_alloc_random_port
<LI><a href="#[4db]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;igmp_start_timer
<LI><a href="#[548]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_init
<LI><a href="#[549]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_init
<LI><a href="#[566]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;magic_churnrand
<LI><a href="#[571]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_core_init
</UL>

<P><STRONG><a name="[541]"></a>lwip_hook_tcp_isn</STRONG> (Thumb, 146 bytes, Stack size 136 bytes, .\build\lwip_tcp_isn.o(i.lwip_hook_tcp_isn))
<BR><BR>[Stack]<UL><LI>Max Depth = 712 + Unknown Stack Size
<LI>Call Chain = lwip_hook_tcp_isn &rArr; sys_now &rArr; us_ticker_read &rArr; us_ticker_init &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[468]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;md5_update
<LI><a href="#[467]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;md5_starts
<LI><a href="#[469]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;md5_finish
<LI><a href="#[542]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_now
</UL>
<BR>[Called By]<UL><LI><a href="#[6a3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_next_iss
</UL>

<P><STRONG><a name="[490]"></a>lwip_htonl</STRONG> (Thumb, 26 bytes, Stack size 0 bytes, .\build\lwip_def.o(i.lwip_htonl))
<BR><BR>[Called By]<UL><LI><a href="#[48b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip4addr_aton
<LI><a href="#[62]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dns_recv
<LI><a href="#[562]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_output
<LI><a href="#[d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ipcp_up
<LI><a href="#[d7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ipcp_reqci
<LI><a href="#[d6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ipcp_rejci
<LI><a href="#[d5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ipcp_nakci
<LI><a href="#[d3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ipcp_addci
<LI><a href="#[d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ipcp_ackci
<LI><a href="#[4fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_input
<LI><a href="#[6b3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_output_segment
<LI><a href="#[6af]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_output_alloc_header
<LI><a href="#[6a6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_create_segment
<LI><a href="#[6ac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_send_empty_ack
<LI><a href="#[6b7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_rexmit
<LI><a href="#[6b6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_receive
<LI><a href="#[6bb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_zero_window_probe
<LI><a href="#[696]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_rst
<LI><a href="#[6ae]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_keepalive
<LI><a href="#[632]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_vslprintf
</UL>

<P><STRONG><a name="[48e]"></a>lwip_htons</STRONG> (Thumb, 12 bytes, Stack size 0 bytes, .\build\lwip_def.o(i.lwip_htons))
<BR><BR>[Called By]<UL><LI><a href="#[484]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dns_send
<LI><a href="#[62]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dns_recv
<LI><a href="#[561]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_write
<LI><a href="#[4ec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_standard_chksum
<LI><a href="#[4ee]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;inet_cksum_pseudo_base
<LI><a href="#[562]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_output
<LI><a href="#[503]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip_reass_chain_frag_into_datagram_and_validate
<LI><a href="#[4fb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_input
<LI><a href="#[4fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_input
<LI><a href="#[4fa]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip4_reass
<LI><a href="#[4f3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip4_frag
<LI><a href="#[4fe]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip4_output_if_opt_src
<LI><a href="#[4f9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip4_input
<LI><a href="#[6b3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_output_segment
<LI><a href="#[6af]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_output_alloc_header
<LI><a href="#[6a6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_create_segment
<LI><a href="#[6b6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_receive
<LI><a href="#[6bb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_zero_window_probe
<LI><a href="#[6a2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_send_fin
<LI><a href="#[696]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_rst
<LI><a href="#[6c3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_sendto_if_src
</UL>

<P><STRONG><a name="[543]"></a>lwip_init</STRONG> (Thumb, 44 bytes, Stack size 8 bytes, .\build\lwip_init.o(i.lwip_init))
<BR><BR>[Stack]<UL><LI>Max Depth = 712 + Unknown Stack Size
<LI>Call Chain = lwip_init &rArr; ppp_init &rArr; magic_init &rArr; magic_churnrand &rArr; sys_jiffies &rArr; us_ticker_read &rArr; us_ticker_init &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[54b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dns_init
<LI><a href="#[54a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;igmp_init
<LI><a href="#[548]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_init
<LI><a href="#[549]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_init
<LI><a href="#[54d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_timeouts_init
<LI><a href="#[544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_init
<LI><a href="#[54c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_init
<LI><a href="#[547]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netif_init
<LI><a href="#[546]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memp_init
<LI><a href="#[545]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mem_init
</UL>
<BR>[Called By]<UL><LI><a href="#[57c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcpip_init
</UL>

<P><STRONG><a name="[54e]"></a>lwip_init_tcp_isn</STRONG> (Thumb, 36 bytes, Stack size 16 bytes, .\build\lwip_tcp_isn.o(i.lwip_init_tcp_isn))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = lwip_init_tcp_isn
</UL>
<BR>[Calls]<UL><LI><a href="#[24e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memclr
<LI><a href="#[249]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Called By]<UL><LI><a href="#[571]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_core_init
</UL>

<P><STRONG><a name="[76]"></a>lwip_netconn_do_bind</STRONG> (Thumb, 130 bytes, Stack size 16 bytes, .\build\lwip_api_msg.o(i.lwip_netconn_do_bind))
<BR><BR>[Stack]<UL><LI>Max Depth = 664 + Unknown Stack Size
<LI>Call Chain = lwip_netconn_do_bind &rArr; tcp_bind &rArr; tcp_timer_needed &rArr; sys_timeout &rArr; sys_now &rArr; us_ticker_read &rArr; us_ticker_init &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[47d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_bind
<LI><a href="#[54f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_bind
<LI><a href="#[497]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_unprotect
<LI><a href="#[496]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_protect
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lwip_api_lib.o(i.netconn_bind)
</UL>
<P><STRONG><a name="[77]"></a>lwip_netconn_do_close</STRONG> (Thumb, 174 bytes, Stack size 24 bytes, .\build\lwip_api_msg.o(i.lwip_netconn_do_close))
<BR><BR>[Stack]<UL><LI>Max Depth = 1096 + Unknown Stack Size
<LI>Call Chain = lwip_netconn_do_close &rArr; lwip_netconn_do_close_internal &rArr; tcp_abort &rArr; tcp_abandon &rArr; tcp_pcb_remove &rArr; tcp_output &rArr; tcp_output_segment &rArr; ip4_output_if &rArr; ip4_output_if_opt &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[552]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_mutex_unlock
<LI><a href="#[554]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_mutex_lock
<LI><a href="#[550]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netconn_drain
<LI><a href="#[551]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_netconn_do_close_internal
<LI><a href="#[497]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_unprotect
<LI><a href="#[553]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_sem_wait
<LI><a href="#[496]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_protect
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lwip_api_lib.o(i.netconn_close_shutdown)
</UL>
<P><STRONG><a name="[78]"></a>lwip_netconn_do_connect</STRONG> (Thumb, 264 bytes, Stack size 16 bytes, .\build\lwip_api_msg.o(i.lwip_netconn_do_connect))
<BR><BR>[Stack]<UL><LI>Max Depth = 1016 + Unknown Stack Size
<LI>Call Chain = lwip_netconn_do_connect &rArr; tcp_connect &rArr; tcp_output &rArr; tcp_output_segment &rArr; ip4_output_if &rArr; ip4_output_if_opt &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[559]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_connect
<LI><a href="#[55a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_connect
<LI><a href="#[552]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_mutex_unlock
<LI><a href="#[554]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_mutex_lock
<LI><a href="#[451]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;setup_tcp
<LI><a href="#[497]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_unprotect
<LI><a href="#[553]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_sem_wait
<LI><a href="#[496]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_protect
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lwip_api_lib.o(i.netconn_connect)
</UL>
<P><STRONG><a name="[79]"></a>lwip_netconn_do_delconn</STRONG> (Thumb, 256 bytes, Stack size 24 bytes, .\build\lwip_api_msg.o(i.lwip_netconn_do_delconn))
<BR><BR>[Stack]<UL><LI>Max Depth = 1096 + Unknown Stack Size
<LI>Call Chain = lwip_netconn_do_delconn &rArr; lwip_netconn_do_close_internal &rArr; tcp_abort &rArr; tcp_abandon &rArr; tcp_pcb_remove &rArr; tcp_output &rArr; tcp_output_segment &rArr; ip4_output_if &rArr; ip4_output_if_opt &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[47e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_remove
<LI><a href="#[552]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_mutex_unlock
<LI><a href="#[554]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_mutex_lock
<LI><a href="#[550]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netconn_drain
<LI><a href="#[551]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_netconn_do_close_internal
<LI><a href="#[497]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_unprotect
<LI><a href="#[553]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_sem_wait
<LI><a href="#[496]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_protect
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lwip_api_lib.o(i.netconn_delete)
</UL>
<P><STRONG><a name="[7a]"></a>lwip_netconn_do_getaddr</STRONG> (Thumb, 208 bytes, Stack size 16 bytes, .\build\lwip_api_msg.o(i.lwip_netconn_do_getaddr))
<BR><BR>[Stack]<UL><LI>Max Depth = 480 + Unknown Stack Size
<LI>Call Chain = lwip_netconn_do_getaddr &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[497]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_unprotect
<LI><a href="#[496]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_protect
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lwip_api_lib.o(i.netconn_getaddr)
</UL>
<P><STRONG><a name="[7b]"></a>lwip_netconn_do_gethostbyname</STRONG> (Thumb, 44 bytes, Stack size 24 bytes, .\build\lwip_api_msg.o(i.lwip_netconn_do_gethostbyname))
<BR><BR>[Stack]<UL><LI>Max Depth = 1128 + Unknown Stack Size
<LI>Call Chain = lwip_netconn_do_gethostbyname &rArr; dns_gethostbyname_addrtype &rArr; dns_enqueue &rArr; dns_check_entry &rArr; dns_send &rArr; udp_sendto &rArr; udp_sendto_if &rArr; udp_sendto_if_src &rArr; ip4_output_if_src &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[37c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_sem_signal
<LI><a href="#[48a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dns_gethostbyname_addrtype
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lwip_api_lib.o(i.netconn_gethostbyname)
</UL>
<P><STRONG><a name="[7c]"></a>lwip_netconn_do_listen</STRONG> (Thumb, 270 bytes, Stack size 24 bytes, .\build\lwip_api_msg.o(i.lwip_netconn_do_listen))
<BR><BR>[Stack]<UL><LI>Max Depth = 1016 + Unknown Stack Size
<LI>Call Chain = lwip_netconn_do_listen &rArr; tcp_close &rArr; tcp_close_shutdown &rArr; tcp_pcb_remove &rArr; tcp_output &rArr; tcp_output_segment &rArr; ip4_output_if &rArr; ip4_output_if_opt &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[55b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_listen_with_backlog_and_err
<LI><a href="#[556]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_close
<LI><a href="#[452]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_arg
<LI><a href="#[555]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_accept
<LI><a href="#[55c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_mbox_new
<LI><a href="#[457]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_mbox_free
<LI><a href="#[497]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_unprotect
<LI><a href="#[496]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_protect
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lwip_api_lib.o(i.netconn_listen_with_backlog)
</UL>
<P><STRONG><a name="[7d]"></a>lwip_netconn_do_newconn</STRONG> (Thumb, 64 bytes, Stack size 16 bytes, .\build\lwip_api_msg.o(i.lwip_netconn_do_newconn))
<BR><BR>[Stack]<UL><LI>Max Depth = 1104 + Unknown Stack Size
<LI>Call Chain = lwip_netconn_do_newconn &rArr; pcb_new &rArr; tcp_new_ip_type &rArr; tcp_alloc &rArr; tcp_kill_prio &rArr; tcp_abort &rArr; tcp_abandon &rArr; tcp_pcb_remove &rArr; tcp_output &rArr; tcp_output_segment &rArr; ip4_output_if &rArr; ip4_output_if_opt &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[55d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pcb_new
<LI><a href="#[497]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_unprotect
<LI><a href="#[496]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_protect
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lwip_api_lib.o(i.netconn_new_with_proto_and_callback)
</UL>
<P><STRONG><a name="[7e]"></a>lwip_netconn_do_recv</STRONG> (Thumb, 112 bytes, Stack size 24 bytes, .\build\lwip_api_msg.o(i.lwip_netconn_do_recv))
<BR><BR>[Stack]<UL><LI>Max Depth = 984 + Unknown Stack Size
<LI>Call Chain = lwip_netconn_do_recv &rArr; tcp_recved &rArr; tcp_output &rArr; tcp_output_segment &rArr; ip4_output_if &rArr; ip4_output_if_opt &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[55e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_recved
<LI><a href="#[497]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_unprotect
<LI><a href="#[496]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_protect
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lwip_api_lib.o(i.netconn_recv_data)
</UL>
<P><STRONG><a name="[7f]"></a>lwip_netconn_do_send</STRONG> (Thumb, 140 bytes, Stack size 16 bytes, .\build\lwip_api_msg.o(i.lwip_netconn_do_send))
<BR><BR>[Stack]<UL><LI>Max Depth = 952 + Unknown Stack Size
<LI>Call Chain = lwip_netconn_do_send &rArr; udp_send &rArr; udp_sendto &rArr; udp_sendto_if &rArr; udp_sendto_if_src &rArr; ip4_output_if_src &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[494]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_sendto
<LI><a href="#[55f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_send
<LI><a href="#[497]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_unprotect
<LI><a href="#[496]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_protect
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lwip_api_lib.o(i.netconn_send)
</UL>
<P><STRONG><a name="[80]"></a>lwip_netconn_do_write</STRONG> (Thumb, 166 bytes, Stack size 16 bytes, .\build\lwip_api_msg.o(i.lwip_netconn_do_write))
<BR><BR>[Stack]<UL><LI>Max Depth = 1016 + Unknown Stack Size
<LI>Call Chain = lwip_netconn_do_write &rArr; lwip_netconn_do_writemore &rArr; tcp_output &rArr; tcp_output_segment &rArr; ip4_output_if &rArr; ip4_output_if_opt &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[552]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_mutex_unlock
<LI><a href="#[554]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_mutex_lock
<LI><a href="#[560]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_netconn_do_writemore
<LI><a href="#[497]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_unprotect
<LI><a href="#[553]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_sem_wait
<LI><a href="#[496]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_protect
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lwip_api_lib.o(i.netconn_write_partly)
</UL>
<P><STRONG><a name="[563]"></a>lwip_seed_random</STRONG> (Thumb, 8 bytes, Stack size 8 bytes, .\build\lwip_random.o(i.lwip_seed_random))
<BR><BR>[Stack]<UL><LI>Max Depth = 60<LI>Call Chain = lwip_seed_random &rArr; randLIB_seed_random &rArr; randLIB_add_seed &rArr; splitmix64
</UL>
<BR>[Calls]<UL><LI><a href="#[564]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;randLIB_seed_random
</UL>
<BR>[Called By]<UL><LI><a href="#[571]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_core_init
</UL>

<P><STRONG><a name="[4ec]"></a>lwip_standard_chksum</STRONG> (Thumb, 72 bytes, Stack size 24 bytes, .\build\lwip_inet_chksum.o(i.lwip_standard_chksum))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = lwip_standard_chksum
</UL>
<BR>[Calls]<UL><LI><a href="#[48e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_htons
</UL>
<BR>[Called By]<UL><LI><a href="#[4ee]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;inet_cksum_pseudo_base
<LI><a href="#[4d3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;inet_chksum_pbuf
<LI><a href="#[4d6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;inet_chksum
</UL>

<P><STRONG><a name="[489]"></a>lwip_strnicmp</STRONG> (Thumb, 70 bytes, Stack size 20 bytes, .\build\lwip_def.o(i.lwip_strnicmp))
<BR><BR>[Stack]<UL><LI>Max Depth = 20<LI>Call Chain = lwip_strnicmp
</UL>
<BR>[Called By]<UL><LI><a href="#[48c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dns_lookup
<LI><a href="#[488]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dns_enqueue
</UL>

<P><STRONG><a name="[52c]"></a>magic</STRONG> (Thumb, 14 bytes, Stack size 8 bytes, .\build\lwip_magic.o(i.magic))
<BR><BR>[Stack]<UL><LI>Max Depth = 276<LI>Call Chain = magic &rArr; magic_random_bytes &rArr; md5_finish &rArr; md5_update &rArr; md5_process
</UL>
<BR>[Calls]<UL><LI><a href="#[565]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;magic_random_bytes
</UL>
<BR>[Called By]<UL><LI><a href="#[e2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lcp_resetci
<LI><a href="#[e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lcp_reqci
<LI><a href="#[e6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lcp_nakci
</UL>

<P><STRONG><a name="[568]"></a>magic_init</STRONG> (Thumb, 12 bytes, Stack size 8 bytes, .\build\lwip_magic.o(i.magic_init))
<BR><BR>[Stack]<UL><LI>Max Depth = 696 + Unknown Stack Size
<LI>Call Chain = magic_init &rArr; magic_churnrand &rArr; sys_jiffies &rArr; us_ticker_read &rArr; us_ticker_init &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[566]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;magic_churnrand
</UL>
<BR>[Called By]<UL><LI><a href="#[54c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_init
</UL>

<P><STRONG><a name="[565]"></a>magic_random_bytes</STRONG> (Thumb, 88 bytes, Stack size 120 bytes, .\build\lwip_magic.o(i.magic_random_bytes))
<BR><BR>[Stack]<UL><LI>Max Depth = 268<LI>Call Chain = magic_random_bytes &rArr; md5_finish &rArr; md5_update &rArr; md5_process
</UL>
<BR>[Calls]<UL><LI><a href="#[468]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;md5_update
<LI><a href="#[467]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;md5_starts
<LI><a href="#[469]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;md5_finish
<LI><a href="#[249]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Called By]<UL><LI><a href="#[52c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;magic
</UL>

<P><STRONG><a name="[569]"></a>magic_randomize</STRONG> (Thumb, 12 bytes, Stack size 8 bytes, .\build\lwip_magic.o(i.magic_randomize))
<BR><BR>[Stack]<UL><LI>Max Depth = 696 + Unknown Stack Size
<LI>Call Chain = magic_randomize &rArr; magic_churnrand &rArr; sys_jiffies &rArr; us_ticker_read &rArr; us_ticker_init &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[566]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;magic_churnrand
</UL>
<BR>[Called By]<UL><LI><a href="#[62f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_input
</UL>

<P><STRONG><a name="[281]"></a>$Super$$main</STRONG> (Thumb, 120 bytes, Stack size 32 bytes, .\build\main.o(i.main))
<BR><BR>[Stack]<UL><LI>Max Depth = 856 + Unknown Stack Size
<LI>Call Chain = $Super$$main &rArr; test_send_recv() &rArr; TCPSocket::TCPSocket() &rArr; Socket::Socket__sub_object() &rArr; rtos::Mutex::Mutex() &rArr; rtos::Mutex::constructor(const char*) &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[282]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void()&rang;::Callback(void(*)())
<LI><a href="#[3ad]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Thread::start(mbed::Callback&lang;void()&rang;)
<LI><a href="#[189]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::EasyCellularConnection::set_credentials(const char*, const char*, const char*)
<LI><a href="#[3cb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::EasyCellularConnection::modem_debug_on(bool)
<LI><a href="#[18a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::EasyCellularConnection::set_sim_pin(const char*)
<LI><a href="#[2ec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;test_send_recv()
<LI><a href="#[2df]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;print_function(const char*)
<LI><a href="#[2de]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;do_connect()
</UL>
<BR>[Called By]<UL><LI><a href="#[27f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;main
</UL>

<P><STRONG><a name="[33a]"></a>mbed_assert_internal</STRONG> (Thumb, 30 bytes, Stack size 16 bytes, .\build\mbed_assert.o(i.mbed_assert_internal))
<BR><BR>[Stack]<UL><LI>Max Depth = 528 + Unknown Stack Size
<LI>Call Chain = mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[30c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;core_util_critical_section_enter
<LI><a href="#[4b3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_die
<LI><a href="#[56a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_error_printf
</UL>
<BR>[Called By]<UL><LI><a href="#[4cb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pin_mode
<LI><a href="#[30c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;core_util_critical_section_enter
<LI><a href="#[372]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::resp_start(const char*, bool)
<LI><a href="#[37b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void(nsapi_event, int)&rang;::operator ()(nsapi_event, int) const
<LI><a href="#[17d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::get_registration_status(mbed::CellularNetwork::RegistrationType, mbed::CellularNetwork::RegistrationStatus&)
<LI><a href="#[35b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void()&rang;::operator ()() const
<LI><a href="#[3b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;bool(int, int)&rang;::operator ()(int, int) const
<LI><a href="#[3ad]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Thread::start(mbed::Callback&lang;void()&rang;)
<LI><a href="#[c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::CellularConnectionFSM::event()
<LI><a href="#[3b5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::CellularConnectionFSM::start_dispatch()
<LI><a href="#[ca]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::EasyCellularConnection::cellular_status(int, int)
<LI><a href="#[418]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::EventFlags::constructor(const char*)
<LI><a href="#[3f1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::FilePath::FilePath(const char*)
<LI><a href="#[445]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;gpio_init
<LI><a href="#[2fb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__cxa_guard_release
<LI><a href="#[2f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__cxa_guard_acquire
<LI><a href="#[477]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hal_critical_section_exit
<LI><a href="#[6cd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SingletonPtr&lang;rtos::Mutex&rang;::get()
<LI><a href="#[422]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Mutex::constructor(const char*)
<LI><a href="#[115]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;us_ticker_init
<LI><a href="#[4ef]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;initialize
<LI><a href="#[64a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_leuart_baud
<LI><a href="#[651]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_get_tx_irq_index
<LI><a href="#[650]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_get_rx_irq_index
<LI><a href="#[42d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Semaphore::constructor(int, unsigned short)
<LI><a href="#[33d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void(int)&rang;::call(int) const
<LI><a href="#[52]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::SerialBase::_irq_handler(unsigned, SerialIrq)
<LI><a href="#[654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_preinit
<LI><a href="#[2f3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TCPSocket::connect(const SocketAddress&)
<LI><a href="#[13b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TCPSocket::event()
<LI><a href="#[2f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TCPSocket::send(const void*, unsigned)
<LI><a href="#[2f5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TCPSocket::recv(void*, unsigned)
<LI><a href="#[6ce]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void()&rang;::call() const
<LI><a href="#[56]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Thread::_thunk(void*)
<LI><a href="#[1a9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Timeout::handler()
<LI><a href="#[1a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Ticker::handler()
<LI><a href="#[13e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;UDPSocket::event()
</UL>

<P><STRONG><a name="[4b3]"></a>mbed_die</STRONG> (Thumb, 94 bytes, Stack size 16 bytes, .\build\mbed_board.o(i.mbed_die))
<BR><BR>[Stack]<UL><LI>Max Depth = 512 + Unknown Stack Size
<LI>Call Chain = mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[56b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;wait_ms
<LI><a href="#[336]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;gpio_init_out
<LI><a href="#[449]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;gpio_write
</UL>
<BR>[Called By]<UL><LI><a href="#[33a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_assert_internal
<LI><a href="#[37c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_sem_signal
<LI><a href="#[4b2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;exit
</UL>

<P><STRONG><a name="[56a]"></a>mbed_error_printf</STRONG> (Thumb, 26 bytes, Stack size 24 bytes, .\build\mbed_board.o(i.mbed_error_printf))
<BR><BR>[Stack]<UL><LI>Max Depth = 392 + Unknown Stack Size
<LI>Call Chain = mbed_error_printf &rArr; mbed_error_vfprintf &rArr; serial_init &rArr; uart_init &rArr; serial_baud &rArr; serial_leuart_baud &rArr;  mbed_assert_internal (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[4b1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_error_vfprintf
</UL>
<BR>[Called By]<UL><LI><a href="#[33a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_assert_internal
</UL>

<P><STRONG><a name="[4b1]"></a>mbed_error_vfprintf</STRONG> (Thumb, 100 bytes, Stack size 160 bytes, .\build\mbed_board.o(i.mbed_error_vfprintf))
<BR><BR>[Stack]<UL><LI>Max Depth = 368 + Unknown Stack Size
<LI>Call Chain = mbed_error_vfprintf &rArr; serial_init &rArr; uart_init &rArr; serial_baud &rArr; serial_leuart_baud &rArr;  mbed_assert_internal (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[311]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;core_util_critical_section_exit
<LI><a href="#[30c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;core_util_critical_section_enter
<LI><a href="#[326]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_putc
<LI><a href="#[327]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_init
<LI><a href="#[221]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vsnprintf
</UL>
<BR>[Called By]<UL><LI><a href="#[3e6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;error
<LI><a href="#[56a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_error_printf
</UL>

<P><STRONG><a name="[42]"></a>mbed_fault_handler</STRONG> (Thumb, 186 bytes, Stack size 0 bytes, .\build\mbed_rtx_fault_handler.o(i.mbed_fault_handler))
<BR><BR>[Stack]<UL><LI>Max Depth = 216<LI>Call Chain = mbed_fault_handler &rArr; fault_print_init &rArr; serial_init &rArr; uart_init &rArr; serial_baud &rArr; serial_leuart_baud &rArr;  mbed_assert_internal (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[56e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;print_threads_info
<LI><a href="#[56d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;print_thread
<LI><a href="#[56c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;print_context_info
<LI><a href="#[4b5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fault_print_str
<LI><a href="#[4b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fault_print_init
</UL>
<BR>[Address Reference Count : 1]<UL><LI> except.o(.text)
</UL>
<P><STRONG><a name="[392]"></a>mbed_lwip_bringup_2</STRONG> (Thumb, 420 bytes, Stack size 48 bytes, .\build\lwip_stack.o(i.mbed_lwip_bringup_2))
<BR><BR>[Stack]<UL><LI>Max Depth = 1280 + Unknown Stack Size
<LI>Call Chain = mbed_lwip_bringup_2 &rArr; ppp_lwip_if_init &rArr; pppos_create &rArr; ppp_new &rArr; netif_add &rArr; netif_set_addr &rArr; netif_set_ipaddr &rArr; tcp_netif_ip_addr_changed &rArr; tcp_netif_ip_addr_changed_pcblist &rArr; tcp_abort &rArr; tcp_abandon &rArr; tcp_pcb_remove &rArr; tcp_output &rArr; tcp_output_segment &rArr; ip4_output_if &rArr; ip4_output_if_opt &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[48b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip4addr_aton
<LI><a href="#[553]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_sem_wait
<LI><a href="#[576]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netif_set_status_callback
<LI><a href="#[575]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netif_set_link_callback
<LI><a href="#[574]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netif_set_default
<LI><a href="#[471]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netif_set_addr
<LI><a href="#[572]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_lwip_if_init
<LI><a href="#[579]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_lwip_disconnect
<LI><a href="#[577]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_lwip_connect
<LI><a href="#[45a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_get_ip_addr
<LI><a href="#[573]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_emac_init
<LI><a href="#[459]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;add_dns_addr
<LI><a href="#[57a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_set_dhcp
<LI><a href="#[578]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_err_remap
<LI><a href="#[571]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_core_init
</UL>
<BR>[Called By]<UL><LI><a href="#[391]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::nsapi_ppp_connect(mbed::FileHandle*, mbed::Callback&lang;void(nsapi_event, int)&rang;, const char*, const char*, nsapi_ip_stack)
</UL>

<P><STRONG><a name="[573]"></a>mbed_lwip_emac_init</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, .\build\lwip_stack.o(i.mbed_lwip_emac_init))
<BR><BR>[Called By]<UL><LI><a href="#[392]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_bringup_2
</UL>

<P><STRONG><a name="[45a]"></a>mbed_lwip_get_ip_addr</STRONG> (Thumb, 40 bytes, Stack size 24 bytes, .\build\lwip_stack.o(i.mbed_lwip_get_ip_addr))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = mbed_lwip_get_ip_addr
</UL>
<BR>[Calls]<UL><LI><a href="#[57d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_get_ipv4_addr
</UL>
<BR>[Called By]<UL><LI><a href="#[392]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_bringup_2
<LI><a href="#[459]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;add_dns_addr
<LI><a href="#[72]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_netif_status_irq
</UL>

<P><STRONG><a name="[280]"></a>mbed_main</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\mbed_boot.o(i.mbed_main))
<BR><BR>[Called By]<UL><LI><a href="#[27f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;main
</UL>

<P><STRONG><a name="[43e]"></a>mbed_sdk_init</STRONG> (Thumb, 56 bytes, Stack size 8 bytes, .\build\mbed_overrides.o(i.mbed_sdk_init))
<BR><BR>[Stack]<UL><LI>Max Depth = 648 + Unknown Stack Size
<LI>Call Chain = mbed_sdk_init &rArr; gpio_init_out_ex &rArr; _gpio_init_out &rArr; gpio_dir &rArr; gpio_mode &rArr; pin_mode &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[28b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CMU_ClockEnable
<LI><a href="#[292]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CMU_ClockSelectSet
<LI><a href="#[2d5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SystemLFXOClockSet
<LI><a href="#[2d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SystemHFXOClockSet
<LI><a href="#[4ca]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;gpio_init_out_ex
</UL>
<BR>[Called By]<UL><LI><a href="#[1de]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_entry
</UL>

<P><STRONG><a name="[43c]"></a>mbed_set_stack_heap</STRONG> (Thumb, 50 bytes, Stack size 0 bytes, .\build\mbed_boot.o(i.mbed_set_stack_heap))
<BR><BR>[Called By]<UL><LI><a href="#[1de]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_entry
</UL>

<P><STRONG><a name="[440]"></a>mbed_start_main</STRONG> (Thumb, 56 bytes, Stack size 8 bytes, .\build\mbed_boot.o(i.mbed_start_main))
<BR><BR>[Stack]<UL><LI>Max Depth = 464 + Unknown Stack Size
<LI>Call Chain = mbed_start_main &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[3e6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;error
<LI><a href="#[426]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osThreadNew
<LI><a href="#[591]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osKernelStart
</UL>
<BR>[Called By]<UL><LI><a href="#[1de]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_entry
</UL>

<P><STRONG><a name="[469]"></a>md5_finish</STRONG> (Thumb, 206 bytes, Stack size 40 bytes, .\build\lwip_md5.o(i.md5_finish))
<BR><BR>[Stack]<UL><LI>Max Depth = 148<LI>Call Chain = md5_finish &rArr; md5_update &rArr; md5_process
</UL>
<BR>[Calls]<UL><LI><a href="#[468]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;md5_update
</UL>
<BR>[Called By]<UL><LI><a href="#[cb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;chap_md5_make_response
<LI><a href="#[565]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;magic_random_bytes
<LI><a href="#[566]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;magic_churnrand
<LI><a href="#[541]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_hook_tcp_isn
</UL>

<P><STRONG><a name="[467]"></a>md5_starts</STRONG> (Thumb, 26 bytes, Stack size 0 bytes, .\build\lwip_md5.o(i.md5_starts))
<BR><BR>[Called By]<UL><LI><a href="#[cb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;chap_md5_make_response
<LI><a href="#[565]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;magic_random_bytes
<LI><a href="#[566]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;magic_churnrand
<LI><a href="#[541]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_hook_tcp_isn
</UL>

<P><STRONG><a name="[468]"></a>md5_update</STRONG> (Thumb, 128 bytes, Stack size 24 bytes, .\build\lwip_md5.o(i.md5_update))
<BR><BR>[Stack]<UL><LI>Max Depth = 108<LI>Call Chain = md5_update &rArr; md5_process
</UL>
<BR>[Calls]<UL><LI><a href="#[592]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;md5_process
<LI><a href="#[249]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Called By]<UL><LI><a href="#[469]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;md5_finish
<LI><a href="#[cb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;chap_md5_make_response
<LI><a href="#[565]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;magic_random_bytes
<LI><a href="#[566]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;magic_churnrand
<LI><a href="#[541]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_hook_tcp_isn
</UL>

<P><STRONG><a name="[593]"></a>mem_free</STRONG> (Thumb, 80 bytes, Stack size 16 bytes, .\build\lwip_mem.o(i.mem_free))
<BR><BR>[Stack]<UL><LI>Max Depth = 480 + Unknown Stack Size
<LI>Call Chain = mem_free &rArr; sys_mutex_unlock &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[552]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_mutex_unlock
<LI><a href="#[554]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_mutex_lock
<LI><a href="#[497]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_unprotect
<LI><a href="#[496]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_protect
<LI><a href="#[594]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;plug_holes
</UL>
<BR>[Called By]<UL><LI><a href="#[46b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_free
</UL>

<P><STRONG><a name="[545]"></a>mem_init</STRONG> (Thumb, 78 bytes, Stack size 8 bytes, .\build\lwip_mem.o(i.mem_init))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = mem_init &rArr; sys_mutex_new &rArr; osMutexNew
</UL>
<BR>[Calls]<UL><LI><a href="#[595]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_mutex_new
</UL>
<BR>[Called By]<UL><LI><a href="#[543]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_init
</UL>

<P><STRONG><a name="[596]"></a>mem_malloc</STRONG> (Thumb, 236 bytes, Stack size 24 bytes, .\build\lwip_mem.o(i.mem_malloc))
<BR><BR>[Stack]<UL><LI>Max Depth = 488 + Unknown Stack Size
<LI>Call Chain = mem_malloc &rArr; sys_mutex_unlock &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[552]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_mutex_unlock
<LI><a href="#[554]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_mutex_lock
</UL>
<BR>[Called By]<UL><LI><a href="#[46a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_alloc
</UL>

<P><STRONG><a name="[597]"></a>mem_trim</STRONG> (Thumb, 268 bytes, Stack size 40 bytes, .\build\lwip_mem.o(i.mem_trim))
<BR><BR>[Stack]<UL><LI>Max Depth = 504 + Unknown Stack Size
<LI>Call Chain = mem_trim &rArr; sys_mutex_unlock &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[552]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_mutex_unlock
<LI><a href="#[554]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_mutex_lock
<LI><a href="#[497]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_unprotect
<LI><a href="#[496]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_protect
</UL>
<BR>[Called By]<UL><LI><a href="#[46e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_realloc
</UL>

<P><STRONG><a name="[4e7]"></a>memp_free</STRONG> (Thumb, 36 bytes, Stack size 16 bytes, .\build\lwip_memp.o(i.memp_free))
<BR><BR>[Stack]<UL><LI>Max Depth = 504 + Unknown Stack Size
<LI>Call Chain = memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[495]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;do_memp_free_pool
</UL>
<BR>[Called By]<UL><LI><a href="#[47e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_remove
<LI><a href="#[4e5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;igmp_leavegroup_netif
<LI><a href="#[2bf]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_untimeout
<LI><a href="#[55b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_listen_with_backlog_and_err
<LI><a href="#[46b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_free
<LI><a href="#[585]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netbuf_delete
<LI><a href="#[5a1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcpip_callback_with_block
<LI><a href="#[458]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netconn_free
<LI><a href="#[450]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netconn_alloc
<LI><a href="#[58a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netconn_recv
<LI><a href="#[589]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netconn_new_with_proto_and_callback
<LI><a href="#[504]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip_reass_dequeue_datagram
<LI><a href="#[4f6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip_frag_free_pbuf_custom_ref
<LI><a href="#[4fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_input
<LI><a href="#[68e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_check_timeouts
<LI><a href="#[be]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcpip_thread
<LI><a href="#[6ba]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_slowtmr
<LI><a href="#[6a7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_seg_free
<LI><a href="#[693]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_abandon
<LI><a href="#[69d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_close_shutdown
</UL>

<P><STRONG><a name="[598]"></a>memp_free_pool</STRONG> (Thumb, 24 bytes, Stack size 16 bytes, .\build\lwip_memp.o(i.memp_free_pool))
<BR><BR>[Stack]<UL><LI>Max Depth = 504 + Unknown Stack Size
<LI>Call Chain = memp_free_pool &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[495]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;do_memp_free_pool
</UL>
<BR>[Called By]<UL><LI><a href="#[f7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pppos_destroy
<LI><a href="#[635]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pppos_create
<LI><a href="#[637]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_new
</UL>

<P><STRONG><a name="[546]"></a>memp_init</STRONG> (Thumb, 26 bytes, Stack size 8 bytes, .\build\lwip_memp.o(i.memp_init))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = memp_init &rArr; memp_init_pool
</UL>
<BR>[Calls]<UL><LI><a href="#[599]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memp_init_pool
</UL>
<BR>[Called By]<UL><LI><a href="#[543]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_init
</UL>

<P><STRONG><a name="[599]"></a>memp_init_pool</STRONG> (Thumb, 44 bytes, Stack size 8 bytes, .\build\lwip_memp.o(i.memp_init_pool))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = memp_init_pool
</UL>
<BR>[Called By]<UL><LI><a href="#[54c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_init
<LI><a href="#[546]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memp_init
</UL>

<P><STRONG><a name="[4e8]"></a>memp_malloc</STRONG> (Thumb, 32 bytes, Stack size 16 bytes, .\build\lwip_memp.o(i.memp_malloc))
<BR><BR>[Stack]<UL><LI>Max Depth = 496 + Unknown Stack Size
<LI>Call Chain = memp_malloc &rArr; do_memp_malloc_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[498]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;do_memp_malloc_pool
</UL>
<BR>[Called By]<UL><LI><a href="#[46a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_alloc
<LI><a href="#[4e2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;igmp_lookup_group
<LI><a href="#[2c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_timeout
<LI><a href="#[55b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_listen_with_backlog_and_err
<LI><a href="#[9f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;recv_udp
<LI><a href="#[5a1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcpip_callback_with_block
<LI><a href="#[450]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netconn_alloc
<LI><a href="#[58a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netconn_recv
<LI><a href="#[502]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip_reass_enqueue_new_datagram
<LI><a href="#[4f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip_frag_alloc_pbuf_custom_ref
<LI><a href="#[58c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netbuf_new
<LI><a href="#[6a6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_create_segment
<LI><a href="#[697]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_alloc
<LI><a href="#[6c1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_new
</UL>

<P><STRONG><a name="[59a]"></a>memp_malloc_pool</STRONG> (Thumb, 18 bytes, Stack size 8 bytes, .\build\lwip_memp.o(i.memp_malloc_pool))
<BR><BR>[Stack]<UL><LI>Max Depth = 488 + Unknown Stack Size
<LI>Call Chain = memp_malloc_pool &rArr; do_memp_malloc_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[498]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;do_memp_malloc_pool
</UL>
<BR>[Called By]<UL><LI><a href="#[635]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pppos_create
<LI><a href="#[637]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_new
</UL>

<P><STRONG><a name="[585]"></a>netbuf_delete</STRONG> (Thumb, 32 bytes, Stack size 8 bytes, .\build\lwip_netbuf.o(i.netbuf_delete))
<BR><BR>[Stack]<UL><LI>Max Depth = 544 + Unknown Stack Size
<LI>Call Chain = netbuf_delete &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[46b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_free
<LI><a href="#[4e7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memp_free
</UL>
<BR>[Called By]<UL><LI><a href="#[9f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;recv_udp
<LI><a href="#[550]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netconn_drain
<LI><a href="#[106]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_socket_sendto
<LI><a href="#[107]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_socket_recvfrom
<LI><a href="#[105]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_socket_recv
<LI><a href="#[ff]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_socket_close
</UL>

<P><STRONG><a name="[58e]"></a>netbuf_free</STRONG> (Thumb, 32 bytes, Stack size 8 bytes, .\build\lwip_netbuf.o(i.netbuf_free))
<BR><BR>[Stack]<UL><LI>Max Depth = 544 + Unknown Stack Size
<LI>Call Chain = netbuf_free &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[46b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_free
</UL>
<BR>[Called By]<UL><LI><a href="#[106]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_socket_sendto
</UL>

<P><STRONG><a name="[58c]"></a>netbuf_new</STRONG> (Thumb, 26 bytes, Stack size 8 bytes, .\build\lwip_netbuf.o(i.netbuf_new))
<BR><BR>[Stack]<UL><LI>Max Depth = 504 + Unknown Stack Size
<LI>Call Chain = netbuf_new &rArr; memp_malloc &rArr; do_memp_malloc_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[4e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memp_malloc
</UL>
<BR>[Called By]<UL><LI><a href="#[106]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_socket_sendto
</UL>

<P><STRONG><a name="[58d]"></a>netbuf_ref</STRONG> (Thumb, 74 bytes, Stack size 16 bytes, .\build\lwip_netbuf.o(i.netbuf_ref))
<BR><BR>[Stack]<UL><LI>Max Depth = 592 + Unknown Stack Size
<LI>Call Chain = netbuf_ref &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[46a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_alloc
<LI><a href="#[46b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_free
</UL>
<BR>[Called By]<UL><LI><a href="#[106]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_socket_sendto
</UL>

<P><STRONG><a name="[581]"></a>netconn_accept</STRONG> (Thumb, 174 bytes, Stack size 24 bytes, .\build\lwip_api_lib.o(i.netconn_accept))
<BR><BR>[Stack]<UL><LI>Max Depth = 624 + Unknown Stack Size
<LI>Call Chain = netconn_accept &rArr; sys_arch_mbox_fetch &rArr; us_ticker_read &rArr; us_ticker_init &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[497]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_unprotect
<LI><a href="#[496]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_protect
<LI><a href="#[59b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_mbox_fetch
</UL>
<BR>[Called By]<UL><LI><a href="#[103]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_socket_accept
</UL>

<P><STRONG><a name="[450]"></a>netconn_alloc</STRONG> (Thumb, 132 bytes, Stack size 24 bytes, .\build\lwip_api_msg.o(i.netconn_alloc))
<BR><BR>[Stack]<UL><LI>Max Depth = 528 + Unknown Stack Size
<LI>Call Chain = netconn_alloc &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[55c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_mbox_new
<LI><a href="#[57b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_sem_new
<LI><a href="#[457]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_mbox_free
<LI><a href="#[4e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memp_malloc
<LI><a href="#[4e7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memp_free
</UL>
<BR>[Called By]<UL><LI><a href="#[6f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;accept_function
<LI><a href="#[589]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netconn_new_with_proto_and_callback
</UL>

<P><STRONG><a name="[584]"></a>netconn_bind</STRONG> (Thumb, 50 bytes, Stack size 40 bytes, .\build\lwip_api_lib.o(i.netconn_bind))
<BR><BR>[Stack]<UL><LI>Max Depth = 536 + Unknown Stack Size
<LI>Call Chain = netconn_bind &rArr; netconn_apimsg &rArr; tcpip_send_msg_wait_sem &rArr; sys_mutex_unlock &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[59c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netconn_apimsg
</UL>
<BR>[Called By]<UL><LI><a href="#[100]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_socket_bind
</UL>

<P><STRONG><a name="[587]"></a>netconn_connect</STRONG> (Thumb, 50 bytes, Stack size 40 bytes, .\build\lwip_api_lib.o(i.netconn_connect))
<BR><BR>[Stack]<UL><LI>Max Depth = 536 + Unknown Stack Size
<LI>Call Chain = netconn_connect &rArr; netconn_apimsg &rArr; tcpip_send_msg_wait_sem &rArr; sys_mutex_unlock &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[59c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netconn_apimsg
</UL>
<BR>[Called By]<UL><LI><a href="#[102]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_socket_connect
</UL>

<P><STRONG><a name="[586]"></a>netconn_delete</STRONG> (Thumb, 48 bytes, Stack size 32 bytes, .\build\lwip_api_lib.o(i.netconn_delete))
<BR><BR>[Stack]<UL><LI>Max Depth = 544 + Unknown Stack Size
<LI>Call Chain = netconn_delete &rArr; netconn_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[458]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netconn_free
<LI><a href="#[59c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netconn_apimsg
</UL>
<BR>[Called By]<UL><LI><a href="#[ff]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_socket_close
</UL>

<P><STRONG><a name="[458]"></a>netconn_free</STRONG> (Thumb, 26 bytes, Stack size 8 bytes, .\build\lwip_api_msg.o(i.netconn_free))
<BR><BR>[Stack]<UL><LI>Max Depth = 512 + Unknown Stack Size
<LI>Call Chain = netconn_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[5a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_sem_free
<LI><a href="#[4e7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memp_free
</UL>
<BR>[Called By]<UL><LI><a href="#[550]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netconn_drain
<LI><a href="#[6f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;accept_function
<LI><a href="#[586]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netconn_delete
</UL>

<P><STRONG><a name="[582]"></a>netconn_getaddr</STRONG> (Thumb, 78 bytes, Stack size 48 bytes, .\build\lwip_api_lib.o(i.netconn_getaddr))
<BR><BR>[Stack]<UL><LI>Max Depth = 544 + Unknown Stack Size
<LI>Call Chain = netconn_getaddr &rArr; netconn_apimsg &rArr; tcpip_send_msg_wait_sem &rArr; sys_mutex_unlock &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[59c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netconn_apimsg
</UL>
<BR>[Called By]<UL><LI><a href="#[103]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_socket_accept
</UL>

<P><STRONG><a name="[57e]"></a>netconn_gethostbyname</STRONG> (Thumb, 112 bytes, Stack size 72 bytes, .\build\lwip_api_lib.o(i.netconn_gethostbyname))
<BR><BR>[Stack]<UL><LI>Max Depth = 656 + Unknown Stack Size
<LI>Call Chain = netconn_gethostbyname &rArr; sys_arch_sem_wait &rArr; us_ticker_read &rArr; us_ticker_init &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[5a1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcpip_callback_with_block
<LI><a href="#[57b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_sem_new
<LI><a href="#[5a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_sem_free
<LI><a href="#[553]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_sem_wait
</UL>
<BR>[Called By]<UL><LI><a href="#[fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_gethostbyname
</UL>

<P><STRONG><a name="[588]"></a>netconn_listen_with_backlog</STRONG> (Thumb, 38 bytes, Stack size 40 bytes, .\build\lwip_api_lib.o(i.netconn_listen_with_backlog))
<BR><BR>[Stack]<UL><LI>Max Depth = 536 + Unknown Stack Size
<LI>Call Chain = netconn_listen_with_backlog &rArr; netconn_apimsg &rArr; tcpip_send_msg_wait_sem &rArr; sys_mutex_unlock &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[59c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netconn_apimsg
</UL>
<BR>[Called By]<UL><LI><a href="#[101]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_socket_listen
</UL>

<P><STRONG><a name="[589]"></a>netconn_new_with_proto_and_callback</STRONG> (Thumb, 84 bytes, Stack size 48 bytes, .\build\lwip_api_lib.o(i.netconn_new_with_proto_and_callback))
<BR><BR>[Stack]<UL><LI>Max Depth = 576 + Unknown Stack Size
<LI>Call Chain = netconn_new_with_proto_and_callback &rArr; netconn_alloc &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[5a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_sem_free
<LI><a href="#[457]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_mbox_free
<LI><a href="#[450]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netconn_alloc
<LI><a href="#[4e7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memp_free
<LI><a href="#[59c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netconn_apimsg
</UL>
<BR>[Called By]<UL><LI><a href="#[fe]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_socket_open
</UL>

<P><STRONG><a name="[58a]"></a>netconn_recv</STRONG> (Thumb, 118 bytes, Stack size 24 bytes, .\build\lwip_api_lib.o(i.netconn_recv))
<BR><BR>[Stack]<UL><LI>Max Depth = 664 + Unknown Stack Size
<LI>Call Chain = netconn_recv &rArr; netconn_recv_data &rArr; sys_arch_mbox_fetch &rArr; us_ticker_read &rArr; us_ticker_init &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[4e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memp_malloc
<LI><a href="#[4e7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memp_free
<LI><a href="#[5a2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netconn_recv_data
</UL>
<BR>[Called By]<UL><LI><a href="#[107]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_socket_recvfrom
<LI><a href="#[105]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_socket_recv
</UL>

<P><STRONG><a name="[5a3]"></a>netconn_send</STRONG> (Thumb, 40 bytes, Stack size 40 bytes, .\build\lwip_api_lib.o(i.netconn_send))
<BR><BR>[Stack]<UL><LI>Max Depth = 536 + Unknown Stack Size
<LI>Call Chain = netconn_send &rArr; netconn_apimsg &rArr; tcpip_send_msg_wait_sem &rArr; sys_mutex_unlock &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[59c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netconn_apimsg
</UL>
<BR>[Called By]<UL><LI><a href="#[58f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netconn_sendto
</UL>

<P><STRONG><a name="[58f]"></a>netconn_sendto</STRONG> (Thumb, 44 bytes, Stack size 24 bytes, .\build\lwip_api_lib.o(i.netconn_sendto))
<BR><BR>[Stack]<UL><LI>Max Depth = 560 + Unknown Stack Size
<LI>Call Chain = netconn_sendto &rArr; netconn_send &rArr; netconn_apimsg &rArr; tcpip_send_msg_wait_sem &rArr; sys_mutex_unlock &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[5a3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netconn_send
</UL>
<BR>[Called By]<UL><LI><a href="#[106]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_socket_sendto
</UL>

<P><STRONG><a name="[58b]"></a>netconn_write_partly</STRONG> (Thumb, 144 bytes, Stack size 56 bytes, .\build\lwip_api_lib.o(i.netconn_write_partly))
<BR><BR>[Stack]<UL><LI>Max Depth = 552 + Unknown Stack Size
<LI>Call Chain = netconn_write_partly &rArr; netconn_apimsg &rArr; tcpip_send_msg_wait_sem &rArr; sys_mutex_unlock &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[59c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netconn_apimsg
</UL>
<BR>[Called By]<UL><LI><a href="#[104]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_socket_send
</UL>

<P><STRONG><a name="[5a4]"></a>netif_add</STRONG> (Thumb, 128 bytes, Stack size 32 bytes, .\build\lwip_netif.o(i.netif_add))
<BR><BR>[Stack]<UL><LI>Max Depth = 1136 + Unknown Stack Size
<LI>Call Chain = netif_add &rArr; netif_set_addr &rArr; netif_set_ipaddr &rArr; tcp_netif_ip_addr_changed &rArr; tcp_netif_ip_addr_changed_pcblist &rArr; tcp_abort &rArr; tcp_abandon &rArr; tcp_pcb_remove &rArr; tcp_output &rArr; tcp_output_segment &rArr; ip4_output_if &rArr; ip4_output_if_opt &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[4ea]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;igmp_start
<LI><a href="#[471]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netif_set_addr
</UL>
<BR>[Called By]<UL><LI><a href="#[637]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_new
</UL>

<P><STRONG><a name="[547]"></a>netif_init</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\lwip_netif.o(i.netif_init))
<BR><BR>[Called By]<UL><LI><a href="#[543]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_init
</UL>

<P><STRONG><a name="[471]"></a>netif_set_addr</STRONG> (Thumb, 72 bytes, Stack size 24 bytes, .\build\lwip_netif.o(i.netif_set_addr))
<BR><BR>[Stack]<UL><LI>Max Depth = 1104 + Unknown Stack Size
<LI>Call Chain = netif_set_addr &rArr; netif_set_ipaddr &rArr; tcp_netif_ip_addr_changed &rArr; tcp_netif_ip_addr_changed_pcblist &rArr; tcp_abort &rArr; tcp_abandon &rArr; tcp_pcb_remove &rArr; tcp_output &rArr; tcp_output_segment &rArr; ip4_output_if &rArr; ip4_output_if_opt &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[5a7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netif_set_netmask
<LI><a href="#[5a6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netif_set_ipaddr
<LI><a href="#[5a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netif_set_gw
</UL>
<BR>[Called By]<UL><LI><a href="#[392]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_bringup_2
<LI><a href="#[50e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sifaddr
<LI><a href="#[470]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;cifaddr
<LI><a href="#[5a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netif_add
</UL>

<P><STRONG><a name="[574]"></a>netif_set_default</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, .\build\lwip_netif.o(i.netif_set_default))
<BR><BR>[Called By]<UL><LI><a href="#[392]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_bringup_2
</UL>

<P><STRONG><a name="[580]"></a>netif_set_down</STRONG> (Thumb, 42 bytes, Stack size 8 bytes, .\build\lwip_netif.o(i.netif_set_down))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = netif_set_down
</UL>
<BR>[Called By]<UL><LI><a href="#[71]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_netif_link_irq
</UL>

<P><STRONG><a name="[5a8]"></a>netif_set_gw</STRONG> (Thumb, 12 bytes, Stack size 0 bytes, .\build\lwip_netif.o(i.netif_set_gw))
<BR><BR>[Called By]<UL><LI><a href="#[471]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netif_set_addr
</UL>

<P><STRONG><a name="[5a6]"></a>netif_set_ipaddr</STRONG> (Thumb, 86 bytes, Stack size 16 bytes, .\build\lwip_netif.o(i.netif_set_ipaddr))
<BR><BR>[Stack]<UL><LI>Max Depth = 1080 + Unknown Stack Size
<LI>Call Chain = netif_set_ipaddr &rArr; tcp_netif_ip_addr_changed &rArr; tcp_netif_ip_addr_changed_pcblist &rArr; tcp_abort &rArr; tcp_abandon &rArr; tcp_pcb_remove &rArr; tcp_output &rArr; tcp_output_segment &rArr; ip4_output_if &rArr; ip4_output_if_opt &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[5a5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netif_issue_reports
<LI><a href="#[5aa]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_netif_ip_addr_changed
<LI><a href="#[5a9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_netif_ip_addr_changed
</UL>
<BR>[Called By]<UL><LI><a href="#[471]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netif_set_addr
</UL>

<P><STRONG><a name="[575]"></a>netif_set_link_callback</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, .\build\lwip_netif.o(i.netif_set_link_callback))
<BR><BR>[Called By]<UL><LI><a href="#[392]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_bringup_2
</UL>

<P><STRONG><a name="[66f]"></a>netif_set_link_down</STRONG> (Thumb, 42 bytes, Stack size 8 bytes, .\build\lwip_netif.o(i.netif_set_link_down))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = netif_set_link_down
</UL>
<BR>[Called By]<UL><LI><a href="#[509]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sifdown
</UL>

<P><STRONG><a name="[5ab]"></a>netif_set_link_up</STRONG> (Thumb, 58 bytes, Stack size 8 bytes, .\build\lwip_netif.o(i.netif_set_link_up))
<BR><BR>[Stack]<UL><LI>Max Depth = 152<LI>Call Chain = netif_set_link_up &rArr; netif_issue_reports &rArr; igmp_report_groups &rArr; igmp_delaying_member &rArr; igmp_start_timer &rArr; lwip_get_random &rArr; randLIB_get_32bit &rArr; randLIB_get_64bit &rArr; rol
</UL>
<BR>[Calls]<UL><LI><a href="#[5a5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netif_issue_reports
</UL>
<BR>[Called By]<UL><LI><a href="#[50f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sifup
</UL>

<P><STRONG><a name="[530]"></a>netif_set_mtu</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, .\build\lwip_ppp.o(i.netif_set_mtu))
<BR><BR>[Called By]<UL><LI><a href="#[e9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lcp_up
</UL>

<P><STRONG><a name="[5a7]"></a>netif_set_netmask</STRONG> (Thumb, 12 bytes, Stack size 0 bytes, .\build\lwip_netif.o(i.netif_set_netmask))
<BR><BR>[Called By]<UL><LI><a href="#[471]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netif_set_addr
</UL>

<P><STRONG><a name="[576]"></a>netif_set_status_callback</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, .\build\lwip_netif.o(i.netif_set_status_callback))
<BR><BR>[Called By]<UL><LI><a href="#[392]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_bringup_2
</UL>

<P><STRONG><a name="[590]"></a>netif_set_up</STRONG> (Thumb, 60 bytes, Stack size 8 bytes, .\build\lwip_netif.o(i.netif_set_up))
<BR><BR>[Stack]<UL><LI>Max Depth = 152<LI>Call Chain = netif_set_up &rArr; netif_issue_reports &rArr; igmp_report_groups &rArr; igmp_delaying_member &rArr; igmp_start_timer &rArr; lwip_get_random &rArr; randLIB_get_32bit &rArr; randLIB_get_64bit &rArr; rol
</UL>
<BR>[Calls]<UL><LI><a href="#[5a5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netif_issue_reports
</UL>
<BR>[Called By]<UL><LI><a href="#[57a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_set_dhcp
</UL>

<P><STRONG><a name="[523]"></a>new_phase</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, .\build\lwip_ppp.o(i.new_phase))
<BR><BR>[Called By]<UL><LI><a href="#[f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lcp_close
<LI><a href="#[5ac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;start_networks
<LI><a href="#[510]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;np_up
<LI><a href="#[508]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;np_down
<LI><a href="#[52b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;link_terminated
<LI><a href="#[531]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;link_established
<LI><a href="#[525]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;link_down
<LI><a href="#[638]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_start
<LI><a href="#[637]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_new
<LI><a href="#[631]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_link_end
<LI><a href="#[62d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_connect
<LI><a href="#[3a6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_close
<LI><a href="#[a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_do_connect
</UL>

<P><STRONG><a name="[508]"></a>np_down</STRONG> (Thumb, 30 bytes, Stack size 16 bytes, .\build\lwip_auth.o(i.np_down))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = np_down
</UL>
<BR>[Calls]<UL><LI><a href="#[523]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;new_phase
</UL>
<BR>[Called By]<UL><LI><a href="#[d9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ipcp_down
</UL>

<P><STRONG><a name="[50a]"></a>np_finished</STRONG> (Thumb, 32 bytes, Stack size 16 bytes, .\build\lwip_auth.o(i.np_finished))
<BR><BR>[Stack]<UL><LI>Max Depth = 712 + Unknown Stack Size
<LI>Call Chain = np_finished &rArr; lcp_close &rArr; fsm_close &rArr; terminate_layer &rArr; fsm_sdata &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lcp_close
</UL>
<BR>[Called By]<UL><LI><a href="#[da]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ipcp_finished
</UL>

<P><STRONG><a name="[510]"></a>np_up</STRONG> (Thumb, 32 bytes, Stack size 16 bytes, .\build\lwip_auth.o(i.np_up))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = np_up
</UL>
<BR>[Calls]<UL><LI><a href="#[523]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;new_phase
</UL>
<BR>[Called By]<UL><LI><a href="#[d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ipcp_up
</UL>

<P><STRONG><a name="[44c]"></a>open</STRONG> (Thumb, 160 bytes, Stack size 48 bytes, .\build\mbed_retarget.o(i.open))
<BR><BR>[Stack]<UL><LI>Max Depth = 688 + Unknown Stack Size
<LI>Call Chain = open &rArr; mbed::FilePath::FilePath(const char*) &rArr; mbed::FileBase::lookup(const char*, unsigned) &rArr; SingletonPtr&lang;rtos::Mutex&rang;::operator -&rang;() &rArr; SingletonPtr&lang;rtos::Mutex&rang;::get() &rArr; rtos::Mutex::Mutex() &rArr; rtos::Mutex::constructor(const char*) &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[3f1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::FilePath::FilePath(const char*)
<LI><a href="#[5ae]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::FilePath::fileName()
<LI><a href="#[3f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::FilePath::isFile()
<LI><a href="#[5ad]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::FilePath::exists()
<LI><a href="#[3ef]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::FilePath::file()
<LI><a href="#[3ed]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::FilePath::fileSystem()
<LI><a href="#[319]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;reserve_filehandle()
<LI><a href="#[318]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;handle_open_errors(int, unsigned)
</UL>
<BR>[Called By]<UL><LI><a href="#[242]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_sys_open
</UL>

<P><STRONG><a name="[425]"></a>osDelay</STRONG> (Thumb, 64 bytes, Stack size 8 bytes, .\build\rtx_delay.o(i.osDelay))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = osDelay
</UL>
<BR>[Calls]<UL><LI><a href="#[5b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxThreadError
<LI><a href="#[5af]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxThreadDelay
</UL>
<BR>[Called By]<UL><LI><a href="#[35e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Thread::wait(unsigned)
</UL>

<P><STRONG><a name="[5b1]"></a>osEventFlagsClear</STRONG> (Thumb, 58 bytes, Stack size 16 bytes, .\build\rtx_evflags.o(i.osEventFlagsClear))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = osEventFlagsClear &rArr; svcRtxEventFlagsClear &rArr; EventFlagsClear
</UL>
<BR>[Calls]<UL><LI><a href="#[5b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__get_PRIMASK
<LI><a href="#[5b3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__get_IPSR
<LI><a href="#[5b5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__get_BASEPRI
<LI><a href="#[5b2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxEventFlagsClear
<LI><a href="#[82]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxEventFlagsClear
</UL>
<BR>[Called By]<UL><LI><a href="#[44f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_mbox_trypost
<LI><a href="#[59f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_mbox_tryfetch
<LI><a href="#[59b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_mbox_fetch
<LI><a href="#[68f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_mbox_post
</UL>

<P><STRONG><a name="[421]"></a>osEventFlagsDelete</STRONG> (Thumb, 58 bytes, Stack size 8 bytes, .\build\rtx_evflags.o(i.osEventFlagsDelete))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = osEventFlagsDelete
</UL>
<BR>[Calls]<UL><LI><a href="#[5b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__get_PRIMASK
<LI><a href="#[5b3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__get_IPSR
<LI><a href="#[5b5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__get_BASEPRI
<LI><a href="#[512]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxEventFlagsError
<LI><a href="#[5b6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxEventFlagsDelete
</UL>
<BR>[Called By]<UL><LI><a href="#[4ac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_sema_destroy
<LI><a href="#[420]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::EventFlags::~EventFlags()
</UL>

<P><STRONG><a name="[419]"></a>osEventFlagsNew</STRONG> (Thumb, 102 bytes, Stack size 16 bytes, .\build\rtx_evflags.o(i.osEventFlagsNew))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = osEventFlagsNew
</UL>
<BR>[Calls]<UL><LI><a href="#[5b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__get_PRIMASK
<LI><a href="#[5b3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__get_IPSR
<LI><a href="#[5b5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__get_BASEPRI
<LI><a href="#[5b7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxEventFlagsNew
<LI><a href="#[512]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxEventFlagsError
</UL>
<BR>[Called By]<UL><LI><a href="#[4a7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_sema_create
<LI><a href="#[418]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::EventFlags::constructor(const char*)
<LI><a href="#[55c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_mbox_new
</UL>

<P><STRONG><a name="[41b]"></a>osEventFlagsSet</STRONG> (Thumb, 136 bytes, Stack size 32 bytes, .\build\rtx_evflags.o(i.osEventFlagsSet))
<BR><BR>[Stack]<UL><LI>Max Depth = 64<LI>Call Chain = osEventFlagsSet &rArr; osRtxPostProcess &rArr; isr_queue_put
</UL>
<BR>[Calls]<UL><LI><a href="#[5b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__get_PRIMASK
<LI><a href="#[5b3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__get_IPSR
<LI><a href="#[5b5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__get_BASEPRI
<LI><a href="#[2a3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EventFlagsSet
<LI><a href="#[518]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxPostProcess
<LI><a href="#[5b9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxEventFlagsSetDone
<LI><a href="#[5b8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxEventFlagsSet
<LI><a href="#[512]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxEventFlagsError
</UL>
<BR>[Called By]<UL><LI><a href="#[4b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_sema_signal
<LI><a href="#[41a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::EventFlags::set(unsigned)
<LI><a href="#[44f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_mbox_trypost
<LI><a href="#[55c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_mbox_new
<LI><a href="#[59f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_mbox_tryfetch
<LI><a href="#[59b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_mbox_fetch
<LI><a href="#[68f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_mbox_post
</UL>

<P><STRONG><a name="[41d]"></a>osEventFlagsWait</STRONG> (Thumb, 78 bytes, Stack size 24 bytes, .\build\rtx_evflags.o(i.osEventFlagsWait))
<BR><BR>[Stack]<UL><LI>Max Depth = 80<LI>Call Chain = osEventFlagsWait &rArr; isrRtxEventFlagsWait &rArr; EventFlagsCheck
</UL>
<BR>[Calls]<UL><LI><a href="#[511]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;isrRtxEventFlagsWait
<LI><a href="#[5b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__get_PRIMASK
<LI><a href="#[5b3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__get_IPSR
<LI><a href="#[5b5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__get_BASEPRI
<LI><a href="#[5ba]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxEventFlagsWait
</UL>
<BR>[Called By]<UL><LI><a href="#[4af]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_sema_wait
<LI><a href="#[41c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::EventFlags::wait(unsigned, unsigned, unsigned, bool)
<LI><a href="#[44f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_mbox_trypost
<LI><a href="#[59f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_mbox_tryfetch
<LI><a href="#[59b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_mbox_fetch
<LI><a href="#[68f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_mbox_post
</UL>

<P><STRONG><a name="[5bb]"></a>osKernelGetState</STRONG> (Thumb, 62 bytes, Stack size 8 bytes, .\build\rtx_kernel.o(i.osKernelGetState))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = osKernelGetState &rArr; svcRtxKernelGetState
</UL>
<BR>[Calls]<UL><LI><a href="#[87]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxKernelGetState
<LI><a href="#[5bd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__get_PRIMASK
<LI><a href="#[5bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__get_IPSR
<LI><a href="#[5c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__get_CONTROL
<LI><a href="#[5be]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__get_BASEPRI
<LI><a href="#[5bf]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxKernelGetState
</UL>
<BR>[Called By]<UL><LI><a href="#[591]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osKernelStart
<LI><a href="#[441]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;os_kernel_is_active
</UL>

<P><STRONG><a name="[44a]"></a>osKernelInitialize</STRONG> (Thumb, 94 bytes, Stack size 8 bytes, .\build\rtx_kernel.o(i.osKernelInitialize))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = osKernelInitialize
</UL>
<BR>[Calls]<UL><LI><a href="#[5bd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__get_PRIMASK
<LI><a href="#[5bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__get_IPSR
<LI><a href="#[5c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__get_CONTROL
<LI><a href="#[5be]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__get_BASEPRI
<LI><a href="#[5c1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxKernelInitialize
<LI><a href="#[5c2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxKernelError
</UL>
<BR>[Called By]<UL><LI><a href="#[43f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_platform_post_stackheap_init
</UL>

<P><STRONG><a name="[5c3]"></a>osKernelLock</STRONG> (Thumb, 50 bytes, Stack size 8 bytes, .\build\rtx_kernel.o(i.osKernelLock))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = osKernelLock
</UL>
<BR>[Calls]<UL><LI><a href="#[5bd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__get_PRIMASK
<LI><a href="#[5bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__get_IPSR
<LI><a href="#[5be]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__get_BASEPRI
<LI><a href="#[5c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxKernelLock
<LI><a href="#[5c2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxKernelError
</UL>
<BR>[Called By]<UL><LI><a href="#[44f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_mbox_trypost
<LI><a href="#[59f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_mbox_tryfetch
<LI><a href="#[59b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_mbox_fetch
<LI><a href="#[68f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_mbox_post
</UL>

<P><STRONG><a name="[5c5]"></a>osKernelRestoreLock</STRONG> (Thumb, 56 bytes, Stack size 8 bytes, .\build\rtx_kernel.o(i.osKernelRestoreLock))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = osKernelRestoreLock
</UL>
<BR>[Calls]<UL><LI><a href="#[5bd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__get_PRIMASK
<LI><a href="#[5bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__get_IPSR
<LI><a href="#[5be]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__get_BASEPRI
<LI><a href="#[5c6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxKernelRestoreLock
<LI><a href="#[5c2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxKernelError
</UL>
<BR>[Called By]<UL><LI><a href="#[44f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_mbox_trypost
<LI><a href="#[59f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_mbox_tryfetch
<LI><a href="#[59b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_mbox_fetch
<LI><a href="#[68f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_mbox_post
</UL>

<P><STRONG><a name="[591]"></a>osKernelStart</STRONG> (Thumb, 124 bytes, Stack size 8 bytes, .\build\rtx_kernel.o(i.osKernelStart))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = osKernelStart &rArr; osKernelGetState &rArr; svcRtxKernelGetState
</UL>
<BR>[Calls]<UL><LI><a href="#[5bb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osKernelGetState
<LI><a href="#[5bd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__get_PRIMASK
<LI><a href="#[5bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__get_IPSR
<LI><a href="#[5c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__get_CONTROL
<LI><a href="#[5be]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__get_BASEPRI
<LI><a href="#[5c7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxKernelStart
<LI><a href="#[5c2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxKernelError
</UL>
<BR>[Called By]<UL><LI><a href="#[440]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_start_main
</UL>

<P><STRONG><a name="[5c8]"></a>osMessageQueueGet</STRONG> (Thumb, 78 bytes, Stack size 24 bytes, .\build\rtx_msgqueue.o(i.osMessageQueueGet))
<BR><BR>[Stack]<UL><LI>Max Depth = 88<LI>Call Chain = osMessageQueueGet &rArr; isrRtxMessageQueueGet &rArr; osRtxPostProcess &rArr; isr_queue_put
</UL>
<BR>[Calls]<UL><LI><a href="#[515]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;isrRtxMessageQueueGet
<LI><a href="#[5cb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__get_PRIMASK
<LI><a href="#[5ca]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__get_IPSR
<LI><a href="#[5cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__get_BASEPRI
<LI><a href="#[5c9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxMessageQueueGet
</UL>
<BR>[Called By]<UL><LI><a href="#[b6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxTimerThread
</UL>

<P><STRONG><a name="[5cd]"></a>osMessageQueueNew</STRONG> (Thumb, 122 bytes, Stack size 32 bytes, .\build\rtx_msgqueue.o(i.osMessageQueueNew))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = osMessageQueueNew
</UL>
<BR>[Calls]<UL><LI><a href="#[5cb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__get_PRIMASK
<LI><a href="#[5ca]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__get_IPSR
<LI><a href="#[5cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__get_BASEPRI
<LI><a href="#[5ce]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxMessageQueueNew
<LI><a href="#[516]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxMessageQueueError
</UL>
<BR>[Called By]<UL><LI><a href="#[b6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxTimerThread
</UL>

<P><STRONG><a name="[5cf]"></a>osMessageQueuePut</STRONG> (Thumb, 78 bytes, Stack size 24 bytes, .\build\rtx_msgqueue.o(i.osMessageQueuePut))
<BR><BR>[Stack]<UL><LI>Max Depth = 88<LI>Call Chain = osMessageQueuePut &rArr; isrRtxMessageQueuePut &rArr; osRtxPostProcess &rArr; isr_queue_put
</UL>
<BR>[Calls]<UL><LI><a href="#[51a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;isrRtxMessageQueuePut
<LI><a href="#[5cb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__get_PRIMASK
<LI><a href="#[5ca]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__get_IPSR
<LI><a href="#[5cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__get_BASEPRI
<LI><a href="#[5d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxMessageQueuePut
</UL>
<BR>[Called By]<UL><LI><a href="#[93]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxTimerTick
</UL>

<P><STRONG><a name="[2eb]"></a>osMutexAcquire</STRONG> (Thumb, 64 bytes, Stack size 16 bytes, .\build\rtx_mutex.o(i.osMutexAcquire))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = osMutexAcquire
</UL>
<BR>[Calls]<UL><LI><a href="#[5d3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__get_PRIMASK
<LI><a href="#[5d2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__get_IPSR
<LI><a href="#[5d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__get_BASEPRI
<LI><a href="#[5d5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxMutexError
<LI><a href="#[5d1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxMutexAcquire
</UL>
<BR>[Called By]<UL><LI><a href="#[2e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Mutex::lock(unsigned)
<LI><a href="#[554]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_mutex_lock
<LI><a href="#[496]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_protect
<LI><a href="#[2ea]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;singleton_lock()
<LI><a href="#[1da]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_mutex_acquire
</UL>

<P><STRONG><a name="[424]"></a>osMutexDelete</STRONG> (Thumb, 58 bytes, Stack size 8 bytes, .\build\rtx_mutex.o(i.osMutexDelete))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = osMutexDelete
</UL>
<BR>[Calls]<UL><LI><a href="#[5d3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__get_PRIMASK
<LI><a href="#[5d2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__get_IPSR
<LI><a href="#[5d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__get_BASEPRI
<LI><a href="#[5d5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxMutexError
<LI><a href="#[5d6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxMutexDelete
</UL>
<BR>[Called By]<UL><LI><a href="#[5f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Mutex::~Mutex()
</UL>

<P><STRONG><a name="[423]"></a>osMutexNew</STRONG> (Thumb, 102 bytes, Stack size 16 bytes, .\build\rtx_mutex.o(i.osMutexNew))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = osMutexNew
</UL>
<BR>[Calls]<UL><LI><a href="#[5d3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__get_PRIMASK
<LI><a href="#[5d2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__get_IPSR
<LI><a href="#[5d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__get_BASEPRI
<LI><a href="#[5d7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxMutexNew
<LI><a href="#[5d5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxMutexError
</UL>
<BR>[Called By]<UL><LI><a href="#[544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_init
<LI><a href="#[595]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_mutex_new
<LI><a href="#[75]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pre_main
<LI><a href="#[245]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_mutex_initialize
<LI><a href="#[422]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Mutex::constructor(const char*)
</UL>

<P><STRONG><a name="[30b]"></a>osMutexRelease</STRONG> (Thumb, 58 bytes, Stack size 8 bytes, .\build\rtx_mutex.o(i.osMutexRelease))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = osMutexRelease
</UL>
<BR>[Calls]<UL><LI><a href="#[5d3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__get_PRIMASK
<LI><a href="#[5d2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__get_IPSR
<LI><a href="#[5d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__get_BASEPRI
<LI><a href="#[5d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxMutexRelease
<LI><a href="#[5d5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxMutexError
</UL>
<BR>[Called By]<UL><LI><a href="#[2e9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Mutex::unlock()
<LI><a href="#[552]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_mutex_unlock
<LI><a href="#[497]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_unprotect
<LI><a href="#[30a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;singleton_unlock()
<LI><a href="#[1db]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_mutex_release
</UL>

<P><STRONG><a name="[442]"></a>osRtxErrorNotify</STRONG> (Thumb, 116 bytes, Stack size 0 bytes, .\build\mbed_rtx_handlers.o(i.osRtxErrorNotify))
<BR><BR>[Stack]<UL><LI>Max Depth = 8 + In Cycle
<LI>Call Chain = osRtxErrorNotify &rArr;  error (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[3e6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;error
<LI><a href="#[2a6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osThreadGetId
<LI><a href="#[5d9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osThreadGetName
</UL>
<BR>[Called By]<UL><LI><a href="#[245]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_mutex_initialize
<LI><a href="#[518]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxPostProcess
<LI><a href="#[219]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__user_perthread_libspace
<LI><a href="#[93]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxTimerTick
<LI><a href="#[608]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadStackCheck
</UL>

<P><STRONG><a name="[b4]"></a>osRtxEventFlagsPostProcess</STRONG> (Thumb, 76 bytes, Stack size 24 bytes, .\build\rtx_evflags.o(i.osRtxEventFlagsPostProcess))
<BR><BR>[Stack]<UL><LI>Max Depth = 88<LI>Call Chain = osRtxEventFlagsPostProcess &rArr; osRtxThreadWaitExit &rArr; osRtxThreadDispatch &rArr; osRtxThreadSwitch &rArr; osRtxThreadStackCheck &rArr; osRtxErrorNotify &rArr;  error (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[29e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EventFlagsCheck
<LI><a href="#[5db]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadWaitExit
<LI><a href="#[5da]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadListRemove
<LI><a href="#[513]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxEventFlagsWaitCompleted
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rtx_evflags.o(i.svcRtxEventFlagsNew)
</UL>
<P><STRONG><a name="[b5]"></a>osRtxIdleThread</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, .\build\mbed_rtx_handlers.o(i.osRtxIdleThread))
<BR><BR>[Calls]<UL><LI><a href="#[5dc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos_idle_loop
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rtx_kernel.o(i.svcRtxKernelStart)
</UL>
<P><STRONG><a name="[5dd]"></a>osRtxMemoryAlloc</STRONG> (Thumb, 162 bytes, Stack size 32 bytes, .\build\rtx_memory.o(i.osRtxMemoryAlloc))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = osRtxMemoryAlloc
</UL>
<BR>[Calls]<UL><LI><a href="#[5de]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxMemoryAlloc
</UL>
<BR>[Called By]<UL><LI><a href="#[84]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxEventFlagsNew
<LI><a href="#[97]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxSemaphoreNew
<LI><a href="#[91]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxMutexNew
<LI><a href="#[8d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxMessageQueueNew
<LI><a href="#[99]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxThreadNew
</UL>

<P><STRONG><a name="[5df]"></a>osRtxMemoryFree</STRONG> (Thumb, 102 bytes, Stack size 24 bytes, .\build\rtx_memory.o(i.osRtxMemoryFree))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = osRtxMemoryFree
</UL>
<BR>[Calls]<UL><LI><a href="#[5e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxMemoryFree
</UL>
<BR>[Called By]<UL><LI><a href="#[83]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxEventFlagsDelete
<LI><a href="#[604]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadFree
<LI><a href="#[95]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxSemaphoreDelete
<LI><a href="#[90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxMutexDelete
<LI><a href="#[8d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxMessageQueueNew
<LI><a href="#[99]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxThreadNew
</UL>

<P><STRONG><a name="[5e1]"></a>osRtxMemoryInit</STRONG> (Thumb, 82 bytes, Stack size 24 bytes, .\build\rtx_memory.o(i.osRtxMemoryInit))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = osRtxMemoryInit
</UL>
<BR>[Calls]<UL><LI><a href="#[5e2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxMemoryInit
</UL>
<BR>[Called By]<UL><LI><a href="#[88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxKernelInitialize
</UL>

<P><STRONG><a name="[51b]"></a>osRtxMemoryPoolAlloc</STRONG> (Thumb, 58 bytes, Stack size 16 bytes, .\build\rtx_mempool.o(i.osRtxMemoryPoolAlloc))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = osRtxMemoryPoolAlloc
</UL>
<BR>[Calls]<UL><LI><a href="#[5e5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__asm___13_rtx_mempool_c_7914b4c7__atomic_link_get
<LI><a href="#[5e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__asm___13_rtx_mempool_c_7914b4c7__atomic_inc32_lt
<LI><a href="#[5e3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxMemoryBlockAlloc
</UL>
<BR>[Called By]<UL><LI><a href="#[84]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxEventFlagsNew
<LI><a href="#[97]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxSemaphoreNew
<LI><a href="#[91]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxMutexNew
<LI><a href="#[8e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxMessageQueuePut
<LI><a href="#[8d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxMessageQueueNew
<LI><a href="#[8c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxMessageQueueGet
<LI><a href="#[b7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxMessageQueuePostProcess
<LI><a href="#[51a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;isrRtxMessageQueuePut
<LI><a href="#[99]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxThreadNew
</UL>

<P><STRONG><a name="[5e6]"></a>osRtxMemoryPoolFree</STRONG> (Thumb, 78 bytes, Stack size 16 bytes, .\build\rtx_mempool.o(i.osRtxMemoryPoolFree))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = osRtxMemoryPoolFree
</UL>
<BR>[Calls]<UL><LI><a href="#[20f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__asm___13_rtx_mempool_c_7914b4c7__atomic_link_put
<LI><a href="#[5e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__asm___13_rtx_mempool_c_7914b4c7__atomic_dec32_nz
<LI><a href="#[5e7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxMemoryBlockFree
</UL>
<BR>[Called By]<UL><LI><a href="#[83]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxEventFlagsDelete
<LI><a href="#[604]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadFree
<LI><a href="#[95]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxSemaphoreDelete
<LI><a href="#[90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxMutexDelete
<LI><a href="#[8d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxMessageQueueNew
<LI><a href="#[8c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxMessageQueueGet
<LI><a href="#[b7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxMessageQueuePostProcess
<LI><a href="#[99]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxThreadNew
</UL>

<P><STRONG><a name="[5e9]"></a>osRtxMemoryPoolInit</STRONG> (Thumb, 80 bytes, Stack size 24 bytes, .\build\rtx_mempool.o(i.osRtxMemoryPoolInit))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = osRtxMemoryPoolInit
</UL>
<BR>[Calls]<UL><LI><a href="#[5ea]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxMemoryBlockInit
</UL>
<BR>[Called By]<UL><LI><a href="#[8d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxMessageQueueNew
<LI><a href="#[88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxKernelInitialize
</UL>

<P><STRONG><a name="[b7]"></a>osRtxMessageQueuePostProcess</STRONG> (Thumb, 274 bytes, Stack size 24 bytes, .\build\rtx_msgqueue.o(i.osRtxMessageQueuePostProcess))
<BR><BR>[Stack]<UL><LI>Max Depth = 88<LI>Call Chain = osRtxMessageQueuePostProcess &rArr; osRtxThreadWaitExit &rArr; osRtxThreadDispatch &rArr; osRtxThreadSwitch &rArr; osRtxThreadStackCheck &rArr; osRtxErrorNotify &rArr;  error (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[5db]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadWaitExit
<LI><a href="#[5ec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadListGet
<LI><a href="#[5e6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxMemoryPoolFree
<LI><a href="#[51b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxMemoryPoolAlloc
<LI><a href="#[5ed]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadRegPtr
<LI><a href="#[5eb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MessageQueueRemove
<LI><a href="#[2c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MessageQueuePut
<LI><a href="#[517]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxMessageQueueRetrieved
<LI><a href="#[5ee]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxMessageQueueInserted
<LI><a href="#[249]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rtx_msgqueue.o(i.svcRtxMessageQueueNew)
</UL>
<P><STRONG><a name="[5ef]"></a>osRtxMutexOwnerRelease</STRONG> (Thumb, 84 bytes, Stack size 16 bytes, .\build\rtx_mutex.o(i.osRtxMutexOwnerRelease))
<BR><BR>[Stack]<UL><LI>Max Depth = 80<LI>Call Chain = osRtxMutexOwnerRelease &rArr; osRtxThreadWaitExit &rArr; osRtxThreadDispatch &rArr; osRtxThreadSwitch &rArr; osRtxThreadStackCheck &rArr; osRtxErrorNotify &rArr;  error (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[5db]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadWaitExit
<LI><a href="#[5ec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadListGet
<LI><a href="#[5f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxMutexReleased
<LI><a href="#[5f1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxMutexAcquired
</UL>
<BR>[Called By]<UL><LI><a href="#[9d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxThreadTerminate
<LI><a href="#[9a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxThreadExit
</UL>

<P><STRONG><a name="[215]"></a>osRtxPendSV_Handler</STRONG> (Thumb, 96 bytes, Stack size 8 bytes, .\build\rtx_system.o(i.osRtxPendSV_Handler))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = osRtxPendSV_Handler &rArr; osRtxThreadDispatch &rArr; osRtxThreadSwitch &rArr; osRtxThreadStackCheck &rArr; osRtxErrorNotify &rArr;  error (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[5f2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadDispatch
<LI><a href="#[51e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;isr_queue_get
</UL>
<BR>[Called By]<UL><LI><a href="#[18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;PendSV_Handler
</UL>

<P><STRONG><a name="[518]"></a>osRtxPostProcess</STRONG> (Thumb, 50 bytes, Stack size 8 bytes, .\build\rtx_system.o(i.osRtxPostProcess))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = osRtxPostProcess &rArr; isr_queue_put
</UL>
<BR>[Calls]<UL><LI><a href="#[442]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxErrorNotify
<LI><a href="#[521]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;isr_queue_put
</UL>
<BR>[Called By]<UL><LI><a href="#[41b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osEventFlagsSet
<LI><a href="#[431]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osSemaphoreRelease
<LI><a href="#[51a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;isrRtxMessageQueuePut
<LI><a href="#[515]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;isrRtxMessageQueueGet
</UL>

<P><STRONG><a name="[b8]"></a>osRtxSemaphorePostProcess</STRONG> (Thumb, 50 bytes, Stack size 16 bytes, .\build\rtx_semaphore.o(i.osRtxSemaphorePostProcess))
<BR><BR>[Stack]<UL><LI>Max Depth = 80<LI>Call Chain = osRtxSemaphorePostProcess &rArr; osRtxThreadWaitExit &rArr; osRtxThreadDispatch &rArr; osRtxThreadSwitch &rArr; osRtxThreadStackCheck &rArr; osRtxErrorNotify &rArr;  error (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[5db]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadWaitExit
<LI><a href="#[5ec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadListGet
<LI><a href="#[2d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SemaphoreTokenDecrement
<LI><a href="#[5f3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxSemaphoreAcquired
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rtx_semaphore.o(i.svcRtxSemaphoreNew)
</UL>
<P><STRONG><a name="[602]"></a>osRtxThreadBlock</STRONG> (Thumb, 42 bytes, Stack size 8 bytes, .\build\rtx_thread.o(i.osRtxThreadBlock))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = osRtxThreadBlock
</UL>
<BR>[Called By]<UL><LI><a href="#[5f2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadDispatch
</UL>

<P><STRONG><a name="[60c]"></a>osRtxThreadDelayInsert</STRONG> (Thumb, 100 bytes, Stack size 8 bytes, .\build\rtx_thread.o(i.osRtxThreadDelayInsert))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = osRtxThreadDelayInsert
</UL>
<BR>[Called By]<UL><LI><a href="#[60a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadWaitEnter
</UL>

<P><STRONG><a name="[60d]"></a>osRtxThreadDelayRemove</STRONG> (Thumb, 116 bytes, Stack size 0 bytes, .\build\rtx_thread.o(i.osRtxThreadDelayRemove))
<BR><BR>[Called By]<UL><LI><a href="#[5db]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadWaitExit
<LI><a href="#[9d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxThreadTerminate
</UL>

<P><STRONG><a name="[5f4]"></a>osRtxThreadDelayTick</STRONG> (Thumb, 216 bytes, Stack size 16 bytes, .\build\rtx_thread.o(i.osRtxThreadDelayTick))
<BR><BR>[Stack]<UL><LI>Max Depth = 36<LI>Call Chain = osRtxThreadDelayTick &rArr; osRtxThreadReadyPut &rArr; osRtxThreadListPut
</UL>
<BR>[Calls]<UL><LI><a href="#[5da]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadListRemove
<LI><a href="#[5ff]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadReadyPut
<LI><a href="#[5ed]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadRegPtr
<LI><a href="#[5fe]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxThreadUnblocked
<LI><a href="#[5f6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxThreadFlagsWaitTimeout
<LI><a href="#[5f5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxThreadDelayCompleted
<LI><a href="#[5fa]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxSemaphoreAcquireTimeout
<LI><a href="#[5f9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxMutexAcquireTimeout
<LI><a href="#[5fd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxMessageQueuePutTimeout
<LI><a href="#[5fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxMessageQueueGetTimeout
<LI><a href="#[5fb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxMemoryPoolAllocTimeout
<LI><a href="#[5f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxEventFlagsWaitTimeout
<LI><a href="#[5f7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadListRoot
</UL>
<BR>[Called By]<UL><LI><a href="#[216]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxTick_Handler
<LI><a href="#[310]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxKernelResume
</UL>

<P><STRONG><a name="[5f2]"></a>osRtxThreadDispatch</STRONG> (Thumb, 102 bytes, Stack size 16 bytes, .\build\rtx_thread.o(i.osRtxThreadDispatch))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = osRtxThreadDispatch &rArr; osRtxThreadSwitch &rArr; osRtxThreadStackCheck &rArr; osRtxErrorNotify &rArr;  error (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[5da]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadListRemove
<LI><a href="#[601]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadGetRunning
<LI><a href="#[600]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxKernelGetState
<LI><a href="#[5ff]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadReadyPut
<LI><a href="#[603]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadSwitch
<LI><a href="#[602]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadBlock
</UL>
<BR>[Called By]<UL><LI><a href="#[216]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxTick_Handler
<LI><a href="#[215]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxPendSV_Handler
<LI><a href="#[310]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxKernelResume
<LI><a href="#[5db]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadWaitExit
<LI><a href="#[85]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxEventFlagsSet
<LI><a href="#[83]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxEventFlagsDelete
<LI><a href="#[95]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxSemaphoreDelete
<LI><a href="#[92]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxMutexRelease
<LI><a href="#[90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxMutexDelete
<LI><a href="#[99]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxThreadNew
<LI><a href="#[9d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxThreadTerminate
</UL>

<P><STRONG><a name="[5ec]"></a>osRtxThreadListGet</STRONG> (Thumb, 24 bytes, Stack size 0 bytes, .\build\rtx_thread.o(i.osRtxThreadListGet))
<BR><BR>[Called By]<UL><LI><a href="#[60a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadWaitEnter
<LI><a href="#[83]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxEventFlagsDelete
<LI><a href="#[98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxSemaphoreRelease
<LI><a href="#[95]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxSemaphoreDelete
<LI><a href="#[b8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxSemaphorePostProcess
<LI><a href="#[92]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxMutexRelease
<LI><a href="#[90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxMutexDelete
<LI><a href="#[5ef]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxMutexOwnerRelease
<LI><a href="#[8e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxMessageQueuePut
<LI><a href="#[8c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxMessageQueueGet
<LI><a href="#[b7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxMessageQueuePostProcess
<LI><a href="#[8b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxKernelStart
<LI><a href="#[9d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxThreadTerminate
<LI><a href="#[9a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxThreadExit
</UL>

<P><STRONG><a name="[606]"></a>osRtxThreadListPut</STRONG> (Thumb, 46 bytes, Stack size 12 bytes, .\build\rtx_thread.o(i.osRtxThreadListPut))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = osRtxThreadListPut
</UL>
<BR>[Called By]<UL><LI><a href="#[86]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxEventFlagsWait
<LI><a href="#[5ff]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadReadyPut
<LI><a href="#[94]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxSemaphoreAcquire
<LI><a href="#[605]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadListSort
<LI><a href="#[8f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxMutexAcquire
<LI><a href="#[8e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxMessageQueuePut
<LI><a href="#[8c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxMessageQueueGet
</UL>

<P><STRONG><a name="[5da]"></a>osRtxThreadListRemove</STRONG> (Thumb, 26 bytes, Stack size 0 bytes, .\build\rtx_thread.o(i.osRtxThreadListRemove))
<BR><BR>[Called By]<UL><LI><a href="#[216]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxTick_Handler
<LI><a href="#[60a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadWaitEnter
<LI><a href="#[5f2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadDispatch
<LI><a href="#[85]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxEventFlagsSet
<LI><a href="#[b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxEventFlagsPostProcess
<LI><a href="#[605]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadListSort
<LI><a href="#[5f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadDelayTick
<LI><a href="#[9e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxThreadYield
<LI><a href="#[9d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxThreadTerminate
</UL>

<P><STRONG><a name="[5f7]"></a>osRtxThreadListRoot</STRONG> (Thumb, 14 bytes, Stack size 0 bytes, .\build\rtx_thread.o(i.osRtxThreadListRoot))
<BR><BR>[Called By]<UL><LI><a href="#[5f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadDelayTick
</UL>

<P><STRONG><a name="[605]"></a>osRtxThreadListSort</STRONG> (Thumb, 40 bytes, Stack size 16 bytes, .\build\rtx_thread.o(i.osRtxThreadListSort))
<BR><BR>[Stack]<UL><LI>Max Depth = 28<LI>Call Chain = osRtxThreadListSort &rArr; osRtxThreadListPut
</UL>
<BR>[Calls]<UL><LI><a href="#[5da]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadListRemove
<LI><a href="#[606]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadListPut
</UL>
<BR>[Called By]<UL><LI><a href="#[90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxMutexDelete
<LI><a href="#[8f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxMutexAcquire
</UL>

<P><STRONG><a name="[ba]"></a>osRtxThreadPostProcess</STRONG> (Thumb, 64 bytes, Stack size 16 bytes, .\build\rtx_thread.o(i.osRtxThreadPostProcess))
<BR><BR>[Stack]<UL><LI>Max Depth = 80<LI>Call Chain = osRtxThreadPostProcess &rArr; osRtxThreadWaitExit &rArr; osRtxThreadDispatch &rArr; osRtxThreadSwitch &rArr; osRtxThreadStackCheck &rArr; osRtxErrorNotify &rArr;  error (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[5db]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadWaitExit
<LI><a href="#[2d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ThreadFlagsCheck
<LI><a href="#[607]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxThreadFlagsWaitCompleted
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rtx_thread.o(i.svcRtxThreadNew)
</UL>
<P><STRONG><a name="[5ff]"></a>osRtxThreadReadyPut</STRONG> (Thumb, 18 bytes, Stack size 8 bytes, .\build\rtx_thread.o(i.osRtxThreadReadyPut))
<BR><BR>[Stack]<UL><LI>Max Depth = 20<LI>Call Chain = osRtxThreadReadyPut &rArr; osRtxThreadListPut
</UL>
<BR>[Calls]<UL><LI><a href="#[606]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadListPut
</UL>
<BR>[Called By]<UL><LI><a href="#[216]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxTick_Handler
<LI><a href="#[5db]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadWaitExit
<LI><a href="#[5f2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadDispatch
<LI><a href="#[5f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadDelayTick
<LI><a href="#[9e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxThreadYield
</UL>

<P><STRONG><a name="[5ed]"></a>osRtxThreadRegPtr</STRONG> (Thumb, 24 bytes, Stack size 0 bytes, .\build\rtx_thread.o(i.osRtxThreadRegPtr))
<BR><BR>[Called By]<UL><LI><a href="#[5db]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadWaitExit
<LI><a href="#[8e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxMessageQueuePut
<LI><a href="#[8c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxMessageQueueGet
<LI><a href="#[b7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxMessageQueuePostProcess
<LI><a href="#[5f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadDelayTick
</UL>

<P><STRONG><a name="[608]"></a>osRtxThreadStackCheck</STRONG> (Thumb, 38 bytes, Stack size 8 bytes, .\build\rtx_thread.o(i.osRtxThreadStackCheck))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = osRtxThreadStackCheck &rArr; osRtxErrorNotify &rArr;  error (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[442]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxErrorNotify
<LI><a href="#[601]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadGetRunning
</UL>
<BR>[Called By]<UL><LI><a href="#[603]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadSwitch
</UL>

<P><STRONG><a name="[603]"></a>osRtxThreadSwitch</STRONG> (Thumb, 24 bytes, Stack size 8 bytes, .\build\rtx_thread.o(i.osRtxThreadSwitch))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = osRtxThreadSwitch &rArr; osRtxThreadStackCheck &rArr; osRtxErrorNotify &rArr;  error (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[609]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxThreadSwitch
<LI><a href="#[608]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadStackCheck
</UL>
<BR>[Called By]<UL><LI><a href="#[216]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxTick_Handler
<LI><a href="#[60a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadWaitEnter
<LI><a href="#[5f2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadDispatch
<LI><a href="#[8b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxKernelStart
<LI><a href="#[9e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxThreadYield
<LI><a href="#[9d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxThreadTerminate
<LI><a href="#[9a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxThreadExit
</UL>

<P><STRONG><a name="[60a]"></a>osRtxThreadWaitEnter</STRONG> (Thumb, 84 bytes, Stack size 16 bytes, .\build\rtx_thread.o(i.osRtxThreadWaitEnter))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = osRtxThreadWaitEnter &rArr; osRtxThreadSwitch &rArr; osRtxThreadStackCheck &rArr; osRtxErrorNotify &rArr;  error (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[5da]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadListRemove
<LI><a href="#[5ec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadListGet
<LI><a href="#[601]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadGetRunning
<LI><a href="#[600]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxKernelGetState
<LI><a href="#[603]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadSwitch
<LI><a href="#[60b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxThreadBlocked
<LI><a href="#[60c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadDelayInsert
</UL>
<BR>[Called By]<UL><LI><a href="#[81]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxDelay
<LI><a href="#[86]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxEventFlagsWait
<LI><a href="#[94]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxSemaphoreAcquire
<LI><a href="#[8f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxMutexAcquire
<LI><a href="#[8e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxMessageQueuePut
<LI><a href="#[8c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxMessageQueueGet
</UL>

<P><STRONG><a name="[5db]"></a>osRtxThreadWaitExit</STRONG> (Thumb, 54 bytes, Stack size 24 bytes, .\build\rtx_thread.o(i.osRtxThreadWaitExit))
<BR><BR>[Stack]<UL><LI>Max Depth = 64<LI>Call Chain = osRtxThreadWaitExit &rArr; osRtxThreadDispatch &rArr; osRtxThreadSwitch &rArr; osRtxThreadStackCheck &rArr; osRtxErrorNotify &rArr;  error (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[5f2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadDispatch
<LI><a href="#[5ff]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadReadyPut
<LI><a href="#[5ed]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadRegPtr
<LI><a href="#[5fe]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxThreadUnblocked
<LI><a href="#[60d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadDelayRemove
</UL>
<BR>[Called By]<UL><LI><a href="#[85]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxEventFlagsSet
<LI><a href="#[83]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxEventFlagsDelete
<LI><a href="#[b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxEventFlagsPostProcess
<LI><a href="#[98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxSemaphoreRelease
<LI><a href="#[95]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxSemaphoreDelete
<LI><a href="#[b8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxSemaphorePostProcess
<LI><a href="#[92]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxMutexRelease
<LI><a href="#[90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxMutexDelete
<LI><a href="#[5ef]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxMutexOwnerRelease
<LI><a href="#[8e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxMessageQueuePut
<LI><a href="#[8c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxMessageQueueGet
<LI><a href="#[b7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxMessageQueuePostProcess
<LI><a href="#[9d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxThreadTerminate
<LI><a href="#[9a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxThreadExit
<LI><a href="#[ba]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadPostProcess
</UL>

<P><STRONG><a name="[216]"></a>osRtxTick_Handler</STRONG> (Thumb, 146 bytes, Stack size 8 bytes, .\build\rtx_system.o(i.osRtxTick_Handler))
<BR><BR>[Stack]<UL><LI>Max Depth = 240<LI>Call Chain = osRtxTick_Handler &rArr; OS_Tick_AcknowledgeIRQ &rArr; rtos::internal::SysTimer::schedule_tick(unsigned) &rArr; mbed::TimerEvent::insert_absolute(unsigned long long) &rArr; ticker_insert_event_us &rArr; schedule_interrupt &rArr; update_present_time &rArr; __aeabi_uldivmod
</UL>
<BR>[Calls]<UL><LI><a href="#[2ca]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OS_Tick_AcknowledgeIRQ
<LI><a href="#[5da]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadListRemove
<LI><a href="#[5f2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadDispatch
<LI><a href="#[5ff]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadReadyPut
<LI><a href="#[603]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadSwitch
<LI><a href="#[5f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadDelayTick
</UL>
<BR>[Called By]<UL><LI><a href="#[19]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SysTick_Handler
</UL>

<P><STRONG><a name="[b6]"></a>osRtxTimerThread</STRONG> (Thumb, 74 bytes, Stack size 24 bytes, .\build\rtx_timer.o(i.osRtxTimerThread))
<BR><BR>[Stack]<UL><LI>Max Depth = 112<LI>Call Chain = osRtxTimerThread &rArr; osMessageQueueGet &rArr; isrRtxMessageQueueGet &rArr; osRtxPostProcess &rArr; isr_queue_put
</UL>
<BR>[Calls]<UL><LI><a href="#[5cd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osMessageQueueNew
<LI><a href="#[5c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osMessageQueueGet
<LI><a href="#[60e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxTimerCallback
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rtx_kernel.o(i.svcRtxKernelStart)
</UL>
<P><STRONG><a name="[93]"></a>osRtxTimerTick</STRONG> (Thumb, 88 bytes, Stack size 16 bytes, .\build\rtx_timer.o(i.osRtxTimerTick))
<BR><BR>[Stack]<UL><LI>Max Depth = 104<LI>Call Chain = osRtxTimerTick &rArr; osMessageQueuePut &rArr; isrRtxMessageQueuePut &rArr; osRtxPostProcess &rArr; isr_queue_put
</UL>
<BR>[Calls]<UL><LI><a href="#[5cf]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osMessageQueuePut
<LI><a href="#[442]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxErrorNotify
<LI><a href="#[60f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerUnlink
<LI><a href="#[610]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerInsert
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rtx_timer.o(i.osRtxTimerThread)
</UL>
<P><STRONG><a name="[42f]"></a>osSemaphoreAcquire</STRONG> (Thumb, 138 bytes, Stack size 24 bytes, .\build\rtx_semaphore.o(i.osSemaphoreAcquire))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = osSemaphoreAcquire &rArr; SemaphoreTokenDecrement
</UL>
<BR>[Calls]<UL><LI><a href="#[613]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__get_PRIMASK
<LI><a href="#[612]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__get_IPSR
<LI><a href="#[614]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__get_BASEPRI
<LI><a href="#[2d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SemaphoreTokenDecrement
<LI><a href="#[616]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxSemaphoreNotAcquired
<LI><a href="#[615]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxSemaphoreError
<LI><a href="#[5f3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxSemaphoreAcquired
<LI><a href="#[611]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxSemaphoreAcquire
</UL>
<BR>[Called By]<UL><LI><a href="#[3d1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Semaphore::wait(unsigned)
<LI><a href="#[553]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_sem_wait
</UL>

<P><STRONG><a name="[432]"></a>osSemaphoreDelete</STRONG> (Thumb, 58 bytes, Stack size 8 bytes, .\build\rtx_semaphore.o(i.osSemaphoreDelete))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = osSemaphoreDelete
</UL>
<BR>[Calls]<UL><LI><a href="#[613]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__get_PRIMASK
<LI><a href="#[612]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__get_IPSR
<LI><a href="#[614]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__get_BASEPRI
<LI><a href="#[615]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxSemaphoreError
<LI><a href="#[617]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxSemaphoreDelete
</UL>
<BR>[Called By]<UL><LI><a href="#[3d5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Semaphore::~Semaphore()
</UL>

<P><STRONG><a name="[430]"></a>osSemaphoreGetCount</STRONG> (Thumb, 44 bytes, Stack size 8 bytes, .\build\rtx_semaphore.o(i.osSemaphoreGetCount))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = osSemaphoreGetCount &rArr; svcRtxSemaphoreGetCount
</UL>
<BR>[Calls]<UL><LI><a href="#[96]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxSemaphoreGetCount
<LI><a href="#[613]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__get_PRIMASK
<LI><a href="#[612]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__get_IPSR
<LI><a href="#[614]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__get_BASEPRI
</UL>
<BR>[Called By]<UL><LI><a href="#[3d1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Semaphore::wait(unsigned)
</UL>

<P><STRONG><a name="[42e]"></a>osSemaphoreNew</STRONG> (Thumb, 122 bytes, Stack size 32 bytes, .\build\rtx_semaphore.o(i.osSemaphoreNew))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = osSemaphoreNew
</UL>
<BR>[Calls]<UL><LI><a href="#[613]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__get_PRIMASK
<LI><a href="#[612]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__get_IPSR
<LI><a href="#[614]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__get_BASEPRI
<LI><a href="#[618]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxSemaphoreNew
<LI><a href="#[615]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxSemaphoreError
</UL>
<BR>[Called By]<UL><LI><a href="#[57b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_sem_new
<LI><a href="#[42d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Semaphore::constructor(int, unsigned short)
</UL>

<P><STRONG><a name="[431]"></a>osSemaphoreRelease</STRONG> (Thumb, 132 bytes, Stack size 16 bytes, .\build\rtx_semaphore.o(i.osSemaphoreRelease))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = osSemaphoreRelease &rArr; osRtxPostProcess &rArr; isr_queue_put
</UL>
<BR>[Calls]<UL><LI><a href="#[518]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxPostProcess
<LI><a href="#[613]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__get_PRIMASK
<LI><a href="#[612]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__get_IPSR
<LI><a href="#[614]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__get_BASEPRI
<LI><a href="#[2d2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SemaphoreTokenIncrement
<LI><a href="#[61a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxSemaphoreReleased
<LI><a href="#[619]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxSemaphoreRelease
<LI><a href="#[615]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxSemaphoreError
</UL>
<BR>[Called By]<UL><LI><a href="#[3cd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Semaphore::release()
<LI><a href="#[37c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_sem_signal
</UL>

<P><STRONG><a name="[61b]"></a>osThreadContextNew</STRONG> (Thumb, 128 bytes, Stack size 40 bytes, .\build\rtx_thread.o(i.osThreadContextNew))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = osThreadContextNew
</UL>
<BR>[Calls]<UL><LI><a href="#[5b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxThreadError
<LI><a href="#[61e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__get_PRIMASK
<LI><a href="#[61d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__get_IPSR
<LI><a href="#[61f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__get_BASEPRI
<LI><a href="#[61c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxThreadNew
</UL>
<BR>[Called By]<UL><LI><a href="#[426]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osThreadNew
</UL>

<P><STRONG><a name="[b9]"></a>osThreadExit</STRONG> (Thumb, 28 bytes, Stack size 0 bytes, .\build\rtx_thread.o(i.osThreadExit))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = osThreadExit &rArr; EvrRtxThreadExit &rArr; osThreadGetId
</UL>
<BR>[Calls]<UL><LI><a href="#[2a5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxThreadExit
<LI><a href="#[5b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxThreadError
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rtx_thread.o(i.svcRtxThreadNew)
</UL>
<P><STRONG><a name="[2a6]"></a>osThreadGetId</STRONG> (Thumb, 42 bytes, Stack size 8 bytes, .\build\rtx_thread.o(i.osThreadGetId))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = osThreadGetId
</UL>
<BR>[Calls]<UL><LI><a href="#[61e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__get_PRIMASK
<LI><a href="#[61d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__get_IPSR
<LI><a href="#[61f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__get_BASEPRI
<LI><a href="#[620]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxThreadGetId
</UL>
<BR>[Called By]<UL><LI><a href="#[442]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxErrorNotify
<LI><a href="#[2a5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxThreadExit
<LI><a href="#[219]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__user_perthread_libspace
</UL>

<P><STRONG><a name="[5d9]"></a>osThreadGetName</STRONG> (Thumb, 48 bytes, Stack size 8 bytes, .\build\rtx_thread.o(i.osThreadGetName))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = osThreadGetName
</UL>
<BR>[Calls]<UL><LI><a href="#[61e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__get_PRIMASK
<LI><a href="#[61d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__get_IPSR
<LI><a href="#[61f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__get_BASEPRI
<LI><a href="#[621]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxThreadGetName
</UL>
<BR>[Called By]<UL><LI><a href="#[442]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxErrorNotify
</UL>

<P><STRONG><a name="[426]"></a>osThreadNew</STRONG> (Thumb, 22 bytes, Stack size 16 bytes, .\build\rtx_thread.o(i.osThreadNew))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = osThreadNew &rArr; osThreadContextNew
</UL>
<BR>[Calls]<UL><LI><a href="#[61b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osThreadContextNew
</UL>
<BR>[Called By]<UL><LI><a href="#[3ad]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Thread::start(mbed::Callback&lang;void()&rang;)
<LI><a href="#[690]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_thread_new
<LI><a href="#[440]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_start_main
</UL>

<P><STRONG><a name="[428]"></a>osThreadTerminate</STRONG> (Thumb, 58 bytes, Stack size 8 bytes, .\build\rtx_thread.o(i.osThreadTerminate))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = osThreadTerminate &rArr; EvrRtxThreadTerminate &rArr; thread_terminate_hook
</UL>
<BR>[Calls]<UL><LI><a href="#[2a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxThreadTerminate
<LI><a href="#[5b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxThreadError
<LI><a href="#[61e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__get_PRIMASK
<LI><a href="#[61d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__get_IPSR
<LI><a href="#[61f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__get_BASEPRI
</UL>
<BR>[Called By]<UL><LI><a href="#[3bd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Thread::terminate()
</UL>

<P><STRONG><a name="[427]"></a>osThreadYield</STRONG> (Thumb, 52 bytes, Stack size 8 bytes, .\build\rtx_thread.o(i.osThreadYield))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = osThreadYield
</UL>
<BR>[Calls]<UL><LI><a href="#[5b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxThreadError
<LI><a href="#[61e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__get_PRIMASK
<LI><a href="#[61d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__get_IPSR
<LI><a href="#[61f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__get_BASEPRI
<LI><a href="#[622]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxThreadYield
</UL>
<BR>[Called By]<UL><LI><a href="#[3fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Thread::yield()
</UL>

<P><STRONG><a name="[46a]"></a>pbuf_alloc</STRONG> (Thumb, 380 bytes, Stack size 40 bytes, .\build\lwip_pbuf.o(i.pbuf_alloc))
<BR><BR>[Stack]<UL><LI>Max Depth = 576 + Unknown Stack Size
<LI>Call Chain = pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[46b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_free
<LI><a href="#[4e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memp_malloc
<LI><a href="#[596]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mem_malloc
</UL>
<BR>[Called By]<UL><LI><a href="#[484]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dns_send
<LI><a href="#[466]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;chap_respond
<LI><a href="#[561]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_write
<LI><a href="#[4e3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;igmp_send
<LI><a href="#[4d1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;icmp_input
<LI><a href="#[4d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;icmp_send_response
<LI><a href="#[2c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fsm_sdata
<LI><a href="#[4c6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fsm_sconfreq
<LI><a href="#[e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lcp_reqci
<LI><a href="#[4f3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip4_frag
<LI><a href="#[58d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netbuf_ref
<LI><a href="#[f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pppos_write
<LI><a href="#[f9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pppos_netif_output
<LI><a href="#[630]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_singlebuf
<LI><a href="#[416]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pppos_input
<LI><a href="#[6af]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_output_alloc_header
<LI><a href="#[696]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_rst
<LI><a href="#[6a5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_enqueue_flags
<LI><a href="#[6c3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_sendto_if_src
</UL>

<P><STRONG><a name="[4f5]"></a>pbuf_alloced_custom</STRONG> (Thumb, 106 bytes, Stack size 20 bytes, .\build\lwip_pbuf.o(i.pbuf_alloced_custom))
<BR><BR>[Stack]<UL><LI>Max Depth = 20<LI>Call Chain = pbuf_alloced_custom
</UL>
<BR>[Called By]<UL><LI><a href="#[4f3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip4_frag
</UL>

<P><STRONG><a name="[4f8]"></a>pbuf_cat</STRONG> (Thumb, 48 bytes, Stack size 8 bytes, .\build\lwip_pbuf.o(i.pbuf_cat))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = pbuf_cat
</UL>
<BR>[Called By]<UL><LI><a href="#[561]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_write
<LI><a href="#[4fa]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip4_reass
<LI><a href="#[4f3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip4_frag
<LI><a href="#[623]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_chain
<LI><a href="#[416]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pppos_input
</UL>

<P><STRONG><a name="[623]"></a>pbuf_chain</STRONG> (Thumb, 22 bytes, Stack size 16 bytes, .\build\lwip_pbuf.o(i.pbuf_chain))
<BR><BR>[Stack]<UL><LI>Max Depth = 496 + Unknown Stack Size
<LI>Call Chain = pbuf_chain &rArr; pbuf_ref &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[4f7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_ref
<LI><a href="#[4f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_cat
</UL>
<BR>[Called By]<UL><LI><a href="#[6c3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_sendto_if_src
</UL>

<P><STRONG><a name="[500]"></a>pbuf_clen</STRONG> (Thumb, 18 bytes, Stack size 0 bytes, .\build\lwip_pbuf.o(i.pbuf_clen))
<BR><BR>[Called By]<UL><LI><a href="#[561]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_write
<LI><a href="#[506]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip_reass_free_complete_datagram
<LI><a href="#[503]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip_reass_chain_frag_into_datagram_and_validate
<LI><a href="#[4fa]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip4_reass
<LI><a href="#[6b6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_receive
<LI><a href="#[6a5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_enqueue_flags
</UL>

<P><STRONG><a name="[4d5]"></a>pbuf_copy</STRONG> (Thumb, 184 bytes, Stack size 24 bytes, .\build\lwip_pbuf.o(i.pbuf_copy))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = pbuf_copy
</UL>
<BR>[Calls]<UL><LI><a href="#[249]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Called By]<UL><LI><a href="#[4d1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;icmp_input
</UL>

<P><STRONG><a name="[48d]"></a>pbuf_copy_partial</STRONG> (Thumb, 146 bytes, Stack size 40 bytes, .\build\lwip_pbuf.o(i.pbuf_copy_partial))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = pbuf_copy_partial
</UL>
<BR>[Calls]<UL><LI><a href="#[249]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Called By]<UL><LI><a href="#[62]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dns_recv
<LI><a href="#[107]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_socket_recvfrom
<LI><a href="#[105]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_socket_recv
<LI><a href="#[6bb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_zero_window_probe
</UL>

<P><STRONG><a name="[46b]"></a>pbuf_free</STRONG> (Thumb, 128 bytes, Stack size 32 bytes, .\build\lwip_pbuf.o(i.pbuf_free))
<BR><BR>[Stack]<UL><LI>Max Depth = 536 + Unknown Stack Size
<LI>Call Chain = pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[497]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_unprotect
<LI><a href="#[496]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_protect
<LI><a href="#[4e7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memp_free
<LI><a href="#[593]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mem_free
</UL>
<BR>[Called By]<UL><LI><a href="#[484]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dns_send
<LI><a href="#[62]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dns_recv
<LI><a href="#[46e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_realloc
<LI><a href="#[46a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_alloc
<LI><a href="#[466]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;chap_respond
<LI><a href="#[561]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_write
<LI><a href="#[557]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_shutdown
<LI><a href="#[4dc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;igmp_input
<LI><a href="#[4e3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;igmp_send
<LI><a href="#[4d1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;icmp_input
<LI><a href="#[4d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;icmp_send_response
<LI><a href="#[2c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fsm_sdata
<LI><a href="#[4c6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fsm_sconfreq
<LI><a href="#[585]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netbuf_delete
<LI><a href="#[9f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;recv_udp
<LI><a href="#[b3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;recv_tcp
<LI><a href="#[550]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netconn_drain
<LI><a href="#[e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lcp_reqci
<LI><a href="#[67]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ipfrag_free_pbuf_custom
<LI><a href="#[506]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip_reass_free_complete_datagram
<LI><a href="#[503]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip_reass_chain_frag_into_datagram_and_validate
<LI><a href="#[4fb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_input
<LI><a href="#[4fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_input
<LI><a href="#[4fa]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip4_reass
<LI><a href="#[4f3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip4_frag
<LI><a href="#[4f9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip4_input
<LI><a href="#[58d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netbuf_ref
<LI><a href="#[58e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netbuf_free
<LI><a href="#[f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pppos_write
<LI><a href="#[63c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pppos_output_last
<LI><a href="#[639]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pppos_input_free_current_packet
<LI><a href="#[a6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pppos_input_callback
<LI><a href="#[630]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_singlebuf
<LI><a href="#[62f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_input
<LI><a href="#[636]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_netif_output
<LI><a href="#[416]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pppos_input
<LI><a href="#[6a6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_create_segment
<LI><a href="#[6ac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_send_empty_ack
<LI><a href="#[6bb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_zero_window_probe
<LI><a href="#[696]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_rst
<LI><a href="#[6ae]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_keepalive
<LI><a href="#[6a7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_seg_free
<LI><a href="#[bb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_recv_null
<LI><a href="#[69e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_pcb_purge
<LI><a href="#[6c3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_sendto_if_src
</UL>

<P><STRONG><a name="[4d4]"></a>pbuf_header</STRONG> (Thumb, 18 bytes, Stack size 16 bytes, .\build\lwip_pbuf.o(i.pbuf_header))
<BR><BR>[Stack]<UL><LI>Max Depth = 36<LI>Call Chain = pbuf_header &rArr; pbuf_header_impl
</UL>
<BR>[Calls]<UL><LI><a href="#[624]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_header_impl
</UL>
<BR>[Called By]<UL><LI><a href="#[4d1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;icmp_input
<LI><a href="#[4fb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_input
<LI><a href="#[4fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_input
<LI><a href="#[4fa]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip4_reass
<LI><a href="#[4fe]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip4_output_if_opt_src
<LI><a href="#[4f9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip4_input
<LI><a href="#[a6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pppos_input_callback
<LI><a href="#[62f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_input
<LI><a href="#[6a6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_create_segment
<LI><a href="#[6b6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_receive
<LI><a href="#[6c3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_sendto_if_src
</UL>

<P><STRONG><a name="[4fd]"></a>pbuf_header_force</STRONG> (Thumb, 18 bytes, Stack size 16 bytes, .\build\lwip_pbuf.o(i.pbuf_header_force))
<BR><BR>[Stack]<UL><LI>Max Depth = 36<LI>Call Chain = pbuf_header_force &rArr; pbuf_header_impl
</UL>
<BR>[Calls]<UL><LI><a href="#[624]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_header_impl
</UL>
<BR>[Called By]<UL><LI><a href="#[4fb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_input
<LI><a href="#[4f9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip4_input
</UL>

<P><STRONG><a name="[492]"></a>pbuf_put_at</STRONG> (Thumb, 42 bytes, Stack size 24 bytes, .\build\lwip_pbuf.o(i.pbuf_put_at))
<BR><BR>[Stack]<UL><LI>Max Depth = 60<LI>Call Chain = pbuf_put_at &rArr; pbuf_skip &rArr; pbuf_skip_const
</UL>
<BR>[Calls]<UL><LI><a href="#[625]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_skip
</UL>
<BR>[Called By]<UL><LI><a href="#[484]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dns_send
</UL>

<P><STRONG><a name="[46e]"></a>pbuf_realloc</STRONG> (Thumb, 108 bytes, Stack size 24 bytes, .\build\lwip_pbuf.o(i.pbuf_realloc))
<BR><BR>[Stack]<UL><LI>Max Depth = 560 + Unknown Stack Size
<LI>Call Chain = pbuf_realloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[46b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_free
<LI><a href="#[597]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mem_trim
</UL>
<BR>[Called By]<UL><LI><a href="#[466]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;chap_respond
<LI><a href="#[4f9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip4_input
<LI><a href="#[416]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pppos_input
<LI><a href="#[6b6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_receive
</UL>

<P><STRONG><a name="[4f7]"></a>pbuf_ref</STRONG> (Thumb, 30 bytes, Stack size 16 bytes, .\build\lwip_pbuf.o(i.pbuf_ref))
<BR><BR>[Stack]<UL><LI>Max Depth = 480 + Unknown Stack Size
<LI>Call Chain = pbuf_ref &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[497]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_unprotect
<LI><a href="#[496]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_protect
</UL>
<BR>[Called By]<UL><LI><a href="#[4f3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip4_frag
<LI><a href="#[623]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_chain
</UL>

<P><STRONG><a name="[625]"></a>pbuf_skip</STRONG> (Thumb, 28 bytes, Stack size 24 bytes, .\build\lwip_pbuf.o(i.pbuf_skip))
<BR><BR>[Stack]<UL><LI>Max Depth = 36<LI>Call Chain = pbuf_skip &rArr; pbuf_skip_const
</UL>
<BR>[Calls]<UL><LI><a href="#[626]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_skip_const
</UL>
<BR>[Called By]<UL><LI><a href="#[493]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_take_at
<LI><a href="#[492]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_put_at
</UL>

<P><STRONG><a name="[491]"></a>pbuf_take</STRONG> (Thumb, 130 bytes, Stack size 32 bytes, .\build\lwip_pbuf.o(i.pbuf_take))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = pbuf_take
</UL>
<BR>[Calls]<UL><LI><a href="#[249]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Called By]<UL><LI><a href="#[493]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_take_at
<LI><a href="#[484]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dns_send
</UL>

<P><STRONG><a name="[493]"></a>pbuf_take_at</STRONG> (Thumb, 118 bytes, Stack size 40 bytes, .\build\lwip_pbuf.o(i.pbuf_take_at))
<BR><BR>[Stack]<UL><LI>Max Depth = 76<LI>Call Chain = pbuf_take_at &rArr; pbuf_skip &rArr; pbuf_skip_const
</UL>
<BR>[Calls]<UL><LI><a href="#[491]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_take
<LI><a href="#[625]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_skip
<LI><a href="#[249]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Called By]<UL><LI><a href="#[484]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dns_send
</UL>

<P><STRONG><a name="[486]"></a>pbuf_try_get_at</STRONG> (Thumb, 46 bytes, Stack size 24 bytes, .\build\lwip_pbuf.o(i.pbuf_try_get_at))
<BR><BR>[Stack]<UL><LI>Max Depth = 36<LI>Call Chain = pbuf_try_get_at &rArr; pbuf_skip_const
</UL>
<BR>[Calls]<UL><LI><a href="#[626]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_skip_const
</UL>
<BR>[Called By]<UL><LI><a href="#[48f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dns_skip_name
<LI><a href="#[485]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dns_compare_name
</UL>

<P><STRONG><a name="[628]"></a>pin_location</STRONG> (Thumb, 42 bytes, Stack size 16 bytes, .\build\pinmap_function.o(i.pin_location))
<BR><BR>[Stack]<UL><LI>Max Depth = 16 + In Cycle
<LI>Call Chain = pin_location &rArr;  error (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[3e6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;error
<LI><a href="#[629]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pinmap_get_function_field
</UL>
<BR>[Called By]<UL><LI><a href="#[654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_preinit
</UL>

<P><STRONG><a name="[4cb]"></a>pin_mode</STRONG> (Thumb, 106 bytes, Stack size 32 bytes, .\build\pinmap.o(i.pin_mode))
<BR><BR>[Stack]<UL><LI>Max Depth = 560 + Unknown Stack Size
<LI>Call Chain = pin_mode &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[33a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_assert_internal
<LI><a href="#[28b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CMU_ClockEnable
<LI><a href="#[2ad]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GPIO_PinModeSet
</UL>
<BR>[Called By]<UL><LI><a href="#[447]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;gpio_mode
<LI><a href="#[64e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_enable_pins
</UL>

<P><STRONG><a name="[62c]"></a>pinmap_find_peripheral</STRONG> (Thumb, 28 bytes, Stack size 0 bytes, .\build\mbed_pinmap_common.o(i.pinmap_find_peripheral))
<BR><BR>[Called By]<UL><LI><a href="#[62b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pinmap_peripheral
</UL>

<P><STRONG><a name="[629]"></a>pinmap_get_function_field</STRONG> (Thumb, 28 bytes, Stack size 0 bytes, .\build\pinmap_function.o(i.pinmap_get_function_field))
<BR><BR>[Called By]<UL><LI><a href="#[628]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pin_location
</UL>

<P><STRONG><a name="[62a]"></a>pinmap_merge</STRONG> (Thumb, 42 bytes, Stack size 16 bytes, .\build\mbed_pinmap_common.o(i.pinmap_merge))
<BR><BR>[Stack]<UL><LI>Max Depth = 16 + In Cycle
<LI>Call Chain = pinmap_merge &rArr;  error (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[3e6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;error
</UL>
<BR>[Called By]<UL><LI><a href="#[654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_preinit
</UL>

<P><STRONG><a name="[62b]"></a>pinmap_peripheral</STRONG> (Thumb, 44 bytes, Stack size 16 bytes, .\build\mbed_pinmap_common.o(i.pinmap_peripheral))
<BR><BR>[Stack]<UL><LI>Max Depth = 16 + In Cycle
<LI>Call Chain = pinmap_peripheral &rArr;  error (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[3e6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;error
<LI><a href="#[62c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pinmap_find_peripheral
</UL>
<BR>[Called By]<UL><LI><a href="#[654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_preinit
</UL>

<P><STRONG><a name="[3a6]"></a>ppp_close</STRONG> (Thumb, 136 bytes, Stack size 16 bytes, .\build\lwip_ppp.o(i.ppp_close))
<BR><BR>[Stack]<UL><LI>Max Depth = 712 + Unknown Stack Size
<LI>Call Chain = ppp_close &rArr; lcp_close &rArr; fsm_close &rArr; terminate_layer &rArr; fsm_sdata &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[539]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_link_terminated
<LI><a href="#[523]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;new_phase
<LI><a href="#[f2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lcp_lowerdown
<LI><a href="#[f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lcp_close
<LI><a href="#[52b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;link_terminated
<LI><a href="#[2bf]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_untimeout
</UL>
<BR>[Called By]<UL><LI><a href="#[579]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_lwip_disconnect
<LI><a href="#[3a5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::handle_modem_hangup()
</UL>

<P><STRONG><a name="[62d]"></a>ppp_connect</STRONG> (Thumb, 58 bytes, Stack size 16 bytes, .\build\lwip_ppp.o(i.ppp_connect))
<BR><BR>[Stack]<UL><LI>Max Depth = 624 + Unknown Stack Size
<LI>Call Chain = ppp_connect &rArr; sys_timeout &rArr; sys_now &rArr; us_ticker_read &rArr; us_ticker_init &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[523]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;new_phase
<LI><a href="#[2c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_timeout
<LI><a href="#[a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_do_connect
</UL>
<BR>[Called By]<UL><LI><a href="#[577]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_lwip_connect
</UL>

<P><STRONG><a name="[52d]"></a>ppp_dbglog</STRONG> (Thumb, 28 bytes, Stack size 24 bytes, .\build\lwip_utils.o(i.ppp_dbglog))
<BR><BR>[Stack]<UL><LI>Max Depth = 488<LI>Call Chain = ppp_dbglog &rArr; ppp_logit &rArr; ppp_vslprintf &rArr; ppp_slprintf &rArr;  ppp_vslprintf (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[62e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_logit
</UL>
<BR>[Called By]<UL><LI><a href="#[529]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lcp_rprotrej
<LI><a href="#[e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lcp_reqci
<LI><a href="#[52a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lcp_received_echo_reply
<LI><a href="#[62f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_input
</UL>

<P><STRONG><a name="[463]"></a>ppp_error</STRONG> (Thumb, 28 bytes, Stack size 24 bytes, .\build\lwip_utils.o(i.ppp_error))
<BR><BR>[Stack]<UL><LI>Max Depth = 488<LI>Call Chain = ppp_error &rArr; ppp_logit &rArr; ppp_vslprintf &rArr; ppp_slprintf &rArr;  ppp_vslprintf (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[62e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_logit
</UL>
<BR>[Called By]<UL><LI><a href="#[ce]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;chap_protrej
<LI><a href="#[465]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;chap_handle_status
<LI><a href="#[462]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;chap_auth_with_peer
<LI><a href="#[46d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;get_secret
<LI><a href="#[4c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fsm_rconfnakrej
<LI><a href="#[4bf]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fsm_rconfack
<LI><a href="#[f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lcp_protrej
<LI><a href="#[e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lcp_addci
<LI><a href="#[d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ipcp_up
</UL>

<P><STRONG><a name="[464]"></a>ppp_fatal</STRONG> (Thumb, 28 bytes, Stack size 24 bytes, .\build\lwip_utils.o(i.ppp_fatal))
<BR><BR>[Stack]<UL><LI>Max Depth = 488<LI>Call Chain = ppp_fatal &rArr; ppp_logit &rArr; ppp_vslprintf &rArr; ppp_slprintf &rArr;  ppp_vslprintf (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[62e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_logit
</UL>
<BR>[Called By]<UL><LI><a href="#[462]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;chap_auth_with_peer
</UL>

<P><STRONG><a name="[2c2]"></a>ppp_info</STRONG> (Thumb, 28 bytes, Stack size 24 bytes, .\build\lwip_utils.o(i.ppp_info))
<BR><BR>[Stack]<UL><LI>Max Depth = 488<LI>Call Chain = ppp_info &rArr; ppp_logit &rArr; ppp_vslprintf &rArr; ppp_slprintf &rArr;  ppp_vslprintf (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[62e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_logit
</UL>
<BR>[Called By]<UL><LI><a href="#[465]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;chap_handle_status
<LI><a href="#[4c1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fsm_rtermreq
<LI><a href="#[2c1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LcpLinkFailure
</UL>

<P><STRONG><a name="[54c]"></a>ppp_init</STRONG> (Thumb, 22 bytes, Stack size 8 bytes, .\build\lwip_ppp.o(i.ppp_init))
<BR><BR>[Stack]<UL><LI>Max Depth = 704 + Unknown Stack Size
<LI>Call Chain = ppp_init &rArr; magic_init &rArr; magic_churnrand &rArr; sys_jiffies &rArr; us_ticker_read &rArr; us_ticker_init &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[599]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memp_init_pool
<LI><a href="#[568]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;magic_init
</UL>
<BR>[Called By]<UL><LI><a href="#[543]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_init
</UL>

<P><STRONG><a name="[62f]"></a>ppp_input</STRONG> (Thumb, 202 bytes, Stack size 24 bytes, .\build\lwip_ppp.o(i.ppp_input))
<BR><BR>[Stack]<UL><LI>Max Depth = 1200 + Unknown Stack Size
<LI>Call Chain = ppp_input &rArr; ip4_input &rArr; tcp_input &rArr; tcp_listen_input &rArr; tcp_alloc &rArr; tcp_kill_prio &rArr; tcp_abort &rArr; tcp_abandon &rArr; tcp_pcb_remove &rArr; tcp_output &rArr; tcp_output_segment &rArr; ip4_output_if &rArr; ip4_output_if_opt &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[4d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_header
<LI><a href="#[46b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_free
<LI><a href="#[4f9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip4_input
<LI><a href="#[569]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;magic_randomize
<LI><a href="#[52d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_dbglog
<LI><a href="#[52e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lcp_sprotrej
<LI><a href="#[630]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_singlebuf
</UL>
<BR>[Called By]<UL><LI><a href="#[a6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pppos_input_callback
</UL>

<P><STRONG><a name="[631]"></a>ppp_link_end</STRONG> (Thumb, 38 bytes, Stack size 8 bytes, .\build\lwip_ppp.o(i.ppp_link_end))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = ppp_link_end
</UL>
<BR>[Calls]<UL><LI><a href="#[523]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;new_phase
</UL>
<BR>[Called By]<UL><LI><a href="#[f6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pppos_disconnect
</UL>

<P><STRONG><a name="[539]"></a>ppp_link_terminated</STRONG> (Thumb, 16 bytes, Stack size 8 bytes, .\build\lwip_ppp.o(i.ppp_link_terminated))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = ppp_link_terminated
</UL>
<BR>[Called By]<UL><LI><a href="#[52b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;link_terminated
<LI><a href="#[3a6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_close
</UL>

<P><STRONG><a name="[577]"></a>ppp_lwip_connect</STRONG> (Thumb, 82 bytes, Stack size 32 bytes, .\build\ppp_lwip.o(i.ppp_lwip_connect))
<BR><BR>[Stack]<UL><LI>Max Depth = 656 + Unknown Stack Size
<LI>Call Chain = ppp_lwip_connect &rArr; ppp_connect &rArr; sys_timeout &rArr; sys_now &rArr; us_ticker_read &rArr; us_ticker_init &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[53]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void()&rang;::~Callback()
<LI><a href="#[634]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_set_auth
<LI><a href="#[62d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_connect
<LI><a href="#[417]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;T1()&rang; mbed::callback&lang;void&rang;(T1(*)())
</UL>
<BR>[Called By]<UL><LI><a href="#[392]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_bringup_2
</UL>

<P><STRONG><a name="[579]"></a>ppp_lwip_disconnect</STRONG> (Thumb, 86 bytes, Stack size 32 bytes, .\build\ppp_lwip.o(i.ppp_lwip_disconnect))
<BR><BR>[Stack]<UL><LI>Max Depth = 744 + Unknown Stack Size
<LI>Call Chain = ppp_lwip_disconnect &rArr; ppp_close &rArr; lcp_close &rArr; fsm_close &rArr; terminate_layer &rArr; fsm_sdata &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[53]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void()&rang;::~Callback()
<LI><a href="#[282]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void()&rang;::Callback(void(*)())
<LI><a href="#[553]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_sem_wait
<LI><a href="#[3a6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_close
</UL>
<BR>[Called By]<UL><LI><a href="#[392]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_bringup_2
</UL>

<P><STRONG><a name="[572]"></a>ppp_lwip_if_init</STRONG> (Thumb, 84 bytes, Stack size 16 bytes, .\build\ppp_lwip.o(i.ppp_lwip_if_init))
<BR><BR>[Stack]<UL><LI>Max Depth = 1232 + Unknown Stack Size
<LI>Call Chain = ppp_lwip_if_init &rArr; pppos_create &rArr; ppp_new &rArr; netif_add &rArr; netif_set_addr &rArr; netif_set_ipaddr &rArr; tcp_netif_ip_addr_changed &rArr; tcp_netif_ip_addr_changed_pcblist &rArr; tcp_abort &rArr; tcp_abandon &rArr; tcp_pcb_remove &rArr; tcp_output &rArr; tcp_output_segment &rArr; ip4_output_if &rArr; ip4_output_if_opt &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[57b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_sem_new
<LI><a href="#[635]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pppos_create
<LI><a href="#[3a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::prepare_event_queue()
</UL>
<BR>[Called By]<UL><LI><a href="#[392]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_bringup_2
</UL>

<P><STRONG><a name="[637]"></a>ppp_new</STRONG> (Thumb, 172 bytes, Stack size 48 bytes, .\build\lwip_ppp.o(i.ppp_new))
<BR><BR>[Stack]<UL><LI>Max Depth = 1184 + Unknown Stack Size
<LI>Call Chain = ppp_new &rArr; netif_add &rArr; netif_set_addr &rArr; netif_set_ipaddr &rArr; tcp_netif_ip_addr_changed &rArr; tcp_netif_ip_addr_changed_pcblist &rArr; tcp_abort &rArr; tcp_abandon &rArr; tcp_pcb_remove &rArr; tcp_output &rArr; tcp_output_segment &rArr; ip4_output_if &rArr; ip4_output_if_opt &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[523]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;new_phase
<LI><a href="#[59a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memp_malloc_pool
<LI><a href="#[598]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memp_free_pool
<LI><a href="#[5a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netif_add
<LI><a href="#[23c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memclr4
</UL>
<BR>[Called By]<UL><LI><a href="#[635]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pppos_create
</UL>

<P><STRONG><a name="[2c3]"></a>ppp_notice</STRONG> (Thumb, 28 bytes, Stack size 24 bytes, .\build\lwip_utils.o(i.ppp_notice))
<BR><BR>[Stack]<UL><LI>Max Depth = 488<LI>Call Chain = ppp_notice &rArr; ppp_logit &rArr; ppp_vslprintf &rArr; ppp_slprintf &rArr;  ppp_vslprintf (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[62e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_logit
</UL>
<BR>[Called By]<UL><LI><a href="#[52b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;link_terminated
<LI><a href="#[45f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;auth_withpeer_success
<LI><a href="#[e6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lcp_nakci
<LI><a href="#[2c1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LcpLinkFailure
<LI><a href="#[d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ipcp_up
</UL>

<P><STRONG><a name="[527]"></a>ppp_recv_config</STRONG> (Thumb, 44 bytes, Stack size 32 bytes, .\build\lwip_ppp.o(i.ppp_recv_config))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = ppp_recv_config
</UL>
<BR>[Called By]<UL><LI><a href="#[e9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lcp_up
<LI><a href="#[ea]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lcp_down
<LI><a href="#[f1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lcp_lowerup
</UL>

<P><STRONG><a name="[526]"></a>ppp_send_config</STRONG> (Thumb, 44 bytes, Stack size 32 bytes, .\build\lwip_ppp.o(i.ppp_send_config))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = ppp_send_config
</UL>
<BR>[Called By]<UL><LI><a href="#[e9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lcp_up
<LI><a href="#[ea]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lcp_down
<LI><a href="#[f1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lcp_lowerup
</UL>

<P><STRONG><a name="[634]"></a>ppp_set_auth</STRONG> (Thumb, 22 bytes, Stack size 12 bytes, .\build\lwip_ppp.o(i.ppp_set_auth))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = ppp_set_auth
</UL>
<BR>[Called By]<UL><LI><a href="#[577]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_lwip_connect
</UL>

<P><STRONG><a name="[630]"></a>ppp_singlebuf</STRONG> (Thumb, 74 bytes, Stack size 24 bytes, .\build\lwip_ppp.o(i.ppp_singlebuf))
<BR><BR>[Stack]<UL><LI>Max Depth = 600 + Unknown Stack Size
<LI>Call Chain = ppp_singlebuf &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[46a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_alloc
<LI><a href="#[46b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_free
<LI><a href="#[249]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Called By]<UL><LI><a href="#[62f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_input
</UL>

<P><STRONG><a name="[46c]"></a>ppp_slprintf</STRONG> (Thumb, 38 bytes, Stack size 40 bytes, .\build\lwip_utils.o(i.ppp_slprintf))
<BR><BR>[Stack]<UL><LI>Max Depth = 40 + In Cycle
<LI>Call Chain = ppp_slprintf &rArr;  ppp_vslprintf (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[632]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_vslprintf
</UL>
<BR>[Called By]<UL><LI><a href="#[466]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;chap_respond
<LI><a href="#[632]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_vslprintf
</UL>

<P><STRONG><a name="[638]"></a>ppp_start</STRONG> (Thumb, 26 bytes, Stack size 8 bytes, .\build\lwip_ppp.o(i.ppp_start))
<BR><BR>[Stack]<UL><LI>Max Depth = 680 + Unknown Stack Size
<LI>Call Chain = ppp_start &rArr; lcp_open &rArr; fsm_open &rArr; fsm_lowerup &rArr; fsm_sconfreq &rArr; sys_timeout &rArr; sys_now &rArr; us_ticker_read &rArr; us_ticker_init &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[523]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;new_phase
<LI><a href="#[f3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lcp_open
<LI><a href="#[f1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lcp_lowerup
</UL>
<BR>[Called By]<UL><LI><a href="#[f5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pppos_connect
</UL>

<P><STRONG><a name="[632]"></a>ppp_vslprintf</STRONG> (Thumb, 1422 bytes, Stack size 144 bytes, .\build\lwip_utils.o(i.ppp_vslprintf))
<BR><BR>[Stack]<UL><LI>Max Depth = 184<LI>Call Chain = ppp_vslprintf &rArr; ppp_slprintf &rArr;  ppp_vslprintf (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[490]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_htonl
<LI><a href="#[46c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_slprintf
<LI><a href="#[249]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
<LI><a href="#[31d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;strlen
<LI><a href="#[217]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_ctype_table
</UL>
<BR>[Called By]<UL><LI><a href="#[46c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_slprintf
<LI><a href="#[62e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_logit
</UL>

<P><STRONG><a name="[2be]"></a>ppp_warn</STRONG> (Thumb, 28 bytes, Stack size 24 bytes, .\build\lwip_utils.o(i.ppp_warn))
<BR><BR>[Stack]<UL><LI>Max Depth = 488<LI>Call Chain = ppp_warn &rArr; ppp_logit &rArr; ppp_vslprintf &rArr; ppp_slprintf &rArr;  ppp_vslprintf (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[62e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_logit
</UL>
<BR>[Called By]<UL><LI><a href="#[466]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;chap_respond
<LI><a href="#[45f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;auth_withpeer_success
<LI><a href="#[66]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fsm_timeout
<LI><a href="#[4c3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fsm_rcoderej
<LI><a href="#[529]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lcp_rprotrej
<LI><a href="#[52a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lcp_received_echo_reply
<LI><a href="#[2bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LcpEchoCheck
<LI><a href="#[d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ipcp_up
</UL>

<P><STRONG><a name="[46f]"></a>ppp_write</STRONG> (Thumb, 20 bytes, Stack size 16 bytes, .\build\lwip_ppp.o(i.ppp_write))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = ppp_write
</UL>
<BR>[Called By]<UL><LI><a href="#[466]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;chap_respond
<LI><a href="#[2c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fsm_sdata
<LI><a href="#[4c6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fsm_sconfreq
</UL>

<P><STRONG><a name="[635]"></a>pppos_create</STRONG> (Thumb, 76 bytes, Stack size 32 bytes, .\build\lwip_pppos.o(i.pppos_create))
<BR><BR>[Stack]<UL><LI>Max Depth = 1216 + Unknown Stack Size
<LI>Call Chain = pppos_create &rArr; ppp_new &rArr; netif_add &rArr; netif_set_addr &rArr; netif_set_ipaddr &rArr; tcp_netif_ip_addr_changed &rArr; tcp_netif_ip_addr_changed_pcblist &rArr; tcp_abort &rArr; tcp_abandon &rArr; tcp_pcb_remove &rArr; tcp_output &rArr; tcp_output_segment &rArr; ip4_output_if &rArr; ip4_output_if_opt &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[59a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memp_malloc_pool
<LI><a href="#[598]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memp_free_pool
<LI><a href="#[637]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_new
<LI><a href="#[23c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memclr4
</UL>
<BR>[Called By]<UL><LI><a href="#[572]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_lwip_if_init
</UL>

<P><STRONG><a name="[416]"></a>pppos_input</STRONG> (Thumb, 592 bytes, Stack size 40 bytes, .\build\lwip_pppos.o(i.pppos_input))
<BR><BR>[Stack]<UL><LI>Max Depth = 616 + Unknown Stack Size
<LI>Call Chain = pppos_input &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[46e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_realloc
<LI><a href="#[46a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_alloc
<LI><a href="#[46b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_free
<LI><a href="#[5a1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcpip_callback_with_block
<LI><a href="#[497]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_unprotect
<LI><a href="#[496]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_protect
<LI><a href="#[4f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_cat
<LI><a href="#[63a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pppos_input_drop
</UL>
<BR>[Called By]<UL><LI><a href="#[55]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ppp_input()
</UL>

<P><STRONG><a name="[75]"></a>pre_main</STRONG> (Thumb, 62 bytes, Stack size 24 bytes, .\build\mbed_boot.o(i.pre_main))
<BR><BR>[Stack]<UL><LI>Max Depth = 888 + Unknown Stack Size
<LI>Call Chain = pre_main &rArr; main &rArr; $Super$$main &rArr; test_send_recv() &rArr; TCPSocket::TCPSocket() &rArr; Socket::Socket__sub_object() &rArr; rtos::Mutex::Mutex() &rArr; rtos::Mutex::constructor(const char*) &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[423]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osMutexNew
<LI><a href="#[27f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;main
<LI><a href="#[63d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init
</UL>
<BR>[Address Reference Count : 1]<UL><LI> mbed_boot.o(i.mbed_start_main)
</UL>
<P><STRONG><a name="[56c]"></a>print_context_info</STRONG> (Thumb, 240 bytes, Stack size 32 bytes, .\build\mbed_rtx_fault_handler.o(i.print_context_info))
<BR><BR>[Stack]<UL><LI>Max Depth = 104<LI>Call Chain = print_context_info &rArr; fault_print_str &rArr; serial_putc &rArr; LEUART_Tx
</UL>
<BR>[Calls]<UL><LI><a href="#[4b5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fault_print_str
<LI><a href="#[23c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memclr4
</UL>
<BR>[Called By]<UL><LI><a href="#[42]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_fault_handler
</UL>

<P><STRONG><a name="[56d]"></a>print_thread</STRONG> (Thumb, 38 bytes, Stack size 32 bytes, .\build\mbed_rtx_fault_handler.o(i.print_thread))
<BR><BR>[Stack]<UL><LI>Max Depth = 104<LI>Call Chain = print_thread &rArr; fault_print_str &rArr; serial_putc &rArr; LEUART_Tx
</UL>
<BR>[Calls]<UL><LI><a href="#[4b5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fault_print_str
</UL>
<BR>[Called By]<UL><LI><a href="#[42]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_fault_handler
<LI><a href="#[56e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;print_threads_info
</UL>

<P><STRONG><a name="[56e]"></a>print_threads_info</STRONG> (Thumb, 20 bytes, Stack size 8 bytes, .\build\mbed_rtx_fault_handler.o(i.print_threads_info))
<BR><BR>[Stack]<UL><LI>Max Depth = 112<LI>Call Chain = print_threads_info &rArr; print_thread &rArr; fault_print_str &rArr; serial_putc &rArr; LEUART_Tx
</UL>
<BR>[Calls]<UL><LI><a href="#[56d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;print_thread
</UL>
<BR>[Called By]<UL><LI><a href="#[42]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_fault_handler
</UL>

<P><STRONG><a name="[63e]"></a>randLIB_add_seed</STRONG> (Thumb, 86 bytes, Stack size 16 bytes, .\build\randlib.o(i.randLIB_add_seed))
<BR><BR>[Stack]<UL><LI>Max Depth = 36<LI>Call Chain = randLIB_add_seed &rArr; splitmix64
</UL>
<BR>[Calls]<UL><LI><a href="#[63f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;splitmix64
</UL>
<BR>[Called By]<UL><LI><a href="#[564]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;randLIB_seed_random
</UL>

<P><STRONG><a name="[540]"></a>randLIB_get_32bit</STRONG> (Thumb, 12 bytes, Stack size 8 bytes, .\build\randlib.o(i.randLIB_get_32bit))
<BR><BR>[Stack]<UL><LI>Max Depth = 72<LI>Call Chain = randLIB_get_32bit &rArr; randLIB_get_64bit &rArr; rol
</UL>
<BR>[Calls]<UL><LI><a href="#[640]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;randLIB_get_64bit
</UL>
<BR>[Called By]<UL><LI><a href="#[47c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_get_random
</UL>

<P><STRONG><a name="[640]"></a>randLIB_get_64bit</STRONG> (Thumb, 80 bytes, Stack size 32 bytes, .\build\randlib.o(i.randLIB_get_64bit))
<BR><BR>[Stack]<UL><LI>Max Depth = 64<LI>Call Chain = randLIB_get_64bit &rArr; rol
</UL>
<BR>[Calls]<UL><LI><a href="#[641]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rol
</UL>
<BR>[Called By]<UL><LI><a href="#[540]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;randLIB_get_32bit
</UL>

<P><STRONG><a name="[564]"></a>randLIB_seed_random</STRONG> (Thumb, 98 bytes, Stack size 16 bytes, .\build\randlib.o(i.randLIB_seed_random))
<BR><BR>[Stack]<UL><LI>Max Depth = 52<LI>Call Chain = randLIB_seed_random &rArr; randLIB_add_seed &rArr; splitmix64
</UL>
<BR>[Calls]<UL><LI><a href="#[643]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;arm_random_seed_get
<LI><a href="#[642]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;arm_random_module_init
<LI><a href="#[63e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;randLIB_add_seed
</UL>
<BR>[Called By]<UL><LI><a href="#[563]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_seed_random
</UL>

<P><STRONG><a name="[53a]"></a>rtc_enable_comp0</STRONG> (Thumb, 42 bytes, Stack size 8 bytes, .\build\rtc_api.o(i.rtc_enable_comp0))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = rtc_enable_comp0
</UL>
<BR>[Calls]<UL><LI><a href="#[645]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RTC_FreezeEnable
<LI><a href="#[646]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RTC_IntEnable
</UL>
<BR>[Called By]<UL><LI><a href="#[110]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lp_ticker_disable_interrupt
<LI><a href="#[53f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtc_set_comp0_value
</UL>

<P><STRONG><a name="[53b]"></a>rtc_force_comp0</STRONG> (Thumb, 16 bytes, Stack size 0 bytes, .\build\rtc_api.o(i.rtc_force_comp0))
<BR><BR>[Called By]<UL><LI><a href="#[113]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lp_ticker_fire_interrupt
</UL>

<P><STRONG><a name="[53e]"></a>rtc_get_full</STRONG> (Thumb, 92 bytes, Stack size 16 bytes, .\build\rtc_api.o(i.rtc_get_full))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = rtc_get_full
</UL>
<BR>[Calls]<UL><LI><a href="#[2cf]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RTC_IntClear
</UL>
<BR>[Called By]<UL><LI><a href="#[112]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lp_ticker_set_interrupt
<LI><a href="#[10f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lp_ticker_read
</UL>

<P><STRONG><a name="[53c]"></a>rtc_init_real</STRONG> (Thumb, 132 bytes, Stack size 16 bytes, .\build\rtc_api.o(i.rtc_init_real))
<BR><BR>[Stack]<UL><LI>Max Depth = 104<LI>Call Chain = rtc_init_real &rArr; CMU_ClockEnable &rArr; CMU_ClockFreqGet &rArr; lfClkGet &rArr; getHfLeConfig &rArr; BUS_RegBitRead
</UL>
<BR>[Calls]<UL><LI><a href="#[28b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CMU_ClockEnable
<LI><a href="#[283]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CMU_ClockDivSet
<LI><a href="#[647]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RTC_Init
<LI><a href="#[646]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RTC_IntEnable
</UL>
<BR>[Called By]<UL><LI><a href="#[10e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lp_ticker_init
</UL>

<P><STRONG><a name="[53d]"></a>rtc_set_comp0_handler</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, .\build\rtc_api.o(i.rtc_set_comp0_handler))
<BR><BR>[Called By]<UL><LI><a href="#[10e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lp_ticker_init
</UL>

<P><STRONG><a name="[53f]"></a>rtc_set_comp0_value</STRONG> (Thumb, 58 bytes, Stack size 16 bytes, .\build\rtc_api.o(i.rtc_set_comp0_value))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = rtc_set_comp0_value &rArr; rtc_enable_comp0
</UL>
<BR>[Calls]<UL><LI><a href="#[645]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RTC_FreezeEnable
<LI><a href="#[648]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RTC_CompareSet
<LI><a href="#[53a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtc_enable_comp0
</UL>
<BR>[Called By]<UL><LI><a href="#[112]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lp_ticker_set_interrupt
</UL>

<P><STRONG><a name="[5dc]"></a>rtos_idle_loop</STRONG> (Thumb, 10 bytes, Stack size 0 bytes, .\build\mbed_rtx_idle.o(i.rtos_idle_loop))
<BR><BR>[Called By]<UL><LI><a href="#[b5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxIdleThread
</UL>

<P><STRONG><a name="[50c]"></a>sdns</STRONG> (Thumb, 32 bytes, Stack size 24 bytes, .\build\lwip_ppp.o(i.sdns))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = sdns
</UL>
<BR>[Calls]<UL><LI><a href="#[45d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dns_setserver
</UL>
<BR>[Called By]<UL><LI><a href="#[d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ipcp_up
</UL>

<P><STRONG><a name="[328]"></a>serial_baud</STRONG> (Thumb, 46 bytes, Stack size 16 bytes, .\build\serial_api.o(i.serial_baud))
<BR><BR>[Stack]<UL><LI>Max Depth = 136<LI>Call Chain = serial_baud &rArr; serial_leuart_baud &rArr;  mbed_assert_internal (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[2db]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;USART_BaudrateAsyncSet
<LI><a href="#[64a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_leuart_baud
</UL>
<BR>[Called By]<UL><LI><a href="#[2f9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DirectSerial::DirectSerial(PinName, PinName, int)
<LI><a href="#[347]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::SerialBase::SerialBase(PinName, PinName, int)
<LI><a href="#[656]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;uart_init
</UL>

<P><STRONG><a name="[325]"></a>serial_getc</STRONG> (Thumb, 36 bytes, Stack size 8 bytes, .\build\serial_api.o(i.serial_getc))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = serial_getc
</UL>
<BR>[Calls]<UL><LI><a href="#[652]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LEUART_Rx
<LI><a href="#[653]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;USART_Rx
</UL>
<BR>[Called By]<UL><LI><a href="#[124]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DirectSerial::read(void*, unsigned)
<LI><a href="#[337]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::SerialBase::_base_getc()
</UL>

<P><STRONG><a name="[327]"></a>serial_init</STRONG> (Thumb, 186 bytes, Stack size 24 bytes, .\build\serial_api.o(i.serial_init))
<BR><BR>[Stack]<UL><LI>Max Depth = 208<LI>Call Chain = serial_init &rArr; uart_init &rArr; serial_baud &rArr; serial_leuart_baud &rArr;  mbed_assert_internal (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[28b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CMU_ClockEnable
<LI><a href="#[292]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CMU_ClockSelectSet
<LI><a href="#[656]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;uart_init
<LI><a href="#[657]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_set_route
<LI><a href="#[655]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_get_clock
<LI><a href="#[64e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_enable_pins
<LI><a href="#[64b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_enable
<LI><a href="#[654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_preinit
<LI><a href="#[247]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy4
</UL>
<BR>[Called By]<UL><LI><a href="#[4b1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_error_vfprintf
<LI><a href="#[4b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fault_print_init
<LI><a href="#[2f9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DirectSerial::DirectSerial(PinName, PinName, int)
<LI><a href="#[347]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::SerialBase::SerialBase(PinName, PinName, int)
</UL>

<P><STRONG><a name="[34b]"></a>serial_irq_handler</STRONG> (Thumb, 26 bytes, Stack size 16 bytes, .\build\serial_api.o(i.serial_irq_handler))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = serial_irq_handler &rArr; serial_get_index
</UL>
<BR>[Calls]<UL><LI><a href="#[64d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_get_index
</UL>
<BR>[Called By]<UL><LI><a href="#[347]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::SerialBase::SerialBase(PinName, PinName, int)
</UL>

<P><STRONG><a name="[33b]"></a>serial_irq_handler_asynch</STRONG> (Thumb, 260 bytes, Stack size 16 bytes, .\build\serial_api.o(i.serial_irq_handler_asynch))
<BR><BR>[Stack]<UL><LI>Max Depth = 528 + Unknown Stack Size
<LI>Call Chain = serial_irq_handler_asynch &rArr; serial_rx_irq_handler_asynch &rArr; serial_rx_abort_asynch_intern &rArr; serial_unblock_sleep &rArr; sleep_manager_unlock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[65a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_tx_abort_asynch_intern
<LI><a href="#[659]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_rx_abort_asynch_intern
<LI><a href="#[65e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;USART_StatusGet
<LI><a href="#[658]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;USART_IntGetEnabled
<LI><a href="#[65c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LEUART_StatusGet
<LI><a href="#[532]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LEUART_IntGetEnabled
<LI><a href="#[65d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_tx_irq_handler_asynch
<LI><a href="#[65b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_rx_irq_handler_asynch
</UL>
<BR>[Called By]<UL><LI><a href="#[11d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::SerialBase::interrupt_handler_asynch()
</UL>

<P><STRONG><a name="[342]"></a>serial_irq_set</STRONG> (Thumb, 324 bytes, Stack size 24 bytes, .\build\serial_api.o(i.serial_irq_set))
<BR><BR>[Stack]<UL><LI>Max Depth = 560 + Unknown Stack Size
<LI>Call Chain = serial_irq_set &rArr; serial_get_tx_irq_index &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[651]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_get_tx_irq_index
<LI><a href="#[650]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_get_rx_irq_index
<LI><a href="#[661]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__NVIC_SetPriority
<LI><a href="#[660]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__NVIC_EnableIRQ
<LI><a href="#[662]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__NVIC_DisableIRQ
<LI><a href="#[65f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__NVIC_ClearPendingIRQ
</UL>
<BR>[Called By]<UL><LI><a href="#[33f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::SerialBase::attach(mbed::Callback&lang;void()&rang;, mbed::SerialBase::IrqType)
</UL>

<P><STRONG><a name="[654]"></a>serial_preinit</STRONG> (Thumb, 328 bytes, Stack size 40 bytes, .\build\serial_api.o(i.serial_preinit))
<BR><BR>[Stack]<UL><LI>Max Depth = 56 + In Cycle
<LI>Call Chain = serial_preinit &rArr;  mbed_assert_internal (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[62b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pinmap_peripheral
<LI><a href="#[628]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pin_location
<LI><a href="#[33a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_assert_internal
<LI><a href="#[62a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pinmap_merge
<LI><a href="#[663]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__NVIC_SetVector
<LI><a href="#[661]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__NVIC_SetPriority
</UL>
<BR>[Called By]<UL><LI><a href="#[327]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_init
</UL>

<P><STRONG><a name="[326]"></a>serial_putc</STRONG> (Thumb, 70 bytes, Stack size 16 bytes, .\build\serial_api.o(i.serial_putc))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = serial_putc &rArr; LEUART_Tx
</UL>
<BR>[Calls]<UL><LI><a href="#[2bb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LEUART_Tx
<LI><a href="#[664]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;USART_Tx
</UL>
<BR>[Called By]<UL><LI><a href="#[4b1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_error_vfprintf
<LI><a href="#[4b5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fault_print_str
<LI><a href="#[125]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DirectSerial::write(const void*, unsigned)
<LI><a href="#[338]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::SerialBase::_base_putc(int)
</UL>

<P><STRONG><a name="[344]"></a>serial_readable</STRONG> (Thumb, 38 bytes, Stack size 0 bytes, .\build\serial_api.o(i.serial_readable))
<BR><BR>[Called By]<UL><LI><a href="#[12b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DirectSerial::poll(short) const
<LI><a href="#[343]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::SerialBase::readable()
</UL>

<P><STRONG><a name="[65b]"></a>serial_rx_irq_handler_asynch</STRONG> (Thumb, 648 bytes, Stack size 24 bytes, .\build\serial_api.o(i.serial_rx_irq_handler_asynch))
<BR><BR>[Stack]<UL><LI>Max Depth = 512 + Unknown Stack Size
<LI>Call Chain = serial_rx_irq_handler_asynch &rArr; serial_rx_abort_asynch_intern &rArr; serial_unblock_sleep &rArr; sleep_manager_unlock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[659]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_rx_abort_asynch_intern
<LI><a href="#[65e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;USART_StatusGet
<LI><a href="#[66c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;USART_RxDataGet
<LI><a href="#[658]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;USART_IntGetEnabled
<LI><a href="#[669]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;USART_IntClear
<LI><a href="#[65c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LEUART_StatusGet
<LI><a href="#[66b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LEUART_RxDataGet
<LI><a href="#[532]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LEUART_IntGetEnabled
<LI><a href="#[534]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LEUART_IntClear
</UL>
<BR>[Called By]<UL><LI><a href="#[33b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_irq_handler_asynch
</UL>

<P><STRONG><a name="[65d]"></a>serial_tx_irq_handler_asynch</STRONG> (Thumb, 252 bytes, Stack size 16 bytes, .\build\serial_api.o(i.serial_tx_irq_handler_asynch))
<BR><BR>[Stack]<UL><LI>Max Depth = 504 + Unknown Stack Size
<LI>Call Chain = serial_tx_irq_handler_asynch &rArr; serial_tx_abort_asynch_intern &rArr; serial_unblock_sleep &rArr; sleep_manager_unlock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[2bb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LEUART_Tx
<LI><a href="#[664]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;USART_Tx
<LI><a href="#[65a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_tx_abort_asynch_intern
<LI><a href="#[65e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;USART_StatusGet
<LI><a href="#[66e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;USART_IntEnable
<LI><a href="#[668]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;USART_IntDisable
<LI><a href="#[65c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LEUART_StatusGet
<LI><a href="#[66d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LEUART_IntEnable
<LI><a href="#[667]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LEUART_IntDisable
</UL>
<BR>[Called By]<UL><LI><a href="#[33b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_irq_handler_asynch
</UL>

<P><STRONG><a name="[346]"></a>serial_writable</STRONG> (Thumb, 38 bytes, Stack size 0 bytes, .\build\serial_api.o(i.serial_writable))
<BR><BR>[Called By]<UL><LI><a href="#[12b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DirectSerial::poll(short) const
<LI><a href="#[345]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::SerialBase::writeable()
</UL>

<P><STRONG><a name="[50e]"></a>sifaddr</STRONG> (Thumb, 32 bytes, Stack size 32 bytes, .\build\lwip_ppp.o(i.sifaddr))
<BR><BR>[Stack]<UL><LI>Max Depth = 1136 + Unknown Stack Size
<LI>Call Chain = sifaddr &rArr; netif_set_addr &rArr; netif_set_ipaddr &rArr; tcp_netif_ip_addr_changed &rArr; tcp_netif_ip_addr_changed_pcblist &rArr; tcp_abort &rArr; tcp_abandon &rArr; tcp_pcb_remove &rArr; tcp_output &rArr; tcp_output_segment &rArr; ip4_output_if &rArr; ip4_output_if_opt &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[471]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netif_set_addr
</UL>
<BR>[Called By]<UL><LI><a href="#[d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ipcp_up
</UL>

<P><STRONG><a name="[509]"></a>sifdown</STRONG> (Thumb, 22 bytes, Stack size 8 bytes, .\build\lwip_ppp.o(i.sifdown))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = sifdown &rArr; netif_set_link_down
</UL>
<BR>[Calls]<UL><LI><a href="#[66f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netif_set_link_down
</UL>
<BR>[Called By]<UL><LI><a href="#[d9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ipcp_down
</UL>

<P><STRONG><a name="[50f]"></a>sifup</STRONG> (Thumb, 44 bytes, Stack size 8 bytes, .\build\lwip_ppp.o(i.sifup))
<BR><BR>[Stack]<UL><LI>Max Depth = 160<LI>Call Chain = sifup &rArr; netif_set_link_up &rArr; netif_issue_reports &rArr; igmp_report_groups &rArr; igmp_delaying_member &rArr; igmp_start_timer &rArr; lwip_get_random &rArr; randLIB_get_32bit &rArr; randLIB_get_64bit &rArr; rol
</UL>
<BR>[Calls]<UL><LI><a href="#[5ab]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netif_set_link_up
</UL>
<BR>[Called By]<UL><LI><a href="#[d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ipcp_up
</UL>

<P><STRONG><a name="[671]"></a>sleep_manager_can_deep_sleep</STRONG> (Thumb, 14 bytes, Stack size 0 bytes, .\build\mbed_sleep_manager.o(i.sleep_manager_can_deep_sleep))
<BR><BR>[Called By]<UL><LI><a href="#[30e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sleep_manager_sleep_auto
</UL>

<P><STRONG><a name="[340]"></a>sleep_manager_lock_deep_sleep_internal</STRONG> (Thumb, 42 bytes, Stack size 8 bytes, .\build\mbed_sleep_manager.o(i.sleep_manager_lock_deep_sleep_internal))
<BR><BR>[Stack]<UL><LI>Max Depth = 464 + Unknown Stack Size
<LI>Call Chain = sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[3e6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;error
<LI><a href="#[311]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;core_util_critical_section_exit
<LI><a href="#[30c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;core_util_critical_section_enter
<LI><a href="#[670]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;core_util_atomic_incr_u16
</UL>
<BR>[Called By]<UL><LI><a href="#[309]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Ticker::attach_us(mbed::Callback&lang;void()&rang;, unsigned long long)
<LI><a href="#[308]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Timer::start()
<LI><a href="#[6ca]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;wait_us
<LI><a href="#[33f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::SerialBase::attach(mbed::Callback&lang;void()&rang;, mbed::SerialBase::IrqType)
</UL>

<P><STRONG><a name="[30e]"></a>sleep_manager_sleep_auto</STRONG> (Thumb, 28 bytes, Stack size 8 bytes, .\build\mbed_sleep_manager.o(i.sleep_manager_sleep_auto))
<BR><BR>[Stack]<UL><LI>Max Depth = 152<LI>Call Chain = sleep_manager_sleep_auto &rArr; hal_deepsleep &rArr; EMU_EnterEM2 &rArr; emState &rArr; CMU_ClockSelectSet &rArr; CMU_ClockFreqGet &rArr; lfClkGet &rArr; getHfLeConfig &rArr; BUS_RegBitRead
</UL>
<BR>[Calls]<UL><LI><a href="#[311]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;core_util_critical_section_exit
<LI><a href="#[30c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;core_util_critical_section_enter
<LI><a href="#[672]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hal_sleep
<LI><a href="#[4ce]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hal_deepsleep
<LI><a href="#[671]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sleep_manager_can_deep_sleep
</UL>
<BR>[Called By]<UL><LI><a href="#[f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;default_idle_hook()
</UL>

<P><STRONG><a name="[33e]"></a>sleep_manager_unlock_deep_sleep_internal</STRONG> (Thumb, 36 bytes, Stack size 8 bytes, .\build\mbed_sleep_manager.o(i.sleep_manager_unlock_deep_sleep_internal))
<BR><BR>[Stack]<UL><LI>Max Depth = 464 + Unknown Stack Size
<LI>Call Chain = sleep_manager_unlock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[3e6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;error
<LI><a href="#[311]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;core_util_critical_section_exit
<LI><a href="#[30c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;core_util_critical_section_enter
<LI><a href="#[673]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;core_util_atomic_decr_u16
</UL>
<BR>[Called By]<UL><LI><a href="#[3e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Ticker::detach()
<LI><a href="#[59]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Timer::~Timer()
<LI><a href="#[6ca]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;wait_us
<LI><a href="#[66a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_unblock_sleep
<LI><a href="#[33f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::SerialBase::attach(mbed::Callback&lang;void()&rang;, mbed::SerialBase::IrqType)
<LI><a href="#[11d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::SerialBase::interrupt_handler_asynch()
</UL>

<P><STRONG><a name="[5ac]"></a>start_networks</STRONG> (Thumb, 20 bytes, Stack size 8 bytes, .\build\lwip_auth.o(i.start_networks))
<BR><BR>[Stack]<UL><LI>Max Depth = 720 + Unknown Stack Size
<LI>Call Chain = start_networks &rArr; continue_networks &rArr; lcp_close &rArr; fsm_close &rArr; terminate_layer &rArr; fsm_sdata &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[523]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;new_phase
<LI><a href="#[473]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;continue_networks
</UL>
<BR>[Called By]<UL><LI><a href="#[460]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;network_phase
</UL>

<P><STRONG><a name="[81]"></a>svcRtxDelay</STRONG> (Thumb, 22 bytes, Stack size 8 bytes, .\build\rtx_delay.o(i.svcRtxDelay))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = svcRtxDelay &rArr; osRtxThreadWaitEnter &rArr; osRtxThreadSwitch &rArr; osRtxThreadStackCheck &rArr; osRtxErrorNotify &rArr;  error (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[60a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadWaitEnter
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rtx_delay.o(i.osDelay)
</UL>
<P><STRONG><a name="[82]"></a>svcRtxEventFlagsClear</STRONG> (Thumb, 84 bytes, Stack size 24 bytes, .\build\rtx_evflags.o(i.svcRtxEventFlagsClear))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = svcRtxEventFlagsClear &rArr; EventFlagsClear
</UL>
<BR>[Calls]<UL><LI><a href="#[2a1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EventFlagsClear
<LI><a href="#[512]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxEventFlagsError
<LI><a href="#[674]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxEventFlagsClearDone
</UL>
<BR>[Called By]<UL><LI><a href="#[5b1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osEventFlagsClear
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rtx_evflags.o(i.osEventFlagsClear)
</UL>
<P><STRONG><a name="[83]"></a>svcRtxEventFlagsDelete</STRONG> (Thumb, 140 bytes, Stack size 16 bytes, .\build\rtx_evflags.o(i.svcRtxEventFlagsDelete))
<BR><BR>[Stack]<UL><LI>Max Depth = 80<LI>Call Chain = svcRtxEventFlagsDelete &rArr; osRtxThreadWaitExit &rArr; osRtxThreadDispatch &rArr; osRtxThreadSwitch &rArr; osRtxThreadStackCheck &rArr; osRtxErrorNotify &rArr;  error (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[5db]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadWaitExit
<LI><a href="#[5ec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadListGet
<LI><a href="#[5f2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadDispatch
<LI><a href="#[5e6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxMemoryPoolFree
<LI><a href="#[5df]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxMemoryFree
<LI><a href="#[512]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxEventFlagsError
<LI><a href="#[675]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxEventFlagsDestroyed
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rtx_evflags.o(i.osEventFlagsDelete)
</UL>
<P><STRONG><a name="[84]"></a>svcRtxEventFlagsNew</STRONG> (Thumb, 160 bytes, Stack size 24 bytes, .\build\rtx_evflags.o(i.svcRtxEventFlagsNew))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = svcRtxEventFlagsNew &rArr; osRtxMemoryAlloc
</UL>
<BR>[Calls]<UL><LI><a href="#[51b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxMemoryPoolAlloc
<LI><a href="#[5dd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxMemoryAlloc
<LI><a href="#[512]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxEventFlagsError
<LI><a href="#[676]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxEventFlagsCreated
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rtx_evflags.o(i.osEventFlagsNew)
</UL>
<P><STRONG><a name="[85]"></a>svcRtxEventFlagsSet</STRONG> (Thumb, 170 bytes, Stack size 32 bytes, .\build\rtx_evflags.o(i.svcRtxEventFlagsSet))
<BR><BR>[Stack]<UL><LI>Max Depth = 96<LI>Call Chain = svcRtxEventFlagsSet &rArr; osRtxThreadWaitExit &rArr; osRtxThreadDispatch &rArr; osRtxThreadSwitch &rArr; osRtxThreadStackCheck &rArr; osRtxErrorNotify &rArr;  error (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[2a3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EventFlagsSet
<LI><a href="#[29e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EventFlagsCheck
<LI><a href="#[5db]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadWaitExit
<LI><a href="#[5da]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadListRemove
<LI><a href="#[5f2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadDispatch
<LI><a href="#[513]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxEventFlagsWaitCompleted
<LI><a href="#[5b9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxEventFlagsSetDone
<LI><a href="#[512]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxEventFlagsError
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rtx_evflags.o(i.osEventFlagsSet)
</UL>
<P><STRONG><a name="[86]"></a>svcRtxEventFlagsWait</STRONG> (Thumb, 184 bytes, Stack size 32 bytes, .\build\rtx_evflags.o(i.svcRtxEventFlagsWait))
<BR><BR>[Stack]<UL><LI>Max Depth = 72<LI>Call Chain = svcRtxEventFlagsWait &rArr; osRtxThreadWaitEnter &rArr; osRtxThreadSwitch &rArr; osRtxThreadStackCheck &rArr; osRtxErrorNotify &rArr;  error (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[29e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EventFlagsCheck
<LI><a href="#[60a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadWaitEnter
<LI><a href="#[606]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadListPut
<LI><a href="#[677]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxEventFlagsWaitPending
<LI><a href="#[514]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxEventFlagsWaitNotCompleted
<LI><a href="#[513]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxEventFlagsWaitCompleted
<LI><a href="#[512]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxEventFlagsError
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rtx_evflags.o(i.osEventFlagsWait)
</UL>
<P><STRONG><a name="[87]"></a>svcRtxKernelGetState</STRONG> (Thumb, 16 bytes, Stack size 8 bytes, .\build\rtx_kernel.o(i.svcRtxKernelGetState))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = svcRtxKernelGetState
</UL>
<BR>[Calls]<UL><LI><a href="#[5bf]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxKernelGetState
</UL>
<BR>[Called By]<UL><LI><a href="#[5bb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osKernelGetState
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rtx_kernel.o(i.osKernelGetState)
</UL>
<P><STRONG><a name="[88]"></a>svcRtxKernelInitialize</STRONG> (Thumb, 660 bytes, Stack size 8 bytes, .\build\rtx_kernel.o(i.svcRtxKernelInitialize))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = svcRtxKernelInitialize &rArr; osRtxMemoryPoolInit
</UL>
<BR>[Calls]<UL><LI><a href="#[5e9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxMemoryPoolInit
<LI><a href="#[5e1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxMemoryInit
<LI><a href="#[678]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxKernelInitializeCompleted
<LI><a href="#[5c2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxKernelError
<LI><a href="#[23c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memclr4
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rtx_kernel.o(i.osKernelInitialize)
</UL>
<P><STRONG><a name="[89]"></a>svcRtxKernelLock</STRONG> (Thumb, 58 bytes, Stack size 8 bytes, .\build\rtx_kernel.o(i.svcRtxKernelLock))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = svcRtxKernelLock
</UL>
<BR>[Calls]<UL><LI><a href="#[679]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxKernelLocked
<LI><a href="#[5c2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxKernelError
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rtx_kernel.o(i.osKernelLock)
</UL>
<P><STRONG><a name="[8a]"></a>svcRtxKernelRestoreLock</STRONG> (Thumb, 76 bytes, Stack size 8 bytes, .\build\rtx_kernel.o(i.svcRtxKernelRestoreLock))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = svcRtxKernelRestoreLock
</UL>
<BR>[Calls]<UL><LI><a href="#[67a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxKernelLockRestored
<LI><a href="#[5c2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxKernelError
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rtx_kernel.o(i.osKernelRestoreLock)
</UL>
<P><STRONG><a name="[310]"></a>svcRtxKernelResume</STRONG> (Thumb, 190 bytes, Stack size 24 bytes, .\build\rtx_kernel.o(i.svcRtxKernelResume))
<BR><BR>[Stack]<UL><LI>Max Depth = 272<LI>Call Chain = svcRtxKernelResume &rArr; KernelUnblock &rArr; OS_Tick_Enable &rArr; rtos::internal::SysTimer::SysTimer() &rArr; mbed::TimerEvent::TimerEvent__sub_object(const ticker_data_t*) &rArr; ticker_set_handler &rArr; initialize &rArr;  mbed_assert_internal (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[5f2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadDispatch
<LI><a href="#[5f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadDelayTick
<LI><a href="#[2b2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;KernelUnblock
<LI><a href="#[67b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxKernelResumed
</UL>
<BR>[Called By]<UL><LI><a href="#[f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;default_idle_hook()
</UL>

<P><STRONG><a name="[8b]"></a>svcRtxKernelStart</STRONG> (Thumb, 232 bytes, Stack size 8 bytes, .\build\rtx_kernel.o(i.svcRtxKernelStart))
<BR><BR>[Stack]<UL><LI>Max Depth = 248<LI>Call Chain = svcRtxKernelStart &rArr; OS_Tick_Enable &rArr; rtos::internal::SysTimer::SysTimer() &rArr; mbed::TimerEvent::TimerEvent__sub_object(const ticker_data_t*) &rArr; ticker_set_handler &rArr; initialize &rArr;  mbed_assert_internal (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[67c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OS_Tick_GetIRQn
<LI><a href="#[2b3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OS_Tick_Enable
<LI><a href="#[42b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OS_Tick_Setup
<LI><a href="#[5ec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadListGet
<LI><a href="#[99]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxThreadNew
<LI><a href="#[603]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadSwitch
<LI><a href="#[67d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxKernelStarted
<LI><a href="#[5c2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxKernelError
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rtx_kernel.o(i.osKernelStart)
</UL>
<P><STRONG><a name="[30d]"></a>svcRtxKernelSuspend</STRONG> (Thumb, 68 bytes, Stack size 16 bytes, .\build\rtx_kernel.o(i.svcRtxKernelSuspend))
<BR><BR>[Stack]<UL><LI>Max Depth = 200<LI>Call Chain = svcRtxKernelSuspend &rArr; KernelBlock &rArr; OS_Tick_Disable &rArr; rtos::internal::SysTimer::cancel_tick() &rArr; mbed::TimerEvent::remove() &rArr; ticker_remove_event &rArr; schedule_interrupt &rArr; update_present_time &rArr; __aeabi_uldivmod
</UL>
<BR>[Calls]<UL><LI><a href="#[2b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;KernelBlock
<LI><a href="#[67e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxKernelSuspended
<LI><a href="#[5c2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxKernelError
</UL>
<BR>[Called By]<UL><LI><a href="#[f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;default_idle_hook()
</UL>

<P><STRONG><a name="[8c]"></a>svcRtxMessageQueueGet</STRONG> (Thumb, 300 bytes, Stack size 40 bytes, .\build\rtx_msgqueue.o(i.svcRtxMessageQueueGet))
<BR><BR>[Stack]<UL><LI>Max Depth = 104<LI>Call Chain = svcRtxMessageQueueGet &rArr; osRtxThreadWaitExit &rArr; osRtxThreadDispatch &rArr; osRtxThreadSwitch &rArr; osRtxThreadStackCheck &rArr; osRtxErrorNotify &rArr;  error (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[60a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadWaitEnter
<LI><a href="#[5db]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadWaitExit
<LI><a href="#[606]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadListPut
<LI><a href="#[5ec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadListGet
<LI><a href="#[5e6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxMemoryPoolFree
<LI><a href="#[51b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxMemoryPoolAlloc
<LI><a href="#[5ed]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadRegPtr
<LI><a href="#[5eb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MessageQueueRemove
<LI><a href="#[2c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MessageQueuePut
<LI><a href="#[2c5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MessageQueueGet
<LI><a href="#[517]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxMessageQueueRetrieved
<LI><a href="#[519]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxMessageQueueNotRetrieved
<LI><a href="#[5ee]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxMessageQueueInserted
<LI><a href="#[67f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxMessageQueueGetPending
<LI><a href="#[516]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxMessageQueueError
<LI><a href="#[249]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rtx_msgqueue.o(i.osMessageQueueGet)
</UL>
<P><STRONG><a name="[8d]"></a>svcRtxMessageQueueNew</STRONG> (Thumb, 408 bytes, Stack size 48 bytes, .\build\rtx_msgqueue.o(i.svcRtxMessageQueueNew))
<BR><BR>[Stack]<UL><LI>Max Depth = 80<LI>Call Chain = svcRtxMessageQueueNew &rArr; osRtxMemoryAlloc
</UL>
<BR>[Calls]<UL><LI><a href="#[5e6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxMemoryPoolFree
<LI><a href="#[51b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxMemoryPoolAlloc
<LI><a href="#[5df]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxMemoryFree
<LI><a href="#[5dd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxMemoryAlloc
<LI><a href="#[5e9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxMemoryPoolInit
<LI><a href="#[516]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxMessageQueueError
<LI><a href="#[680]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxMessageQueueCreated
<LI><a href="#[24e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memclr
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rtx_msgqueue.o(i.osMessageQueueNew)
</UL>
<P><STRONG><a name="[8e]"></a>svcRtxMessageQueuePut</STRONG> (Thumb, 276 bytes, Stack size 40 bytes, .\build\rtx_msgqueue.o(i.svcRtxMessageQueuePut))
<BR><BR>[Stack]<UL><LI>Max Depth = 104<LI>Call Chain = svcRtxMessageQueuePut &rArr; osRtxThreadWaitExit &rArr; osRtxThreadDispatch &rArr; osRtxThreadSwitch &rArr; osRtxThreadStackCheck &rArr; osRtxErrorNotify &rArr;  error (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[60a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadWaitEnter
<LI><a href="#[5db]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadWaitExit
<LI><a href="#[606]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadListPut
<LI><a href="#[5ec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadListGet
<LI><a href="#[51b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxMemoryPoolAlloc
<LI><a href="#[5ed]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadRegPtr
<LI><a href="#[2c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MessageQueuePut
<LI><a href="#[517]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxMessageQueueRetrieved
<LI><a href="#[681]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxMessageQueuePutPending
<LI><a href="#[51c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxMessageQueueNotInserted
<LI><a href="#[5ee]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxMessageQueueInserted
<LI><a href="#[516]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxMessageQueueError
<LI><a href="#[249]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rtx_msgqueue.o(i.osMessageQueuePut)
</UL>
<P><STRONG><a name="[8f]"></a>svcRtxMutexAcquire</STRONG> (Thumb, 258 bytes, Stack size 24 bytes, .\build\rtx_mutex.o(i.svcRtxMutexAcquire))
<BR><BR>[Stack]<UL><LI>Max Depth = 64<LI>Call Chain = svcRtxMutexAcquire &rArr; osRtxThreadWaitEnter &rArr; osRtxThreadSwitch &rArr; osRtxThreadStackCheck &rArr; osRtxErrorNotify &rArr;  error (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[60a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadWaitEnter
<LI><a href="#[606]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadListPut
<LI><a href="#[605]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadListSort
<LI><a href="#[683]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxMutexNotAcquired
<LI><a href="#[5d5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxMutexError
<LI><a href="#[5f1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxMutexAcquired
<LI><a href="#[682]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxMutexAcquirePending
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rtx_mutex.o(i.osMutexAcquire)
</UL>
<P><STRONG><a name="[90]"></a>svcRtxMutexDelete</STRONG> (Thumb, 240 bytes, Stack size 24 bytes, .\build\rtx_mutex.o(i.svcRtxMutexDelete))
<BR><BR>[Stack]<UL><LI>Max Depth = 88<LI>Call Chain = svcRtxMutexDelete &rArr; osRtxThreadWaitExit &rArr; osRtxThreadDispatch &rArr; osRtxThreadSwitch &rArr; osRtxThreadStackCheck &rArr; osRtxErrorNotify &rArr;  error (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[5db]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadWaitExit
<LI><a href="#[5ec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadListGet
<LI><a href="#[5f2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadDispatch
<LI><a href="#[5e6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxMemoryPoolFree
<LI><a href="#[5df]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxMemoryFree
<LI><a href="#[605]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadListSort
<LI><a href="#[5d5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxMutexError
<LI><a href="#[684]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxMutexDestroyed
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rtx_mutex.o(i.osMutexDelete)
</UL>
<P><STRONG><a name="[91]"></a>svcRtxMutexNew</STRONG> (Thumb, 172 bytes, Stack size 24 bytes, .\build\rtx_mutex.o(i.svcRtxMutexNew))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = svcRtxMutexNew &rArr; osRtxMemoryAlloc
</UL>
<BR>[Calls]<UL><LI><a href="#[51b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxMemoryPoolAlloc
<LI><a href="#[5dd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxMemoryAlloc
<LI><a href="#[5d5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxMutexError
<LI><a href="#[685]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxMutexCreated
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rtx_mutex.o(i.osMutexNew)
</UL>
<P><STRONG><a name="[92]"></a>svcRtxMutexRelease</STRONG> (Thumb, 272 bytes, Stack size 32 bytes, .\build\rtx_mutex.o(i.svcRtxMutexRelease))
<BR><BR>[Stack]<UL><LI>Max Depth = 96<LI>Call Chain = svcRtxMutexRelease &rArr; osRtxThreadWaitExit &rArr; osRtxThreadDispatch &rArr; osRtxThreadSwitch &rArr; osRtxThreadStackCheck &rArr; osRtxErrorNotify &rArr;  error (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[5db]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadWaitExit
<LI><a href="#[5ec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadListGet
<LI><a href="#[5f2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadDispatch
<LI><a href="#[5f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxMutexReleased
<LI><a href="#[5d5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxMutexError
<LI><a href="#[5f1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxMutexAcquired
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rtx_mutex.o(i.osMutexRelease)
</UL>
<P><STRONG><a name="[94]"></a>svcRtxSemaphoreAcquire</STRONG> (Thumb, 126 bytes, Stack size 24 bytes, .\build\rtx_semaphore.o(i.svcRtxSemaphoreAcquire))
<BR><BR>[Stack]<UL><LI>Max Depth = 64<LI>Call Chain = svcRtxSemaphoreAcquire &rArr; osRtxThreadWaitEnter &rArr; osRtxThreadSwitch &rArr; osRtxThreadStackCheck &rArr; osRtxErrorNotify &rArr;  error (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[60a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadWaitEnter
<LI><a href="#[606]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadListPut
<LI><a href="#[2d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SemaphoreTokenDecrement
<LI><a href="#[616]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxSemaphoreNotAcquired
<LI><a href="#[615]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxSemaphoreError
<LI><a href="#[5f3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxSemaphoreAcquired
<LI><a href="#[686]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxSemaphoreAcquirePending
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rtx_semaphore.o(i.osSemaphoreAcquire)
</UL>
<P><STRONG><a name="[95]"></a>svcRtxSemaphoreDelete</STRONG> (Thumb, 140 bytes, Stack size 16 bytes, .\build\rtx_semaphore.o(i.svcRtxSemaphoreDelete))
<BR><BR>[Stack]<UL><LI>Max Depth = 80<LI>Call Chain = svcRtxSemaphoreDelete &rArr; osRtxThreadWaitExit &rArr; osRtxThreadDispatch &rArr; osRtxThreadSwitch &rArr; osRtxThreadStackCheck &rArr; osRtxErrorNotify &rArr;  error (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[5db]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadWaitExit
<LI><a href="#[5ec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadListGet
<LI><a href="#[5f2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadDispatch
<LI><a href="#[5e6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxMemoryPoolFree
<LI><a href="#[5df]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxMemoryFree
<LI><a href="#[615]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxSemaphoreError
<LI><a href="#[687]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxSemaphoreDestroyed
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rtx_semaphore.o(i.osSemaphoreDelete)
</UL>
<P><STRONG><a name="[96]"></a>svcRtxSemaphoreGetCount</STRONG> (Thumb, 54 bytes, Stack size 16 bytes, .\build\rtx_semaphore.o(i.svcRtxSemaphoreGetCount))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = svcRtxSemaphoreGetCount
</UL>
<BR>[Calls]<UL><LI><a href="#[688]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxSemaphoreGetCount
</UL>
<BR>[Called By]<UL><LI><a href="#[430]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osSemaphoreGetCount
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rtx_semaphore.o(i.osSemaphoreGetCount)
</UL>
<P><STRONG><a name="[97]"></a>svcRtxSemaphoreNew</STRONG> (Thumb, 204 bytes, Stack size 32 bytes, .\build\rtx_semaphore.o(i.svcRtxSemaphoreNew))
<BR><BR>[Stack]<UL><LI>Max Depth = 64<LI>Call Chain = svcRtxSemaphoreNew &rArr; osRtxMemoryAlloc
</UL>
<BR>[Calls]<UL><LI><a href="#[51b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxMemoryPoolAlloc
<LI><a href="#[5dd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxMemoryAlloc
<LI><a href="#[615]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxSemaphoreError
<LI><a href="#[689]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxSemaphoreCreated
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rtx_semaphore.o(i.osSemaphoreNew)
</UL>
<P><STRONG><a name="[98]"></a>svcRtxSemaphoreRelease</STRONG> (Thumb, 120 bytes, Stack size 16 bytes, .\build\rtx_semaphore.o(i.svcRtxSemaphoreRelease))
<BR><BR>[Stack]<UL><LI>Max Depth = 80<LI>Call Chain = svcRtxSemaphoreRelease &rArr; osRtxThreadWaitExit &rArr; osRtxThreadDispatch &rArr; osRtxThreadSwitch &rArr; osRtxThreadStackCheck &rArr; osRtxErrorNotify &rArr;  error (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[5db]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadWaitExit
<LI><a href="#[5ec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadListGet
<LI><a href="#[2d2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SemaphoreTokenIncrement
<LI><a href="#[61a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxSemaphoreReleased
<LI><a href="#[615]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxSemaphoreError
<LI><a href="#[5f3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxSemaphoreAcquired
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rtx_semaphore.o(i.osSemaphoreRelease)
</UL>
<P><STRONG><a name="[9a]"></a>svcRtxThreadExit</STRONG> (Thumb, 142 bytes, Stack size 16 bytes, .\build\rtx_thread.o(i.svcRtxThreadExit))
<BR><BR>[Stack]<UL><LI>Max Depth = 96<LI>Call Chain = svcRtxThreadExit &rArr; osRtxMutexOwnerRelease &rArr; osRtxThreadWaitExit &rArr; osRtxThreadDispatch &rArr; osRtxThreadSwitch &rArr; osRtxThreadStackCheck &rArr; osRtxErrorNotify &rArr;  error (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[5db]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadWaitExit
<LI><a href="#[5ec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadListGet
<LI><a href="#[68b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadSetRunning
<LI><a href="#[601]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadGetRunning
<LI><a href="#[604]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadFree
<LI><a href="#[600]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxKernelGetState
<LI><a href="#[5ef]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxMutexOwnerRelease
<LI><a href="#[603]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadSwitch
<LI><a href="#[68a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxThreadJoined
<LI><a href="#[68c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxThreadDestroyed
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rtx_thread.o(i.osThreadExit)
</UL>
<P><STRONG><a name="[9b]"></a>svcRtxThreadGetId</STRONG> (Thumb, 18 bytes, Stack size 8 bytes, .\build\rtx_thread.o(i.svcRtxThreadGetId))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = svcRtxThreadGetId
</UL>
<BR>[Calls]<UL><LI><a href="#[601]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadGetRunning
<LI><a href="#[620]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxThreadGetId
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rtx_thread.o(i.osThreadGetId)
</UL>
<P><STRONG><a name="[9c]"></a>svcRtxThreadGetName</STRONG> (Thumb, 54 bytes, Stack size 16 bytes, .\build\rtx_thread.o(i.svcRtxThreadGetName))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = svcRtxThreadGetName
</UL>
<BR>[Calls]<UL><LI><a href="#[621]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxThreadGetName
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rtx_thread.o(i.osThreadGetName)
</UL>
<P><STRONG><a name="[99]"></a>svcRtxThreadNew</STRONG> (Thumb, 632 bytes, Stack size 64 bytes, .\build\rtx_thread.o(i.svcRtxThreadNew))
<BR><BR>[Stack]<UL><LI>Max Depth = 104<LI>Call Chain = svcRtxThreadNew &rArr; osRtxThreadDispatch &rArr; osRtxThreadSwitch &rArr; osRtxThreadStackCheck &rArr; osRtxErrorNotify &rArr;  error (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[5b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxThreadError
<LI><a href="#[5f2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadDispatch
<LI><a href="#[5e6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxMemoryPoolFree
<LI><a href="#[51b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxMemoryPoolAlloc
<LI><a href="#[5df]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxMemoryFree
<LI><a href="#[5dd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxMemoryAlloc
<LI><a href="#[68d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxThreadCreated
</UL>
<BR>[Called By]<UL><LI><a href="#[8b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxKernelStart
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rtx_thread.o(i.osThreadContextNew)
</UL>
<P><STRONG><a name="[9d]"></a>svcRtxThreadTerminate</STRONG> (Thumb, 278 bytes, Stack size 16 bytes, .\build\rtx_thread.o(i.svcRtxThreadTerminate))
<BR><BR>[Stack]<UL><LI>Max Depth = 96<LI>Call Chain = svcRtxThreadTerminate &rArr; osRtxMutexOwnerRelease &rArr; osRtxThreadWaitExit &rArr; osRtxThreadDispatch &rArr; osRtxThreadSwitch &rArr; osRtxThreadStackCheck &rArr; osRtxErrorNotify &rArr;  error (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[5b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxThreadError
<LI><a href="#[5db]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadWaitExit
<LI><a href="#[5da]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadListRemove
<LI><a href="#[5ec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadListGet
<LI><a href="#[5f2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadDispatch
<LI><a href="#[68b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadSetRunning
<LI><a href="#[604]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadFree
<LI><a href="#[600]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxKernelGetState
<LI><a href="#[5ef]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxMutexOwnerRelease
<LI><a href="#[603]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadSwitch
<LI><a href="#[68a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxThreadJoined
<LI><a href="#[68c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxThreadDestroyed
<LI><a href="#[60d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadDelayRemove
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rtx_thread.o(i.osThreadTerminate)
</UL>
<P><STRONG><a name="[9e]"></a>svcRtxThreadYield</STRONG> (Thumb, 60 bytes, Stack size 16 bytes, .\build\rtx_thread.o(i.svcRtxThreadYield))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = svcRtxThreadYield &rArr; osRtxThreadSwitch &rArr; osRtxThreadStackCheck &rArr; osRtxErrorNotify &rArr;  error (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[5da]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadListRemove
<LI><a href="#[601]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadGetRunning
<LI><a href="#[600]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxKernelGetState
<LI><a href="#[5ff]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadReadyPut
<LI><a href="#[603]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadSwitch
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rtx_thread.o(i.osThreadYield)
</UL>
<P><STRONG><a name="[59b]"></a>sys_arch_mbox_fetch</STRONG> (Thumb, 154 bytes, Stack size 32 bytes, .\build\lwip_sys_arch.o(i.sys_arch_mbox_fetch))
<BR><BR>[Stack]<UL><LI>Max Depth = 600 + Unknown Stack Size
<LI>Call Chain = sys_arch_mbox_fetch &rArr; us_ticker_read &rArr; us_ticker_init &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[41d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osEventFlagsWait
<LI><a href="#[41b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osEventFlagsSet
<LI><a href="#[5b1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osEventFlagsClear
<LI><a href="#[116]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;us_ticker_read
<LI><a href="#[5c5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osKernelRestoreLock
<LI><a href="#[5c3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osKernelLock
</UL>
<BR>[Called By]<UL><LI><a href="#[581]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netconn_accept
<LI><a href="#[5a2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netconn_recv_data
<LI><a href="#[691]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_timeouts_mbox_fetch
</UL>

<P><STRONG><a name="[59f]"></a>sys_arch_mbox_tryfetch</STRONG> (Thumb, 122 bytes, Stack size 24 bytes, .\build\lwip_sys_arch.o(i.sys_arch_mbox_tryfetch))
<BR><BR>[Stack]<UL><LI>Max Depth = 104<LI>Call Chain = sys_arch_mbox_tryfetch &rArr; osEventFlagsWait &rArr; isrRtxEventFlagsWait &rArr; EventFlagsCheck
</UL>
<BR>[Calls]<UL><LI><a href="#[41d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osEventFlagsWait
<LI><a href="#[41b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osEventFlagsSet
<LI><a href="#[5b1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osEventFlagsClear
<LI><a href="#[5c5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osKernelRestoreLock
<LI><a href="#[5c3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osKernelLock
</UL>
<BR>[Called By]<UL><LI><a href="#[550]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netconn_drain
</UL>

<P><STRONG><a name="[496]"></a>sys_arch_protect</STRONG> (Thumb, 26 bytes, Stack size 8 bytes, .\build\lwip_sys_arch.o(i.sys_arch_protect))
<BR><BR>[Stack]<UL><LI>Max Depth = 464 + Unknown Stack Size
<LI>Call Chain = sys_arch_protect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[2eb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osMutexAcquire
<LI><a href="#[3e6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;error
</UL>
<BR>[Called By]<UL><LI><a href="#[46b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_free
<LI><a href="#[b3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;recv_tcp
<LI><a href="#[560]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_netconn_do_writemore
<LI><a href="#[6d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_netconn_do_connected
<LI><a href="#[551]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_netconn_do_close_internal
<LI><a href="#[6c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;err_tcp
<LI><a href="#[80]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_netconn_do_write
<LI><a href="#[7f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_netconn_do_send
<LI><a href="#[7e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_netconn_do_recv
<LI><a href="#[7d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_netconn_do_newconn
<LI><a href="#[7c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_netconn_do_listen
<LI><a href="#[7a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_netconn_do_getaddr
<LI><a href="#[79]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_netconn_do_delconn
<LI><a href="#[78]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_netconn_do_connect
<LI><a href="#[77]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_netconn_do_close
<LI><a href="#[76]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_netconn_do_bind
<LI><a href="#[581]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netconn_accept
<LI><a href="#[4f7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_ref
<LI><a href="#[498]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;do_memp_malloc_pool
<LI><a href="#[495]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;do_memp_free_pool
<LI><a href="#[597]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mem_trim
<LI><a href="#[593]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mem_free
<LI><a href="#[fb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pppos_recv_config
<LI><a href="#[f6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pppos_disconnect
<LI><a href="#[f5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pppos_connect
<LI><a href="#[74]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_socket_callback
<LI><a href="#[109]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_setsockopt
<LI><a href="#[56f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_arena_alloc
<LI><a href="#[416]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pppos_input
</UL>

<P><STRONG><a name="[553]"></a>sys_arch_sem_wait</STRONG> (Thumb, 54 bytes, Stack size 16 bytes, .\build\lwip_sys_arch.o(i.sys_arch_sem_wait))
<BR><BR>[Stack]<UL><LI>Max Depth = 584 + Unknown Stack Size
<LI>Call Chain = sys_arch_sem_wait &rArr; us_ticker_read &rArr; us_ticker_init &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[42f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osSemaphoreAcquire
<LI><a href="#[116]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;us_ticker_read
</UL>
<BR>[Called By]<UL><LI><a href="#[392]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_bringup_2
<LI><a href="#[80]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_netconn_do_write
<LI><a href="#[79]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_netconn_do_delconn
<LI><a href="#[78]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_netconn_do_connect
<LI><a href="#[77]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_netconn_do_close
<LI><a href="#[57e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netconn_gethostbyname
<LI><a href="#[579]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_lwip_disconnect
<LI><a href="#[571]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_core_init
</UL>

<P><STRONG><a name="[497]"></a>sys_arch_unprotect</STRONG> (Thumb, 22 bytes, Stack size 8 bytes, .\build\lwip_sys_arch.o(i.sys_arch_unprotect))
<BR><BR>[Stack]<UL><LI>Max Depth = 464 + Unknown Stack Size
<LI>Call Chain = sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[30b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osMutexRelease
<LI><a href="#[3e6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;error
</UL>
<BR>[Called By]<UL><LI><a href="#[46b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_free
<LI><a href="#[b3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;recv_tcp
<LI><a href="#[560]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_netconn_do_writemore
<LI><a href="#[6d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_netconn_do_connected
<LI><a href="#[551]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_netconn_do_close_internal
<LI><a href="#[6c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;err_tcp
<LI><a href="#[80]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_netconn_do_write
<LI><a href="#[7f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_netconn_do_send
<LI><a href="#[7e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_netconn_do_recv
<LI><a href="#[7d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_netconn_do_newconn
<LI><a href="#[7c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_netconn_do_listen
<LI><a href="#[7a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_netconn_do_getaddr
<LI><a href="#[79]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_netconn_do_delconn
<LI><a href="#[78]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_netconn_do_connect
<LI><a href="#[77]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_netconn_do_close
<LI><a href="#[76]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_netconn_do_bind
<LI><a href="#[581]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netconn_accept
<LI><a href="#[4f7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_ref
<LI><a href="#[498]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;do_memp_malloc_pool
<LI><a href="#[495]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;do_memp_free_pool
<LI><a href="#[597]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mem_trim
<LI><a href="#[593]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mem_free
<LI><a href="#[fb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pppos_recv_config
<LI><a href="#[f6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pppos_disconnect
<LI><a href="#[f5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pppos_connect
<LI><a href="#[74]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_socket_callback
<LI><a href="#[109]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_setsockopt
<LI><a href="#[56f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_arena_alloc
<LI><a href="#[416]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pppos_input
</UL>

<P><STRONG><a name="[544]"></a>sys_init</STRONG> (Thumb, 44 bytes, Stack size 8 bytes, .\build\lwip_sys_arch.o(i.sys_init))
<BR><BR>[Stack]<UL><LI>Max Depth = 576 + Unknown Stack Size
<LI>Call Chain = sys_init &rArr; us_ticker_read &rArr; us_ticker_init &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[423]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osMutexNew
<LI><a href="#[3e6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;error
<LI><a href="#[116]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;us_ticker_read
</UL>
<BR>[Called By]<UL><LI><a href="#[543]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_init
</UL>

<P><STRONG><a name="[567]"></a>sys_jiffies</STRONG> (Thumb, 32 bytes, Stack size 8 bytes, .\build\lwip_sys_arch.o(i.sys_jiffies))
<BR><BR>[Stack]<UL><LI>Max Depth = 576 + Unknown Stack Size
<LI>Call Chain = sys_jiffies &rArr; us_ticker_read &rArr; us_ticker_init &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[116]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;us_ticker_read
</UL>
<BR>[Called By]<UL><LI><a href="#[566]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;magic_churnrand
</UL>

<P><STRONG><a name="[457]"></a>sys_mbox_free</STRONG> (Thumb, 24 bytes, Stack size 8 bytes, .\build\lwip_sys_arch.o(i.sys_mbox_free))
<BR><BR>[Stack]<UL><LI>Max Depth = 464 + Unknown Stack Size
<LI>Call Chain = sys_mbox_free &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[3e6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;error
</UL>
<BR>[Called By]<UL><LI><a href="#[550]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netconn_drain
<LI><a href="#[6f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;accept_function
<LI><a href="#[450]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netconn_alloc
<LI><a href="#[7c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_netconn_do_listen
<LI><a href="#[589]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netconn_new_with_proto_and_callback
</UL>

<P><STRONG><a name="[55c]"></a>sys_mbox_new</STRONG> (Thumb, 64 bytes, Stack size 16 bytes, .\build\lwip_sys_arch.o(i.sys_mbox_new))
<BR><BR>[Stack]<UL><LI>Max Depth = 472 + Unknown Stack Size
<LI>Call Chain = sys_mbox_new &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[3e6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;error
<LI><a href="#[41b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osEventFlagsSet
<LI><a href="#[419]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osEventFlagsNew
<LI><a href="#[23c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memclr4
</UL>
<BR>[Called By]<UL><LI><a href="#[450]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netconn_alloc
<LI><a href="#[7c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_netconn_do_listen
<LI><a href="#[57c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcpip_init
</UL>

<P><STRONG><a name="[68f]"></a>sys_mbox_post</STRONG> (Thumb, 96 bytes, Stack size 16 bytes, .\build\lwip_sys_arch.o(i.sys_mbox_post))
<BR><BR>[Stack]<UL><LI>Max Depth = 96<LI>Call Chain = sys_mbox_post &rArr; osEventFlagsWait &rArr; isrRtxEventFlagsWait &rArr; EventFlagsCheck
</UL>
<BR>[Calls]<UL><LI><a href="#[41d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osEventFlagsWait
<LI><a href="#[41b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osEventFlagsSet
<LI><a href="#[5b1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osEventFlagsClear
<LI><a href="#[5c5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osKernelRestoreLock
<LI><a href="#[5c3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osKernelLock
</UL>
<BR>[Called By]<UL><LI><a href="#[5a1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcpip_callback_with_block
</UL>

<P><STRONG><a name="[44f]"></a>sys_mbox_trypost</STRONG> (Thumb, 120 bytes, Stack size 24 bytes, .\build\lwip_sys_arch.o(i.sys_mbox_trypost))
<BR><BR>[Stack]<UL><LI>Max Depth = 104<LI>Call Chain = sys_mbox_trypost &rArr; osEventFlagsWait &rArr; isrRtxEventFlagsWait &rArr; EventFlagsCheck
</UL>
<BR>[Calls]<UL><LI><a href="#[41d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osEventFlagsWait
<LI><a href="#[41b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osEventFlagsSet
<LI><a href="#[5b1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osEventFlagsClear
<LI><a href="#[5c5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osKernelRestoreLock
<LI><a href="#[5c3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osKernelLock
</UL>
<BR>[Called By]<UL><LI><a href="#[9f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;recv_udp
<LI><a href="#[b3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;recv_tcp
<LI><a href="#[6c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;err_tcp
<LI><a href="#[6f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;accept_function
<LI><a href="#[5a1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcpip_callback_with_block
</UL>

<P><STRONG><a name="[554]"></a>sys_mutex_lock</STRONG> (Thumb, 24 bytes, Stack size 8 bytes, .\build\lwip_sys_arch.o(i.sys_mutex_lock))
<BR><BR>[Stack]<UL><LI>Max Depth = 464 + Unknown Stack Size
<LI>Call Chain = sys_mutex_lock &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[2eb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osMutexAcquire
<LI><a href="#[3e6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;error
</UL>
<BR>[Called By]<UL><LI><a href="#[59d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcpip_send_msg_wait_sem
<LI><a href="#[80]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_netconn_do_write
<LI><a href="#[79]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_netconn_do_delconn
<LI><a href="#[78]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_netconn_do_connect
<LI><a href="#[77]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_netconn_do_close
<LI><a href="#[597]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mem_trim
<LI><a href="#[596]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mem_malloc
<LI><a href="#[593]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mem_free
<LI><a href="#[68e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_check_timeouts
<LI><a href="#[be]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcpip_thread
</UL>

<P><STRONG><a name="[595]"></a>sys_mutex_new</STRONG> (Thumb, 48 bytes, Stack size 8 bytes, .\build\lwip_sys_arch.o(i.sys_mutex_new))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = sys_mutex_new &rArr; osMutexNew
</UL>
<BR>[Calls]<UL><LI><a href="#[423]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osMutexNew
<LI><a href="#[23c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memclr4
</UL>
<BR>[Called By]<UL><LI><a href="#[545]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mem_init
<LI><a href="#[57c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcpip_init
</UL>

<P><STRONG><a name="[552]"></a>sys_mutex_unlock</STRONG> (Thumb, 20 bytes, Stack size 8 bytes, .\build\lwip_sys_arch.o(i.sys_mutex_unlock))
<BR><BR>[Stack]<UL><LI>Max Depth = 464 + Unknown Stack Size
<LI>Call Chain = sys_mutex_unlock &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[30b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osMutexRelease
<LI><a href="#[3e6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;error
</UL>
<BR>[Called By]<UL><LI><a href="#[59d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcpip_send_msg_wait_sem
<LI><a href="#[80]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_netconn_do_write
<LI><a href="#[79]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_netconn_do_delconn
<LI><a href="#[78]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_netconn_do_connect
<LI><a href="#[77]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_netconn_do_close
<LI><a href="#[597]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mem_trim
<LI><a href="#[596]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mem_malloc
<LI><a href="#[593]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mem_free
<LI><a href="#[68e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_check_timeouts
<LI><a href="#[be]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcpip_thread
</UL>

<P><STRONG><a name="[542]"></a>sys_now</STRONG> (Thumb, 16 bytes, Stack size 8 bytes, .\build\lwip_sys_arch.o(i.sys_now))
<BR><BR>[Stack]<UL><LI>Max Depth = 576 + Unknown Stack Size
<LI>Call Chain = sys_now &rArr; us_ticker_read &rArr; us_ticker_init &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[116]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;us_ticker_read
</UL>
<BR>[Called By]<UL><LI><a href="#[2c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_timeout
<LI><a href="#[54d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_timeouts_init
<LI><a href="#[f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pppos_write
<LI><a href="#[63c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pppos_output_last
<LI><a href="#[f9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pppos_netif_output
<LI><a href="#[68e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_check_timeouts
<LI><a href="#[541]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_hook_tcp_isn
<LI><a href="#[692]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_timeouts_sleeptime
</UL>

<P><STRONG><a name="[5a0]"></a>sys_sem_free</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\lwip_sys_arch.o(i.sys_sem_free))
<BR><BR>[Called By]<UL><LI><a href="#[458]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netconn_free
<LI><a href="#[589]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netconn_new_with_proto_and_callback
<LI><a href="#[57e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netconn_gethostbyname
</UL>

<P><STRONG><a name="[57b]"></a>sys_sem_new</STRONG> (Thumb, 52 bytes, Stack size 16 bytes, .\build\lwip_sys_arch.o(i.sys_sem_new))
<BR><BR>[Stack]<UL><LI>Max Depth = 472 + Unknown Stack Size
<LI>Call Chain = sys_sem_new &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[3e6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;error
<LI><a href="#[42e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osSemaphoreNew
<LI><a href="#[23c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memclr4
</UL>
<BR>[Called By]<UL><LI><a href="#[450]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netconn_alloc
<LI><a href="#[57e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netconn_gethostbyname
<LI><a href="#[572]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_lwip_if_init
<LI><a href="#[571]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_core_init
</UL>

<P><STRONG><a name="[37c]"></a>sys_sem_signal</STRONG> (Thumb, 18 bytes, Stack size 8 bytes, .\build\lwip_sys_arch.o(i.sys_sem_signal))
<BR><BR>[Stack]<UL><LI>Max Depth = 520 + Unknown Stack Size
<LI>Call Chain = sys_sem_signal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[431]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osSemaphoreRelease
<LI><a href="#[4b3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_die
</UL>
<BR>[Called By]<UL><LI><a href="#[560]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_netconn_do_writemore
<LI><a href="#[6e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_netconn_do_dns_found
<LI><a href="#[6d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_netconn_do_connected
<LI><a href="#[551]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_netconn_do_close_internal
<LI><a href="#[6c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;err_tcp
<LI><a href="#[7b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_netconn_do_gethostbyname
<LI><a href="#[73]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_tcpip_init_irq
<LI><a href="#[72]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_netif_status_irq
<LI><a href="#[71]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_netif_link_irq
<LI><a href="#[a2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ppp_link_status(ppp_pcb_s*, int, void*)
</UL>

<P><STRONG><a name="[690]"></a>sys_thread_new</STRONG> (Thumb, 134 bytes, Stack size 32 bytes, .\build\lwip_sys_arch.o(i.sys_thread_new))
<BR><BR>[Stack]<UL><LI>Max Depth = 488 + Unknown Stack Size
<LI>Call Chain = sys_thread_new &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[3e6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;error
<LI><a href="#[426]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osThreadNew
<LI><a href="#[23c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memclr4
<LI><a href="#[21d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;malloc
</UL>
<BR>[Called By]<UL><LI><a href="#[57c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcpip_init
</UL>

<P><STRONG><a name="[2c0]"></a>sys_timeout</STRONG> (Thumb, 202 bytes, Stack size 32 bytes, .\build\lwip_timeouts.o(i.sys_timeout))
<BR><BR>[Stack]<UL><LI>Max Depth = 608 + Unknown Stack Size
<LI>Call Chain = sys_timeout &rArr; sys_now &rArr; us_ticker_read &rArr; us_ticker_init &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[4e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memp_malloc
<LI><a href="#[542]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_now
</UL>
<BR>[Called By]<UL><LI><a href="#[4bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;terminate_layer
<LI><a href="#[66]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fsm_timeout
<LI><a href="#[4c6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fsm_sconfreq
<LI><a href="#[4c1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fsm_rtermreq
<LI><a href="#[2bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LcpEchoCheck
<LI><a href="#[54d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_timeouts_init
<LI><a href="#[f1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lcp_lowerup
<LI><a href="#[62d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_connect
<LI><a href="#[61]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;cyclic_timer
<LI><a href="#[69c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_timer_needed
<LI><a href="#[bd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcpip_tcp_timer
</UL>

<P><STRONG><a name="[54d]"></a>sys_timeouts_init</STRONG> (Thumb, 38 bytes, Stack size 8 bytes, .\build\lwip_timeouts.o(i.sys_timeouts_init))
<BR><BR>[Stack]<UL><LI>Max Depth = 616 + Unknown Stack Size
<LI>Call Chain = sys_timeouts_init &rArr; sys_timeout &rArr; sys_now &rArr; us_ticker_read &rArr; us_ticker_init &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[2c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_timeout
<LI><a href="#[542]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_now
</UL>
<BR>[Called By]<UL><LI><a href="#[543]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_init
</UL>

<P><STRONG><a name="[691]"></a>sys_timeouts_mbox_fetch</STRONG> (Thumb, 58 bytes, Stack size 16 bytes, .\build\lwip_timeouts.o(i.sys_timeouts_mbox_fetch))
<BR><BR>[Stack]<UL><LI>Max Depth = 624 + Unknown Stack Size
<LI>Call Chain = sys_timeouts_mbox_fetch &rArr; sys_check_timeouts &rArr; sys_now &rArr; us_ticker_read &rArr; us_ticker_init &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[59b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_mbox_fetch
<LI><a href="#[68e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_check_timeouts
<LI><a href="#[692]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_timeouts_sleeptime
</UL>
<BR>[Called By]<UL><LI><a href="#[be]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcpip_thread
</UL>

<P><STRONG><a name="[2bf]"></a>sys_untimeout</STRONG> (Thumb, 90 bytes, Stack size 24 bytes, .\build\lwip_timeouts.o(i.sys_untimeout))
<BR><BR>[Stack]<UL><LI>Max Depth = 528 + Unknown Stack Size
<LI>Call Chain = sys_untimeout &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[4e7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memp_free
</UL>
<BR>[Called By]<UL><LI><a href="#[f2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lcp_lowerdown
<LI><a href="#[f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lcp_close
<LI><a href="#[4c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fsm_protreject
<LI><a href="#[4c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fsm_lowerdown
<LI><a href="#[4bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;terminate_layer
<LI><a href="#[66]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fsm_timeout
<LI><a href="#[4c6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fsm_sconfreq
<LI><a href="#[4c1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fsm_rtermreq
<LI><a href="#[4c2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fsm_rtermack
<LI><a href="#[4be]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fsm_rconfreq
<LI><a href="#[4c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fsm_rconfnakrej
<LI><a href="#[4bf]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fsm_rconfack
<LI><a href="#[ef]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lcp_input
<LI><a href="#[524]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lcp_echo_lowerdown
<LI><a href="#[2bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LcpEchoCheck
<LI><a href="#[f1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lcp_lowerup
<LI><a href="#[3a6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_close
</UL>

<P><STRONG><a name="[693]"></a>tcp_abandon</STRONG> (Thumb, 216 bytes, Stack size 48 bytes, .\build\lwip_tcp.o(i.tcp_abandon))
<BR><BR>[Stack]<UL><LI>Max Depth = 1008 + Unknown Stack Size
<LI>Call Chain = tcp_abandon &rArr; tcp_pcb_remove &rArr; tcp_output &rArr; tcp_output_segment &rArr; ip4_output_if &rArr; ip4_output_if_opt &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[4e7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memp_free
<LI><a href="#[696]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_rst
<LI><a href="#[695]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_segs_free
<LI><a href="#[694]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_pcb_remove
</UL>
<BR>[Called By]<UL><LI><a href="#[558]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_abort
<LI><a href="#[6ab]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_listen_input
<LI><a href="#[699]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_kill_state
</UL>

<P><STRONG><a name="[558]"></a>tcp_abort</STRONG> (Thumb, 14 bytes, Stack size 8 bytes, .\build\lwip_tcp.o(i.tcp_abort))
<BR><BR>[Stack]<UL><LI>Max Depth = 1016 + Unknown Stack Size
<LI>Call Chain = tcp_abort &rArr; tcp_abandon &rArr; tcp_pcb_remove &rArr; tcp_output &rArr; tcp_output_segment &rArr; ip4_output_if &rArr; ip4_output_if_opt &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[693]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_abandon
</UL>
<BR>[Called By]<UL><LI><a href="#[550]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netconn_drain
<LI><a href="#[551]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_netconn_do_close_internal
<LI><a href="#[4fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_input
<LI><a href="#[6ad]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_process
<LI><a href="#[6b2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_netif_ip_addr_changed_pcblist
<LI><a href="#[698]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_kill_timewait
<LI><a href="#[69a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_kill_prio
<LI><a href="#[bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_accept_null
</UL>

<P><STRONG><a name="[555]"></a>tcp_accept</STRONG> (Thumb, 16 bytes, Stack size 0 bytes, .\build\lwip_tcp.o(i.tcp_accept))
<BR><BR>[Called By]<UL><LI><a href="#[551]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_netconn_do_close_internal
<LI><a href="#[7c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_netconn_do_listen
</UL>

<P><STRONG><a name="[697]"></a>tcp_alloc</STRONG> (Thumb, 176 bytes, Stack size 16 bytes, .\build\lwip_tcp.o(i.tcp_alloc))
<BR><BR>[Stack]<UL><LI>Max Depth = 1056 + Unknown Stack Size
<LI>Call Chain = tcp_alloc &rArr; tcp_kill_prio &rArr; tcp_abort &rArr; tcp_abandon &rArr; tcp_pcb_remove &rArr; tcp_output &rArr; tcp_output_segment &rArr; ip4_output_if &rArr; ip4_output_if_opt &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[4e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memp_malloc
<LI><a href="#[698]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_kill_timewait
<LI><a href="#[699]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_kill_state
<LI><a href="#[69a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_kill_prio
<LI><a href="#[23c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memclr4
</UL>
<BR>[Called By]<UL><LI><a href="#[627]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_new_ip_type
<LI><a href="#[6ab]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_listen_input
</UL>

<P><STRONG><a name="[452]"></a>tcp_arg</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, .\build\lwip_tcp.o(i.tcp_arg))
<BR><BR>[Called By]<UL><LI><a href="#[451]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;setup_tcp
<LI><a href="#[551]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_netconn_do_close_internal
<LI><a href="#[6f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;accept_function
<LI><a href="#[7c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_netconn_do_listen
</UL>

<P><STRONG><a name="[54f]"></a>tcp_bind</STRONG> (Thumb, 190 bytes, Stack size 32 bytes, .\build\lwip_tcp.o(i.tcp_bind))
<BR><BR>[Stack]<UL><LI>Max Depth = 648 + Unknown Stack Size
<LI>Call Chain = tcp_bind &rArr; tcp_timer_needed &rArr; sys_timeout &rArr; sys_now &rArr; us_ticker_read &rArr; us_ticker_init &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[69c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_timer_needed
<LI><a href="#[69b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_new_port
</UL>
<BR>[Called By]<UL><LI><a href="#[76]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_netconn_do_bind
</UL>

<P><STRONG><a name="[556]"></a>tcp_close</STRONG> (Thumb, 28 bytes, Stack size 8 bytes, .\build\lwip_tcp.o(i.tcp_close))
<BR><BR>[Stack]<UL><LI>Max Depth = 992 + Unknown Stack Size
<LI>Call Chain = tcp_close &rArr; tcp_close_shutdown &rArr; tcp_pcb_remove &rArr; tcp_output &rArr; tcp_output_segment &rArr; ip4_output_if &rArr; ip4_output_if_opt &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[69d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_close_shutdown
</UL>
<BR>[Called By]<UL><LI><a href="#[551]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_netconn_do_close_internal
<LI><a href="#[7c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_netconn_do_listen
<LI><a href="#[bb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_recv_null
</UL>

<P><STRONG><a name="[55a]"></a>tcp_connect</STRONG> (Thumb, 384 bytes, Stack size 56 bytes, .\build\lwip_tcp.o(i.tcp_connect))
<BR><BR>[Stack]<UL><LI>Max Depth = 1000 + Unknown Stack Size
<LI>Call Chain = tcp_connect &rArr; tcp_output &rArr; tcp_output_segment &rArr; ip4_output_if &rArr; ip4_output_if_opt &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[4d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip4_route
<LI><a href="#[562]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_output
<LI><a href="#[69c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_timer_needed
<LI><a href="#[6a5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_enqueue_flags
<LI><a href="#[6a3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_next_iss
<LI><a href="#[6a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_eff_send_mss_impl
<LI><a href="#[69b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_new_port
</UL>
<BR>[Called By]<UL><LI><a href="#[78]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_netconn_do_connect
</UL>

<P><STRONG><a name="[6a4]"></a>tcp_eff_send_mss_impl</STRONG> (Thumb, 58 bytes, Stack size 24 bytes, .\build\lwip_tcp.o(i.tcp_eff_send_mss_impl))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = tcp_eff_send_mss_impl &rArr; ip4_route
</UL>
<BR>[Calls]<UL><LI><a href="#[4d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip4_route
</UL>
<BR>[Called By]<UL><LI><a href="#[55a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_connect
<LI><a href="#[6b3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_output_segment
<LI><a href="#[6ad]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_process
<LI><a href="#[6ab]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_listen_input
</UL>

<P><STRONG><a name="[6a5]"></a>tcp_enqueue_flags</STRONG> (Thumb, 240 bytes, Stack size 32 bytes, .\build\lwip_tcp_out.o(i.tcp_enqueue_flags))
<BR><BR>[Stack]<UL><LI>Max Depth = 616 + Unknown Stack Size
<LI>Call Chain = tcp_enqueue_flags &rArr; tcp_create_segment &rArr; tcp_seg_free &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[46a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_alloc
<LI><a href="#[500]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_clen
<LI><a href="#[6a6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_create_segment
</UL>
<BR>[Called By]<UL><LI><a href="#[55a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_connect
<LI><a href="#[6ab]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_listen_input
<LI><a href="#[6a2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_send_fin
</UL>

<P><STRONG><a name="[456]"></a>tcp_err</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, .\build\lwip_tcp.o(i.tcp_err))
<BR><BR>[Called By]<UL><LI><a href="#[451]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;setup_tcp
<LI><a href="#[551]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_netconn_do_close_internal
<LI><a href="#[6f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;accept_function
</UL>

<P><STRONG><a name="[6a8]"></a>tcp_fasttmr</STRONG> (Thumb, 130 bytes, Stack size 16 bytes, .\build\lwip_tcp.o(i.tcp_fasttmr))
<BR><BR>[Stack]<UL><LI>Max Depth = 1056 + Unknown Stack Size
<LI>Call Chain = tcp_fasttmr &rArr; tcp_process_refused_data &rArr; tcp_recv_null &rArr; tcp_close &rArr; tcp_close_shutdown &rArr; tcp_pcb_remove &rArr; tcp_output &rArr; tcp_output_segment &rArr; ip4_output_if &rArr; ip4_output_if_opt &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[562]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_output
<LI><a href="#[6a9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_process_refused_data
<LI><a href="#[6a1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_close_shutdown_fin
</UL>
<BR>[Called By]<UL><LI><a href="#[10a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_tmr
</UL>

<P><STRONG><a name="[549]"></a>tcp_init</STRONG> (Thumb, 20 bytes, Stack size 8 bytes, .\build\lwip_tcp.o(i.tcp_init))
<BR><BR>[Stack]<UL><LI>Max Depth = 88<LI>Call Chain = tcp_init &rArr; lwip_get_random &rArr; randLIB_get_32bit &rArr; randLIB_get_64bit &rArr; rol
</UL>
<BR>[Calls]<UL><LI><a href="#[47c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_get_random
</UL>
<BR>[Called By]<UL><LI><a href="#[543]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_init
</UL>

<P><STRONG><a name="[4fc]"></a>tcp_input</STRONG> (Thumb, 1258 bytes, Stack size 48 bytes, .\build\lwip_tcp_in.o(i.tcp_input))
<BR><BR>[Stack]<UL><LI>Max Depth = 1136 + Unknown Stack Size
<LI>Call Chain = tcp_input &rArr; tcp_listen_input &rArr; tcp_alloc &rArr; tcp_kill_prio &rArr; tcp_abort &rArr; tcp_abandon &rArr; tcp_pcb_remove &rArr; tcp_output &rArr; tcp_output_segment &rArr; ip4_output_if &rArr; ip4_output_if_opt &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[48e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_htons
<LI><a href="#[490]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_htonl
<LI><a href="#[505]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip_chksum_pseudo
<LI><a href="#[4d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_header
<LI><a href="#[4d2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip4_addr_isbroadcast_u32
<LI><a href="#[562]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_output
<LI><a href="#[558]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_abort
<LI><a href="#[46b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_free
<LI><a href="#[4e7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memp_free
<LI><a href="#[6ac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_send_empty_ack
<LI><a href="#[6aa]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_timewait_input
<LI><a href="#[6ad]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_process
<LI><a href="#[6ab]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_listen_input
<LI><a href="#[696]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_rst
<LI><a href="#[bb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_recv_null
<LI><a href="#[6a9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_process_refused_data
<LI><a href="#[694]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_pcb_remove
</UL>
<BR>[Called By]<UL><LI><a href="#[4f9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip4_input
</UL>

<P><STRONG><a name="[6ae]"></a>tcp_keepalive</STRONG> (Thumb, 114 bytes, Stack size 40 bytes, .\build\lwip_tcp_out.o(i.tcp_keepalive))
<BR><BR>[Stack]<UL><LI>Max Depth = 896 + Unknown Stack Size
<LI>Call Chain = tcp_keepalive &rArr; ip4_output_if &rArr; ip4_output_if_opt &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[490]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_htonl
<LI><a href="#[505]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip_chksum_pseudo
<LI><a href="#[4d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip4_route
<LI><a href="#[4d7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip4_output_if
<LI><a href="#[46b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_free
<LI><a href="#[6af]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_output_alloc_header
</UL>
<BR>[Called By]<UL><LI><a href="#[6ba]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_slowtmr
</UL>

<P><STRONG><a name="[55b]"></a>tcp_listen_with_backlog_and_err</STRONG> (Thumb, 236 bytes, Stack size 24 bytes, .\build\lwip_tcp.o(i.tcp_listen_with_backlog_and_err))
<BR><BR>[Stack]<UL><LI>Max Depth = 640 + Unknown Stack Size
<LI>Call Chain = tcp_listen_with_backlog_and_err &rArr; tcp_timer_needed &rArr; sys_timeout &rArr; sys_now &rArr; us_ticker_read &rArr; us_ticker_init &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[4e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memp_malloc
<LI><a href="#[4e7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memp_free
<LI><a href="#[69c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_timer_needed
</UL>
<BR>[Called By]<UL><LI><a href="#[7c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_netconn_do_listen
</UL>

<P><STRONG><a name="[5a9]"></a>tcp_netif_ip_addr_changed</STRONG> (Thumb, 70 bytes, Stack size 24 bytes, .\build\lwip_tcp.o(i.tcp_netif_ip_addr_changed))
<BR><BR>[Stack]<UL><LI>Max Depth = 1064 + Unknown Stack Size
<LI>Call Chain = tcp_netif_ip_addr_changed &rArr; tcp_netif_ip_addr_changed_pcblist &rArr; tcp_abort &rArr; tcp_abandon &rArr; tcp_pcb_remove &rArr; tcp_output &rArr; tcp_output_segment &rArr; ip4_output_if &rArr; ip4_output_if_opt &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[6b2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_netif_ip_addr_changed_pcblist
</UL>
<BR>[Called By]<UL><LI><a href="#[5a6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netif_set_ipaddr
</UL>

<P><STRONG><a name="[627]"></a>tcp_new_ip_type</STRONG> (Thumb, 16 bytes, Stack size 16 bytes, .\build\lwip_tcp.o(i.tcp_new_ip_type))
<BR><BR>[Stack]<UL><LI>Max Depth = 1072 + Unknown Stack Size
<LI>Call Chain = tcp_new_ip_type &rArr; tcp_alloc &rArr; tcp_kill_prio &rArr; tcp_abort &rArr; tcp_abandon &rArr; tcp_pcb_remove &rArr; tcp_output &rArr; tcp_output_segment &rArr; ip4_output_if &rArr; ip4_output_if_opt &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[697]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_alloc
</UL>
<BR>[Called By]<UL><LI><a href="#[55d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pcb_new
</UL>

<P><STRONG><a name="[6a3]"></a>tcp_next_iss</STRONG> (Thumb, 18 bytes, Stack size 8 bytes, .\build\lwip_tcp.o(i.tcp_next_iss))
<BR><BR>[Stack]<UL><LI>Max Depth = 720 + Unknown Stack Size
<LI>Call Chain = tcp_next_iss &rArr; lwip_hook_tcp_isn &rArr; sys_now &rArr; us_ticker_read &rArr; us_ticker_init &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[541]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_hook_tcp_isn
</UL>
<BR>[Called By]<UL><LI><a href="#[55a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_connect
<LI><a href="#[6ab]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_listen_input
</UL>

<P><STRONG><a name="[562]"></a>tcp_output</STRONG> (Thumb, 564 bytes, Stack size 40 bytes, .\build\lwip_tcp_out.o(i.tcp_output))
<BR><BR>[Stack]<UL><LI>Max Depth = 944 + Unknown Stack Size
<LI>Call Chain = tcp_output &rArr; tcp_output_segment &rArr; ip4_output_if &rArr; ip4_output_if_opt &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[48e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_htons
<LI><a href="#[490]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_htonl
<LI><a href="#[4d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip4_route
<LI><a href="#[6b3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_output_segment
<LI><a href="#[6ac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_send_empty_ack
<LI><a href="#[6a7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_seg_free
</UL>
<BR>[Called By]<UL><LI><a href="#[55e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_recved
<LI><a href="#[55a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_connect
<LI><a href="#[560]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_netconn_do_writemore
<LI><a href="#[4fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_input
<LI><a href="#[6aa]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_timewait_input
<LI><a href="#[6ab]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_listen_input
<LI><a href="#[6b5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_rexmit_rto
<LI><a href="#[6ba]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_slowtmr
<LI><a href="#[694]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_pcb_remove
<LI><a href="#[6a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_fasttmr
<LI><a href="#[6a1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_close_shutdown_fin
</UL>

<P><STRONG><a name="[69e]"></a>tcp_pcb_purge</STRONG> (Thumb, 60 bytes, Stack size 8 bytes, .\build\lwip_tcp.o(i.tcp_pcb_purge))
<BR><BR>[Stack]<UL><LI>Max Depth = 568 + Unknown Stack Size
<LI>Call Chain = tcp_pcb_purge &rArr; tcp_segs_free &rArr; tcp_seg_free &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[46b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_free
<LI><a href="#[695]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_segs_free
</UL>
<BR>[Called By]<UL><LI><a href="#[6ad]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_process
<LI><a href="#[6ba]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_slowtmr
<LI><a href="#[694]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_pcb_remove
<LI><a href="#[69d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_close_shutdown
</UL>

<P><STRONG><a name="[694]"></a>tcp_pcb_remove</STRONG> (Thumb, 102 bytes, Stack size 16 bytes, .\build\lwip_tcp.o(i.tcp_pcb_remove))
<BR><BR>[Stack]<UL><LI>Max Depth = 960 + Unknown Stack Size
<LI>Call Chain = tcp_pcb_remove &rArr; tcp_output &rArr; tcp_output_segment &rArr; ip4_output_if &rArr; ip4_output_if_opt &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[562]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_output
<LI><a href="#[69e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_pcb_purge
</UL>
<BR>[Called By]<UL><LI><a href="#[4fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_input
<LI><a href="#[693]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_abandon
<LI><a href="#[69d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_close_shutdown
</UL>

<P><STRONG><a name="[455]"></a>tcp_poll</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, .\build\lwip_tcp.o(i.tcp_poll))
<BR><BR>[Called By]<UL><LI><a href="#[451]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;setup_tcp
<LI><a href="#[551]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_netconn_do_close_internal
<LI><a href="#[6f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;accept_function
</UL>

<P><STRONG><a name="[6a9]"></a>tcp_process_refused_data</STRONG> (Thumb, 144 bytes, Stack size 24 bytes, .\build\lwip_tcp.o(i.tcp_process_refused_data))
<BR><BR>[Stack]<UL><LI>Max Depth = 1040 + Unknown Stack Size
<LI>Call Chain = tcp_process_refused_data &rArr; tcp_recv_null &rArr; tcp_close &rArr; tcp_close_shutdown &rArr; tcp_pcb_remove &rArr; tcp_output &rArr; tcp_output_segment &rArr; ip4_output_if &rArr; ip4_output_if_opt &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[bb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_recv_null
</UL>
<BR>[Called By]<UL><LI><a href="#[4fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_input
<LI><a href="#[6a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_fasttmr
</UL>

<P><STRONG><a name="[453]"></a>tcp_recv</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, .\build\lwip_tcp.o(i.tcp_recv))
<BR><BR>[Called By]<UL><LI><a href="#[451]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;setup_tcp
<LI><a href="#[551]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_netconn_do_close_internal
<LI><a href="#[6f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;accept_function
</UL>

<P><STRONG><a name="[bb]"></a>tcp_recv_null</STRONG> (Thumb, 46 bytes, Stack size 24 bytes, .\build\lwip_tcp.o(i.tcp_recv_null))
<BR><BR>[Stack]<UL><LI>Max Depth = 1016 + Unknown Stack Size
<LI>Call Chain = tcp_recv_null &rArr; tcp_close &rArr; tcp_close_shutdown &rArr; tcp_pcb_remove &rArr; tcp_output &rArr; tcp_output_segment &rArr; ip4_output_if &rArr; ip4_output_if_opt &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[55e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_recved
<LI><a href="#[556]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_close
<LI><a href="#[46b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_free
</UL>
<BR>[Called By]<UL><LI><a href="#[4fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_input
<LI><a href="#[6a9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_process_refused_data
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lwip_tcp.o(i.tcp_alloc)
</UL>
<P><STRONG><a name="[55e]"></a>tcp_recved</STRONG> (Thumb, 84 bytes, Stack size 16 bytes, .\build\lwip_tcp.o(i.tcp_recved))
<BR><BR>[Stack]<UL><LI>Max Depth = 960 + Unknown Stack Size
<LI>Call Chain = tcp_recved &rArr; tcp_output &rArr; tcp_output_segment &rArr; ip4_output_if &rArr; ip4_output_if_opt &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[562]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_output
<LI><a href="#[6b9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_update_rcv_ann_wnd
</UL>
<BR>[Called By]<UL><LI><a href="#[b3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;recv_tcp
<LI><a href="#[550]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netconn_drain
<LI><a href="#[7e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_netconn_do_recv
<LI><a href="#[bb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_recv_null
</UL>

<P><STRONG><a name="[6b7]"></a>tcp_rexmit</STRONG> (Thumb, 88 bytes, Stack size 24 bytes, .\build\lwip_tcp_out.o(i.tcp_rexmit))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = tcp_rexmit
</UL>
<BR>[Calls]<UL><LI><a href="#[490]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_htonl
</UL>
<BR>[Called By]<UL><LI><a href="#[6b8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_rexmit_fast
<LI><a href="#[6ad]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_process
</UL>

<P><STRONG><a name="[6b8]"></a>tcp_rexmit_fast</STRONG> (Thumb, 110 bytes, Stack size 8 bytes, .\build\lwip_tcp_out.o(i.tcp_rexmit_fast))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = tcp_rexmit_fast &rArr; tcp_rexmit
</UL>
<BR>[Calls]<UL><LI><a href="#[6b7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_rexmit
</UL>
<BR>[Called By]<UL><LI><a href="#[6b6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_receive
</UL>

<P><STRONG><a name="[6b5]"></a>tcp_rexmit_rto</STRONG> (Thumb, 66 bytes, Stack size 16 bytes, .\build\lwip_tcp_out.o(i.tcp_rexmit_rto))
<BR><BR>[Stack]<UL><LI>Max Depth = 960 + Unknown Stack Size
<LI>Call Chain = tcp_rexmit_rto &rArr; tcp_output &rArr; tcp_output_segment &rArr; ip4_output_if &rArr; ip4_output_if_opt &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[562]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_output
</UL>
<BR>[Called By]<UL><LI><a href="#[6ad]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_process
<LI><a href="#[6ba]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_slowtmr
</UL>

<P><STRONG><a name="[696]"></a>tcp_rst</STRONG> (Thumb, 148 bytes, Stack size 48 bytes, .\build\lwip_tcp_out.o(i.tcp_rst))
<BR><BR>[Stack]<UL><LI>Max Depth = 904 + Unknown Stack Size
<LI>Call Chain = tcp_rst &rArr; ip4_output_if &rArr; ip4_output_if_opt &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[48e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_htons
<LI><a href="#[490]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_htonl
<LI><a href="#[46a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_alloc
<LI><a href="#[505]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip_chksum_pseudo
<LI><a href="#[4d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip4_route
<LI><a href="#[4d7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip4_output_if
<LI><a href="#[46b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_free
</UL>
<BR>[Called By]<UL><LI><a href="#[4fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_input
<LI><a href="#[6aa]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_timewait_input
<LI><a href="#[6ad]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_process
<LI><a href="#[6ab]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_listen_input
<LI><a href="#[6ba]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_slowtmr
<LI><a href="#[693]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_abandon
<LI><a href="#[69d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_close_shutdown
</UL>

<P><STRONG><a name="[6a7]"></a>tcp_seg_free</STRONG> (Thumb, 26 bytes, Stack size 8 bytes, .\build\lwip_tcp.o(i.tcp_seg_free))
<BR><BR>[Stack]<UL><LI>Max Depth = 544 + Unknown Stack Size
<LI>Call Chain = tcp_seg_free &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[46b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_free
<LI><a href="#[4e7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memp_free
</UL>
<BR>[Called By]<UL><LI><a href="#[562]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_output
<LI><a href="#[6a6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_create_segment
<LI><a href="#[6b6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_receive
<LI><a href="#[6ad]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_process
<LI><a href="#[695]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_segs_free
</UL>

<P><STRONG><a name="[695]"></a>tcp_segs_free</STRONG> (Thumb, 24 bytes, Stack size 16 bytes, .\build\lwip_tcp.o(i.tcp_segs_free))
<BR><BR>[Stack]<UL><LI>Max Depth = 560 + Unknown Stack Size
<LI>Call Chain = tcp_segs_free &rArr; tcp_seg_free &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[6a7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_seg_free
</UL>
<BR>[Called By]<UL><LI><a href="#[561]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_write
<LI><a href="#[69e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_pcb_purge
<LI><a href="#[693]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_abandon
</UL>

<P><STRONG><a name="[6ac]"></a>tcp_send_empty_ack</STRONG> (Thumb, 142 bytes, Stack size 48 bytes, .\build\lwip_tcp_out.o(i.tcp_send_empty_ack))
<BR><BR>[Stack]<UL><LI>Max Depth = 904 + Unknown Stack Size
<LI>Call Chain = tcp_send_empty_ack &rArr; ip4_output_if &rArr; ip4_output_if_opt &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[490]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_htonl
<LI><a href="#[505]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip_chksum_pseudo
<LI><a href="#[4d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip4_route
<LI><a href="#[4d7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip4_output_if
<LI><a href="#[46b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_free
<LI><a href="#[6af]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_output_alloc_header
</UL>
<BR>[Called By]<UL><LI><a href="#[562]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_output
<LI><a href="#[4fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_input
<LI><a href="#[6b6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_receive
</UL>

<P><STRONG><a name="[6a2]"></a>tcp_send_fin</STRONG> (Thumb, 74 bytes, Stack size 16 bytes, .\build\lwip_tcp_out.o(i.tcp_send_fin))
<BR><BR>[Stack]<UL><LI>Max Depth = 632 + Unknown Stack Size
<LI>Call Chain = tcp_send_fin &rArr; tcp_enqueue_flags &rArr; tcp_create_segment &rArr; tcp_seg_free &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[48e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_htons
<LI><a href="#[6a5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_enqueue_flags
</UL>
<BR>[Called By]<UL><LI><a href="#[6a1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_close_shutdown_fin
</UL>

<P><STRONG><a name="[454]"></a>tcp_sent</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, .\build\lwip_tcp.o(i.tcp_sent))
<BR><BR>[Called By]<UL><LI><a href="#[451]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;setup_tcp
<LI><a href="#[551]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_netconn_do_close_internal
<LI><a href="#[6f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;accept_function
</UL>

<P><STRONG><a name="[557]"></a>tcp_shutdown</STRONG> (Thumb, 98 bytes, Stack size 16 bytes, .\build\lwip_tcp.o(i.tcp_shutdown))
<BR><BR>[Stack]<UL><LI>Max Depth = 1000 + Unknown Stack Size
<LI>Call Chain = tcp_shutdown &rArr; tcp_close_shutdown &rArr; tcp_pcb_remove &rArr; tcp_output &rArr; tcp_output_segment &rArr; ip4_output_if &rArr; ip4_output_if_opt &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[46b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_free
<LI><a href="#[69d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_close_shutdown
</UL>
<BR>[Called By]<UL><LI><a href="#[551]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_netconn_do_close_internal
</UL>

<P><STRONG><a name="[6ba]"></a>tcp_slowtmr</STRONG> (Thumb, 798 bytes, Stack size 56 bytes, .\build\lwip_tcp.o(i.tcp_slowtmr))
<BR><BR>[Stack]<UL><LI>Max Depth = 1016 + Unknown Stack Size
<LI>Call Chain = tcp_slowtmr &rArr; tcp_rexmit_rto &rArr; tcp_output &rArr; tcp_output_segment &rArr; ip4_output_if &rArr; ip4_output_if_opt &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[562]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_output
<LI><a href="#[4e7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memp_free
<LI><a href="#[6bb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_zero_window_probe
<LI><a href="#[696]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_rst
<LI><a href="#[6b5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_rexmit_rto
<LI><a href="#[6ae]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_keepalive
<LI><a href="#[69e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_pcb_purge
</UL>
<BR>[Called By]<UL><LI><a href="#[10a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_tmr
</UL>

<P><STRONG><a name="[69c]"></a>tcp_timer_needed</STRONG> (Thumb, 38 bytes, Stack size 8 bytes, .\build\lwip_timeouts.o(i.tcp_timer_needed))
<BR><BR>[Stack]<UL><LI>Max Depth = 616 + Unknown Stack Size
<LI>Call Chain = tcp_timer_needed &rArr; sys_timeout &rArr; sys_now &rArr; us_ticker_read &rArr; us_ticker_init &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[2c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_timeout
</UL>
<BR>[Called By]<UL><LI><a href="#[55b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_listen_with_backlog_and_err
<LI><a href="#[55a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_connect
<LI><a href="#[54f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_bind
<LI><a href="#[6ad]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_process
<LI><a href="#[6ab]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_listen_input
<LI><a href="#[69d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_close_shutdown
</UL>

<P><STRONG><a name="[10a]"></a>tcp_tmr</STRONG> (Thumb, 30 bytes, Stack size 8 bytes, .\build\lwip_tcp.o(i.tcp_tmr))
<BR><BR>[Stack]<UL><LI>Max Depth = 1064 + Unknown Stack Size
<LI>Call Chain = tcp_tmr &rArr; tcp_fasttmr &rArr; tcp_process_refused_data &rArr; tcp_recv_null &rArr; tcp_close &rArr; tcp_close_shutdown &rArr; tcp_pcb_remove &rArr; tcp_output &rArr; tcp_output_segment &rArr; ip4_output_if &rArr; ip4_output_if_opt &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[6ba]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_slowtmr
<LI><a href="#[6a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_fasttmr
</UL>
<BR>[Called By]<UL><LI><a href="#[bd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcpip_tcp_timer
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lwip_timeouts.o(.constdata)
</UL>
<P><STRONG><a name="[69f]"></a>tcp_trigger_input_pcb_close</STRONG> (Thumb, 14 bytes, Stack size 0 bytes, .\build\lwip_tcp_in.o(i.tcp_trigger_input_pcb_close))
<BR><BR>[Called By]<UL><LI><a href="#[69d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_close_shutdown
</UL>

<P><STRONG><a name="[6b9]"></a>tcp_update_rcv_ann_wnd</STRONG> (Thumb, 74 bytes, Stack size 8 bytes, .\build\lwip_tcp.o(i.tcp_update_rcv_ann_wnd))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = tcp_update_rcv_ann_wnd
</UL>
<BR>[Called By]<UL><LI><a href="#[55e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_recved
<LI><a href="#[6b6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_receive
</UL>

<P><STRONG><a name="[561]"></a>tcp_write</STRONG> (Thumb, 812 bytes, Stack size 104 bytes, .\build\lwip_tcp_out.o(i.tcp_write))
<BR><BR>[Stack]<UL><LI>Max Depth = 688 + Unknown Stack Size
<LI>Call Chain = tcp_write &rArr; tcp_create_segment &rArr; tcp_seg_free &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[48e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_htons
<LI><a href="#[46a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_alloc
<LI><a href="#[46b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_free
<LI><a href="#[500]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_clen
<LI><a href="#[4f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_cat
<LI><a href="#[6bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_write_checks
<LI><a href="#[6a6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_create_segment
<LI><a href="#[695]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_segs_free
<LI><a href="#[249]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Called By]<UL><LI><a href="#[560]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_netconn_do_writemore
</UL>

<P><STRONG><a name="[6bb]"></a>tcp_zero_window_probe</STRONG> (Thumb, 238 bytes, Stack size 56 bytes, .\build\lwip_tcp_out.o(i.tcp_zero_window_probe))
<BR><BR>[Stack]<UL><LI>Max Depth = 912 + Unknown Stack Size
<LI>Call Chain = tcp_zero_window_probe &rArr; ip4_output_if &rArr; ip4_output_if_opt &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[48d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_copy_partial
<LI><a href="#[48e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_htons
<LI><a href="#[490]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_htonl
<LI><a href="#[505]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip_chksum_pseudo
<LI><a href="#[4d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip4_route
<LI><a href="#[4d7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip4_output_if
<LI><a href="#[46b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_free
<LI><a href="#[6af]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_output_alloc_header
</UL>
<BR>[Called By]<UL><LI><a href="#[6ba]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_slowtmr
</UL>

<P><STRONG><a name="[5a1]"></a>tcpip_callback_with_block</STRONG> (Thumb, 76 bytes, Stack size 24 bytes, .\build\lwip_tcpip.o(i.tcpip_callback_with_block))
<BR><BR>[Stack]<UL><LI>Max Depth = 528 + Unknown Stack Size
<LI>Call Chain = tcpip_callback_with_block &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[44f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_mbox_trypost
<LI><a href="#[4e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memp_malloc
<LI><a href="#[4e7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memp_free
<LI><a href="#[68f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_mbox_post
</UL>
<BR>[Called By]<UL><LI><a href="#[57e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netconn_gethostbyname
<LI><a href="#[416]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pppos_input
</UL>

<P><STRONG><a name="[57c]"></a>tcpip_init</STRONG> (Thumb, 52 bytes, Stack size 16 bytes, .\build\lwip_tcpip.o(i.tcpip_init))
<BR><BR>[Stack]<UL><LI>Max Depth = 728 + Unknown Stack Size
<LI>Call Chain = tcpip_init &rArr; lwip_init &rArr; ppp_init &rArr; magic_init &rArr; magic_churnrand &rArr; sys_jiffies &rArr; us_ticker_read &rArr; us_ticker_init &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[55c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_mbox_new
<LI><a href="#[543]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_init
<LI><a href="#[595]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_mutex_new
<LI><a href="#[690]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_thread_new
</UL>
<BR>[Called By]<UL><LI><a href="#[571]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_core_init
</UL>

<P><STRONG><a name="[59d]"></a>tcpip_send_msg_wait_sem</STRONG> (Thumb, 28 bytes, Stack size 16 bytes, .\build\lwip_tcpip.o(i.tcpip_send_msg_wait_sem))
<BR><BR>[Stack]<UL><LI>Max Depth = 480 + Unknown Stack Size
<LI>Call Chain = tcpip_send_msg_wait_sem &rArr; sys_mutex_unlock &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[552]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_mutex_unlock
<LI><a href="#[554]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_mutex_lock
</UL>
<BR>[Called By]<UL><LI><a href="#[59c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netconn_apimsg
</UL>

<P><STRONG><a name="[2a7]"></a>thread_terminate_hook</STRONG> (Thumb, 20 bytes, Stack size 8 bytes, .\build\thread.o(i.thread_terminate_hook))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = thread_terminate_hook
</UL>
<BR>[Called By]<UL><LI><a href="#[2a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxThreadTerminate
<LI><a href="#[2a5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxThreadExit
</UL>

<P><STRONG><a name="[34f]"></a>ticker_insert_event_us</STRONG> (Thumb, 104 bytes, Stack size 32 bytes, .\build\mbed_ticker_api.o(i.ticker_insert_event_us))
<BR><BR>[Stack]<UL><LI>Max Depth = 168<LI>Call Chain = ticker_insert_event_us &rArr; schedule_interrupt &rArr; update_present_time &rArr; __aeabi_uldivmod
</UL>
<BR>[Calls]<UL><LI><a href="#[311]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;core_util_critical_section_exit
<LI><a href="#[30c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;core_util_critical_section_enter
<LI><a href="#[4f1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;update_present_time
<LI><a href="#[4f2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;schedule_interrupt
</UL>
<BR>[Called By]<UL><LI><a href="#[34e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::TimerEvent::insert_absolute(unsigned long long)
</UL>

<P><STRONG><a name="[e]"></a>ticker_irq_handler</STRONG> (Thumb, 98 bytes, Stack size 16 bytes, .\build\mbed_ticker_api.o(i.ticker_irq_handler))
<BR><BR>[Stack]<UL><LI>Max Depth = 152<LI>Call Chain = ticker_irq_handler &rArr; schedule_interrupt &rArr; update_present_time &rArr; __aeabi_uldivmod
</UL>
<BR>[Calls]<UL><LI><a href="#[311]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;core_util_critical_section_exit
<LI><a href="#[30c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;core_util_critical_section_enter
<LI><a href="#[4f1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;update_present_time
<LI><a href="#[4f2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;schedule_interrupt
</UL>
<BR>[Address Reference Count : 2]<UL><LI> mbed_lp_ticker_api.o(.data)
<LI> mbed_us_ticker_api.o(.data)
</UL>
<P><STRONG><a name="[6bd]"></a>ticker_read</STRONG> (Thumb, 12 bytes, Stack size 8 bytes, .\build\mbed_ticker_api.o(i.ticker_read))
<BR><BR>[Stack]<UL><LI>Max Depth = 200<LI>Call Chain = ticker_read &rArr; ticker_read_us &rArr; initialize &rArr;  mbed_assert_internal (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[3e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ticker_read_us
</UL>
<BR>[Called By]<UL><LI><a href="#[6ca]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;wait_us
</UL>

<P><STRONG><a name="[3e0]"></a>ticker_read_us</STRONG> (Thumb, 32 bytes, Stack size 8 bytes, .\build\mbed_ticker_api.o(i.ticker_read_us))
<BR><BR>[Stack]<UL><LI>Max Depth = 192<LI>Call Chain = ticker_read_us &rArr; initialize &rArr;  mbed_assert_internal (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[311]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;core_util_critical_section_exit
<LI><a href="#[30c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;core_util_critical_section_enter
<LI><a href="#[4f1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;update_present_time
<LI><a href="#[4ef]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;initialize
</UL>
<BR>[Called By]<UL><LI><a href="#[3e7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Ticker::setup(unsigned long long)
<LI><a href="#[317]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Timer::reset()
<LI><a href="#[308]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Timer::start()
<LI><a href="#[2cd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::internal::SysTimer::SysTimer()
<LI><a href="#[30f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::internal::SysTimer::update_tick()
<LI><a href="#[6bd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ticker_read
<LI><a href="#[3df]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Timer::slicetime()
</UL>

<P><STRONG><a name="[351]"></a>ticker_remove_event</STRONG> (Thumb, 66 bytes, Stack size 16 bytes, .\build\mbed_ticker_api.o(i.ticker_remove_event))
<BR><BR>[Stack]<UL><LI>Max Depth = 152<LI>Call Chain = ticker_remove_event &rArr; schedule_interrupt &rArr; update_present_time &rArr; __aeabi_uldivmod
</UL>
<BR>[Calls]<UL><LI><a href="#[311]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;core_util_critical_section_exit
<LI><a href="#[30c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;core_util_critical_section_enter
<LI><a href="#[4f2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;schedule_interrupt
</UL>
<BR>[Called By]<UL><LI><a href="#[350]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::TimerEvent::remove()
</UL>

<P><STRONG><a name="[353]"></a>ticker_set_handler</STRONG> (Thumb, 30 bytes, Stack size 16 bytes, .\build\mbed_ticker_api.o(i.ticker_set_handler))
<BR><BR>[Stack]<UL><LI>Max Depth = 200<LI>Call Chain = ticker_set_handler &rArr; initialize &rArr;  mbed_assert_internal (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[311]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;core_util_critical_section_exit
<LI><a href="#[30c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;core_util_critical_section_enter
<LI><a href="#[6be]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;set_handler
<LI><a href="#[4ef]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;initialize
</UL>
<BR>[Called By]<UL><LI><a href="#[307]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::TimerEvent::TimerEvent__sub_object()
<LI><a href="#[352]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::TimerEvent::TimerEvent__sub_object(const ticker_data_t*)
</UL>

<P><STRONG><a name="[47d]"></a>udp_bind</STRONG> (Thumb, 154 bytes, Stack size 24 bytes, .\build\lwip_udp.o(i.udp_bind))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = udp_bind &rArr; udp_new_port
</UL>
<BR>[Calls]<UL><LI><a href="#[6bf]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_new_port
</UL>
<BR>[Called By]<UL><LI><a href="#[47a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dns_alloc_random_port
<LI><a href="#[559]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_connect
<LI><a href="#[76]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_netconn_do_bind
<LI><a href="#[6c3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_sendto_if_src
</UL>

<P><STRONG><a name="[559]"></a>udp_connect</STRONG> (Thumb, 104 bytes, Stack size 24 bytes, .\build\lwip_udp.o(i.udp_connect))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = udp_connect &rArr; udp_bind &rArr; udp_new_port
</UL>
<BR>[Calls]<UL><LI><a href="#[47d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_bind
</UL>
<BR>[Called By]<UL><LI><a href="#[78]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_netconn_do_connect
</UL>

<P><STRONG><a name="[548]"></a>udp_init</STRONG> (Thumb, 20 bytes, Stack size 8 bytes, .\build\lwip_udp.o(i.udp_init))
<BR><BR>[Stack]<UL><LI>Max Depth = 88<LI>Call Chain = udp_init &rArr; lwip_get_random &rArr; randLIB_get_32bit &rArr; randLIB_get_64bit &rArr; rol
</UL>
<BR>[Calls]<UL><LI><a href="#[47c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_get_random
</UL>
<BR>[Called By]<UL><LI><a href="#[543]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_init
</UL>

<P><STRONG><a name="[4fb]"></a>udp_input</STRONG> (Thumb, 348 bytes, Stack size 56 bytes, .\build\lwip_udp.o(i.udp_input))
<BR><BR>[Stack]<UL><LI>Max Depth = 976 + Unknown Stack Size
<LI>Call Chain = udp_input &rArr; icmp_dest_unreach &rArr; icmp_send_response &rArr; ip4_output_if &rArr; ip4_output_if_opt &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[48e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_htons
<LI><a href="#[505]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip_chksum_pseudo
<LI><a href="#[4d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_header
<LI><a href="#[4d2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip4_addr_isbroadcast_u32
<LI><a href="#[4cf]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;icmp_dest_unreach
<LI><a href="#[46b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_free
<LI><a href="#[4fd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_header_force
<LI><a href="#[6c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_input_local_match
</UL>
<BR>[Called By]<UL><LI><a href="#[4f9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip4_input
</UL>

<P><STRONG><a name="[5aa]"></a>udp_netif_ip_addr_changed</STRONG> (Thumb, 42 bytes, Stack size 8 bytes, .\build\lwip_udp.o(i.udp_netif_ip_addr_changed))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = udp_netif_ip_addr_changed
</UL>
<BR>[Called By]<UL><LI><a href="#[5a6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netif_set_ipaddr
</UL>

<P><STRONG><a name="[6c1]"></a>udp_new</STRONG> (Thumb, 34 bytes, Stack size 8 bytes, .\build\lwip_udp.o(i.udp_new))
<BR><BR>[Stack]<UL><LI>Max Depth = 504 + Unknown Stack Size
<LI>Call Chain = udp_new &rArr; memp_malloc &rArr; do_memp_malloc_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[4e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memp_malloc
<LI><a href="#[23c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memclr4
</UL>
<BR>[Called By]<UL><LI><a href="#[47b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_new_ip_type
</UL>

<P><STRONG><a name="[47b]"></a>udp_new_ip_type</STRONG> (Thumb, 14 bytes, Stack size 16 bytes, .\build\lwip_udp.o(i.udp_new_ip_type))
<BR><BR>[Stack]<UL><LI>Max Depth = 520 + Unknown Stack Size
<LI>Call Chain = udp_new_ip_type &rArr; udp_new &rArr; memp_malloc &rArr; do_memp_malloc_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[6c1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_new
</UL>
<BR>[Called By]<UL><LI><a href="#[47a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dns_alloc_random_port
<LI><a href="#[55d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pcb_new
</UL>

<P><STRONG><a name="[47f]"></a>udp_recv</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, .\build\lwip_udp.o(i.udp_recv))
<BR><BR>[Called By]<UL><LI><a href="#[47a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dns_alloc_random_port
<LI><a href="#[55d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pcb_new
</UL>

<P><STRONG><a name="[47e]"></a>udp_remove</STRONG> (Thumb, 64 bytes, Stack size 16 bytes, .\build\lwip_udp.o(i.udp_remove))
<BR><BR>[Stack]<UL><LI>Max Depth = 520 + Unknown Stack Size
<LI>Call Chain = udp_remove &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[4e7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memp_free
</UL>
<BR>[Called By]<UL><LI><a href="#[480]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dns_call_found
<LI><a href="#[47a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dns_alloc_random_port
<LI><a href="#[79]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_netconn_do_delconn
</UL>

<P><STRONG><a name="[55f]"></a>udp_send</STRONG> (Thumb, 30 bytes, Stack size 16 bytes, .\build\lwip_udp.o(i.udp_send))
<BR><BR>[Stack]<UL><LI>Max Depth = 936 + Unknown Stack Size
<LI>Call Chain = udp_send &rArr; udp_sendto &rArr; udp_sendto_if &rArr; udp_sendto_if_src &rArr; ip4_output_if_src &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[494]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_sendto
</UL>
<BR>[Called By]<UL><LI><a href="#[7f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_netconn_do_send
</UL>

<P><STRONG><a name="[494]"></a>udp_sendto</STRONG> (Thumb, 88 bytes, Stack size 32 bytes, .\build\lwip_udp.o(i.udp_sendto))
<BR><BR>[Stack]<UL><LI>Max Depth = 920 + Unknown Stack Size
<LI>Call Chain = udp_sendto &rArr; udp_sendto_if &rArr; udp_sendto_if_src &rArr; ip4_output_if_src &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[4d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip4_route
<LI><a href="#[6c2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_sendto_if
</UL>
<BR>[Called By]<UL><LI><a href="#[484]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dns_send
<LI><a href="#[55f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_send
<LI><a href="#[7f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_netconn_do_send
</UL>

<P><STRONG><a name="[6c2]"></a>udp_sendto_if</STRONG> (Thumb, 82 bytes, Stack size 40 bytes, .\build\lwip_udp.o(i.udp_sendto_if))
<BR><BR>[Stack]<UL><LI>Max Depth = 888 + Unknown Stack Size
<LI>Call Chain = udp_sendto_if &rArr; udp_sendto_if_src &rArr; ip4_output_if_src &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[6c3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_sendto_if_src
</UL>
<BR>[Called By]<UL><LI><a href="#[494]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_sendto
</UL>

<P><STRONG><a name="[6c3]"></a>udp_sendto_if_src</STRONG> (Thumb, 278 bytes, Stack size 56 bytes, .\build\lwip_udp.o(i.udp_sendto_if_src))
<BR><BR>[Stack]<UL><LI>Max Depth = 848 + Unknown Stack Size
<LI>Call Chain = udp_sendto_if_src &rArr; ip4_output_if_src &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[48e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_htons
<LI><a href="#[46a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_alloc
<LI><a href="#[47d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_bind
<LI><a href="#[505]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip_chksum_pseudo
<LI><a href="#[4d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_header
<LI><a href="#[46b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_free
<LI><a href="#[4ff]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip4_output_if_src
<LI><a href="#[623]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_chain
</UL>
<BR>[Called By]<UL><LI><a href="#[6c2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_sendto_if
</UL>

<P><STRONG><a name="[538]"></a>upper_layers_down</STRONG> (Thumb, 72 bytes, Stack size 16 bytes, .\build\lwip_auth.o(i.upper_layers_down))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = upper_layers_down
</UL>
<BR>[Called By]<UL><LI><a href="#[525]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;link_down
</UL>

<P><STRONG><a name="[118]"></a>us_ticker_clear_interrupt</STRONG> (Thumb, 12 bytes, Stack size 8 bytes, .\build\us_ticker.o(i.us_ticker_clear_interrupt))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = us_ticker_clear_interrupt
</UL>
<BR>[Calls]<UL><LI><a href="#[6c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TIMER_IntClear
</UL>
<BR>[Address Reference Count : 1]<UL><LI> mbed_us_ticker_api.o(.constdata)
</UL>
<P><STRONG><a name="[117]"></a>us_ticker_disable_interrupt</STRONG> (Thumb, 12 bytes, Stack size 8 bytes, .\build\us_ticker.o(i.us_ticker_disable_interrupt))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = us_ticker_disable_interrupt
</UL>
<BR>[Calls]<UL><LI><a href="#[6c5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TIMER_IntDisable
</UL>
<BR>[Address Reference Count : 1]<UL><LI> mbed_us_ticker_api.o(.constdata)
</UL>
<P><STRONG><a name="[11a]"></a>us_ticker_fire_interrupt</STRONG> (Thumb, 40 bytes, Stack size 0 bytes, .\build\us_ticker.o(i.us_ticker_fire_interrupt))
<BR>[Address Reference Count : 1]<UL><LI> mbed_us_ticker_api.o(.constdata)
</UL>
<P><STRONG><a name="[11b]"></a>us_ticker_get_info</STRONG> (Thumb, 4 bytes, Stack size 0 bytes, .\build\mbed_retarget.o(i.us_ticker_get_info))
<BR>[Address Reference Count : 1]<UL><LI> mbed_us_ticker_api.o(.constdata)
</UL>
<P><STRONG><a name="[115]"></a>us_ticker_init</STRONG> (Thumb, 286 bytes, Stack size 24 bytes, .\build\us_ticker.o(i.us_ticker_init))
<BR><BR>[Stack]<UL><LI>Max Depth = 552 + Unknown Stack Size
<LI>Call Chain = us_ticker_init &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[33a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_assert_internal
<LI><a href="#[28b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CMU_ClockEnable
<LI><a href="#[2d6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TIMER_InitCC
<LI><a href="#[6c6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TIMER_IntEnable
</UL>
<BR>[Called By]<UL><LI><a href="#[116]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;us_ticker_read
</UL>
<BR>[Address Reference Count : 1]<UL><LI> mbed_us_ticker_api.o(.constdata)
</UL>
<P><STRONG><a name="[6c8]"></a>us_ticker_irq_handler</STRONG> (Thumb, 18 bytes, Stack size 8 bytes, .\build\mbed_us_ticker_api.o(i.us_ticker_irq_handler))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = us_ticker_irq_handler
</UL>
<BR>[Called By]<UL><LI><a href="#[bf]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;us_ticker_irq_handler_internal
</UL>

<P><STRONG><a name="[bf]"></a>us_ticker_irq_handler_internal</STRONG> (Thumb, 94 bytes, Stack size 8 bytes, .\build\us_ticker.o(i.us_ticker_irq_handler_internal))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = us_ticker_irq_handler_internal &rArr; us_ticker_irq_handler
</UL>
<BR>[Calls]<UL><LI><a href="#[6c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;us_ticker_irq_handler
<LI><a href="#[6c7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TIMER_IntGet
<LI><a href="#[6c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TIMER_IntClear
</UL>
<BR>[Address Reference Count : 1]<UL><LI> us_ticker.o(i.us_ticker_init)
</UL>
<P><STRONG><a name="[116]"></a>us_ticker_read</STRONG> (Thumb, 92 bytes, Stack size 16 bytes, .\build\us_ticker.o(i.us_ticker_read))
<BR><BR>[Stack]<UL><LI>Max Depth = 568 + Unknown Stack Size
<LI>Call Chain = us_ticker_read &rArr; us_ticker_init &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[115]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;us_ticker_init
<LI><a href="#[6c7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TIMER_IntGet
</UL>
<BR>[Called By]<UL><LI><a href="#[553]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_sem_wait
<LI><a href="#[59b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_mbox_fetch
<LI><a href="#[544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_init
<LI><a href="#[567]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_jiffies
<LI><a href="#[542]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_now
<LI><a href="#[119]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;us_ticker_set_interrupt
</UL>
<BR>[Address Reference Count : 1]<UL><LI> mbed_us_ticker_api.o(.constdata)
</UL>
<P><STRONG><a name="[119]"></a>us_ticker_set_interrupt</STRONG> (Thumb, 192 bytes, Stack size 24 bytes, .\build\us_ticker.o(i.us_ticker_set_interrupt))
<BR><BR>[Stack]<UL><LI>Max Depth = 592 + Unknown Stack Size
<LI>Call Chain = us_ticker_set_interrupt &rArr; us_ticker_read &rArr; us_ticker_init &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[116]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;us_ticker_read
<LI><a href="#[6c6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TIMER_IntEnable
<LI><a href="#[6c5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TIMER_IntDisable
<LI><a href="#[6c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TIMER_IntClear
<LI><a href="#[6c9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TIMER_CompareSet
</UL>
<BR>[Address Reference Count : 1]<UL><LI> mbed_us_ticker_api.o(.constdata)
</UL>
<P><STRONG><a name="[324]"></a>wait</STRONG> (Thumb, 36 bytes, Stack size 16 bytes, .\build\mbed_wait_api_rtos.o(i.wait))
<BR><BR>[Stack]<UL><LI>Max Depth = 504 + Unknown Stack Size
<LI>Call Chain = wait &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[6ca]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;wait_us
</UL>
<BR>[Called By]<UL><LI><a href="#[187]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::EasyCellularConnection::connect()
<LI><a href="#[70]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dot_event()
</UL>

<P><STRONG><a name="[56b]"></a>wait_ms</STRONG> (Thumb, 18 bytes, Stack size 8 bytes, .\build\mbed_wait_api_rtos.o(i.wait_ms))
<BR><BR>[Stack]<UL><LI>Max Depth = 496 + Unknown Stack Size
<LI>Call Chain = wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[6ca]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;wait_us
</UL>
<BR>[Called By]<UL><LI><a href="#[4b3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_die
</UL>

<P><STRONG><a name="[6ca]"></a>wait_us</STRONG> (Thumb, 70 bytes, Stack size 24 bytes, .\build\mbed_wait_api_rtos.o(i.wait_us))
<BR><BR>[Stack]<UL><LI>Max Depth = 488 + Unknown Stack Size
<LI>Call Chain = wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[340]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sleep_manager_lock_deep_sleep_internal
<LI><a href="#[33e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sleep_manager_unlock_deep_sleep_internal
<LI><a href="#[6cb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;core_util_are_interrupts_enabled
<LI><a href="#[35e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Thread::wait(unsigned)
<LI><a href="#[6bd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ticker_read
<LI><a href="#[354]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;get_us_ticker_data
</UL>
<BR>[Called By]<UL><LI><a href="#[56b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;wait_ms
<LI><a href="#[324]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;wait
</UL>

<P><STRONG><a name="[44e]"></a>write</STRONG> (Thumb, 72 bytes, Stack size 24 bytes, .\build\mbed_retarget.o(i.write))
<BR><BR>[Stack]<UL><LI>Max Depth = 296<LI>Call Chain = write &rArr; get_fhc(int) &rArr; get_console(int) &rArr; default_console() &rArr; DirectSerial::DirectSerial(PinName, PinName, int) &rArr; serial_init &rArr; uart_init &rArr; serial_baud &rArr; serial_leuart_baud &rArr;  mbed_assert_internal (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[321]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;get_fhc(int)
<LI><a href="#[218]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_errno_addr
</UL>
<BR>[Called By]<UL><LI><a href="#[26a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_sys_write
</UL>

<P><STRONG><a name="[45]"></a>_get_lc_ctype</STRONG> (Thumb, 44 bytes, Stack size 8 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(lc_ctype_c.o)(locale$$code))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = _get_lc_ctype
</UL>
<BR>[Calls]<UL><LI><a href="#[396]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;strcmp
</UL>
<BR>[Called By]<UL><LI><a href="#[208]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init_lc_ctype_2
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rt_ctype_table.o(.text)
</UL>
<P><STRONG><a name="[20a]"></a>_get_lc_numeric</STRONG> (Thumb, 44 bytes, Stack size 8 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(lc_numeric_c.o)(locale$$code))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = _get_lc_numeric
</UL>
<BR>[Calls]<UL><LI><a href="#[396]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;strcmp
</UL>
<BR>[Called By]<UL><LI><a href="#[209]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init_lc_numeric_2
</UL>

<P><STRONG><a name="[2ee]"></a>NetworkStack* nsapi_create_stack&lang;mbed::EasyCellularConnection&rang;(T1*)</STRONG> (Thumb, 20 bytes, Stack size 16 bytes, .\build\main.o(t._Z18nsapi_create_stackIN4mbed22EasyCellularConnectionEEP12NetworkStackPT_))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = NetworkStack* nsapi_create_stack&lang;mbed::EasyCellularConnection&rang;(T1*)
</UL>
<BR>[Calls]<UL><LI><a href="#[6cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;nsapi_create_stack(NetworkStack*)
</UL>
<BR>[Called By]<UL><LI><a href="#[2ec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;test_send_recv()
</UL>

<P><STRONG><a name="[6cd]"></a>SingletonPtr&lang;rtos::Mutex&rang;::get()</STRONG> (Thumb, 66 bytes, Stack size 16 bytes, .\build\mbed_retarget.o(t._ZN12SingletonPtrIN4rtos5MutexEE3getEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 584 + Unknown Stack Size
<LI>Call Chain = SingletonPtr&lang;rtos::Mutex&rang;::get() &rArr; rtos::Mutex::Mutex() &rArr; rtos::Mutex::constructor(const char*) &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[33a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_assert_internal
<LI><a href="#[361]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Mutex::Mutex()
<LI><a href="#[30a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;singleton_unlock()
<LI><a href="#[2ea]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;singleton_lock()
</UL>
<BR>[Called By]<UL><LI><a href="#[31a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SingletonPtr&lang;rtos::Mutex&rang;::operator -&rang;()
</UL>

<P><STRONG><a name="[31a]"></a>SingletonPtr&lang;rtos::Mutex&rang;::operator -&rang;()</STRONG> (Thumb, 12 bytes, Stack size 8 bytes, .\build\fatfilesystem.o(t._ZN12SingletonPtrIN4rtos5MutexEEptEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 592 + Unknown Stack Size
<LI>Call Chain = SingletonPtr&lang;rtos::Mutex&rang;::operator -&rang;() &rArr; SingletonPtr&lang;rtos::Mutex&rang;::get() &rArr; rtos::Mutex::Mutex() &rArr; rtos::Mutex::constructor(const char*) &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[6cd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SingletonPtr&lang;rtos::Mutex&rang;::get()
</UL>
<BR>[Called By]<UL><LI><a href="#[393]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::remove_filehandle(mbed::FileHandle*)
<LI><a href="#[3e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::FileBase::FileBase(const char*, mbed::PathType)
<LI><a href="#[3ea]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::FileBase::lookup(const char*, unsigned)
<LI><a href="#[1aa]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::FileBase::~FileBase()
<LI><a href="#[319]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;reserve_filehandle()
</UL>

<P><STRONG><a name="[5b]"></a>mbed::Transaction&lang;mbed::SPI&rang;::Transaction()</STRONG> (Thumb, 28 bytes, Stack size 8 bytes, .\build\spi.o(t._ZN4mbed11TransactionINS_3SPIEEC1Ev))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = mbed::Transaction&lang;mbed::SPI&rang;::Transaction() &rArr; mbed::transaction_t::transaction_t() &rArr; mbed::Callback&lang;void(int)&rang;::Callback(void(*)(int))
</UL>
<BR>[Calls]<UL><LI><a href="#[36c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::transaction_t::transaction_t()
<LI><a href="#[23c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memclr4
</UL>
<BR>[Address Reference Count : 1]<UL><LI> spi.o(i.__sti___7_SPI_cpp_ab1f1164)
</UL>
<P><STRONG><a name="[787]"></a>mbed::Transaction&lang;mbed::SPI&rang;::Transaction__sub_object()</STRONG> (Thumb, 0 bytes, Stack size 8 bytes, .\build\spi.o(t._ZN4mbed11TransactionINS_3SPIEEC1Ev), UNUSED)

<P><STRONG><a name="[c0]"></a>mbed::Transaction&lang;mbed::SPI&rang;::~Transaction()</STRONG> (Thumb, 16 bytes, Stack size 8 bytes, .\build\spi.o(t._ZN4mbed11TransactionINS_3SPIEED1Ev))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = mbed::Transaction&lang;mbed::SPI&rang;::~Transaction() &rArr; mbed::transaction_t::~transaction_t() &rArr; mbed::Callback&lang;void(int)&rang;::~Callback()
</UL>
<BR>[Calls]<UL><LI><a href="#[36d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::transaction_t::~transaction_t()
</UL>
<BR>[Address Reference Count : 1]<UL><LI> spi.o(t._ZN4mbed14CircularBufferINS_11TransactionINS_3SPIEEELj4EjED1Ev)
</UL>
<P><STRONG><a name="[788]"></a>mbed::Transaction&lang;mbed::SPI&rang;::~Transaction__sub_object()</STRONG> (Thumb, 0 bytes, Stack size 8 bytes, .\build\spi.o(t._ZN4mbed11TransactionINS_3SPIEED1Ev), UNUSED)

<P><STRONG><a name="[5c]"></a>mbed::CircularBuffer&lang;mbed::Transaction&lang;mbed::SPI&rang;, (unsigned)4, unsigned&rang;::~CircularBuffer()</STRONG> (Thumb, 20 bytes, Stack size 8 bytes, .\build\spi.o(t._ZN4mbed14CircularBufferINS_11TransactionINS_3SPIEEELj4EjED1Ev))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = mbed::CircularBuffer&lang;mbed::Transaction&lang;mbed::SPI&rang;, (unsigned)4, unsigned&rang;::~CircularBuffer() &rArr; __aeabi_vec_dtor
</UL>
<BR>[Calls]<UL><LI><a href="#[34c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_vec_dtor
</UL>
<BR>[Address Reference Count : 1]<UL><LI> spi.o(i.__sti___7_SPI_cpp_ab1f1164)
</UL>
<P><STRONG><a name="[789]"></a>mbed::CircularBuffer&lang;mbed::Transaction&lang;mbed::SPI&rang;, (unsigned)4, unsigned&rang;::~CircularBuffer__sub_object()</STRONG> (Thumb, 0 bytes, Stack size 8 bytes, .\build\spi.o(t._ZN4mbed14CircularBufferINS_11TransactionINS_3SPIEEELj4EjED1Ev), UNUSED)

<P><STRONG><a name="[357]"></a>mbed::CircularBuffer&lang;char, (unsigned)256, unsigned&rang;::pop(char&)</STRONG> (Thumb, 60 bytes, Stack size 16 bytes, .\build\uartserial.o(t._ZN4mbed14CircularBufferIcLj256EjE3popERc))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = mbed::CircularBuffer&lang;char, (unsigned)256, unsigned&rang;::pop(char&) &rArr; mbed::CircularBuffer&lang;char, (unsigned)256, unsigned&rang;::empty() const &rArr; core_util_critical_section_exit &rArr; hal_critical_section_exit &rArr;  mbed_assert_internal (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[311]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;core_util_critical_section_exit
<LI><a href="#[30c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;core_util_critical_section_enter
<LI><a href="#[356]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::CircularBuffer&lang;char, (unsigned)256, unsigned&rang;::empty() const
</UL>
<BR>[Called By]<UL><LI><a href="#[11f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::UARTSerial::tx_irq()
<LI><a href="#[14c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::UARTSerial::read(void*, unsigned)
</UL>

<P><STRONG><a name="[35c]"></a>mbed::CircularBuffer&lang;char, (unsigned)256, unsigned&rang;::push(const char&)</STRONG> (Thumb, 86 bytes, Stack size 16 bytes, .\build\uartserial.o(t._ZN4mbed14CircularBufferIcLj256EjE4pushERKc))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = mbed::CircularBuffer&lang;char, (unsigned)256, unsigned&rang;::push(const char&) &rArr; mbed::CircularBuffer&lang;char, (unsigned)256, unsigned&rang;::full() const &rArr; core_util_critical_section_exit &rArr; hal_critical_section_exit &rArr;  mbed_assert_internal (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[311]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;core_util_critical_section_exit
<LI><a href="#[30c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;core_util_critical_section_enter
<LI><a href="#[358]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::CircularBuffer&lang;char, (unsigned)256, unsigned&rang;::full() const
</UL>
<BR>[Called By]<UL><LI><a href="#[120]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::UARTSerial::rx_irq()
<LI><a href="#[14b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::UARTSerial::write(const void*, unsigned)
</UL>

<P><STRONG><a name="[360]"></a>mbed::CircularBuffer&lang;char, (unsigned)256, unsigned&rang;::CircularBuffer()</STRONG> (Thumb, 16 bytes, Stack size 0 bytes, .\build\uartserial.o(t._ZN4mbed14CircularBufferIcLj256EjEC1Ev))
<BR><BR>[Called By]<UL><LI><a href="#[35f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::UARTSerial::UARTSerial(PinName, PinName, int)
</UL>

<P><STRONG><a name="[78a]"></a>mbed::CircularBuffer&lang;char, (unsigned)256, unsigned&rang;::CircularBuffer__sub_object()</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, .\build\uartserial.o(t._ZN4mbed14CircularBufferIcLj256EjEC1Ev), UNUSED)

<P><STRONG><a name="[1ae]"></a>bool mbed::Callback&lang;bool(int, int)&rang;::function_call&lang;mbed::Callback&lang;bool(int, int)&rang;::method_context&lang;mbed::EasyCellularConnection, bool(mbed::EasyCellularConnection::*)(int, int)&rang;&rang;(const void*, int, int)</STRONG> (Thumb, 62 bytes, Stack size 40 bytes, .\build\easycellularconnection.o(t._ZN4mbed8CallbackIFbiiEE13function_callINS2_14method_contextINS_22EasyCellularConnectionEMS5_FbiiEEEEEbPKvii))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = bool mbed::Callback&lang;bool(int, int)&rang;::function_call&lang;mbed::Callback&lang;bool(int, int)&rang;::method_context&lang;mbed::EasyCellularConnection, bool(mbed::EasyCellularConnection::*)(int, int)&rang;&rang;(const void*, int, int)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> easycellularconnection.o(.constdata__ZZN4mbed8CallbackIFbiiEE8generateINS2_14method_contextINS_22EasyCellularConnectionEMS5_FbiiEEEEEvRKT_E3ops)
</UL>
<P><STRONG><a name="[1b1]"></a>bool mbed::Callback&lang;bool(int, int)&rang;::function_call&lang;bool(*)(int, int)&rang;(const void*, int, int)</STRONG> (Thumb, 18 bytes, Stack size 16 bytes, .\build\cellularconnectionfsm.o(t._ZN4mbed8CallbackIFbiiEE13function_callIPS1_EEbPKvii))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = bool mbed::Callback&lang;bool(int, int)&rang;::function_call&lang;bool(*)(int, int)&rang;(const void*, int, int)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> cellularconnectionfsm.o(.constdata__ZZN4mbed8CallbackIFbiiEE8generateIPS1_EEvRKT_E3ops)
</UL>
<P><STRONG><a name="[1b0]"></a>void mbed::Callback&lang;bool(int, int)&rang;::function_dtor&lang;mbed::Callback&lang;bool(int, int)&rang;::method_context&lang;mbed::EasyCellularConnection, bool(mbed::EasyCellularConnection::*)(int, int)&rang;&rang;(void*)</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\easycellularconnection.o(t._ZN4mbed8CallbackIFbiiEE13function_dtorINS2_14method_contextINS_22EasyCellularConnectionEMS5_FbiiEEEEEvPv))
<BR>[Address Reference Count : 1]<UL><LI> easycellularconnection.o(.constdata__ZZN4mbed8CallbackIFbiiEE8generateINS2_14method_contextINS_22EasyCellularConnectionEMS5_FbiiEEEEEvRKT_E3ops)
</UL>
<P><STRONG><a name="[1b3]"></a>void mbed::Callback&lang;bool(int, int)&rang;::function_dtor&lang;bool(*)(int, int)&rang;(void*)</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\cellularconnectionfsm.o(t._ZN4mbed8CallbackIFbiiEE13function_dtorIPS1_EEvPv))
<BR>[Address Reference Count : 1]<UL><LI> cellularconnectionfsm.o(.constdata__ZZN4mbed8CallbackIFbiiEE8generateIPS1_EEvRKT_E3ops)
</UL>
<P><STRONG><a name="[1af]"></a>void mbed::Callback&lang;bool(int, int)&rang;::function_move&lang;mbed::Callback&lang;bool(int, int)&rang;::method_context&lang;mbed::EasyCellularConnection, bool(mbed::EasyCellularConnection::*)(int, int)&rang;&rang;(void*, const void*)</STRONG> (Thumb, 20 bytes, Stack size 12 bytes, .\build\easycellularconnection.o(t._ZN4mbed8CallbackIFbiiEE13function_moveINS2_14method_contextINS_22EasyCellularConnectionEMS5_FbiiEEEEEvPvPKv))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = void mbed::Callback&lang;bool(int, int)&rang;::function_move&lang;mbed::Callback&lang;bool(int, int)&rang;::method_context&lang;mbed::EasyCellularConnection, bool(mbed::EasyCellularConnection::*)(int, int)&rang;&rang;(void*, const void*)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> easycellularconnection.o(.constdata__ZZN4mbed8CallbackIFbiiEE8generateINS2_14method_contextINS_22EasyCellularConnectionEMS5_FbiiEEEEEvRKT_E3ops)
</UL>
<P><STRONG><a name="[1b2]"></a>void mbed::Callback&lang;bool(int, int)&rang;::function_move&lang;bool(*)(int, int)&rang;(void*, const void*)</STRONG> (Thumb, 14 bytes, Stack size 0 bytes, .\build\cellularconnectionfsm.o(t._ZN4mbed8CallbackIFbiiEE13function_moveIPS1_EEvPvPKv))
<BR>[Address Reference Count : 1]<UL><LI> cellularconnectionfsm.o(.constdata__ZZN4mbed8CallbackIFbiiEE8generateIPS1_EEvRKT_E3ops)
</UL>
<P><STRONG><a name="[6d5]"></a>mbed::Callback&lang;bool(int, int)&rang;::Callback&lang;mbed::EasyCellularConnection, mbed::EasyCellularConnection&rang;(T2*, bool(T1::*)(int, int))</STRONG> (Thumb, 68 bytes, Stack size 56 bytes, .\build\easycellularconnection.o(t._ZN4mbed8CallbackIFbiiEEC1INS_22EasyCellularConnectionES4_EEPT0_MT_FbiiE))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = mbed::Callback&lang;bool(int, int)&rang;::Callback&lang;mbed::EasyCellularConnection, mbed::EasyCellularConnection&rang;(T2*, bool(T1::*)(int, int))
</UL>
<BR>[Called By]<UL><LI><a href="#[3d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;T3(T4, T5)&rang; mbed::callback&lang;mbed::EasyCellularConnection, mbed::EasyCellularConnection, bool, int, int&rang;(T2*, T3(T1::*)(T4, T5))
</UL>

<P><STRONG><a name="[78b]"></a>mbed::Callback&lang;bool(int, int)&rang;::Callback__sub_object&lang;mbed::EasyCellularConnection, mbed::EasyCellularConnection&rang;(T2*, bool(T1::*)(int, int))</STRONG> (Thumb, 0 bytes, Stack size 56 bytes, .\build\easycellularconnection.o(t._ZN4mbed8CallbackIFbiiEEC1INS_22EasyCellularConnectionES4_EEPT0_MT_FbiiE), UNUSED)

<P><STRONG><a name="[3b1]"></a>mbed::Callback&lang;bool(int, int)&rang;::~Callback()</STRONG> (Thumb, 20 bytes, Stack size 8 bytes, .\build\cellularconnectionfsm.o(t._ZN4mbed8CallbackIFbiiEED1Ev))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = mbed::Callback&lang;bool(int, int)&rang;::~Callback()
</UL>
<BR>[Called By]<UL><LI><a href="#[183]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::CellularConnectionFSM::~CellularConnectionFSM()
<LI><a href="#[3b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::CellularConnectionFSM::set_callback(mbed::Callback&lang;bool(int, int)&rang;)
</UL>

<P><STRONG><a name="[78c]"></a>mbed::Callback&lang;bool(int, int)&rang;::~Callback__sub_object()</STRONG> (Thumb, 0 bytes, Stack size 8 bytes, .\build\cellularconnectionfsm.o(t._ZN4mbed8CallbackIFbiiEED1Ev), UNUSED)

<P><STRONG><a name="[1b4]"></a>void mbed::Callback&lang;void(nsapi_event, int)&rang;::function_call&lang;mbed::Callback&lang;void(nsapi_event, int)&rang;::method_context&lang;mbed::AT_CellularNetwork, void(mbed::AT_CellularNetwork::*)(nsapi_event, int)&rang;&rang;(const void*, nsapi_event, int)</STRONG> (Thumb, 64 bytes, Stack size 40 bytes, .\build\at_cellularnetwork.o(t._ZN4mbed8CallbackIFv11nsapi_eventiEE13function_callINS3_14method_contextINS_18AT_CellularNetworkEMS6_FvS1_iEEEEEvPKvS1_i))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = void mbed::Callback&lang;void(nsapi_event, int)&rang;::function_call&lang;mbed::Callback&lang;void(nsapi_event, int)&rang;::method_context&lang;mbed::AT_CellularNetwork, void(mbed::AT_CellularNetwork::*)(nsapi_event, int)&rang;&rang;(const void*, nsapi_event, int)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> at_cellularnetwork.o(.constdata__ZZN4mbed8CallbackIFv11nsapi_eventiEE8generateINS3_14method_contextINS_18AT_CellularNetworkEMS6_FvS1_iEEEEEvRKT_E3ops)
</UL>
<P><STRONG><a name="[1b7]"></a>void mbed::Callback&lang;void(nsapi_event, int)&rang;::function_call&lang;void(*)(nsapi_event, int)&rang;(const void*, nsapi_event, int)</STRONG> (Thumb, 18 bytes, Stack size 16 bytes, .\build\at_cellularnetwork.o(t._ZN4mbed8CallbackIFv11nsapi_eventiEE13function_callIPS2_EEvPKvS1_i))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = void mbed::Callback&lang;void(nsapi_event, int)&rang;::function_call&lang;void(*)(nsapi_event, int)&rang;(const void*, nsapi_event, int)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> at_cellularnetwork.o(.constdata__ZZN4mbed8CallbackIFv11nsapi_eventiEE8generateIPS2_EEvRKT_E3ops)
</UL>
<P><STRONG><a name="[1b6]"></a>void mbed::Callback&lang;void(nsapi_event, int)&rang;::function_dtor&lang;mbed::Callback&lang;void(nsapi_event, int)&rang;::method_context&lang;mbed::AT_CellularNetwork, void(mbed::AT_CellularNetwork::*)(nsapi_event, int)&rang;&rang;(void*)</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\at_cellularnetwork.o(t._ZN4mbed8CallbackIFv11nsapi_eventiEE13function_dtorINS3_14method_contextINS_18AT_CellularNetworkEMS6_FvS1_iEEEEEvPv))
<BR>[Address Reference Count : 1]<UL><LI> at_cellularnetwork.o(.constdata__ZZN4mbed8CallbackIFv11nsapi_eventiEE8generateINS3_14method_contextINS_18AT_CellularNetworkEMS6_FvS1_iEEEEEvRKT_E3ops)
</UL>
<P><STRONG><a name="[1b9]"></a>void mbed::Callback&lang;void(nsapi_event, int)&rang;::function_dtor&lang;void(*)(nsapi_event, int)&rang;(void*)</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\at_cellularnetwork.o(t._ZN4mbed8CallbackIFv11nsapi_eventiEE13function_dtorIPS2_EEvPv))
<BR>[Address Reference Count : 1]<UL><LI> at_cellularnetwork.o(.constdata__ZZN4mbed8CallbackIFv11nsapi_eventiEE8generateIPS2_EEvRKT_E3ops)
</UL>
<P><STRONG><a name="[1b5]"></a>void mbed::Callback&lang;void(nsapi_event, int)&rang;::function_move&lang;mbed::Callback&lang;void(nsapi_event, int)&rang;::method_context&lang;mbed::AT_CellularNetwork, void(mbed::AT_CellularNetwork::*)(nsapi_event, int)&rang;&rang;(void*, const void*)</STRONG> (Thumb, 20 bytes, Stack size 12 bytes, .\build\at_cellularnetwork.o(t._ZN4mbed8CallbackIFv11nsapi_eventiEE13function_moveINS3_14method_contextINS_18AT_CellularNetworkEMS6_FvS1_iEEEEEvPvPKv))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = void mbed::Callback&lang;void(nsapi_event, int)&rang;::function_move&lang;mbed::Callback&lang;void(nsapi_event, int)&rang;::method_context&lang;mbed::AT_CellularNetwork, void(mbed::AT_CellularNetwork::*)(nsapi_event, int)&rang;&rang;(void*, const void*)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> at_cellularnetwork.o(.constdata__ZZN4mbed8CallbackIFv11nsapi_eventiEE8generateINS3_14method_contextINS_18AT_CellularNetworkEMS6_FvS1_iEEEEEvRKT_E3ops)
</UL>
<P><STRONG><a name="[1b8]"></a>void mbed::Callback&lang;void(nsapi_event, int)&rang;::function_move&lang;void(*)(nsapi_event, int)&rang;(void*, const void*)</STRONG> (Thumb, 14 bytes, Stack size 0 bytes, .\build\at_cellularnetwork.o(t._ZN4mbed8CallbackIFv11nsapi_eventiEE13function_moveIPS2_EEvPvPKv))
<BR>[Address Reference Count : 1]<UL><LI> at_cellularnetwork.o(.constdata__ZZN4mbed8CallbackIFv11nsapi_eventiEE8generateIPS2_EEvRKT_E3ops)
</UL>
<P><STRONG><a name="[6d2]"></a>mbed::Callback&lang;void(nsapi_event, int)&rang;::Callback&lang;mbed::AT_CellularNetwork, mbed::AT_CellularNetwork&rang;(T2*, void(T1::*)(nsapi_event, int))</STRONG> (Thumb, 68 bytes, Stack size 56 bytes, .\build\at_cellularnetwork.o(t._ZN4mbed8CallbackIFv11nsapi_eventiEEC1INS_18AT_CellularNetworkES5_EEPT0_MT_FvS1_iE))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = mbed::Callback&lang;void(nsapi_event, int)&rang;::Callback&lang;mbed::AT_CellularNetwork, mbed::AT_CellularNetwork&rang;(T2*, void(T1::*)(nsapi_event, int))
</UL>
<BR>[Called By]<UL><LI><a href="#[39e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;T3(T4, T5)&rang; mbed::callback&lang;mbed::AT_CellularNetwork, mbed::AT_CellularNetwork, void, nsapi_event, int&rang;(T2*, T3(T1::*)(T4, T5))
</UL>

<P><STRONG><a name="[78d]"></a>mbed::Callback&lang;void(nsapi_event, int)&rang;::Callback__sub_object&lang;mbed::AT_CellularNetwork, mbed::AT_CellularNetwork&rang;(T2*, void(T1::*)(nsapi_event, int))</STRONG> (Thumb, 0 bytes, Stack size 56 bytes, .\build\at_cellularnetwork.o(t._ZN4mbed8CallbackIFv11nsapi_eventiEEC1INS_18AT_CellularNetworkES5_EEPT0_MT_FvS1_iE), UNUSED)

<P><STRONG><a name="[58]"></a>mbed::Callback&lang;void(nsapi_event, int)&rang;::~Callback()</STRONG> (Thumb, 20 bytes, Stack size 8 bytes, .\build\at_cellularnetwork.o(t._ZN4mbed8CallbackIFv11nsapi_eventiEED1Ev))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = mbed::Callback&lang;void(nsapi_event, int)&rang;::~Callback()
</UL>
<BR>[Called By]<UL><LI><a href="#[391]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::nsapi_ppp_connect(mbed::FileHandle*, mbed::Callback&lang;void(nsapi_event, int)&rang;, const char*, const char*, nsapi_ip_stack)
<LI><a href="#[178]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::~AT_CellularNetwork()
<LI><a href="#[39d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::open_data_channel()
</UL>
<BR>[Address Reference Count : 1]<UL><LI> ppp_lwip.o(i.__sti___12_ppp_lwip_cpp_b3a13e7c)
</UL>
<P><STRONG><a name="[78e]"></a>mbed::Callback&lang;void(nsapi_event, int)&rang;::~Callback__sub_object()</STRONG> (Thumb, 0 bytes, Stack size 8 bytes, .\build\at_cellularnetwork.o(t._ZN4mbed8CallbackIFv11nsapi_eventiEED1Ev), UNUSED)

<P><STRONG><a name="[1ba]"></a>void mbed::Callback&lang;void(int)&rang;::function_call&lang;void(*)(int)&rang;(const void*, int)</STRONG> (Thumb, 14 bytes, Stack size 16 bytes, .\build\eventqueue.o(t._ZN4mbed8CallbackIFviEE13function_callIPS1_EEvPKvi))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = void mbed::Callback&lang;void(int)&rang;::function_call&lang;void(*)(int)&rang;(const void*, int)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> eventqueue.o(.constdata__ZZN4mbed8CallbackIFviEE8generateIPS1_EEvRKT_E3ops)
</UL>
<P><STRONG><a name="[1bc]"></a>void mbed::Callback&lang;void(int)&rang;::function_dtor&lang;void(*)(int)&rang;(void*)</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\eventqueue.o(t._ZN4mbed8CallbackIFviEE13function_dtorIPS1_EEvPv))
<BR>[Address Reference Count : 1]<UL><LI> eventqueue.o(.constdata__ZZN4mbed8CallbackIFviEE8generateIPS1_EEvRKT_E3ops)
</UL>
<P><STRONG><a name="[1bb]"></a>void mbed::Callback&lang;void(int)&rang;::function_move&lang;void(*)(int)&rang;(void*, const void*)</STRONG> (Thumb, 14 bytes, Stack size 0 bytes, .\build\eventqueue.o(t._ZN4mbed8CallbackIFviEE13function_moveIPS1_EEvPvPKv))
<BR>[Address Reference Count : 1]<UL><LI> eventqueue.o(.constdata__ZZN4mbed8CallbackIFviEE8generateIPS1_EEvRKT_E3ops)
</UL>
<P><STRONG><a name="[349]"></a>mbed::Callback&lang;void(int)&rang;::Callback(void(*)(int))</STRONG> (Thumb, 50 bytes, Stack size 8 bytes, .\build\serialbase.o(t._ZN4mbed8CallbackIFviEEC1EPS1_))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = mbed::Callback&lang;void(int)&rang;::Callback(void(*)(int))
</UL>
<BR>[Called By]<UL><LI><a href="#[347]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::SerialBase::SerialBase(PinName, PinName, int)
<LI><a href="#[36c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::transaction_t::transaction_t()
</UL>

<P><STRONG><a name="[78f]"></a>mbed::Callback&lang;void(int)&rang;::Callback__sub_object(void(*)(int))</STRONG> (Thumb, 0 bytes, Stack size 8 bytes, .\build\serialbase.o(t._ZN4mbed8CallbackIFviEEC1EPS1_), UNUSED)

<P><STRONG><a name="[34d]"></a>mbed::Callback&lang;void(int)&rang;::~Callback()</STRONG> (Thumb, 20 bytes, Stack size 8 bytes, .\build\eventqueue.o(t._ZN4mbed8CallbackIFviEED1Ev))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = mbed::Callback&lang;void(int)&rang;::~Callback()
</UL>
<BR>[Called By]<UL><LI><a href="#[3ae]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;events::EventQueue::~EventQueue()
<LI><a href="#[145]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::SerialBase::~SerialBase()
<LI><a href="#[36d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::transaction_t::~transaction_t()
</UL>

<P><STRONG><a name="[790]"></a>mbed::Callback&lang;void(int)&rang;::~Callback__sub_object()</STRONG> (Thumb, 0 bytes, Stack size 8 bytes, .\build\eventqueue.o(t._ZN4mbed8CallbackIFviEED1Ev), UNUSED)

<P><STRONG><a name="[1bd]"></a>void mbed::Callback&lang;void()&rang;::function_call&lang;mbed::Callback&lang;void()&rang;::method_context&lang;Socket, void(Socket::*)()&rang;&rang;(const void*)</STRONG> (Thumb, 48 bytes, Stack size 24 bytes, .\build\socket.o(t._ZN4mbed8CallbackIFvvEE13function_callINS2_14method_contextI6SocketMS5_FvvEEEEEvPKv))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = void mbed::Callback&lang;void()&rang;::function_call&lang;mbed::Callback&lang;void()&rang;::method_context&lang;Socket, void(Socket::*)()&rang;&rang;(const void*)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> socket.o(.constdata__ZZN4mbed8CallbackIFvvEE8generateINS2_14method_contextI6SocketMS5_FvvEEEEEvRKT_E3ops)
</UL>
<P><STRONG><a name="[1c0]"></a>void mbed::Callback&lang;void()&rang;::function_call&lang;mbed::Callback&lang;void()&rang;::method_context&lang;events::EventQueue, void(events::EventQueue::*)()&rang;&rang;(const void*)</STRONG> (Thumb, 48 bytes, Stack size 24 bytes, .\build\cellularconnectionfsm.o(t._ZN4mbed8CallbackIFvvEE13function_callINS2_14method_contextIN6events10EventQueueEMS6_FvvEEEEEvPKv))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = void mbed::Callback&lang;void()&rang;::function_call&lang;mbed::Callback&lang;void()&rang;::method_context&lang;events::EventQueue, void(events::EventQueue::*)()&rang;&rang;(const void*)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> cellularconnectionfsm.o(.constdata__ZZN4mbed8CallbackIFvvEE8generateINS2_14method_contextIN6events10EventQueueEMS6_FvvEEEEEvRKT_E3ops)
</UL>
<P><STRONG><a name="[1c3]"></a>void mbed::Callback&lang;void()&rang;::function_call&lang;mbed::Callback&lang;void()&rang;::method_context&lang;mbed::UARTSerial, void(mbed::UARTSerial::*)()&rang;&rang;(const void*)</STRONG> (Thumb, 48 bytes, Stack size 24 bytes, .\build\uartserial.o(t._ZN4mbed8CallbackIFvvEE13function_callINS2_14method_contextINS_10UARTSerialEMS5_FvvEEEEEvPKv))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = void mbed::Callback&lang;void()&rang;::function_call&lang;mbed::Callback&lang;void()&rang;::method_context&lang;mbed::UARTSerial, void(mbed::UARTSerial::*)()&rang;&rang;(const void*)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> uartserial.o(.constdata__ZZN4mbed8CallbackIFvvEE8generateINS2_14method_contextINS_10UARTSerialEMS5_FvvEEEEEvRKT_E3ops)
</UL>
<P><STRONG><a name="[1c6]"></a>void mbed::Callback&lang;void()&rang;::function_call&lang;mbed::Callback&lang;void()&rang;::method_context&lang;mbed::AT_CellularNetwork, void(mbed::AT_CellularNetwork::*)()&rang;&rang;(const void*)</STRONG> (Thumb, 48 bytes, Stack size 24 bytes, .\build\at_cellularnetwork.o(t._ZN4mbed8CallbackIFvvEE13function_callINS2_14method_contextINS_18AT_CellularNetworkEMS5_FvvEEEEEvPKv))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = void mbed::Callback&lang;void()&rang;::function_call&lang;mbed::Callback&lang;void()&rang;::method_context&lang;mbed::AT_CellularNetwork, void(mbed::AT_CellularNetwork::*)()&rang;&rang;(const void*)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> at_cellularnetwork.o(.constdata__ZZN4mbed8CallbackIFvvEE8generateINS2_14method_contextINS_18AT_CellularNetworkEMS5_FvvEEEEEvRKT_E3ops)
</UL>
<P><STRONG><a name="[1c9]"></a>void mbed::Callback&lang;void()&rang;::function_call&lang;mbed::Callback&lang;void()&rang;::method_context&lang;mbed::CellularConnectionFSM, void(mbed::CellularConnectionFSM::*)()&rang;&rang;(const void*)</STRONG> (Thumb, 48 bytes, Stack size 24 bytes, .\build\cellularconnectionfsm.o(t._ZN4mbed8CallbackIFvvEE13function_callINS2_14method_contextINS_21CellularConnectionFSMEMS5_FvvEEEEEvPKv))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = void mbed::Callback&lang;void()&rang;::function_call&lang;mbed::Callback&lang;void()&rang;::method_context&lang;mbed::CellularConnectionFSM, void(mbed::CellularConnectionFSM::*)()&rang;&rang;(const void*)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> cellularconnectionfsm.o(.constdata__ZZN4mbed8CallbackIFvvEE8generateINS2_14method_contextINS_21CellularConnectionFSMEMS5_FvvEEEEEvRKT_E3ops)
</UL>
<P><STRONG><a name="[1cc]"></a>void mbed::Callback&lang;void()&rang;::function_call&lang;mbed::Callback&lang;void()&rang;::method_context&lang;mbed::QUECTEL_BG96_CellularStack, void(mbed::QUECTEL_BG96_CellularStack::*)()&rang;&rang;(const void*)</STRONG> (Thumb, 48 bytes, Stack size 24 bytes, .\build\quectel_bg96_cellularstack.o(t._ZN4mbed8CallbackIFvvEE13function_callINS2_14method_contextINS_26QUECTEL_BG96_CellularStackEMS5_FvvEEEEEvPKv))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = void mbed::Callback&lang;void()&rang;::function_call&lang;mbed::Callback&lang;void()&rang;::method_context&lang;mbed::QUECTEL_BG96_CellularStack, void(mbed::QUECTEL_BG96_CellularStack::*)()&rang;&rang;(const void*)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> quectel_bg96_cellularstack.o(.constdata__ZZN4mbed8CallbackIFvvEE8generateINS2_14method_contextINS_26QUECTEL_BG96_CellularStackEMS5_FvvEEEEEvRKT_E3ops)
</UL>
<P><STRONG><a name="[1cf]"></a>void mbed::Callback&lang;void()&rang;::function_call&lang;mbed::Callback&lang;void()&rang;::method_context&lang;mbed::ATHandler, void(mbed::ATHandler::*)()&rang;&rang;(const void*)</STRONG> (Thumb, 48 bytes, Stack size 24 bytes, .\build\athandler.o(t._ZN4mbed8CallbackIFvvEE13function_callINS2_14method_contextINS_9ATHandlerEMS5_FvvEEEEEvPKv))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = void mbed::Callback&lang;void()&rang;::function_call&lang;mbed::Callback&lang;void()&rang;::method_context&lang;mbed::ATHandler, void(mbed::ATHandler::*)()&rang;&rang;(const void*)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> athandler.o(.constdata__ZZN4mbed8CallbackIFvvEE8generateINS2_14method_contextINS_9ATHandlerEMS5_FvvEEEEEvRKT_E3ops)
</UL>
<P><STRONG><a name="[1d2]"></a>void mbed::Callback&lang;void()&rang;::function_call&lang;void(*)()&rang;(const void*)</STRONG> (Thumb, 10 bytes, Stack size 8 bytes, .\build\arm_hal_timer.o(t._ZN4mbed8CallbackIFvvEE13function_callIPS1_EEvPKv))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = void mbed::Callback&lang;void()&rang;::function_call&lang;void(*)()&rang;(const void*)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> arm_hal_timer.o(.constdata__ZZN4mbed8CallbackIFvvEE8generateIPS1_EEvRKT_E3ops)
</UL>
<P><STRONG><a name="[1bf]"></a>void mbed::Callback&lang;void()&rang;::function_dtor&lang;mbed::Callback&lang;void()&rang;::method_context&lang;Socket, void(Socket::*)()&rang;&rang;(void*)</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\socket.o(t._ZN4mbed8CallbackIFvvEE13function_dtorINS2_14method_contextI6SocketMS5_FvvEEEEEvPv))
<BR>[Address Reference Count : 1]<UL><LI> socket.o(.constdata__ZZN4mbed8CallbackIFvvEE8generateINS2_14method_contextI6SocketMS5_FvvEEEEEvRKT_E3ops)
</UL>
<P><STRONG><a name="[1c2]"></a>void mbed::Callback&lang;void()&rang;::function_dtor&lang;mbed::Callback&lang;void()&rang;::method_context&lang;events::EventQueue, void(events::EventQueue::*)()&rang;&rang;(void*)</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\cellularconnectionfsm.o(t._ZN4mbed8CallbackIFvvEE13function_dtorINS2_14method_contextIN6events10EventQueueEMS6_FvvEEEEEvPv))
<BR>[Address Reference Count : 1]<UL><LI> cellularconnectionfsm.o(.constdata__ZZN4mbed8CallbackIFvvEE8generateINS2_14method_contextIN6events10EventQueueEMS6_FvvEEEEEvRKT_E3ops)
</UL>
<P><STRONG><a name="[1c5]"></a>void mbed::Callback&lang;void()&rang;::function_dtor&lang;mbed::Callback&lang;void()&rang;::method_context&lang;mbed::UARTSerial, void(mbed::UARTSerial::*)()&rang;&rang;(void*)</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\uartserial.o(t._ZN4mbed8CallbackIFvvEE13function_dtorINS2_14method_contextINS_10UARTSerialEMS5_FvvEEEEEvPv))
<BR>[Address Reference Count : 1]<UL><LI> uartserial.o(.constdata__ZZN4mbed8CallbackIFvvEE8generateINS2_14method_contextINS_10UARTSerialEMS5_FvvEEEEEvRKT_E3ops)
</UL>
<P><STRONG><a name="[1c8]"></a>void mbed::Callback&lang;void()&rang;::function_dtor&lang;mbed::Callback&lang;void()&rang;::method_context&lang;mbed::AT_CellularNetwork, void(mbed::AT_CellularNetwork::*)()&rang;&rang;(void*)</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\at_cellularnetwork.o(t._ZN4mbed8CallbackIFvvEE13function_dtorINS2_14method_contextINS_18AT_CellularNetworkEMS5_FvvEEEEEvPv))
<BR>[Address Reference Count : 1]<UL><LI> at_cellularnetwork.o(.constdata__ZZN4mbed8CallbackIFvvEE8generateINS2_14method_contextINS_18AT_CellularNetworkEMS5_FvvEEEEEvRKT_E3ops)
</UL>
<P><STRONG><a name="[1cb]"></a>void mbed::Callback&lang;void()&rang;::function_dtor&lang;mbed::Callback&lang;void()&rang;::method_context&lang;mbed::CellularConnectionFSM, void(mbed::CellularConnectionFSM::*)()&rang;&rang;(void*)</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\cellularconnectionfsm.o(t._ZN4mbed8CallbackIFvvEE13function_dtorINS2_14method_contextINS_21CellularConnectionFSMEMS5_FvvEEEEEvPv))
<BR>[Address Reference Count : 1]<UL><LI> cellularconnectionfsm.o(.constdata__ZZN4mbed8CallbackIFvvEE8generateINS2_14method_contextINS_21CellularConnectionFSMEMS5_FvvEEEEEvRKT_E3ops)
</UL>
<P><STRONG><a name="[1ce]"></a>void mbed::Callback&lang;void()&rang;::function_dtor&lang;mbed::Callback&lang;void()&rang;::method_context&lang;mbed::QUECTEL_BG96_CellularStack, void(mbed::QUECTEL_BG96_CellularStack::*)()&rang;&rang;(void*)</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\quectel_bg96_cellularstack.o(t._ZN4mbed8CallbackIFvvEE13function_dtorINS2_14method_contextINS_26QUECTEL_BG96_CellularStackEMS5_FvvEEEEEvPv))
<BR>[Address Reference Count : 1]<UL><LI> quectel_bg96_cellularstack.o(.constdata__ZZN4mbed8CallbackIFvvEE8generateINS2_14method_contextINS_26QUECTEL_BG96_CellularStackEMS5_FvvEEEEEvRKT_E3ops)
</UL>
<P><STRONG><a name="[1d1]"></a>void mbed::Callback&lang;void()&rang;::function_dtor&lang;mbed::Callback&lang;void()&rang;::method_context&lang;mbed::ATHandler, void(mbed::ATHandler::*)()&rang;&rang;(void*)</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\athandler.o(t._ZN4mbed8CallbackIFvvEE13function_dtorINS2_14method_contextINS_9ATHandlerEMS5_FvvEEEEEvPv))
<BR>[Address Reference Count : 1]<UL><LI> athandler.o(.constdata__ZZN4mbed8CallbackIFvvEE8generateINS2_14method_contextINS_9ATHandlerEMS5_FvvEEEEEvRKT_E3ops)
</UL>
<P><STRONG><a name="[1d4]"></a>void mbed::Callback&lang;void()&rang;::function_dtor&lang;void(*)()&rang;(void*)</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\arm_hal_timer.o(t._ZN4mbed8CallbackIFvvEE13function_dtorIPS1_EEvPv))
<BR>[Address Reference Count : 1]<UL><LI> arm_hal_timer.o(.constdata__ZZN4mbed8CallbackIFvvEE8generateIPS1_EEvRKT_E3ops)
</UL>
<P><STRONG><a name="[1be]"></a>void mbed::Callback&lang;void()&rang;::function_move&lang;mbed::Callback&lang;void()&rang;::method_context&lang;Socket, void(Socket::*)()&rang;&rang;(void*, const void*)</STRONG> (Thumb, 20 bytes, Stack size 12 bytes, .\build\socket.o(t._ZN4mbed8CallbackIFvvEE13function_moveINS2_14method_contextI6SocketMS5_FvvEEEEEvPvPKv))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = void mbed::Callback&lang;void()&rang;::function_move&lang;mbed::Callback&lang;void()&rang;::method_context&lang;Socket, void(Socket::*)()&rang;&rang;(void*, const void*)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> socket.o(.constdata__ZZN4mbed8CallbackIFvvEE8generateINS2_14method_contextI6SocketMS5_FvvEEEEEvRKT_E3ops)
</UL>
<P><STRONG><a name="[1c1]"></a>void mbed::Callback&lang;void()&rang;::function_move&lang;mbed::Callback&lang;void()&rang;::method_context&lang;events::EventQueue, void(events::EventQueue::*)()&rang;&rang;(void*, const void*)</STRONG> (Thumb, 20 bytes, Stack size 12 bytes, .\build\cellularconnectionfsm.o(t._ZN4mbed8CallbackIFvvEE13function_moveINS2_14method_contextIN6events10EventQueueEMS6_FvvEEEEEvPvPKv))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = void mbed::Callback&lang;void()&rang;::function_move&lang;mbed::Callback&lang;void()&rang;::method_context&lang;events::EventQueue, void(events::EventQueue::*)()&rang;&rang;(void*, const void*)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> cellularconnectionfsm.o(.constdata__ZZN4mbed8CallbackIFvvEE8generateINS2_14method_contextIN6events10EventQueueEMS6_FvvEEEEEvRKT_E3ops)
</UL>
<P><STRONG><a name="[1c4]"></a>void mbed::Callback&lang;void()&rang;::function_move&lang;mbed::Callback&lang;void()&rang;::method_context&lang;mbed::UARTSerial, void(mbed::UARTSerial::*)()&rang;&rang;(void*, const void*)</STRONG> (Thumb, 20 bytes, Stack size 12 bytes, .\build\uartserial.o(t._ZN4mbed8CallbackIFvvEE13function_moveINS2_14method_contextINS_10UARTSerialEMS5_FvvEEEEEvPvPKv))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = void mbed::Callback&lang;void()&rang;::function_move&lang;mbed::Callback&lang;void()&rang;::method_context&lang;mbed::UARTSerial, void(mbed::UARTSerial::*)()&rang;&rang;(void*, const void*)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> uartserial.o(.constdata__ZZN4mbed8CallbackIFvvEE8generateINS2_14method_contextINS_10UARTSerialEMS5_FvvEEEEEvRKT_E3ops)
</UL>
<P><STRONG><a name="[1c7]"></a>void mbed::Callback&lang;void()&rang;::function_move&lang;mbed::Callback&lang;void()&rang;::method_context&lang;mbed::AT_CellularNetwork, void(mbed::AT_CellularNetwork::*)()&rang;&rang;(void*, const void*)</STRONG> (Thumb, 20 bytes, Stack size 12 bytes, .\build\at_cellularnetwork.o(t._ZN4mbed8CallbackIFvvEE13function_moveINS2_14method_contextINS_18AT_CellularNetworkEMS5_FvvEEEEEvPvPKv))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = void mbed::Callback&lang;void()&rang;::function_move&lang;mbed::Callback&lang;void()&rang;::method_context&lang;mbed::AT_CellularNetwork, void(mbed::AT_CellularNetwork::*)()&rang;&rang;(void*, const void*)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> at_cellularnetwork.o(.constdata__ZZN4mbed8CallbackIFvvEE8generateINS2_14method_contextINS_18AT_CellularNetworkEMS5_FvvEEEEEvRKT_E3ops)
</UL>
<P><STRONG><a name="[1ca]"></a>void mbed::Callback&lang;void()&rang;::function_move&lang;mbed::Callback&lang;void()&rang;::method_context&lang;mbed::CellularConnectionFSM, void(mbed::CellularConnectionFSM::*)()&rang;&rang;(void*, const void*)</STRONG> (Thumb, 20 bytes, Stack size 12 bytes, .\build\cellularconnectionfsm.o(t._ZN4mbed8CallbackIFvvEE13function_moveINS2_14method_contextINS_21CellularConnectionFSMEMS5_FvvEEEEEvPvPKv))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = void mbed::Callback&lang;void()&rang;::function_move&lang;mbed::Callback&lang;void()&rang;::method_context&lang;mbed::CellularConnectionFSM, void(mbed::CellularConnectionFSM::*)()&rang;&rang;(void*, const void*)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> cellularconnectionfsm.o(.constdata__ZZN4mbed8CallbackIFvvEE8generateINS2_14method_contextINS_21CellularConnectionFSMEMS5_FvvEEEEEvRKT_E3ops)
</UL>
<P><STRONG><a name="[1cd]"></a>void mbed::Callback&lang;void()&rang;::function_move&lang;mbed::Callback&lang;void()&rang;::method_context&lang;mbed::QUECTEL_BG96_CellularStack, void(mbed::QUECTEL_BG96_CellularStack::*)()&rang;&rang;(void*, const void*)</STRONG> (Thumb, 20 bytes, Stack size 12 bytes, .\build\quectel_bg96_cellularstack.o(t._ZN4mbed8CallbackIFvvEE13function_moveINS2_14method_contextINS_26QUECTEL_BG96_CellularStackEMS5_FvvEEEEEvPvPKv))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = void mbed::Callback&lang;void()&rang;::function_move&lang;mbed::Callback&lang;void()&rang;::method_context&lang;mbed::QUECTEL_BG96_CellularStack, void(mbed::QUECTEL_BG96_CellularStack::*)()&rang;&rang;(void*, const void*)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> quectel_bg96_cellularstack.o(.constdata__ZZN4mbed8CallbackIFvvEE8generateINS2_14method_contextINS_26QUECTEL_BG96_CellularStackEMS5_FvvEEEEEvRKT_E3ops)
</UL>
<P><STRONG><a name="[1d0]"></a>void mbed::Callback&lang;void()&rang;::function_move&lang;mbed::Callback&lang;void()&rang;::method_context&lang;mbed::ATHandler, void(mbed::ATHandler::*)()&rang;&rang;(void*, const void*)</STRONG> (Thumb, 20 bytes, Stack size 12 bytes, .\build\athandler.o(t._ZN4mbed8CallbackIFvvEE13function_moveINS2_14method_contextINS_9ATHandlerEMS5_FvvEEEEEvPvPKv))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = void mbed::Callback&lang;void()&rang;::function_move&lang;mbed::Callback&lang;void()&rang;::method_context&lang;mbed::ATHandler, void(mbed::ATHandler::*)()&rang;&rang;(void*, const void*)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> athandler.o(.constdata__ZZN4mbed8CallbackIFvvEE8generateINS2_14method_contextINS_9ATHandlerEMS5_FvvEEEEEvRKT_E3ops)
</UL>
<P><STRONG><a name="[1d3]"></a>void mbed::Callback&lang;void()&rang;::function_move&lang;void(*)()&rang;(void*, const void*)</STRONG> (Thumb, 14 bytes, Stack size 0 bytes, .\build\arm_hal_timer.o(t._ZN4mbed8CallbackIFvvEE13function_moveIPS1_EEvPvPKv))
<BR>[Address Reference Count : 1]<UL><LI> arm_hal_timer.o(.constdata__ZZN4mbed8CallbackIFvvEE8generateIPS1_EEvRKT_E3ops)
</UL>
<P><STRONG><a name="[57]"></a>mbed::Callback&lang;void()&rang;::thunk(void*)</STRONG> (Thumb, 12 bytes, Stack size 8 bytes, .\build\tcpserver.o(t._ZN4mbed8CallbackIFvvEE5thunkEPv))
<BR><BR>[Stack]<UL><LI>Max Depth = 544 + Unknown Stack Size
<LI>Call Chain = mbed::Callback&lang;void()&rang;::thunk(void*) &rArr; mbed::Callback&lang;void()&rang;::call() const &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[6ce]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void()&rang;::call() const
</UL>
<BR>[Address Reference Count : 1]<UL><LI> socket.o(i._ZN6Socket4openEP12NetworkStack)
</UL>
<P><STRONG><a name="[282]"></a>mbed::Callback&lang;void()&rang;::Callback(void(*)())</STRONG> (Thumb, 50 bytes, Stack size 8 bytes, .\build\arm_hal_timer.o(t._ZN4mbed8CallbackIFvvEEC1EPS1_))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = mbed::Callback&lang;void()&rang;::Callback(void(*)())
</UL>
<BR>[Called By]<UL><LI><a href="#[1d5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__sti___17_arm_hal_timer_cpp_749a681d
<LI><a href="#[35f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::UARTSerial::UARTSerial(PinName, PinName, int)
<LI><a href="#[305]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_tick_init()
<LI><a href="#[145]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::SerialBase::~SerialBase()
<LI><a href="#[579]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_lwip_disconnect
<LI><a href="#[281]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;$Super$$main
<LI><a href="#[417]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;T1()&rang; mbed::callback&lang;void&rang;(T1(*)())
<LI><a href="#[3a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::prepare_event_queue()
<LI><a href="#[347]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::SerialBase::SerialBase(PinName, PinName, int)
<LI><a href="#[33f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::SerialBase::attach(mbed::Callback&lang;void()&rang;, mbed::SerialBase::IrqType)
<LI><a href="#[51]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;&lang;Func4&rang;
<LI><a href="#[434]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Socket::Socket__sub_object()
<LI><a href="#[11f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::UARTSerial::tx_irq()
<LI><a href="#[120]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::UARTSerial::rx_irq()
<LI><a href="#[1d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__sti___8_main_cpp_led0
</UL>

<P><STRONG><a name="[791]"></a>mbed::Callback&lang;void()&rang;::Callback__sub_object(void(*)())</STRONG> (Thumb, 0 bytes, Stack size 8 bytes, .\build\arm_hal_timer.o(t._ZN4mbed8CallbackIFvvEEC1EPS1_), UNUSED)

<P><STRONG><a name="[408]"></a>mbed::Callback&lang;void()&rang;::Callback(const mbed::Callback&lang;void()&rang;&)</STRONG> (Thumb, 28 bytes, Stack size 16 bytes, .\build\athandler.o(t._ZN4mbed8CallbackIFvvEEC1ERKS2_))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = mbed::Callback&lang;void()&rang;::Callback(const mbed::Callback&lang;void()&rang;&)
</UL>
<BR>[Called By]<UL><LI><a href="#[3a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::set_urc_handler(const char*, mbed::Callback&lang;void()&rang;)
<LI><a href="#[40e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;int events::EventQueue::call&lang;mbed::Callback&lang;void()&rang;&rang;(T1)
<LI><a href="#[3ad]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Thread::start(mbed::Callback&lang;void()&rang;)
<LI><a href="#[341]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void()&rang;::operator =(const mbed::Callback&lang;void()&rang;&)
</UL>

<P><STRONG><a name="[792]"></a>mbed::Callback&lang;void()&rang;::Callback__sub_object(const mbed::Callback&lang;void()&rang;&)</STRONG> (Thumb, 0 bytes, Stack size 16 bytes, .\build\athandler.o(t._ZN4mbed8CallbackIFvvEEC1ERKS2_), UNUSED)

<P><STRONG><a name="[6cf]"></a>mbed::Callback&lang;void()&rang;::Callback&lang;Socket, Socket&rang;(T2*, void(T1::*)())</STRONG> (Thumb, 68 bytes, Stack size 56 bytes, .\build\socket.o(t._ZN4mbed8CallbackIFvvEEC1I6SocketS4_EEPT0_MT_FvvE))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = mbed::Callback&lang;void()&rang;::Callback&lang;Socket, Socket&rang;(T2*, void(T1::*)())
</UL>
<BR>[Called By]<UL><LI><a href="#[433]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;T3()&rang; mbed::callback&lang;Socket, Socket, void&rang;(T2*, T3(T1::*)())
</UL>

<P><STRONG><a name="[793]"></a>mbed::Callback&lang;void()&rang;::Callback__sub_object&lang;Socket, Socket&rang;(T2*, void(T1::*)())</STRONG> (Thumb, 0 bytes, Stack size 56 bytes, .\build\socket.o(t._ZN4mbed8CallbackIFvvEEC1I6SocketS4_EEPT0_MT_FvvE), UNUSED)

<P><STRONG><a name="[6d0]"></a>mbed::Callback&lang;void()&rang;::Callback&lang;events::EventQueue, events::EventQueue&rang;(T2*, void(T1::*)())</STRONG> (Thumb, 68 bytes, Stack size 56 bytes, .\build\cellularconnectionfsm.o(t._ZN4mbed8CallbackIFvvEEC1IN6events10EventQueueES5_EEPT0_MT_FvvE))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = mbed::Callback&lang;void()&rang;::Callback&lang;events::EventQueue, events::EventQueue&rang;(T2*, void(T1::*)())
</UL>
<BR>[Called By]<UL><LI><a href="#[3ac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;T3()&rang; mbed::callback&lang;events::EventQueue, events::EventQueue, void&rang;(T2*, T3(T1::*)())
</UL>

<P><STRONG><a name="[794]"></a>mbed::Callback&lang;void()&rang;::Callback__sub_object&lang;events::EventQueue, events::EventQueue&rang;(T2*, void(T1::*)())</STRONG> (Thumb, 0 bytes, Stack size 56 bytes, .\build\cellularconnectionfsm.o(t._ZN4mbed8CallbackIFvvEEC1IN6events10EventQueueES5_EEPT0_MT_FvvE), UNUSED)

<P><STRONG><a name="[6d1]"></a>mbed::Callback&lang;void()&rang;::Callback&lang;mbed::UARTSerial, mbed::UARTSerial&rang;(T2*, void(T1::*)())</STRONG> (Thumb, 68 bytes, Stack size 56 bytes, .\build\uartserial.o(t._ZN4mbed8CallbackIFvvEEC1INS_10UARTSerialES4_EEPT0_MT_FvvE))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = mbed::Callback&lang;void()&rang;::Callback&lang;mbed::UARTSerial, mbed::UARTSerial&rang;(T2*, void(T1::*)())
</UL>
<BR>[Called By]<UL><LI><a href="#[359]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;T3()&rang; mbed::callback&lang;mbed::UARTSerial, mbed::UARTSerial, void&rang;(T2*, T3(T1::*)())
</UL>

<P><STRONG><a name="[795]"></a>mbed::Callback&lang;void()&rang;::Callback__sub_object&lang;mbed::UARTSerial, mbed::UARTSerial&rang;(T2*, void(T1::*)())</STRONG> (Thumb, 0 bytes, Stack size 56 bytes, .\build\uartserial.o(t._ZN4mbed8CallbackIFvvEEC1INS_10UARTSerialES4_EEPT0_MT_FvvE), UNUSED)

<P><STRONG><a name="[6d3]"></a>mbed::Callback&lang;void()&rang;::Callback&lang;mbed::AT_CellularNetwork, mbed::AT_CellularNetwork&rang;(T2*, void(T1::*)())</STRONG> (Thumb, 68 bytes, Stack size 56 bytes, .\build\at_cellularnetwork.o(t._ZN4mbed8CallbackIFvvEEC1INS_18AT_CellularNetworkES4_EEPT0_MT_FvvE))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = mbed::Callback&lang;void()&rang;::Callback&lang;mbed::AT_CellularNetwork, mbed::AT_CellularNetwork&rang;(T2*, void(T1::*)())
</UL>
<BR>[Called By]<UL><LI><a href="#[3a3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;T3()&rang; mbed::callback&lang;mbed::AT_CellularNetwork, mbed::AT_CellularNetwork, void&rang;(T2*, T3(T1::*)())
</UL>

<P><STRONG><a name="[796]"></a>mbed::Callback&lang;void()&rang;::Callback__sub_object&lang;mbed::AT_CellularNetwork, mbed::AT_CellularNetwork&rang;(T2*, void(T1::*)())</STRONG> (Thumb, 0 bytes, Stack size 56 bytes, .\build\at_cellularnetwork.o(t._ZN4mbed8CallbackIFvvEEC1INS_18AT_CellularNetworkES4_EEPT0_MT_FvvE), UNUSED)

<P><STRONG><a name="[6d4]"></a>mbed::Callback&lang;void()&rang;::Callback&lang;mbed::CellularConnectionFSM, mbed::CellularConnectionFSM&rang;(T2*, void(T1::*)())</STRONG> (Thumb, 68 bytes, Stack size 56 bytes, .\build\cellularconnectionfsm.o(t._ZN4mbed8CallbackIFvvEEC1INS_21CellularConnectionFSMES4_EEPT0_MT_FvvE))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = mbed::Callback&lang;void()&rang;::Callback&lang;mbed::CellularConnectionFSM, mbed::CellularConnectionFSM&rang;(T2*, void(T1::*)())
</UL>
<BR>[Called By]<UL><LI><a href="#[3b9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;T3()&rang; mbed::callback&lang;mbed::CellularConnectionFSM, mbed::CellularConnectionFSM, void&rang;(T2*, T3(T1::*)())
</UL>

<P><STRONG><a name="[797]"></a>mbed::Callback&lang;void()&rang;::Callback__sub_object&lang;mbed::CellularConnectionFSM, mbed::CellularConnectionFSM&rang;(T2*, void(T1::*)())</STRONG> (Thumb, 0 bytes, Stack size 56 bytes, .\build\cellularconnectionfsm.o(t._ZN4mbed8CallbackIFvvEEC1INS_21CellularConnectionFSMES4_EEPT0_MT_FvvE), UNUSED)

<P><STRONG><a name="[3dc]"></a>mbed::Callback&lang;void()&rang;::Callback&lang;mbed::QUECTEL_BG96_CellularStack, mbed::QUECTEL_BG96_CellularStack&rang;(T2*, void(T1::*)())</STRONG> (Thumb, 68 bytes, Stack size 56 bytes, .\build\quectel_bg96_cellularstack.o(t._ZN4mbed8CallbackIFvvEEC1INS_26QUECTEL_BG96_CellularStackES4_EEPT0_MT_FvvE))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = mbed::Callback&lang;void()&rang;::Callback&lang;mbed::QUECTEL_BG96_CellularStack, mbed::QUECTEL_BG96_CellularStack&rang;(T2*, void(T1::*)())
</UL>
<BR>[Called By]<UL><LI><a href="#[3db]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::QUECTEL_BG96_CellularStack::QUECTEL_BG96_CellularStack(mbed::ATHandler&, int, nsapi_ip_stack)
</UL>

<P><STRONG><a name="[798]"></a>mbed::Callback&lang;void()&rang;::Callback__sub_object&lang;mbed::QUECTEL_BG96_CellularStack, mbed::QUECTEL_BG96_CellularStack&rang;(T2*, void(T1::*)())</STRONG> (Thumb, 0 bytes, Stack size 56 bytes, .\build\quectel_bg96_cellularstack.o(t._ZN4mbed8CallbackIFvvEEC1INS_26QUECTEL_BG96_CellularStackES4_EEPT0_MT_FvvE), UNUSED)

<P><STRONG><a name="[40b]"></a>mbed::Callback&lang;void()&rang;::Callback&lang;mbed::ATHandler, mbed::ATHandler&rang;(T2*, void(T1::*)())</STRONG> (Thumb, 68 bytes, Stack size 56 bytes, .\build\athandler.o(t._ZN4mbed8CallbackIFvvEEC1INS_9ATHandlerES4_EEPT0_MT_FvvE))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = mbed::Callback&lang;void()&rang;::Callback&lang;mbed::ATHandler, mbed::ATHandler&rang;(T2*, void(T1::*)())
</UL>
<BR>[Called By]<UL><LI><a href="#[381]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::unlock()
<LI><a href="#[c7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::event()
<LI><a href="#[40a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::set_filehandle_sigio()
</UL>

<P><STRONG><a name="[799]"></a>mbed::Callback&lang;void()&rang;::Callback__sub_object&lang;mbed::ATHandler, mbed::ATHandler&rang;(T2*, void(T1::*)())</STRONG> (Thumb, 0 bytes, Stack size 56 bytes, .\build\athandler.o(t._ZN4mbed8CallbackIFvvEEC1INS_9ATHandlerES4_EEPT0_MT_FvvE), UNUSED)

<P><STRONG><a name="[53]"></a>mbed::Callback&lang;void()&rang;::~Callback()</STRONG> (Thumb, 20 bytes, Stack size 8 bytes, .\build\arm_hal_timer.o(t._ZN4mbed8CallbackIFvvEED1Ev))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = mbed::Callback&lang;void()&rang;::~Callback()
</UL>
<BR>[Called By]<UL><LI><a href="#[3e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Ticker::detach()
<LI><a href="#[390]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::~ATHandler()
<LI><a href="#[5a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Timeout::~Timeout()
<LI><a href="#[309]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Ticker::attach_us(mbed::Callback&lang;void()&rang;, unsigned long long)
<LI><a href="#[381]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::unlock()
<LI><a href="#[3a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::set_urc_handler(const char*, mbed::Callback&lang;void()&rang;)
<LI><a href="#[c2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;void events::EventQueue::function_dtor&lang;mbed::Callback&lang;void()&rang;&rang;(void*)
<LI><a href="#[c7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::event()
<LI><a href="#[40a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::set_filehandle_sigio()
<LI><a href="#[3ad]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Thread::start(mbed::Callback&lang;void()&rang;)
<LI><a href="#[c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::CellularConnectionFSM::event()
<LI><a href="#[3b8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::CellularConnectionFSM::continue_to_state(mbed::CellularConnectionFSM::CellularState)
<LI><a href="#[3b5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::CellularConnectionFSM::start_dispatch()
<LI><a href="#[149]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::UARTSerial::~UARTSerial()
<LI><a href="#[35f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::UARTSerial::UARTSerial(PinName, PinName, int)
<LI><a href="#[305]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_tick_init()
<LI><a href="#[145]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::SerialBase::~SerialBase()
<LI><a href="#[341]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void()&rang;::operator =(const mbed::Callback&lang;void()&rang;&)
<LI><a href="#[579]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_lwip_disconnect
<LI><a href="#[577]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_lwip_connect
<LI><a href="#[60]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Thread::~Thread()
<LI><a href="#[2ef]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Socket::open(NetworkStack*)
<LI><a href="#[a1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::stream_cb()
<LI><a href="#[3a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::prepare_event_queue()
<LI><a href="#[347]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::SerialBase::SerialBase(PinName, PinName, int)
<LI><a href="#[33f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::SerialBase::attach(mbed::Callback&lang;void()&rang;, mbed::SerialBase::IrqType)
<LI><a href="#[138]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Socket::~Socket__sub_object()
<LI><a href="#[1a9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Timeout::handler()
<LI><a href="#[11f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::UARTSerial::tx_irq()
<LI><a href="#[120]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::UARTSerial::rx_irq()
<LI><a href="#[14b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::UARTSerial::write(const void*, unsigned)
<LI><a href="#[151]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::UARTSerial::sigio(mbed::Callback&lang;void()&rang;)
<LI><a href="#[14c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::UARTSerial::read(void*, unsigned)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> serialbase.o(i._ZN4mbed10SerialBaseD1Ev)
</UL>
<P><STRONG><a name="[79a]"></a>mbed::Callback&lang;void()&rang;::~Callback__sub_object()</STRONG> (Thumb, 0 bytes, Stack size 8 bytes, .\build\arm_hal_timer.o(t._ZN4mbed8CallbackIFvvEED1Ev), UNUSED)

<P><STRONG><a name="[341]"></a>mbed::Callback&lang;void()&rang;::operator =(const mbed::Callback&lang;void()&rang;&)</STRONG> (Thumb, 38 bytes, Stack size 16 bytes, .\build\loramac.o(t._ZN4mbed8CallbackIFvvEEaSERKS2_))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = mbed::Callback&lang;void()&rang;::operator =(const mbed::Callback&lang;void()&rang;&) &rArr; mbed::Callback&lang;void()&rang;::Callback(const mbed::Callback&lang;void()&rang;&)
</UL>
<BR>[Calls]<UL><LI><a href="#[53]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void()&rang;::~Callback()
<LI><a href="#[408]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void()&rang;::Callback(const mbed::Callback&lang;void()&rang;&)
</UL>
<BR>[Called By]<UL><LI><a href="#[2ef]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Socket::open(NetworkStack*)
<LI><a href="#[347]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::SerialBase::SerialBase(PinName, PinName, int)
<LI><a href="#[33f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::SerialBase::attach(mbed::Callback&lang;void()&rang;, mbed::SerialBase::IrqType)
</UL>

<P><STRONG><a name="[433]"></a>mbed::Callback&lang;T3()&rang; mbed::callback&lang;Socket, Socket, void&rang;(T2*, T3(T1::*)())</STRONG> (Thumb, 22 bytes, Stack size 32 bytes, .\build\socket.o(t._ZN4mbed8callbackI6SocketS1_vEENS_8CallbackIFT1_vEEEPT0_MT_FS3_vE))
<BR><BR>[Stack]<UL><LI>Max Depth = 88<LI>Call Chain = mbed::Callback&lang;T3()&rang; mbed::callback&lang;Socket, Socket, void&rang;(T2*, T3(T1::*)()) &rArr; mbed::Callback&lang;void()&rang;::Callback&lang;Socket, Socket&rang;(T2*, void(T1::*)())
</UL>
<BR>[Calls]<UL><LI><a href="#[6cf]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void()&rang;::Callback&lang;Socket, Socket&rang;(T2*, void(T1::*)())
</UL>
<BR>[Called By]<UL><LI><a href="#[2ef]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Socket::open(NetworkStack*)
</UL>

<P><STRONG><a name="[3ac]"></a>mbed::Callback&lang;T3()&rang; mbed::callback&lang;events::EventQueue, events::EventQueue, void&rang;(T2*, T3(T1::*)())</STRONG> (Thumb, 22 bytes, Stack size 32 bytes, .\build\cellularconnectionfsm.o(t._ZN4mbed8callbackIN6events10EventQueueES2_vEENS_8CallbackIFT1_vEEEPT0_MT_FS4_vE))
<BR><BR>[Stack]<UL><LI>Max Depth = 88<LI>Call Chain = mbed::Callback&lang;T3()&rang; mbed::callback&lang;events::EventQueue, events::EventQueue, void&rang;(T2*, T3(T1::*)()) &rArr; mbed::Callback&lang;void()&rang;::Callback&lang;events::EventQueue, events::EventQueue&rang;(T2*, void(T1::*)())
</UL>
<BR>[Calls]<UL><LI><a href="#[6d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void()&rang;::Callback&lang;events::EventQueue, events::EventQueue&rang;(T2*, void(T1::*)())
</UL>
<BR>[Called By]<UL><LI><a href="#[3b5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::CellularConnectionFSM::start_dispatch()
<LI><a href="#[3a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::prepare_event_queue()
</UL>

<P><STRONG><a name="[359]"></a>mbed::Callback&lang;T3()&rang; mbed::callback&lang;mbed::UARTSerial, mbed::UARTSerial, void&rang;(T2*, T3(T1::*)())</STRONG> (Thumb, 22 bytes, Stack size 32 bytes, .\build\uartserial.o(t._ZN4mbed8callbackINS_10UARTSerialES1_vEENS_8CallbackIFT1_vEEEPT0_MT_FS3_vE))
<BR><BR>[Stack]<UL><LI>Max Depth = 88<LI>Call Chain = mbed::Callback&lang;T3()&rang; mbed::callback&lang;mbed::UARTSerial, mbed::UARTSerial, void&rang;(T2*, T3(T1::*)()) &rArr; mbed::Callback&lang;void()&rang;::Callback&lang;mbed::UARTSerial, mbed::UARTSerial&rang;(T2*, void(T1::*)())
</UL>
<BR>[Calls]<UL><LI><a href="#[6d1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void()&rang;::Callback&lang;mbed::UARTSerial, mbed::UARTSerial&rang;(T2*, void(T1::*)())
</UL>
<BR>[Called By]<UL><LI><a href="#[35f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::UARTSerial::UARTSerial(PinName, PinName, int)
<LI><a href="#[14b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::UARTSerial::write(const void*, unsigned)
<LI><a href="#[14c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::UARTSerial::read(void*, unsigned)
</UL>

<P><STRONG><a name="[39e]"></a>mbed::Callback&lang;T3(T4, T5)&rang; mbed::callback&lang;mbed::AT_CellularNetwork, mbed::AT_CellularNetwork, void, nsapi_event, int&rang;(T2*, T3(T1::*)(T4, T5))</STRONG> (Thumb, 22 bytes, Stack size 32 bytes, .\build\at_cellularnetwork.o(t._ZN4mbed8callbackINS_18AT_CellularNetworkES1_v11nsapi_eventiEENS_8CallbackIFT1_T2_T3_EEEPT0_MT_FS4_S5_S6_E))
<BR><BR>[Stack]<UL><LI>Max Depth = 88<LI>Call Chain = mbed::Callback&lang;T3(T4, T5)&rang; mbed::callback&lang;mbed::AT_CellularNetwork, mbed::AT_CellularNetwork, void, nsapi_event, int&rang;(T2*, T3(T1::*)(T4, T5)) &rArr; mbed::Callback&lang;void(nsapi_event, int)&rang;::Callback&lang;mbed::AT_CellularNetwork, mbed::AT_CellularNetwork&rang;(T2*, void(T1::*)(nsapi_event, int))
</UL>
<BR>[Calls]<UL><LI><a href="#[6d2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void(nsapi_event, int)&rang;::Callback&lang;mbed::AT_CellularNetwork, mbed::AT_CellularNetwork&rang;(T2*, void(T1::*)(nsapi_event, int))
</UL>
<BR>[Called By]<UL><LI><a href="#[39d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::open_data_channel()
</UL>

<P><STRONG><a name="[3a3]"></a>mbed::Callback&lang;T3()&rang; mbed::callback&lang;mbed::AT_CellularNetwork, mbed::AT_CellularNetwork, void&rang;(T2*, T3(T1::*)())</STRONG> (Thumb, 22 bytes, Stack size 32 bytes, .\build\at_cellularnetwork.o(t._ZN4mbed8callbackINS_18AT_CellularNetworkES1_vEENS_8CallbackIFT1_vEEEPT0_MT_FS3_vE))
<BR><BR>[Stack]<UL><LI>Max Depth = 88<LI>Call Chain = mbed::Callback&lang;T3()&rang; mbed::callback&lang;mbed::AT_CellularNetwork, mbed::AT_CellularNetwork, void&rang;(T2*, T3(T1::*)()) &rArr; mbed::Callback&lang;void()&rang;::Callback&lang;mbed::AT_CellularNetwork, mbed::AT_CellularNetwork&rang;(T2*, void(T1::*)())
</UL>
<BR>[Calls]<UL><LI><a href="#[6d3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void()&rang;::Callback&lang;mbed::AT_CellularNetwork, mbed::AT_CellularNetwork&rang;(T2*, void(T1::*)())
</UL>
<BR>[Called By]<UL><LI><a href="#[388]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::AT_CellularNetwork(mbed::ATHandler&)
</UL>

<P><STRONG><a name="[3b9]"></a>mbed::Callback&lang;T3()&rang; mbed::callback&lang;mbed::CellularConnectionFSM, mbed::CellularConnectionFSM, void&rang;(T2*, T3(T1::*)())</STRONG> (Thumb, 22 bytes, Stack size 32 bytes, .\build\cellularconnectionfsm.o(t._ZN4mbed8callbackINS_21CellularConnectionFSMES1_vEENS_8CallbackIFT1_vEEEPT0_MT_FS3_vE))
<BR><BR>[Stack]<UL><LI>Max Depth = 88<LI>Call Chain = mbed::Callback&lang;T3()&rang; mbed::callback&lang;mbed::CellularConnectionFSM, mbed::CellularConnectionFSM, void&rang;(T2*, T3(T1::*)()) &rArr; mbed::Callback&lang;void()&rang;::Callback&lang;mbed::CellularConnectionFSM, mbed::CellularConnectionFSM&rang;(T2*, void(T1::*)())
</UL>
<BR>[Calls]<UL><LI><a href="#[6d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void()&rang;::Callback&lang;mbed::CellularConnectionFSM, mbed::CellularConnectionFSM&rang;(T2*, void(T1::*)())
</UL>
<BR>[Called By]<UL><LI><a href="#[c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::CellularConnectionFSM::event()
<LI><a href="#[3b8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::CellularConnectionFSM::continue_to_state(mbed::CellularConnectionFSM::CellularState)
</UL>

<P><STRONG><a name="[3d0]"></a>mbed::Callback&lang;T3(T4, T5)&rang; mbed::callback&lang;mbed::EasyCellularConnection, mbed::EasyCellularConnection, bool, int, int&rang;(T2*, T3(T1::*)(T4, T5))</STRONG> (Thumb, 22 bytes, Stack size 32 bytes, .\build\easycellularconnection.o(t._ZN4mbed8callbackINS_22EasyCellularConnectionES1_biiEENS_8CallbackIFT1_T2_T3_EEEPT0_MT_FS3_S4_S5_E))
<BR><BR>[Stack]<UL><LI>Max Depth = 88<LI>Call Chain = mbed::Callback&lang;T3(T4, T5)&rang; mbed::callback&lang;mbed::EasyCellularConnection, mbed::EasyCellularConnection, bool, int, int&rang;(T2*, T3(T1::*)(T4, T5)) &rArr; mbed::Callback&lang;bool(int, int)&rang;::Callback&lang;mbed::EasyCellularConnection, mbed::EasyCellularConnection&rang;(T2*, bool(T1::*)(int, int))
</UL>
<BR>[Calls]<UL><LI><a href="#[6d5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;bool(int, int)&rang;::Callback&lang;mbed::EasyCellularConnection, mbed::EasyCellularConnection&rang;(T2*, bool(T1::*)(int, int))
</UL>
<BR>[Called By]<UL><LI><a href="#[3ca]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::EasyCellularConnection::init()
</UL>

<P><STRONG><a name="[417]"></a>mbed::Callback&lang;T1()&rang; mbed::callback&lang;void&rang;(T1(*)())</STRONG> (Thumb, 18 bytes, Stack size 16 bytes, .\build\ppp_lwip.o(t._ZN4mbed8callbackIvEENS_8CallbackIFT_vEEEPS3_))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = mbed::Callback&lang;T1()&rang; mbed::callback&lang;void&rang;(T1(*)()) &rArr; mbed::Callback&lang;void()&rang;::Callback(void(*)())
</UL>
<BR>[Calls]<UL><LI><a href="#[282]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void()&rang;::Callback(void(*)())
</UL>
<BR>[Called By]<UL><LI><a href="#[577]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_lwip_connect
<LI><a href="#[a1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::stream_cb()
</UL>

<P><STRONG><a name="[c1]"></a>CThunk&lang;mbed::SerialBase&rang;::trampoline(mbed::SerialBase*, void*, void(mbed::SerialBase::**)(void*))</STRONG> (Thumb, 72 bytes, Stack size 32 bytes, .\build\serialbase.o(t._ZN6CThunkIN4mbed10SerialBaseEE10trampolineEPS1_PvPMS1_FvS4_E))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = CThunk&lang;mbed::SerialBase&rang;::trampoline(mbed::SerialBase*, void*, void(mbed::SerialBase::**)(void*))
</UL>
<BR>[Address Reference Count : 1]<UL><LI> serialbase.o(t._ZN6CThunkIN4mbed10SerialBaseEE4initEPS1_MS1_FvPvES4_)
</UL>
<P><STRONG><a name="[348]"></a>CThunk&lang;mbed::SerialBase&rang;::init(mbed::SerialBase*, void(mbed::SerialBase::*)(void*), void*)</STRONG> (Thumb, 72 bytes, Stack size 24 bytes, .\build\serialbase.o(t._ZN6CThunkIN4mbed10SerialBaseEE4initEPS1_MS1_FvPvES4_))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = CThunk&lang;mbed::SerialBase&rang;::init(mbed::SerialBase*, void(mbed::SerialBase::*)(void*), void*)
</UL>
<BR>[Called By]<UL><LI><a href="#[347]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::SerialBase::SerialBase(PinName, PinName, int)
</UL>

<P><STRONG><a name="[c3]"></a>void events::EventQueue::function_call&lang;mbed::Callback&lang;void()&rang;&rang;(void*)</STRONG> (Thumb, 12 bytes, Stack size 8 bytes, .\build\athandler.o(t._ZN6events10EventQueue13function_callIN4mbed8CallbackIFvvEEEEEvPv))
<BR><BR>[Stack]<UL><LI>Max Depth = 552 + Unknown Stack Size
<LI>Call Chain = void events::EventQueue::function_call&lang;mbed::Callback&lang;void()&rang;&rang;(void*) &rArr; mbed::Callback&lang;void()&rang;::operator ()() const &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[35b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void()&rang;::operator ()() const
</UL>
<BR>[Address Reference Count : 2]<UL><LI> athandler.o(t._ZN6events10EventQueue4callIN4mbed8CallbackIFvvEEEEEiT_)
<LI> cellularconnectionfsm.o(t._ZN6events10EventQueue7call_inIN4mbed8CallbackIFvvEEEEEiiT_)
</UL>
<P><STRONG><a name="[c2]"></a>void events::EventQueue::function_dtor&lang;mbed::Callback&lang;void()&rang;&rang;(void*)</STRONG> (Thumb, 12 bytes, Stack size 8 bytes, .\build\athandler.o(t._ZN6events10EventQueue13function_dtorIN4mbed8CallbackIFvvEEEEEvPv))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = void events::EventQueue::function_dtor&lang;mbed::Callback&lang;void()&rang;&rang;(void*) &rArr; mbed::Callback&lang;void()&rang;::~Callback()
</UL>
<BR>[Calls]<UL><LI><a href="#[53]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void()&rang;::~Callback()
</UL>
<BR>[Address Reference Count : 2]<UL><LI> athandler.o(t._ZN6events10EventQueue4callIN4mbed8CallbackIFvvEEEEEiT_)
<LI> cellularconnectionfsm.o(t._ZN6events10EventQueue7call_inIN4mbed8CallbackIFvvEEEEEiiT_)
</UL>
<P><STRONG><a name="[40e]"></a>int events::EventQueue::call&lang;mbed::Callback&lang;void()&rang;&rang;(T1)</STRONG> (Thumb, 68 bytes, Stack size 24 bytes, .\build\athandler.o(t._ZN6events10EventQueue4callIN4mbed8CallbackIFvvEEEEEiT_))
<BR><BR>[Stack]<UL><LI>Max Depth = 624 + Unknown Stack Size
<LI>Call Chain = int events::EventQueue::call&lang;mbed::Callback&lang;void()&rang;&rang;(T1) &rArr; equeue_post &rArr; equeue_tick &rArr; equeue_tick_init() &rArr; mbed::Ticker::attach_us(mbed::Callback&lang;void()&rang;, unsigned long long) &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[4a2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_post
<LI><a href="#[6d6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_event_dtor
<LI><a href="#[499]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_alloc
<LI><a href="#[408]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void()&rang;::Callback(const mbed::Callback&lang;void()&rang;&)
</UL>
<BR>[Called By]<UL><LI><a href="#[381]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::unlock()
<LI><a href="#[c7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::event()
<LI><a href="#[a1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::stream_cb()
</UL>

<P><STRONG><a name="[3ba]"></a>int events::EventQueue::call_in&lang;mbed::Callback&lang;void()&rang;&rang;(int, T1)</STRONG> (Thumb, 96 bytes, Stack size 40 bytes, .\build\cellularconnectionfsm.o(t._ZN6events10EventQueue7call_inIN4mbed8CallbackIFvvEEEEEiiT_))
<BR><BR>[Stack]<UL><LI>Max Depth = 640 + Unknown Stack Size
<LI>Call Chain = int events::EventQueue::call_in&lang;mbed::Callback&lang;void()&rang;&rang;(int, T1) &rArr; equeue_post &rArr; equeue_tick &rArr; equeue_tick_init() &rArr; mbed::Ticker::attach_us(mbed::Callback&lang;void()&rang;, unsigned long long) &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[4a2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_post
<LI><a href="#[6d6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_event_dtor
<LI><a href="#[499]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_alloc
<LI><a href="#[4a1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_event_delay
</UL>
<BR>[Called By]<UL><LI><a href="#[c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::CellularConnectionFSM::event()
<LI><a href="#[3b8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::CellularConnectionFSM::continue_to_state(mbed::CellularConnectionFSM::CellularState)
</UL>

<P><STRONG><a name="[358]"></a>mbed::CircularBuffer&lang;char, (unsigned)256, unsigned&rang;::full() const</STRONG> (Thumb, 20 bytes, Stack size 16 bytes, .\build\uartserial.o(t._ZNK4mbed14CircularBufferIcLj256EjE4fullEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = mbed::CircularBuffer&lang;char, (unsigned)256, unsigned&rang;::full() const &rArr; core_util_critical_section_exit &rArr; hal_critical_section_exit &rArr;  mbed_assert_internal (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[311]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;core_util_critical_section_exit
<LI><a href="#[30c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;core_util_critical_section_enter
</UL>
<BR>[Called By]<UL><LI><a href="#[35c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::CircularBuffer&lang;char, (unsigned)256, unsigned&rang;::push(const char&)
<LI><a href="#[14a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::UARTSerial::poll(short) const
<LI><a href="#[11f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::UARTSerial::tx_irq()
<LI><a href="#[120]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::UARTSerial::rx_irq()
<LI><a href="#[14b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::UARTSerial::write(const void*, unsigned)
<LI><a href="#[14c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::UARTSerial::read(void*, unsigned)
</UL>

<P><STRONG><a name="[356]"></a>mbed::CircularBuffer&lang;char, (unsigned)256, unsigned&rang;::empty() const</STRONG> (Thumb, 42 bytes, Stack size 16 bytes, .\build\uartserial.o(t._ZNK4mbed14CircularBufferIcLj256EjE5emptyEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = mbed::CircularBuffer&lang;char, (unsigned)256, unsigned&rang;::empty() const &rArr; core_util_critical_section_exit &rArr; hal_critical_section_exit &rArr;  mbed_assert_internal (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[311]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;core_util_critical_section_exit
<LI><a href="#[30c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;core_util_critical_section_enter
</UL>
<BR>[Called By]<UL><LI><a href="#[357]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::CircularBuffer&lang;char, (unsigned)256, unsigned&rang;::pop(char&)
<LI><a href="#[14a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::UARTSerial::poll(short) const
<LI><a href="#[11f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::UARTSerial::tx_irq()
<LI><a href="#[120]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::UARTSerial::rx_irq()
<LI><a href="#[14b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::UARTSerial::write(const void*, unsigned)
<LI><a href="#[14c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::UARTSerial::read(void*, unsigned)
</UL>

<P><STRONG><a name="[3b4]"></a>mbed::Callback&lang;bool(int, int)&rang;::operator ()(int, int) const</STRONG> (Thumb, 54 bytes, Stack size 32 bytes, .\build\cellularconnectionfsm.o(t._ZNK4mbed8CallbackIFbiiEEclEii))
<BR><BR>[Stack]<UL><LI>Max Depth = 560 + Unknown Stack Size
<LI>Call Chain = mbed::Callback&lang;bool(int, int)&rang;::operator ()(int, int) const &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[33a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_assert_internal
</UL>
<BR>[Called By]<UL><LI><a href="#[c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::CellularConnectionFSM::event()
<LI><a href="#[3b2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::CellularConnectionFSM::report_failure(const char*)
</UL>

<P><STRONG><a name="[3b3]"></a>mbed::Callback&lang;bool(int, int)&rang;::operator bool() const</STRONG> (Thumb, 14 bytes, Stack size 0 bytes, .\build\cellularconnectionfsm.o(t._ZNK4mbed8CallbackIFbiiEEcvbEv))
<BR><BR>[Called By]<UL><LI><a href="#[c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::CellularConnectionFSM::event()
<LI><a href="#[3b2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::CellularConnectionFSM::report_failure(const char*)
</UL>

<P><STRONG><a name="[37b]"></a>mbed::Callback&lang;void(nsapi_event, int)&rang;::operator ()(nsapi_event, int) const</STRONG> (Thumb, 56 bytes, Stack size 32 bytes, .\build\at_cellularnetwork.o(t._ZNK4mbed8CallbackIFv11nsapi_eventiEEclES1_i))
<BR><BR>[Stack]<UL><LI>Max Depth = 560 + Unknown Stack Size
<LI>Call Chain = mbed::Callback&lang;void(nsapi_event, int)&rang;::operator ()(nsapi_event, int) const &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[33a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_assert_internal
</UL>
<BR>[Called By]<UL><LI><a href="#[17a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::connect()
<LI><a href="#[c5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::urc_no_carrier()
<LI><a href="#[c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::ppp_status_cb(nsapi_event, int)
<LI><a href="#[a2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ppp_link_status(ppp_pcb_s*, int, void*)
</UL>

<P><STRONG><a name="[37a]"></a>mbed::Callback&lang;void(nsapi_event, int)&rang;::operator bool() const</STRONG> (Thumb, 14 bytes, Stack size 0 bytes, .\build\at_cellularnetwork.o(t._ZNK4mbed8CallbackIFv11nsapi_eventiEEcvbEv))
<BR><BR>[Called By]<UL><LI><a href="#[17a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::connect()
<LI><a href="#[c5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::urc_no_carrier()
<LI><a href="#[c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::AT_CellularNetwork::ppp_status_cb(nsapi_event, int)
<LI><a href="#[a2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ppp_link_status(ppp_pcb_s*, int, void*)
</UL>

<P><STRONG><a name="[33d]"></a>mbed::Callback&lang;void(int)&rang;::call(int) const</STRONG> (Thumb, 38 bytes, Stack size 16 bytes, .\build\serialbase.o(t._ZNK4mbed8CallbackIFviEE4callEi))
<BR><BR>[Stack]<UL><LI>Max Depth = 544 + Unknown Stack Size
<LI>Call Chain = mbed::Callback&lang;void(int)&rang;::call(int) const &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[33a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_assert_internal
</UL>
<BR>[Called By]<UL><LI><a href="#[11d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::SerialBase::interrupt_handler_asynch()
</UL>

<P><STRONG><a name="[33c]"></a>mbed::Callback&lang;void(int)&rang;::operator bool() const</STRONG> (Thumb, 14 bytes, Stack size 0 bytes, .\build\serialbase.o(t._ZNK4mbed8CallbackIFviEEcvbEv))
<BR><BR>[Called By]<UL><LI><a href="#[11d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::SerialBase::interrupt_handler_asynch()
</UL>

<P><STRONG><a name="[6ce]"></a>mbed::Callback&lang;void()&rang;::call() const</STRONG> (Thumb, 34 bytes, Stack size 8 bytes, .\build\tcpserver.o(t._ZNK4mbed8CallbackIFvvEE4callEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 536 + Unknown Stack Size
<LI>Call Chain = mbed::Callback&lang;void()&rang;::call() const &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[33a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_assert_internal
</UL>
<BR>[Called By]<UL><LI><a href="#[57]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void()&rang;::thunk(void*)
</UL>

<P><STRONG><a name="[35b]"></a>mbed::Callback&lang;void()&rang;::operator ()() const</STRONG> (Thumb, 40 bytes, Stack size 16 bytes, .\build\at_cellularsms.o(t._ZNK4mbed8CallbackIFvvEEclEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 544 + Unknown Stack Size
<LI>Call Chain = mbed::Callback&lang;void()&rang;::operator ()() const &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[33a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_assert_internal
</UL>
<BR>[Called By]<UL><LI><a href="#[c3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;void events::EventQueue::function_call&lang;mbed::Callback&lang;void()&rang;&rang;(void*)
<LI><a href="#[401]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ATHandler::match_urc()
<LI><a href="#[151]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::UARTSerial::sigio(mbed::Callback&lang;void()&rang;)
<LI><a href="#[35a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::UARTSerial::wake()
</UL>

<P><STRONG><a name="[339]"></a>mbed::Callback&lang;void()&rang;::operator bool() const</STRONG> (Thumb, 14 bytes, Stack size 0 bytes, .\build\at_cellularsms.o(t._ZNK4mbed8CallbackIFvvEEcvbEv))
<BR><BR>[Called By]<UL><LI><a href="#[3e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Ticker::detach()
<LI><a href="#[33f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::SerialBase::attach(mbed::Callback&lang;void()&rang;, mbed::SerialBase::IrqType)
<LI><a href="#[52]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::SerialBase::_irq_handler(unsigned, SerialIrq)
<LI><a href="#[1a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Ticker::handler()
<LI><a href="#[151]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::UARTSerial::sigio(mbed::Callback&lang;void()&rang;)
<LI><a href="#[35a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::UARTSerial::wake()
</UL>

<P><STRONG><a name="[203]"></a>_fp_init</STRONG> (Thumb, 10 bytes, Stack size 0 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\fz_wm.l(fpinit.o)(x$fpl$fpinit))
<BR><BR>[Called By]<UL><LI><a href="#[202]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init_fp_1
</UL>

<P><STRONG><a name="[79b]"></a>__fplib_config_fpu_vfp</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\fz_wm.l(fpinit.o)(x$fpl$fpinit), UNUSED)

<P><STRONG><a name="[79c]"></a>__fplib_config_pureend_doubles</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\fz_wm.l(fpinit.o)(x$fpl$fpinit), UNUSED)

<P><STRONG><a name="[1e5]"></a>_printf_fp_dec</STRONG> (Thumb, 4 bytes, Stack size 0 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\fz_wm.l(printf1.o)(x$fpl$printf1))
<BR><BR>[Stack]<UL><LI>Max Depth = 324<LI>Call Chain = _printf_fp_dec &rArr; _printf_fp_dec_real &rArr; _fp_digits &rArr; _btod_etento &rArr; _btod_emul &rArr; _e2e
</UL>
<BR>[Calls]<UL><LI><a href="#[25a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_fp_dec_real
</UL>
<BR>[Called By]<UL><LI><a href="#[1e7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_g
<LI><a href="#[1e6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_e
<LI><a href="#[1e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_f
</UL>

<P><STRONG><a name="[1e9]"></a>_printf_fp_hex</STRONG> (Thumb, 4 bytes, Stack size 0 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\fz_wm.l(printf2.o)(x$fpl$printf2))
<BR><BR>[Stack]<UL><LI>Max Depth = 112<LI>Call Chain = _printf_fp_hex &rArr; _printf_fp_hex_real &rArr; _printf_fp_infnan &rArr; _printf_post_padding
</UL>
<BR>[Calls]<UL><LI><a href="#[271]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_fp_hex_real
</UL>
<BR>[Called By]<UL><LI><a href="#[1e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_a
</UL>
<P>
<H3>
Local Symbols
</H3>
<P><STRONG><a name="[1d5]"></a>__sti___17_arm_hal_timer_cpp_749a681d</STRONG> (Thumb, 88 bytes, Stack size 16 bytes, .\build\arm_hal_timer.o(i.__sti___17_arm_hal_timer_cpp_749a681d))
<BR><BR>[Stack]<UL><LI>Max Depth = 224<LI>Call Chain = __sti___17_arm_hal_timer_cpp_749a681d &rArr; mbed::Timer::Timer() &rArr; mbed::Timer::reset() &rArr; ticker_read_us &rArr; initialize &rArr;  mbed_assert_internal (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[2fa]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_atexit
<LI><a href="#[306]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Timer::Timer()
<LI><a href="#[307]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::TimerEvent::TimerEvent__sub_object()
<LI><a href="#[282]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void()&rang;::Callback(void(*)())
</UL>
<BR>[Address Reference Count : 1]<UL><LI> arm_hal_timer.o(.init_array)
</UL>
<P><STRONG><a name="[295]"></a>BUS_RegBitRead</STRONG> (Thumb, 20 bytes, Stack size 8 bytes, .\build\em_cmu.o(i.BUS_RegBitRead))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = BUS_RegBitRead
</UL>
<BR>[Called By]<UL><LI><a href="#[294]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CMU_OscillatorEnable
<LI><a href="#[4c9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;getHfLeConfig
</UL>

<P><STRONG><a name="[28d]"></a>BUS_RegBitWrite</STRONG> (Thumb, 18 bytes, Stack size 12 bytes, .\build\em_cmu.o(i.BUS_RegBitWrite))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = BUS_RegBitWrite
</UL>
<BR>[Called By]<UL><LI><a href="#[28b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CMU_ClockEnable
<LI><a href="#[292]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CMU_ClockSelectSet
<LI><a href="#[289]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;setHfLeConfig
</UL>

<P><STRONG><a name="[287]"></a>CMU_DivToLog2</STRONG> (Thumb, 12 bytes, Stack size 0 bytes, .\build\em_cmu.o(i.CMU_DivToLog2))
<BR><BR>[Called By]<UL><LI><a href="#[283]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CMU_ClockDivSet
<LI><a href="#[28c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CMU_ClockFreqGet
</UL>

<P><STRONG><a name="[290]"></a>auxClkGet</STRONG> (Thumb, 110 bytes, Stack size 0 bytes, .\build\em_cmu.o(i.auxClkGet))
<BR><BR>[Called By]<UL><LI><a href="#[28f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dbgClkGet
<LI><a href="#[28c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CMU_ClockFreqGet
</UL>

<P><STRONG><a name="[28f]"></a>dbgClkGet</STRONG> (Thumb, 44 bytes, Stack size 16 bytes, .\build\em_cmu.o(i.dbgClkGet))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = dbgClkGet
</UL>
<BR>[Calls]<UL><LI><a href="#[478]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CMU_ClockSelectGet
<LI><a href="#[290]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;auxClkGet
<LI><a href="#[288]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SystemHFClockGet
</UL>
<BR>[Called By]<UL><LI><a href="#[28c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CMU_ClockFreqGet
</UL>

<P><STRONG><a name="[296]"></a>flashWaitStateControl</STRONG> (Thumb, 136 bytes, Stack size 16 bytes, .\build\em_cmu.o(i.flashWaitStateControl))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = flashWaitStateControl
</UL>
<BR>[Called By]<UL><LI><a href="#[284]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;flashWaitStateMax
<LI><a href="#[286]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CMU_UpdateWaitStates
</UL>

<P><STRONG><a name="[284]"></a>flashWaitStateMax</STRONG> (Thumb, 16 bytes, Stack size 8 bytes, .\build\em_cmu.o(i.flashWaitStateMax))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = flashWaitStateMax &rArr; flashWaitStateControl
</UL>
<BR>[Calls]<UL><LI><a href="#[296]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;flashWaitStateControl
<LI><a href="#[4b9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SystemMaxCoreClockGet
</UL>
<BR>[Called By]<UL><LI><a href="#[292]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CMU_ClockSelectSet
<LI><a href="#[283]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CMU_ClockDivSet
</UL>

<P><STRONG><a name="[4c9]"></a>getHfLeConfig</STRONG> (Thumb, 16 bytes, Stack size 8 bytes, .\build\em_cmu.o(i.getHfLeConfig))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = getHfLeConfig &rArr; BUS_RegBitRead
</UL>
<BR>[Calls]<UL><LI><a href="#[295]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BUS_RegBitRead
</UL>
<BR>[Called By]<UL><LI><a href="#[28e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lfClkGet
</UL>

<P><STRONG><a name="[28e]"></a>lfClkGet</STRONG> (Thumb, 192 bytes, Stack size 24 bytes, .\build\em_cmu.o(i.lfClkGet))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = lfClkGet &rArr; getHfLeConfig &rArr; BUS_RegBitRead
</UL>
<BR>[Calls]<UL><LI><a href="#[478]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CMU_ClockSelectGet
<LI><a href="#[4c9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;getHfLeConfig
<LI><a href="#[537]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SystemULFRCOClockGet
<LI><a href="#[536]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SystemLFXOClockGet
<LI><a href="#[535]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SystemLFRCOClockGet
<LI><a href="#[285]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SystemCoreClockGet
</UL>
<BR>[Called By]<UL><LI><a href="#[28c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CMU_ClockFreqGet
</UL>

<P><STRONG><a name="[289]"></a>setHfLeConfig</STRONG> (Thumb, 58 bytes, Stack size 16 bytes, .\build\em_cmu.o(i.setHfLeConfig))
<BR><BR>[Stack]<UL><LI>Max Depth = 28<LI>Call Chain = setHfLeConfig &rArr; BUS_RegBitWrite
</UL>
<BR>[Calls]<UL><LI><a href="#[28d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BUS_RegBitWrite
</UL>
<BR>[Called By]<UL><LI><a href="#[28b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CMU_ClockEnable
<LI><a href="#[292]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CMU_ClockSelectSet
<LI><a href="#[283]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CMU_ClockDivSet
</UL>

<P><STRONG><a name="[28a]"></a>syncReg</STRONG> (Thumb, 28 bytes, Stack size 0 bytes, .\build\em_cmu.o(i.syncReg))
<BR><BR>[Called By]<UL><LI><a href="#[28b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CMU_ClockEnable
<LI><a href="#[283]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CMU_ClockDivSet
</UL>

<P><STRONG><a name="[291]"></a>usbCClkGet</STRONG> (Thumb, 58 bytes, Stack size 16 bytes, .\build\em_cmu.o(i.usbCClkGet))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = usbCClkGet
</UL>
<BR>[Calls]<UL><LI><a href="#[478]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CMU_ClockSelectGet
<LI><a href="#[536]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SystemLFXOClockGet
<LI><a href="#[535]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SystemLFRCOClockGet
<LI><a href="#[288]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SystemHFClockGet
</UL>
<BR>[Called By]<UL><LI><a href="#[28c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CMU_ClockFreqGet
</UL>

<P><STRONG><a name="[298]"></a>__get_PRIMASK</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, .\build\em_core.o(i.__get_PRIMASK))
<BR><BR>[Called By]<UL><LI><a href="#[297]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CORE_EnterCritical
</UL>

<P><STRONG><a name="[29a]"></a>emState</STRONG> (Thumb, 196 bytes, Stack size 16 bytes, .\build\em_emu.o(i.emState))
<BR><BR>[Stack]<UL><LI>Max Depth = 112<LI>Call Chain = emState &rArr; CMU_ClockSelectSet &rArr; CMU_ClockFreqGet &rArr; lfClkGet &rArr; getHfLeConfig &rArr; BUS_RegBitRead
</UL>
<BR>[Calls]<UL><LI><a href="#[292]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CMU_ClockSelectSet
<LI><a href="#[478]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CMU_ClockSelectGet
</UL>
<BR>[Called By]<UL><LI><a href="#[299]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EMU_EnterEM2
</UL>

<P><STRONG><a name="[29b]"></a>getErrataFixEmuE107En</STRONG> (Thumb, 48 bytes, Stack size 0 bytes, .\build\em_emu.o(i.getErrataFixEmuE107En))
<BR><BR>[Called By]<UL><LI><a href="#[299]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EMU_EnterEM2
</UL>

<P><STRONG><a name="[29c]"></a>ramWFI</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, .\build\em_emu.o(ram_code))
<BR><BR>[Called By]<UL><LI><a href="#[299]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EMU_EnterEM2
</UL>

<P><STRONG><a name="[2af]"></a>GPIO_PinOutClear</STRONG> (Thumb, 20 bytes, Stack size 8 bytes, .\build\em_gpio.o(i.GPIO_PinOutClear))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = GPIO_PinOutClear
</UL>
<BR>[Called By]<UL><LI><a href="#[2ad]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GPIO_PinModeSet
</UL>

<P><STRONG><a name="[2ae]"></a>GPIO_PinOutSet</STRONG> (Thumb, 20 bytes, Stack size 8 bytes, .\build\em_gpio.o(i.GPIO_PinOutSet))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = GPIO_PinOutSet
</UL>
<BR>[Called By]<UL><LI><a href="#[2ad]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GPIO_PinModeSet
</UL>

<P><STRONG><a name="[2b7]"></a>LEUART_Sync</STRONG> (Thumb, 24 bytes, Stack size 0 bytes, .\build\em_leuart.o(i.LEUART_Sync))
<BR><BR>[Called By]<UL><LI><a href="#[2bb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LEUART_Tx
<LI><a href="#[2b9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LEUART_Init
<LI><a href="#[2b8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LEUART_Enable
<LI><a href="#[2b6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LEUART_BaudrateSet
</UL>

<P><STRONG><a name="[2d7]"></a>TIMER_Valid</STRONG> (Thumb, 34 bytes, Stack size 0 bytes, .\build\em_timer.o(i.TIMER_Valid))
<BR><BR>[Called By]<UL><LI><a href="#[2d6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TIMER_InitCC
</UL>

<P><STRONG><a name="[63]"></a>ecallback_dispatch</STRONG> (Thumb, 14 bytes, Stack size 16 bytes, .\build\equeue.o(i.ecallback_dispatch))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = ecallback_dispatch
</UL>
<BR>[Address Reference Count : 1]<UL><LI> equeue.o(i.equeue_call_in)
</UL>
<P><STRONG><a name="[65]"></a>equeue_chain_dispatch</STRONG> (Thumb, 14 bytes, Stack size 8 bytes, .\build\equeue.o(i.equeue_chain_dispatch))
<BR><BR>[Stack]<UL><LI>Max Depth = 616 + Unknown Stack Size
<LI>Call Chain = equeue_chain_dispatch &rArr; equeue_dispatch &rArr; equeue_tick &rArr; equeue_tick_init() &rArr; mbed::Ticker::attach_us(mbed::Callback&lang;void()&rang;, unsigned long long) &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[437]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_dispatch
</UL>
<BR>[Address Reference Count : 1]<UL><LI> equeue.o(i.equeue_chain_update)
</UL>
<P><STRONG><a name="[64]"></a>equeue_chain_update</STRONG> (Thumb, 46 bytes, Stack size 16 bytes, .\build\equeue.o(i.equeue_chain_update))
<BR><BR>[Stack]<UL><LI>Max Depth = 640 + Unknown Stack Size
<LI>Call Chain = equeue_chain_update &rArr; equeue_call_in &rArr; equeue_post &rArr; equeue_tick &rArr; equeue_tick_init() &rArr; mbed::Ticker::attach_us(mbed::Callback&lang;void()&rang;, unsigned long long) &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[4a5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_dealloc
<LI><a href="#[4a3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_cancel
<LI><a href="#[4a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_call_in
</UL>
<BR>[Address Reference Count : 1]<UL><LI> equeue.o(i.equeue_chain)
</UL>
<P><STRONG><a name="[49e]"></a>equeue_clampdiff</STRONG> (Thumb, 22 bytes, Stack size 16 bytes, .\build\equeue.o(i.equeue_clampdiff))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = equeue_clampdiff
</UL>
<BR>[Calls]<UL><LI><a href="#[4a6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_tickdiff
</UL>
<BR>[Called By]<UL><LI><a href="#[4ad]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_enqueue
<LI><a href="#[437]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_dispatch
<LI><a href="#[49b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_background
</UL>

<P><STRONG><a name="[4aa]"></a>equeue_dequeue</STRONG> (Thumb, 138 bytes, Stack size 32 bytes, .\build\equeue.o(i.equeue_dequeue))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = equeue_dequeue &rArr; equeue_mutex_unlock &rArr; core_util_critical_section_exit &rArr; hal_critical_section_exit &rArr;  mbed_assert_internal (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[4a6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_tickdiff
<LI><a href="#[49f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_mutex_unlock
<LI><a href="#[49c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_mutex_lock
</UL>
<BR>[Called By]<UL><LI><a href="#[437]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_dispatch
</UL>

<P><STRONG><a name="[4ad]"></a>equeue_enqueue</STRONG> (Thumb, 198 bytes, Stack size 32 bytes, .\build\equeue.o(i.equeue_enqueue))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = equeue_enqueue &rArr; equeue_mutex_unlock &rArr; core_util_critical_section_exit &rArr; hal_critical_section_exit &rArr;  mbed_assert_internal (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[4a6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_tickdiff
<LI><a href="#[49e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_clampdiff
<LI><a href="#[49f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_mutex_unlock
<LI><a href="#[49c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_mutex_lock
</UL>
<BR>[Called By]<UL><LI><a href="#[4a2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_post
<LI><a href="#[437]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_dispatch
</UL>

<P><STRONG><a name="[4ae]"></a>equeue_incid</STRONG> (Thumb, 20 bytes, Stack size 0 bytes, .\build\equeue.o(i.equeue_incid))
<BR><BR>[Called By]<UL><LI><a href="#[4a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_unqueue
<LI><a href="#[437]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_dispatch
</UL>

<P><STRONG><a name="[49a]"></a>equeue_mem_alloc</STRONG> (Thumb, 136 bytes, Stack size 24 bytes, .\build\equeue.o(i.equeue_mem_alloc))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = equeue_mem_alloc &rArr; equeue_mutex_unlock &rArr; core_util_critical_section_exit &rArr; hal_critical_section_exit &rArr;  mbed_assert_internal (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[49f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_mutex_unlock
<LI><a href="#[49c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_mutex_lock
</UL>
<BR>[Called By]<UL><LI><a href="#[499]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_alloc
</UL>

<P><STRONG><a name="[4a9]"></a>equeue_mem_dealloc</STRONG> (Thumb, 86 bytes, Stack size 16 bytes, .\build\equeue.o(i.equeue_mem_dealloc))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = equeue_mem_dealloc &rArr; equeue_mutex_unlock &rArr; core_util_critical_section_exit &rArr; hal_critical_section_exit &rArr;  mbed_assert_internal (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[49f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_mutex_unlock
<LI><a href="#[49c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_mutex_lock
</UL>
<BR>[Called By]<UL><LI><a href="#[4a5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_dealloc
</UL>

<P><STRONG><a name="[4a6]"></a>equeue_tickdiff</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, .\build\equeue.o(i.equeue_tickdiff))
<BR><BR>[Called By]<UL><LI><a href="#[4a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_unqueue
<LI><a href="#[4ad]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_enqueue
<LI><a href="#[4aa]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_dequeue
<LI><a href="#[49e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_clampdiff
<LI><a href="#[437]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_dispatch
</UL>

<P><STRONG><a name="[4a4]"></a>equeue_unqueue</STRONG> (Thumb, 176 bytes, Stack size 24 bytes, .\build\equeue.o(i.equeue_unqueue))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = equeue_unqueue &rArr; equeue_mutex_unlock &rArr; core_util_critical_section_exit &rArr; hal_critical_section_exit &rArr;  mbed_assert_internal (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[4a6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_tickdiff
<LI><a href="#[4ae]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_incid
<LI><a href="#[49f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_mutex_unlock
<LI><a href="#[49c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_mutex_lock
</UL>
<BR>[Called By]<UL><LI><a href="#[4a3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_cancel
</UL>

<P><STRONG><a name="[305]"></a>equeue_tick_init()</STRONG> (Thumb, 136 bytes, Stack size 40 bytes, .\build\equeue_mbed.o(i._Z16equeue_tick_initv))
<BR><BR>[Stack]<UL><LI>Max Depth = 552 + Unknown Stack Size
<LI>Call Chain = equeue_tick_init() &rArr; mbed::Ticker::attach_us(mbed::Callback&lang;void()&rang;, unsigned long long) &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[306]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Timer::Timer()
<LI><a href="#[307]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::TimerEvent::TimerEvent__sub_object()
<LI><a href="#[53]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void()&rang;::~Callback()
<LI><a href="#[282]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void()&rang;::Callback(void(*)())
<LI><a href="#[309]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Ticker::attach_us(mbed::Callback&lang;void()&rang;, unsigned long long)
<LI><a href="#[308]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Timer::start()
</UL>
<BR>[Called By]<UL><LI><a href="#[49d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;equeue_tick
</UL>

<P><STRONG><a name="[50]"></a>equeue_tick_update()</STRONG> (Thumb, 26 bytes, Stack size 8 bytes, .\build\equeue_mbed.o(i._Z18equeue_tick_updatev))
<BR><BR>[Stack]<UL><LI>Max Depth = 248<LI>Call Chain = equeue_tick_update() &rArr; mbed::Timer::read_ms() &rArr; mbed::Timer::read_high_resolution_us() &rArr; mbed::Timer::slicetime() &rArr; ticker_read_us &rArr; initialize &rArr;  mbed_assert_internal (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[317]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Timer::reset()
<LI><a href="#[316]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Timer::read_ms()
</UL>
<BR>[Address Reference Count : 1]<UL><LI> equeue_mbed.o(i._Z16equeue_tick_initv)
</UL>
<P><STRONG><a name="[4cc]"></a>BUS_RegBitRead</STRONG> (Thumb, 20 bytes, Stack size 8 bytes, .\build\gpio_api.o(i.BUS_RegBitRead))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = BUS_RegBitRead
</UL>
<BR>[Called By]<UL><LI><a href="#[365]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;gpio_read
</UL>

<P><STRONG><a name="[2a9]"></a>GPIOINT_IRQDispatcher</STRONG> (Thumb, 32 bytes, Stack size 16 bytes, .\build\gpio_irq_api.o(i.GPIOINT_IRQDispatcher))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = GPIOINT_IRQDispatcher &rArr; handle_interrupt_in
</UL>
<BR>[Calls]<UL><LI><a href="#[2aa]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;handle_interrupt_in
</UL>
<BR>[Called By]<UL><LI><a href="#[25]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GPIO_ODD_IRQHandler
<LI><a href="#[1b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GPIO_EVEN_IRQHandler
</UL>

<P><STRONG><a name="[2ac]"></a>GPIO_IntClear</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, .\build\gpio_irq_api.o(i.GPIO_IntClear))
<BR><BR>[Called By]<UL><LI><a href="#[25]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GPIO_ODD_IRQHandler
<LI><a href="#[1b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GPIO_EVEN_IRQHandler
<LI><a href="#[2aa]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;handle_interrupt_in
</UL>

<P><STRONG><a name="[2ab]"></a>GPIO_IntGetEnabled</STRONG> (Thumb, 14 bytes, Stack size 0 bytes, .\build\gpio_irq_api.o(i.GPIO_IntGetEnabled))
<BR><BR>[Called By]<UL><LI><a href="#[25]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GPIO_ODD_IRQHandler
<LI><a href="#[1b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GPIO_EVEN_IRQHandler
</UL>

<P><STRONG><a name="[2aa]"></a>handle_interrupt_in</STRONG> (Thumb, 72 bytes, Stack size 16 bytes, .\build\gpio_irq_api.o(i.handle_interrupt_in))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = handle_interrupt_in
</UL>
<BR>[Calls]<UL><LI><a href="#[2ac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GPIO_IntClear
</UL>
<BR>[Called By]<UL><LI><a href="#[2a9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GPIOINT_IRQDispatcher
</UL>

<P><STRONG><a name="[59c]"></a>netconn_apimsg</STRONG> (Thumb, 34 bytes, Stack size 16 bytes, .\build\lwip_api_lib.o(i.netconn_apimsg))
<BR><BR>[Stack]<UL><LI>Max Depth = 496 + Unknown Stack Size
<LI>Call Chain = netconn_apimsg &rArr; tcpip_send_msg_wait_sem &rArr; sys_mutex_unlock &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[59d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcpip_send_msg_wait_sem
</UL>
<BR>[Called By]<UL><LI><a href="#[58b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netconn_write_partly
<LI><a href="#[5a3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netconn_send
<LI><a href="#[589]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netconn_new_with_proto_and_callback
<LI><a href="#[588]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netconn_listen_with_backlog
<LI><a href="#[582]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netconn_getaddr
<LI><a href="#[586]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netconn_delete
<LI><a href="#[587]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netconn_connect
<LI><a href="#[584]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netconn_bind
<LI><a href="#[5a2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netconn_recv_data
<LI><a href="#[59e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netconn_close_shutdown
</UL>

<P><STRONG><a name="[59e]"></a>netconn_close_shutdown</STRONG> (Thumb, 48 bytes, Stack size 40 bytes, .\build\lwip_api_lib.o(i.netconn_close_shutdown))
<BR><BR>[Stack]<UL><LI>Max Depth = 536 + Unknown Stack Size
<LI>Call Chain = netconn_close_shutdown &rArr; netconn_apimsg &rArr; tcpip_send_msg_wait_sem &rArr; sys_mutex_unlock &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[59c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netconn_apimsg
</UL>
<BR>[Called By]<UL><LI><a href="#[5a2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netconn_recv_data
</UL>

<P><STRONG><a name="[5a2]"></a>netconn_recv_data</STRONG> (Thumb, 280 bytes, Stack size 40 bytes, .\build\lwip_api_lib.o(i.netconn_recv_data))
<BR><BR>[Stack]<UL><LI>Max Depth = 640 + Unknown Stack Size
<LI>Call Chain = netconn_recv_data &rArr; sys_arch_mbox_fetch &rArr; us_ticker_read &rArr; us_ticker_init &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[59b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_mbox_fetch
<LI><a href="#[59e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netconn_close_shutdown
<LI><a href="#[59c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netconn_apimsg
</UL>
<BR>[Called By]<UL><LI><a href="#[58a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netconn_recv
</UL>

<P><STRONG><a name="[6f]"></a>accept_function</STRONG> (Thumb, 248 bytes, Stack size 32 bytes, .\build\lwip_api_msg.o(i.accept_function))
<BR><BR>[Stack]<UL><LI>Max Depth = 560 + Unknown Stack Size
<LI>Call Chain = accept_function &rArr; netconn_alloc &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[454]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_sent
<LI><a href="#[453]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_recv
<LI><a href="#[455]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_poll
<LI><a href="#[456]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_err
<LI><a href="#[452]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_arg
<LI><a href="#[44f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_mbox_trypost
<LI><a href="#[451]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;setup_tcp
<LI><a href="#[457]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_mbox_free
<LI><a href="#[458]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netconn_free
<LI><a href="#[450]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netconn_alloc
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lwip_api_msg.o(i.lwip_netconn_do_listen)
</UL>
<P><STRONG><a name="[6c]"></a>err_tcp</STRONG> (Thumb, 282 bytes, Stack size 32 bytes, .\build\lwip_api_msg.o(i.err_tcp))
<BR><BR>[Stack]<UL><LI>Max Depth = 552 + Unknown Stack Size
<LI>Call Chain = err_tcp &rArr; sys_sem_signal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[37c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_sem_signal
<LI><a href="#[44f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_mbox_trypost
<LI><a href="#[497]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_unprotect
<LI><a href="#[496]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_protect
</UL>
<BR>[Address Reference Count : 2]<UL><LI> lwip_api_msg.o(i.lwip_netconn_do_close_internal)
<LI> lwip_api_msg.o(i.setup_tcp)
</UL>
<P><STRONG><a name="[551]"></a>lwip_netconn_do_close_internal</STRONG> (Thumb, 436 bytes, Stack size 56 bytes, .\build\lwip_api_msg.o(i.lwip_netconn_do_close_internal))
<BR><BR>[Stack]<UL><LI>Max Depth = 1072 + Unknown Stack Size
<LI>Call Chain = lwip_netconn_do_close_internal &rArr; tcp_abort &rArr; tcp_abandon &rArr; tcp_pcb_remove &rArr; tcp_output &rArr; tcp_output_segment &rArr; ip4_output_if &rArr; ip4_output_if_opt &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[557]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_shutdown
<LI><a href="#[454]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_sent
<LI><a href="#[453]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_recv
<LI><a href="#[455]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_poll
<LI><a href="#[456]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_err
<LI><a href="#[556]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_close
<LI><a href="#[452]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_arg
<LI><a href="#[555]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_accept
<LI><a href="#[558]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_abort
<LI><a href="#[37c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_sem_signal
<LI><a href="#[497]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_unprotect
<LI><a href="#[496]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_protect
</UL>
<BR>[Called By]<UL><LI><a href="#[6a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sent_tcp
<LI><a href="#[6b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;poll_tcp
<LI><a href="#[79]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_netconn_do_delconn
<LI><a href="#[77]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_netconn_do_close
</UL>

<P><STRONG><a name="[6d]"></a>lwip_netconn_do_connected</STRONG> (Thumb, 164 bytes, Stack size 32 bytes, .\build\lwip_api_msg.o(i.lwip_netconn_do_connected))
<BR><BR>[Stack]<UL><LI>Max Depth = 552 + Unknown Stack Size
<LI>Call Chain = lwip_netconn_do_connected &rArr; sys_sem_signal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[37c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_sem_signal
<LI><a href="#[451]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;setup_tcp
<LI><a href="#[497]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_unprotect
<LI><a href="#[496]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_protect
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lwip_api_msg.o(i.lwip_netconn_do_connect)
</UL>
<P><STRONG><a name="[6e]"></a>lwip_netconn_do_dns_found</STRONG> (Thumb, 44 bytes, Stack size 24 bytes, .\build\lwip_api_msg.o(i.lwip_netconn_do_dns_found))
<BR><BR>[Stack]<UL><LI>Max Depth = 544 + Unknown Stack Size
<LI>Call Chain = lwip_netconn_do_dns_found &rArr; sys_sem_signal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[37c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_sem_signal
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lwip_api_msg.o(i.lwip_netconn_do_gethostbyname)
</UL>
<P><STRONG><a name="[560]"></a>lwip_netconn_do_writemore</STRONG> (Thumb, 462 bytes, Stack size 56 bytes, .\build\lwip_api_msg.o(i.lwip_netconn_do_writemore))
<BR><BR>[Stack]<UL><LI>Max Depth = 1000 + Unknown Stack Size
<LI>Call Chain = lwip_netconn_do_writemore &rArr; tcp_output &rArr; tcp_output_segment &rArr; ip4_output_if &rArr; ip4_output_if_opt &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[561]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_write
<LI><a href="#[562]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_output
<LI><a href="#[37c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_sem_signal
<LI><a href="#[497]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_unprotect
<LI><a href="#[496]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_protect
</UL>
<BR>[Called By]<UL><LI><a href="#[6a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sent_tcp
<LI><a href="#[6b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;poll_tcp
<LI><a href="#[80]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_netconn_do_write
</UL>

<P><STRONG><a name="[550]"></a>netconn_drain</STRONG> (Thumb, 170 bytes, Stack size 24 bytes, .\build\lwip_api_msg.o(i.netconn_drain))
<BR><BR>[Stack]<UL><LI>Max Depth = 1040 + Unknown Stack Size
 + In Cycle
<LI>Call Chain = netconn_drain &rArr;  netconn_drain (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[55e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_recved
<LI><a href="#[558]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_abort
<LI><a href="#[59f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_mbox_tryfetch
<LI><a href="#[46b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_free
<LI><a href="#[585]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netbuf_delete
<LI><a href="#[550]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netconn_drain
<LI><a href="#[457]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_mbox_free
<LI><a href="#[458]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netconn_free
</UL>
<BR>[Called By]<UL><LI><a href="#[550]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netconn_drain
<LI><a href="#[79]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_netconn_do_delconn
<LI><a href="#[77]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_netconn_do_close
</UL>

<P><STRONG><a name="[55d]"></a>pcb_new</STRONG> (Thumb, 112 bytes, Stack size 16 bytes, .\build\lwip_api_msg.o(i.pcb_new))
<BR><BR>[Stack]<UL><LI>Max Depth = 1088 + Unknown Stack Size
<LI>Call Chain = pcb_new &rArr; tcp_new_ip_type &rArr; tcp_alloc &rArr; tcp_kill_prio &rArr; tcp_abort &rArr; tcp_abandon &rArr; tcp_pcb_remove &rArr; tcp_output &rArr; tcp_output_segment &rArr; ip4_output_if &rArr; ip4_output_if_opt &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[47f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_recv
<LI><a href="#[47b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_new_ip_type
<LI><a href="#[627]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_new_ip_type
<LI><a href="#[451]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;setup_tcp
</UL>
<BR>[Called By]<UL><LI><a href="#[7d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_netconn_do_newconn
</UL>

<P><STRONG><a name="[6b]"></a>poll_tcp</STRONG> (Thumb, 136 bytes, Stack size 16 bytes, .\build\lwip_api_msg.o(i.poll_tcp))
<BR><BR>[Stack]<UL><LI>Max Depth = 1088 + Unknown Stack Size
<LI>Call Chain = poll_tcp &rArr; lwip_netconn_do_close_internal &rArr; tcp_abort &rArr; tcp_abandon &rArr; tcp_pcb_remove &rArr; tcp_output &rArr; tcp_output_segment &rArr; ip4_output_if &rArr; ip4_output_if_opt &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[560]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_netconn_do_writemore
<LI><a href="#[551]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_netconn_do_close_internal
</UL>
<BR>[Address Reference Count : 2]<UL><LI> lwip_api_msg.o(i.lwip_netconn_do_close_internal)
<LI> lwip_api_msg.o(i.setup_tcp)
</UL>
<P><STRONG><a name="[b3]"></a>recv_tcp</STRONG> (Thumb, 142 bytes, Stack size 32 bytes, .\build\lwip_api_msg.o(i.recv_tcp))
<BR><BR>[Stack]<UL><LI>Max Depth = 992 + Unknown Stack Size
<LI>Call Chain = recv_tcp &rArr; tcp_recved &rArr; tcp_output &rArr; tcp_output_segment &rArr; ip4_output_if &rArr; ip4_output_if_opt &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[55e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_recved
<LI><a href="#[44f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_mbox_trypost
<LI><a href="#[46b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_free
<LI><a href="#[497]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_unprotect
<LI><a href="#[496]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_protect
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lwip_api_msg.o(i.setup_tcp)
</UL>
<P><STRONG><a name="[9f]"></a>recv_udp</STRONG> (Thumb, 130 bytes, Stack size 40 bytes, .\build\lwip_api_msg.o(i.recv_udp))
<BR><BR>[Stack]<UL><LI>Max Depth = 584 + Unknown Stack Size
<LI>Call Chain = recv_udp &rArr; netbuf_delete &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[44f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_mbox_trypost
<LI><a href="#[46b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_free
<LI><a href="#[585]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netbuf_delete
<LI><a href="#[4e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memp_malloc
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lwip_api_msg.o(i.pcb_new)
</UL>
<P><STRONG><a name="[6a]"></a>sent_tcp</STRONG> (Thumb, 104 bytes, Stack size 24 bytes, .\build\lwip_api_msg.o(i.sent_tcp))
<BR><BR>[Stack]<UL><LI>Max Depth = 1096 + Unknown Stack Size
<LI>Call Chain = sent_tcp &rArr; lwip_netconn_do_close_internal &rArr; tcp_abort &rArr; tcp_abandon &rArr; tcp_pcb_remove &rArr; tcp_output &rArr; tcp_output_segment &rArr; ip4_output_if &rArr; ip4_output_if_opt &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[560]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_netconn_do_writemore
<LI><a href="#[551]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_netconn_do_close_internal
</UL>
<BR>[Address Reference Count : 2]<UL><LI> lwip_api_msg.o(i.lwip_netconn_do_close_internal)
<LI> lwip_api_msg.o(i.setup_tcp)
</UL>
<P><STRONG><a name="[451]"></a>setup_tcp</STRONG> (Thumb, 50 bytes, Stack size 16 bytes, .\build\lwip_api_msg.o(i.setup_tcp))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = setup_tcp
</UL>
<BR>[Calls]<UL><LI><a href="#[454]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_sent
<LI><a href="#[453]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_recv
<LI><a href="#[455]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_poll
<LI><a href="#[456]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_err
<LI><a href="#[452]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_arg
</UL>
<BR>[Called By]<UL><LI><a href="#[55d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pcb_new
<LI><a href="#[6d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_netconn_do_connected
<LI><a href="#[6f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;accept_function
<LI><a href="#[78]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_netconn_do_connect
</UL>

<P><STRONG><a name="[460]"></a>network_phase</STRONG> (Thumb, 12 bytes, Stack size 8 bytes, .\build\lwip_auth.o(i.network_phase))
<BR><BR>[Stack]<UL><LI>Max Depth = 728 + Unknown Stack Size
<LI>Call Chain = network_phase &rArr; start_networks &rArr; continue_networks &rArr; lcp_close &rArr; fsm_close &rArr; terminate_layer &rArr; fsm_sdata &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[5ac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;start_networks
</UL>
<BR>[Called By]<UL><LI><a href="#[531]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;link_established
<LI><a href="#[45f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;auth_withpeer_success
</UL>

<P><STRONG><a name="[cb]"></a>chap_md5_make_response</STRONG> (Thumb, 80 bytes, Stack size 128 bytes, .\build\lwip_chap-md5.o(i.chap_md5_make_response))
<BR><BR>[Stack]<UL><LI>Max Depth = 276<LI>Call Chain = chap_md5_make_response &rArr; md5_finish &rArr; md5_update &rArr; md5_process
</UL>
<BR>[Calls]<UL><LI><a href="#[468]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;md5_update
<LI><a href="#[467]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;md5_starts
<LI><a href="#[469]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;md5_finish
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lwip_chap-md5.o(.constdata)
</UL>
<P><STRONG><a name="[465]"></a>chap_handle_status</STRONG> (Thumb, 194 bytes, Stack size 32 bytes, .\build\lwip_chap-new.o(i.chap_handle_status))
<BR><BR>[Stack]<UL><LI>Max Depth = 784 + Unknown Stack Size
<LI>Call Chain = chap_handle_status &rArr; auth_withpeer_success &rArr; network_phase &rArr; start_networks &rArr; continue_networks &rArr; lcp_close &rArr; fsm_close &rArr; terminate_layer &rArr; fsm_sdata &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[2c2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_info
<LI><a href="#[463]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_error
<LI><a href="#[45f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;auth_withpeer_success
<LI><a href="#[45e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;auth_withpeer_fail
</UL>
<BR>[Called By]<UL><LI><a href="#[cd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;chap_input
</UL>

<P><STRONG><a name="[cc]"></a>chap_init</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\lwip_chap-new.o(i.chap_init))
<BR>[Address Reference Count : 1]<UL><LI> lwip_chap-new.o(.constdata)
</UL>
<P><STRONG><a name="[cd]"></a>chap_input</STRONG> (Thumb, 104 bytes, Stack size 32 bytes, .\build\lwip_chap-new.o(i.chap_input))
<BR><BR>[Stack]<UL><LI>Max Depth = 816 + Unknown Stack Size
<LI>Call Chain = chap_input &rArr; chap_handle_status &rArr; auth_withpeer_success &rArr; network_phase &rArr; start_networks &rArr; continue_networks &rArr; lcp_close &rArr; fsm_close &rArr; terminate_layer &rArr; fsm_sdata &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[466]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;chap_respond
<LI><a href="#[465]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;chap_handle_status
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lwip_chap-new.o(.constdata)
</UL>
<P><STRONG><a name="[d0]"></a>chap_lowerdown</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, .\build\lwip_chap-new.o(i.chap_lowerdown))
<BR>[Address Reference Count : 1]<UL><LI> lwip_chap-new.o(.constdata)
</UL>
<P><STRONG><a name="[cf]"></a>chap_lowerup</STRONG> (Thumb, 14 bytes, Stack size 0 bytes, .\build\lwip_chap-new.o(i.chap_lowerup))
<BR>[Address Reference Count : 1]<UL><LI> lwip_chap-new.o(.constdata)
</UL>
<P><STRONG><a name="[ce]"></a>chap_protrej</STRONG> (Thumb, 46 bytes, Stack size 8 bytes, .\build\lwip_chap-new.o(i.chap_protrej))
<BR><BR>[Stack]<UL><LI>Max Depth = 720 + Unknown Stack Size
<LI>Call Chain = chap_protrej &rArr; auth_withpeer_fail &rArr; lcp_close &rArr; fsm_close &rArr; terminate_layer &rArr; fsm_sdata &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[463]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_error
<LI><a href="#[45e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;auth_withpeer_fail
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lwip_chap-new.o(.constdata)
</UL>
<P><STRONG><a name="[466]"></a>chap_respond</STRONG> (Thumb, 288 bytes, Stack size 192 bytes, .\build\lwip_chap-new.o(i.chap_respond))
<BR><BR>[Stack]<UL><LI>Max Depth = 768 + Unknown Stack Size
<LI>Call Chain = chap_respond &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[46f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_write
<LI><a href="#[46c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_slprintf
<LI><a href="#[46e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_realloc
<LI><a href="#[46a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_alloc
<LI><a href="#[2be]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_warn
<LI><a href="#[46d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;get_secret
<LI><a href="#[46b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_free
<LI><a href="#[23c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memclr4
<LI><a href="#[249]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
<LI><a href="#[31d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;strlen
</UL>
<BR>[Called By]<UL><LI><a href="#[cd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;chap_input
</UL>

<P><STRONG><a name="[479]"></a>dns_alloc_pcb</STRONG> (Thumb, 106 bytes, Stack size 16 bytes, .\build\lwip_dns.o(i.dns_alloc_pcb))
<BR><BR>[Stack]<UL><LI>Max Depth = 552 + Unknown Stack Size
<LI>Call Chain = dns_alloc_pcb &rArr; dns_alloc_random_port &rArr; udp_remove &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[47a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dns_alloc_random_port
</UL>
<BR>[Called By]<UL><LI><a href="#[488]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dns_enqueue
</UL>

<P><STRONG><a name="[47a]"></a>dns_alloc_random_port</STRONG> (Thumb, 84 bytes, Stack size 16 bytes, .\build\lwip_dns.o(i.dns_alloc_random_port))
<BR><BR>[Stack]<UL><LI>Max Depth = 536 + Unknown Stack Size
<LI>Call Chain = dns_alloc_random_port &rArr; udp_remove &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[47c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_get_random
<LI><a href="#[47e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_remove
<LI><a href="#[47f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_recv
<LI><a href="#[47b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_new_ip_type
<LI><a href="#[47d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_bind
</UL>
<BR>[Called By]<UL><LI><a href="#[479]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dns_alloc_pcb
</UL>

<P><STRONG><a name="[480]"></a>dns_call_found</STRONG> (Thumb, 252 bytes, Stack size 24 bytes, .\build\lwip_dns.o(i.dns_call_found))
<BR><BR>[Stack]<UL><LI>Max Depth = 544 + Unknown Stack Size
<LI>Call Chain = dns_call_found &rArr; udp_remove &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[47e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_remove
</UL>
<BR>[Called By]<UL><LI><a href="#[484]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dns_send
<LI><a href="#[62]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dns_recv
<LI><a href="#[487]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dns_correct_response
<LI><a href="#[482]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dns_check_entry
</UL>

<P><STRONG><a name="[481]"></a>dns_check_entries</STRONG> (Thumb, 22 bytes, Stack size 8 bytes, .\build\lwip_dns.o(i.dns_check_entries))
<BR><BR>[Stack]<UL><LI>Max Depth = 1016 + Unknown Stack Size
<LI>Call Chain = dns_check_entries &rArr; dns_check_entry &rArr; dns_send &rArr; udp_sendto &rArr; udp_sendto_if &rArr; udp_sendto_if_src &rArr; ip4_output_if_src &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[482]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dns_check_entry
</UL>
<BR>[Called By]<UL><LI><a href="#[10d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dns_tmr
</UL>

<P><STRONG><a name="[482]"></a>dns_check_entry</STRONG> (Thumb, 180 bytes, Stack size 16 bytes, .\build\lwip_dns.o(i.dns_check_entry))
<BR><BR>[Stack]<UL><LI>Max Depth = 1008 + Unknown Stack Size
<LI>Call Chain = dns_check_entry &rArr; dns_send &rArr; udp_sendto &rArr; udp_sendto_if &rArr; udp_sendto_if_src &rArr; ip4_output_if_src &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[484]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dns_send
<LI><a href="#[483]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dns_create_txid
<LI><a href="#[480]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dns_call_found
</UL>
<BR>[Called By]<UL><LI><a href="#[488]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dns_enqueue
<LI><a href="#[481]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dns_check_entries
</UL>

<P><STRONG><a name="[485]"></a>dns_compare_name</STRONG> (Thumb, 140 bytes, Stack size 32 bytes, .\build\lwip_dns.o(i.dns_compare_name))
<BR><BR>[Stack]<UL><LI>Max Depth = 68<LI>Call Chain = dns_compare_name &rArr; pbuf_try_get_at &rArr; pbuf_skip_const
</UL>
<BR>[Calls]<UL><LI><a href="#[486]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_try_get_at
</UL>
<BR>[Called By]<UL><LI><a href="#[62]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dns_recv
</UL>

<P><STRONG><a name="[487]"></a>dns_correct_response</STRONG> (Thumb, 58 bytes, Stack size 16 bytes, .\build\lwip_dns.o(i.dns_correct_response))
<BR><BR>[Stack]<UL><LI>Max Depth = 560 + Unknown Stack Size
<LI>Call Chain = dns_correct_response &rArr; dns_call_found &rArr; udp_remove &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[480]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dns_call_found
</UL>
<BR>[Called By]<UL><LI><a href="#[62]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dns_recv
</UL>

<P><STRONG><a name="[483]"></a>dns_create_txid</STRONG> (Thumb, 58 bytes, Stack size 16 bytes, .\build\lwip_dns.o(i.dns_create_txid))
<BR><BR>[Stack]<UL><LI>Max Depth = 96<LI>Call Chain = dns_create_txid &rArr; lwip_get_random &rArr; randLIB_get_32bit &rArr; randLIB_get_64bit &rArr; rol
</UL>
<BR>[Calls]<UL><LI><a href="#[47c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_get_random
</UL>
<BR>[Called By]<UL><LI><a href="#[482]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dns_check_entry
</UL>

<P><STRONG><a name="[488]"></a>dns_enqueue</STRONG> (Thumb, 386 bytes, Stack size 64 bytes, .\build\lwip_dns.o(i.dns_enqueue))
<BR><BR>[Stack]<UL><LI>Max Depth = 1072 + Unknown Stack Size
<LI>Call Chain = dns_enqueue &rArr; dns_check_entry &rArr; dns_send &rArr; udp_sendto &rArr; udp_sendto_if &rArr; udp_sendto_if_src &rArr; ip4_output_if_src &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[482]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dns_check_entry
<LI><a href="#[479]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dns_alloc_pcb
<LI><a href="#[489]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_strnicmp
<LI><a href="#[249]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Called By]<UL><LI><a href="#[48a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dns_gethostbyname_addrtype
</UL>

<P><STRONG><a name="[48c]"></a>dns_lookup</STRONG> (Thumb, 86 bytes, Stack size 16 bytes, .\build\lwip_dns.o(i.dns_lookup))
<BR><BR>[Stack]<UL><LI>Max Depth = 36<LI>Call Chain = dns_lookup &rArr; lwip_strnicmp
</UL>
<BR>[Calls]<UL><LI><a href="#[489]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_strnicmp
</UL>
<BR>[Called By]<UL><LI><a href="#[48a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dns_gethostbyname_addrtype
</UL>

<P><STRONG><a name="[62]"></a>dns_recv</STRONG> (Thumb, 456 bytes, Stack size 72 bytes, .\build\lwip_dns.o(i.dns_recv))
<BR><BR>[Stack]<UL><LI>Max Depth = 632 + Unknown Stack Size
<LI>Call Chain = dns_recv &rArr; dns_correct_response &rArr; dns_call_found &rArr; udp_remove &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[48d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_copy_partial
<LI><a href="#[48f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dns_skip_name
<LI><a href="#[487]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dns_correct_response
<LI><a href="#[485]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dns_compare_name
<LI><a href="#[480]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dns_call_found
<LI><a href="#[48e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_htons
<LI><a href="#[490]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_htonl
<LI><a href="#[46b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_free
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lwip_dns.o(i.dns_alloc_random_port)
</UL>
<P><STRONG><a name="[484]"></a>dns_send</STRONG> (Thumb, 296 bytes, Stack size 72 bytes, .\build\lwip_dns.o(i.dns_send))
<BR><BR>[Stack]<UL><LI>Max Depth = 992 + Unknown Stack Size
<LI>Call Chain = dns_send &rArr; udp_sendto &rArr; udp_sendto_if &rArr; udp_sendto_if_src &rArr; ip4_output_if_src &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[493]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_take_at
<LI><a href="#[491]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_take
<LI><a href="#[492]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_put_at
<LI><a href="#[480]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dns_call_found
<LI><a href="#[48e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_htons
<LI><a href="#[46a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_alloc
<LI><a href="#[494]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_sendto
<LI><a href="#[46b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_free
<LI><a href="#[31d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;strlen
</UL>
<BR>[Called By]<UL><LI><a href="#[482]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dns_check_entry
</UL>

<P><STRONG><a name="[48f]"></a>dns_skip_name</STRONG> (Thumb, 98 bytes, Stack size 24 bytes, .\build\lwip_dns.o(i.dns_skip_name))
<BR><BR>[Stack]<UL><LI>Max Depth = 60<LI>Call Chain = dns_skip_name &rArr; pbuf_try_get_at &rArr; pbuf_skip_const
</UL>
<BR>[Calls]<UL><LI><a href="#[486]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_try_get_at
</UL>
<BR>[Called By]<UL><LI><a href="#[62]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dns_recv
</UL>

<P><STRONG><a name="[4c3]"></a>fsm_rcoderej</STRONG> (Thumb, 54 bytes, Stack size 24 bytes, .\build\lwip_fsm.o(i.fsm_rcoderej))
<BR><BR>[Stack]<UL><LI>Max Depth = 512<LI>Call Chain = fsm_rcoderej &rArr; ppp_warn &rArr; ppp_logit &rArr; ppp_vslprintf &rArr; ppp_slprintf &rArr;  ppp_vslprintf (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[2be]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_warn
</UL>
<BR>[Called By]<UL><LI><a href="#[4bd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fsm_input
</UL>

<P><STRONG><a name="[4bf]"></a>fsm_rconfack</STRONG> (Thumb, 224 bytes, Stack size 32 bytes, .\build\lwip_fsm.o(i.fsm_rconfack))
<BR><BR>[Stack]<UL><LI>Max Depth = 672 + Unknown Stack Size
<LI>Call Chain = fsm_rconfack &rArr; fsm_sconfreq &rArr; sys_timeout &rArr; sys_now &rArr; us_ticker_read &rArr; us_ticker_init &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[463]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_error
<LI><a href="#[2bf]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_untimeout
<LI><a href="#[2c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fsm_sdata
<LI><a href="#[4c6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fsm_sconfreq
</UL>
<BR>[Called By]<UL><LI><a href="#[4bd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fsm_input
</UL>

<P><STRONG><a name="[4c0]"></a>fsm_rconfnakrej</STRONG> (Thumb, 264 bytes, Stack size 40 bytes, .\build\lwip_fsm.o(i.fsm_rconfnakrej))
<BR><BR>[Stack]<UL><LI>Max Depth = 680 + Unknown Stack Size
<LI>Call Chain = fsm_rconfnakrej &rArr; fsm_sconfreq &rArr; sys_timeout &rArr; sys_now &rArr; us_ticker_read &rArr; us_ticker_init &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[463]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_error
<LI><a href="#[2bf]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_untimeout
<LI><a href="#[2c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fsm_sdata
<LI><a href="#[4c6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fsm_sconfreq
</UL>
<BR>[Called By]<UL><LI><a href="#[4bd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fsm_input
</UL>

<P><STRONG><a name="[4be]"></a>fsm_rconfreq</STRONG> (Thumb, 244 bytes, Stack size 48 bytes, .\build\lwip_fsm.o(i.fsm_rconfreq))
<BR><BR>[Stack]<UL><LI>Max Depth = 688 + Unknown Stack Size
<LI>Call Chain = fsm_rconfreq &rArr; fsm_sconfreq &rArr; sys_timeout &rArr; sys_now &rArr; us_ticker_read &rArr; us_ticker_init &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[2bf]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_untimeout
<LI><a href="#[2c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fsm_sdata
<LI><a href="#[4c6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fsm_sconfreq
</UL>
<BR>[Called By]<UL><LI><a href="#[4bd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fsm_input
</UL>

<P><STRONG><a name="[4c2]"></a>fsm_rtermack</STRONG> (Thumb, 120 bytes, Stack size 8 bytes, .\build\lwip_fsm.o(i.fsm_rtermack))
<BR><BR>[Stack]<UL><LI>Max Depth = 648 + Unknown Stack Size
<LI>Call Chain = fsm_rtermack &rArr; fsm_sconfreq &rArr; sys_timeout &rArr; sys_now &rArr; us_ticker_read &rArr; us_ticker_init &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[2bf]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_untimeout
<LI><a href="#[4c6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fsm_sconfreq
</UL>
<BR>[Called By]<UL><LI><a href="#[4bd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fsm_input
</UL>

<P><STRONG><a name="[4c1]"></a>fsm_rtermreq</STRONG> (Thumb, 150 bytes, Stack size 32 bytes, .\build\lwip_fsm.o(i.fsm_rtermreq))
<BR><BR>[Stack]<UL><LI>Max Depth = 664 + Unknown Stack Size
<LI>Call Chain = fsm_rtermreq &rArr; fsm_sdata &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[2c2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_info
<LI><a href="#[2bf]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_untimeout
<LI><a href="#[2c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_timeout
<LI><a href="#[2c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fsm_sdata
</UL>
<BR>[Called By]<UL><LI><a href="#[4bd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fsm_input
</UL>

<P><STRONG><a name="[4c6]"></a>fsm_sconfreq</STRONG> (Thumb, 280 bytes, Stack size 32 bytes, .\build\lwip_fsm.o(i.fsm_sconfreq))
<BR><BR>[Stack]<UL><LI>Max Depth = 640 + Unknown Stack Size
<LI>Call Chain = fsm_sconfreq &rArr; sys_timeout &rArr; sys_now &rArr; us_ticker_read &rArr; us_ticker_init &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[46f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_write
<LI><a href="#[46a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_alloc
<LI><a href="#[2bf]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_untimeout
<LI><a href="#[2c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_timeout
<LI><a href="#[46b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_free
</UL>
<BR>[Called By]<UL><LI><a href="#[4c7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fsm_open
<LI><a href="#[4c5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fsm_lowerup
<LI><a href="#[66]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fsm_timeout
<LI><a href="#[4c2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fsm_rtermack
<LI><a href="#[4be]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fsm_rconfreq
<LI><a href="#[4c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fsm_rconfnakrej
<LI><a href="#[4bf]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fsm_rconfack
</UL>

<P><STRONG><a name="[66]"></a>fsm_timeout</STRONG> (Thumb, 216 bytes, Stack size 24 bytes, .\build\lwip_fsm.o(i.fsm_timeout))
<BR><BR>[Stack]<UL><LI>Max Depth = 664 + Unknown Stack Size
<LI>Call Chain = fsm_timeout &rArr; fsm_sconfreq &rArr; sys_timeout &rArr; sys_now &rArr; us_ticker_read &rArr; us_ticker_init &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[2be]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_warn
<LI><a href="#[2bf]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_untimeout
<LI><a href="#[2c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_timeout
<LI><a href="#[2c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fsm_sdata
<LI><a href="#[4c6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fsm_sconfreq
</UL>
<BR>[Address Reference Count : 10]<UL><LI> lwip_fsm.o(i.fsm_lowerdown)
<LI> lwip_fsm.o(i.fsm_protreject)
<LI> lwip_fsm.o(i.fsm_rconfack)
<LI> lwip_fsm.o(i.fsm_rconfnakrej)
<LI> lwip_fsm.o(i.fsm_rconfreq)
<LI> lwip_fsm.o(i.fsm_rtermack)
<LI> lwip_fsm.o(i.fsm_rtermreq)
<LI> lwip_fsm.o(i.fsm_sconfreq)
<LI> lwip_fsm.o(i.fsm_timeout)
<LI> lwip_fsm.o(i.terminate_layer)
</UL>
<P><STRONG><a name="[4bc]"></a>terminate_layer</STRONG> (Thumb, 142 bytes, Stack size 24 bytes, .\build\lwip_fsm.o(i.terminate_layer))
<BR><BR>[Stack]<UL><LI>Max Depth = 656 + Unknown Stack Size
<LI>Call Chain = terminate_layer &rArr; fsm_sdata &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[2bf]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_untimeout
<LI><a href="#[2c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_timeout
<LI><a href="#[2c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fsm_sdata
</UL>
<BR>[Called By]<UL><LI><a href="#[4c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fsm_protreject
<LI><a href="#[4bb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fsm_close
</UL>

<P><STRONG><a name="[4d0]"></a>icmp_send_response</STRONG> (Thumb, 122 bytes, Stack size 48 bytes, .\build\lwip_icmp.o(i.icmp_send_response))
<BR><BR>[Stack]<UL><LI>Max Depth = 904 + Unknown Stack Size
<LI>Call Chain = icmp_send_response &rArr; ip4_output_if &rArr; ip4_output_if_opt &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[46a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_alloc
<LI><a href="#[4d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip4_route
<LI><a href="#[4d7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip4_output_if
<LI><a href="#[4d6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;inet_chksum
<LI><a href="#[46b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_free
<LI><a href="#[249]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Called By]<UL><LI><a href="#[4d9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;icmp_time_exceeded
<LI><a href="#[4cf]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;icmp_dest_unreach
</UL>

<P><STRONG><a name="[4da]"></a>igmp_delaying_member</STRONG> (Thumb, 42 bytes, Stack size 16 bytes, .\build\lwip_igmp.o(i.igmp_delaying_member))
<BR><BR>[Stack]<UL><LI>Max Depth = 112<LI>Call Chain = igmp_delaying_member &rArr; igmp_start_timer &rArr; lwip_get_random &rArr; randLIB_get_32bit &rArr; randLIB_get_64bit &rArr; rol
</UL>
<BR>[Calls]<UL><LI><a href="#[4db]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;igmp_start_timer
</UL>
<BR>[Called By]<UL><LI><a href="#[4e9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;igmp_report_groups
<LI><a href="#[4dc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;igmp_input
</UL>

<P><STRONG><a name="[4de]"></a>igmp_ip_output_if</STRONG> (Thumb, 60 bytes, Stack size 48 bytes, .\build\lwip_igmp.o(i.igmp_ip_output_if))
<BR><BR>[Stack]<UL><LI>Max Depth = 848 + Unknown Stack Size
<LI>Call Chain = igmp_ip_output_if &rArr; ip4_output_if_opt &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[4df]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip4_output_if_opt
</UL>
<BR>[Called By]<UL><LI><a href="#[4e3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;igmp_send
</UL>

<P><STRONG><a name="[4e2]"></a>igmp_lookup_group</STRONG> (Thumb, 76 bytes, Stack size 24 bytes, .\build\lwip_igmp.o(i.igmp_lookup_group))
<BR><BR>[Stack]<UL><LI>Max Depth = 520 + Unknown Stack Size
<LI>Call Chain = igmp_lookup_group &rArr; memp_malloc &rArr; do_memp_malloc_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[4dd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;igmp_lookfor_group
<LI><a href="#[4e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memp_malloc
</UL>
<BR>[Called By]<UL><LI><a href="#[4ea]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;igmp_start
<LI><a href="#[4e1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;igmp_joingroup_netif
</UL>

<P><STRONG><a name="[4e6]"></a>igmp_remove_group</STRONG> (Thumb, 40 bytes, Stack size 8 bytes, .\build\lwip_igmp.o(i.igmp_remove_group))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = igmp_remove_group
</UL>
<BR>[Called By]<UL><LI><a href="#[4e5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;igmp_leavegroup_netif
</UL>

<P><STRONG><a name="[4e3]"></a>igmp_send</STRONG> (Thumb, 128 bytes, Stack size 32 bytes, .\build\lwip_igmp.o(i.igmp_send))
<BR><BR>[Stack]<UL><LI>Max Depth = 880 + Unknown Stack Size
<LI>Call Chain = igmp_send &rArr; igmp_ip_output_if &rArr; ip4_output_if_opt &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[46a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_alloc
<LI><a href="#[4de]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;igmp_ip_output_if
<LI><a href="#[4d6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;inet_chksum
<LI><a href="#[46b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_free
</UL>
<BR>[Called By]<UL><LI><a href="#[4e5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;igmp_leavegroup_netif
<LI><a href="#[4e1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;igmp_joingroup_netif
<LI><a href="#[4eb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;igmp_timeout
</UL>

<P><STRONG><a name="[4db]"></a>igmp_start_timer</STRONG> (Thumb, 38 bytes, Stack size 16 bytes, .\build\lwip_igmp.o(i.igmp_start_timer))
<BR><BR>[Stack]<UL><LI>Max Depth = 96<LI>Call Chain = igmp_start_timer &rArr; lwip_get_random &rArr; randLIB_get_32bit &rArr; randLIB_get_64bit &rArr; rol
</UL>
<BR>[Calls]<UL><LI><a href="#[47c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_get_random
</UL>
<BR>[Called By]<UL><LI><a href="#[4e1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;igmp_joingroup_netif
<LI><a href="#[4da]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;igmp_delaying_member
</UL>

<P><STRONG><a name="[4eb]"></a>igmp_timeout</STRONG> (Thumb, 38 bytes, Stack size 16 bytes, .\build\lwip_igmp.o(i.igmp_timeout))
<BR><BR>[Stack]<UL><LI>Max Depth = 896 + Unknown Stack Size
<LI>Call Chain = igmp_timeout &rArr; igmp_send &rArr; igmp_ip_output_if &rArr; ip4_output_if_opt &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[4e3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;igmp_send
</UL>
<BR>[Called By]<UL><LI><a href="#[10c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;igmp_tmr
</UL>

<P><STRONG><a name="[4ee]"></a>inet_cksum_pseudo_base</STRONG> (Thumb, 126 bytes, Stack size 32 bytes, .\build\lwip_inet_chksum.o(i.inet_cksum_pseudo_base))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = inet_cksum_pseudo_base &rArr; lwip_standard_chksum
</UL>
<BR>[Calls]<UL><LI><a href="#[48e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_htons
<LI><a href="#[4ec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_standard_chksum
</UL>
<BR>[Called By]<UL><LI><a href="#[4ed]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;inet_chksum_pseudo
</UL>

<P><STRONG><a name="[4f4]"></a>ip_frag_alloc_pbuf_custom_ref</STRONG> (Thumb, 10 bytes, Stack size 8 bytes, .\build\lwip_ip4_frag.o(i.ip_frag_alloc_pbuf_custom_ref))
<BR><BR>[Stack]<UL><LI>Max Depth = 504 + Unknown Stack Size
<LI>Call Chain = ip_frag_alloc_pbuf_custom_ref &rArr; memp_malloc &rArr; do_memp_malloc_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[4e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memp_malloc
</UL>
<BR>[Called By]<UL><LI><a href="#[4f3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip4_frag
</UL>

<P><STRONG><a name="[4f6]"></a>ip_frag_free_pbuf_custom_ref</STRONG> (Thumb, 14 bytes, Stack size 8 bytes, .\build\lwip_ip4_frag.o(i.ip_frag_free_pbuf_custom_ref))
<BR><BR>[Stack]<UL><LI>Max Depth = 512 + Unknown Stack Size
<LI>Call Chain = ip_frag_free_pbuf_custom_ref &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[4e7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memp_free
</UL>
<BR>[Called By]<UL><LI><a href="#[67]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ipfrag_free_pbuf_custom
<LI><a href="#[4f3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip4_frag
</UL>

<P><STRONG><a name="[503]"></a>ip_reass_chain_frag_into_datagram_and_validate</STRONG> (Thumb, 320 bytes, Stack size 48 bytes, .\build\lwip_ip4_frag.o(i.ip_reass_chain_frag_into_datagram_and_validate))
<BR><BR>[Stack]<UL><LI>Max Depth = 584 + Unknown Stack Size
<LI>Call Chain = ip_reass_chain_frag_into_datagram_and_validate &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[48e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_htons
<LI><a href="#[46b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_free
<LI><a href="#[500]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_clen
</UL>
<BR>[Called By]<UL><LI><a href="#[4fa]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip4_reass
</UL>

<P><STRONG><a name="[504]"></a>ip_reass_dequeue_datagram</STRONG> (Thumb, 36 bytes, Stack size 16 bytes, .\build\lwip_ip4_frag.o(i.ip_reass_dequeue_datagram))
<BR><BR>[Stack]<UL><LI>Max Depth = 520 + Unknown Stack Size
<LI>Call Chain = ip_reass_dequeue_datagram &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[4e7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memp_free
</UL>
<BR>[Called By]<UL><LI><a href="#[506]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip_reass_free_complete_datagram
<LI><a href="#[4fa]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip4_reass
</UL>

<P><STRONG><a name="[502]"></a>ip_reass_enqueue_new_datagram</STRONG> (Thumb, 80 bytes, Stack size 16 bytes, .\build\lwip_ip4_frag.o(i.ip_reass_enqueue_new_datagram))
<BR><BR>[Stack]<UL><LI>Max Depth = 1008 + Unknown Stack Size
<LI>Call Chain = ip_reass_enqueue_new_datagram &rArr; ip_reass_remove_oldest_datagram &rArr; ip_reass_free_complete_datagram &rArr; icmp_time_exceeded &rArr; icmp_send_response &rArr; ip4_output_if &rArr; ip4_output_if_opt &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[4e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memp_malloc
<LI><a href="#[501]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip_reass_remove_oldest_datagram
<LI><a href="#[23c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memclr4
<LI><a href="#[249]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Called By]<UL><LI><a href="#[4fa]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip4_reass
</UL>

<P><STRONG><a name="[506]"></a>ip_reass_free_complete_datagram</STRONG> (Thumb, 130 bytes, Stack size 32 bytes, .\build\lwip_ip4_frag.o(i.ip_reass_free_complete_datagram))
<BR><BR>[Stack]<UL><LI>Max Depth = 952 + Unknown Stack Size
<LI>Call Chain = ip_reass_free_complete_datagram &rArr; icmp_time_exceeded &rArr; icmp_send_response &rArr; ip4_output_if &rArr; ip4_output_if_opt &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[4d9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;icmp_time_exceeded
<LI><a href="#[46b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_free
<LI><a href="#[500]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_clen
<LI><a href="#[504]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip_reass_dequeue_datagram
<LI><a href="#[249]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Called By]<UL><LI><a href="#[10b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip_reass_tmr
<LI><a href="#[501]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip_reass_remove_oldest_datagram
</UL>

<P><STRONG><a name="[501]"></a>ip_reass_remove_oldest_datagram</STRONG> (Thumb, 130 bytes, Stack size 40 bytes, .\build\lwip_ip4_frag.o(i.ip_reass_remove_oldest_datagram))
<BR><BR>[Stack]<UL><LI>Max Depth = 992 + Unknown Stack Size
<LI>Call Chain = ip_reass_remove_oldest_datagram &rArr; ip_reass_free_complete_datagram &rArr; icmp_time_exceeded &rArr; icmp_send_response &rArr; ip4_output_if &rArr; ip4_output_if_opt &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[506]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip_reass_free_complete_datagram
</UL>
<BR>[Called By]<UL><LI><a href="#[502]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip_reass_enqueue_new_datagram
<LI><a href="#[4fa]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip4_reass
</UL>

<P><STRONG><a name="[67]"></a>ipfrag_free_pbuf_custom</STRONG> (Thumb, 24 bytes, Stack size 16 bytes, .\build\lwip_ip4_frag.o(i.ipfrag_free_pbuf_custom))
<BR><BR>[Stack]<UL><LI>Max Depth = 552 + Unknown Stack Size
<LI>Call Chain = ipfrag_free_pbuf_custom &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[46b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_free
<LI><a href="#[4f6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip_frag_free_pbuf_custom_ref
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lwip_ip4_frag.o(i.ip4_frag)
</UL>
<P><STRONG><a name="[d4]"></a>ipcp_ackci</STRONG> (Thumb, 448 bytes, Stack size 40 bytes, .\build\lwip_ipcp.o(i.ipcp_ackci))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = ipcp_ackci
</UL>
<BR>[Calls]<UL><LI><a href="#[490]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_htonl
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lwip_ipcp.o(.constdata)
</UL>
<P><STRONG><a name="[d3]"></a>ipcp_addci</STRONG> (Thumb, 342 bytes, Stack size 32 bytes, .\build\lwip_ipcp.o(i.ipcp_addci))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = ipcp_addci
</UL>
<BR>[Calls]<UL><LI><a href="#[490]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_htonl
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lwip_ipcp.o(.constdata)
</UL>
<P><STRONG><a name="[d2]"></a>ipcp_cilen</STRONG> (Thumb, 126 bytes, Stack size 12 bytes, .\build\lwip_ipcp.o(i.ipcp_cilen))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = ipcp_cilen
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lwip_ipcp.o(.constdata)
</UL>
<P><STRONG><a name="[507]"></a>ipcp_clear_addrs</STRONG> (Thumb, 26 bytes, Stack size 24 bytes, .\build\lwip_ipcp.o(i.ipcp_clear_addrs))
<BR><BR>[Stack]<UL><LI>Max Depth = 1144 + Unknown Stack Size
<LI>Call Chain = ipcp_clear_addrs &rArr; cifaddr &rArr; netif_set_addr &rArr; netif_set_ipaddr &rArr; tcp_netif_ip_addr_changed &rArr; tcp_netif_ip_addr_changed_pcblist &rArr; tcp_abort &rArr; tcp_abandon &rArr; tcp_pcb_remove &rArr; tcp_output &rArr; tcp_output_segment &rArr; ip4_output_if &rArr; ip4_output_if_opt &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[470]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;cifaddr
</UL>
<BR>[Called By]<UL><LI><a href="#[d9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ipcp_down
</UL>

<P><STRONG><a name="[e1]"></a>ipcp_close</STRONG> (Thumb, 20 bytes, Stack size 16 bytes, .\build\lwip_ipcp.o(i.ipcp_close))
<BR><BR>[Stack]<UL><LI>Max Depth = 688 + Unknown Stack Size
<LI>Call Chain = ipcp_close &rArr; fsm_close &rArr; terminate_layer &rArr; fsm_sdata &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[4bb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fsm_close
</UL>
<BR>[Called By]<UL><LI><a href="#[d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ipcp_up
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lwip_ipcp.o(.constdata)
</UL>
<P><STRONG><a name="[d9]"></a>ipcp_down</STRONG> (Thumb, 72 bytes, Stack size 24 bytes, .\build\lwip_ipcp.o(i.ipcp_down))
<BR><BR>[Stack]<UL><LI>Max Depth = 1168 + Unknown Stack Size
<LI>Call Chain = ipcp_down &rArr; ipcp_clear_addrs &rArr; cifaddr &rArr; netif_set_addr &rArr; netif_set_ipaddr &rArr; tcp_netif_ip_addr_changed &rArr; tcp_netif_ip_addr_changed_pcblist &rArr; tcp_abort &rArr; tcp_abandon &rArr; tcp_pcb_remove &rArr; tcp_output &rArr; tcp_output_segment &rArr; ip4_output_if &rArr; ip4_output_if_opt &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[508]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;np_down
<LI><a href="#[509]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sifdown
<LI><a href="#[461]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;cdns
<LI><a href="#[507]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ipcp_clear_addrs
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lwip_ipcp.o(.constdata)
</UL>
<P><STRONG><a name="[da]"></a>ipcp_finished</STRONG> (Thumb, 32 bytes, Stack size 16 bytes, .\build\lwip_ipcp.o(i.ipcp_finished))
<BR><BR>[Stack]<UL><LI>Max Depth = 728 + Unknown Stack Size
<LI>Call Chain = ipcp_finished &rArr; np_finished &rArr; lcp_close &rArr; fsm_close &rArr; terminate_layer &rArr; fsm_sdata &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[50a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;np_finished
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lwip_ipcp.o(.constdata)
</UL>
<P><STRONG><a name="[db]"></a>ipcp_init</STRONG> (Thumb, 76 bytes, Stack size 24 bytes, .\build\lwip_ipcp.o(i.ipcp_init))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = ipcp_init
</UL>
<BR>[Calls]<UL><LI><a href="#[50b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fsm_init
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lwip_ipcp.o(.constdata)
</UL>
<P><STRONG><a name="[dc]"></a>ipcp_input</STRONG> (Thumb, 28 bytes, Stack size 24 bytes, .\build\lwip_ipcp.o(i.ipcp_input))
<BR><BR>[Stack]<UL><LI>Max Depth = 752 + Unknown Stack Size
<LI>Call Chain = ipcp_input &rArr; fsm_input &rArr; fsm_rconfreq &rArr; fsm_sconfreq &rArr; sys_timeout &rArr; sys_now &rArr; us_ticker_read &rArr; us_ticker_init &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[4bd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fsm_input
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lwip_ipcp.o(.constdata)
</UL>
<P><STRONG><a name="[df]"></a>ipcp_lowerdown</STRONG> (Thumb, 16 bytes, Stack size 16 bytes, .\build\lwip_ipcp.o(i.ipcp_lowerdown))
<BR><BR>[Stack]<UL><LI>Max Depth = 552 + Unknown Stack Size
<LI>Call Chain = ipcp_lowerdown &rArr; fsm_lowerdown &rArr; sys_untimeout &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[4c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fsm_lowerdown
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lwip_ipcp.o(.constdata)
</UL>
<P><STRONG><a name="[de]"></a>ipcp_lowerup</STRONG> (Thumb, 16 bytes, Stack size 16 bytes, .\build\lwip_ipcp.o(i.ipcp_lowerup))
<BR><BR>[Stack]<UL><LI>Max Depth = 664 + Unknown Stack Size
<LI>Call Chain = ipcp_lowerup &rArr; fsm_lowerup &rArr; fsm_sconfreq &rArr; sys_timeout &rArr; sys_now &rArr; us_ticker_read &rArr; us_ticker_init &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[4c5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fsm_lowerup
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lwip_ipcp.o(.constdata)
</UL>
<P><STRONG><a name="[d5]"></a>ipcp_nakci</STRONG> (Thumb, 1066 bytes, Stack size 112 bytes, .\build\lwip_ipcp.o(i.ipcp_nakci))
<BR><BR>[Stack]<UL><LI>Max Depth = 120<LI>Call Chain = ipcp_nakci &rArr; __aeabi_memcpy4
</UL>
<BR>[Calls]<UL><LI><a href="#[490]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_htonl
<LI><a href="#[23c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memclr4
<LI><a href="#[247]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy4
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lwip_ipcp.o(.constdata)
</UL>
<P><STRONG><a name="[e0]"></a>ipcp_open</STRONG> (Thumb, 28 bytes, Stack size 16 bytes, .\build\lwip_ipcp.o(i.ipcp_open))
<BR><BR>[Stack]<UL><LI>Max Depth = 672 + Unknown Stack Size
<LI>Call Chain = ipcp_open &rArr; fsm_open &rArr; fsm_lowerup &rArr; fsm_sconfreq &rArr; sys_timeout &rArr; sys_now &rArr; us_ticker_read &rArr; us_ticker_init &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[4c7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fsm_open
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lwip_ipcp.o(.constdata)
</UL>
<P><STRONG><a name="[dd]"></a>ipcp_protrej</STRONG> (Thumb, 16 bytes, Stack size 16 bytes, .\build\lwip_ipcp.o(i.ipcp_protrej))
<BR><BR>[Stack]<UL><LI>Max Depth = 552 + Unknown Stack Size
<LI>Call Chain = ipcp_protrej &rArr; fsm_lowerdown &rArr; sys_untimeout &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[4c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fsm_lowerdown
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lwip_ipcp.o(.constdata)
</UL>
<P><STRONG><a name="[d6]"></a>ipcp_rejci</STRONG> (Thumb, 466 bytes, Stack size 56 bytes, .\build\lwip_ipcp.o(i.ipcp_rejci))
<BR><BR>[Stack]<UL><LI>Max Depth = 64<LI>Call Chain = ipcp_rejci &rArr; __aeabi_memcpy4
</UL>
<BR>[Calls]<UL><LI><a href="#[490]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_htonl
<LI><a href="#[247]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy4
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lwip_ipcp.o(.constdata)
</UL>
<P><STRONG><a name="[d7]"></a>ipcp_reqci</STRONG> (Thumb, 984 bytes, Stack size 96 bytes, .\build\lwip_ipcp.o(i.ipcp_reqci))
<BR><BR>[Stack]<UL><LI>Max Depth = 100<LI>Call Chain = ipcp_reqci &rArr; __aeabi_memclr4
</UL>
<BR>[Calls]<UL><LI><a href="#[490]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_htonl
<LI><a href="#[23c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memclr4
<LI><a href="#[249]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lwip_ipcp.o(.constdata)
</UL>
<P><STRONG><a name="[d1]"></a>ipcp_resetci</STRONG> (Thumb, 152 bytes, Stack size 24 bytes, .\build\lwip_ipcp.o(i.ipcp_resetci))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = ipcp_resetci &rArr; __aeabi_memcpy4
</UL>
<BR>[Calls]<UL><LI><a href="#[23c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memclr4
<LI><a href="#[247]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy4
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lwip_ipcp.o(.constdata)
</UL>
<P><STRONG><a name="[d8]"></a>ipcp_up</STRONG> (Thumb, 384 bytes, Stack size 32 bytes, .\build\lwip_ipcp.o(i.ipcp_up))
<BR><BR>[Stack]<UL><LI>Max Depth = 1168 + Unknown Stack Size
<LI>Call Chain = ipcp_up &rArr; sifaddr &rArr; netif_set_addr &rArr; netif_set_ipaddr &rArr; tcp_netif_ip_addr_changed &rArr; tcp_netif_ip_addr_changed_pcblist &rArr; tcp_abort &rArr; tcp_abandon &rArr; tcp_pcb_remove &rArr; tcp_output &rArr; tcp_output_segment &rArr; ip4_output_if &rArr; ip4_output_if_opt &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[490]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_htonl
<LI><a href="#[2be]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_warn
<LI><a href="#[2c3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_notice
<LI><a href="#[463]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_error
<LI><a href="#[510]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;np_up
<LI><a href="#[50f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sifup
<LI><a href="#[50e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sifaddr
<LI><a href="#[50c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sdns
<LI><a href="#[50d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;get_mask
<LI><a href="#[e1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ipcp_close
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lwip_ipcp.o(.constdata)
</UL>
<P><STRONG><a name="[2bc]"></a>LcpEchoCheck</STRONG> (Thumb, 80 bytes, Stack size 16 bytes, .\build\lwip_lcp.o(i.LcpEchoCheck))
<BR><BR>[Stack]<UL><LI>Max Depth = 760 + Unknown Stack Size
<LI>Call Chain = LcpEchoCheck &rArr; LcpSendEchoRequest &rArr; LcpLinkFailure &rArr; lcp_close &rArr; fsm_close &rArr; terminate_layer &rArr; fsm_sdata &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[2be]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_warn
<LI><a href="#[2bf]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_untimeout
<LI><a href="#[2c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_timeout
<LI><a href="#[2bd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LcpSendEchoRequest
</UL>
<BR>[Called By]<UL><LI><a href="#[528]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lcp_echo_lowerup
<LI><a href="#[4e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LcpEchoTimeout
</UL>

<P><STRONG><a name="[4e]"></a>LcpEchoTimeout</STRONG> (Thumb, 32 bytes, Stack size 16 bytes, .\build\lwip_lcp.o(i.LcpEchoTimeout))
<BR><BR>[Stack]<UL><LI>Max Depth = 776 + Unknown Stack Size
<LI>Call Chain = LcpEchoTimeout &rArr; LcpEchoCheck &rArr; LcpSendEchoRequest &rArr; LcpLinkFailure &rArr; lcp_close &rArr; fsm_close &rArr; terminate_layer &rArr; fsm_sdata &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[2bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LcpEchoCheck
</UL>
<BR>[Address Reference Count : 2]<UL><LI> lwip_lcp.o(i.LcpEchoCheck)
<LI> lwip_lcp.o(i.lcp_echo_lowerdown)
</UL>
<P><STRONG><a name="[2c1]"></a>LcpLinkFailure</STRONG> (Thumb, 44 bytes, Stack size 16 bytes, .\build\lwip_lcp.o(i.LcpLinkFailure))
<BR><BR>[Stack]<UL><LI>Max Depth = 712 + Unknown Stack Size
<LI>Call Chain = LcpLinkFailure &rArr; lcp_close &rArr; fsm_close &rArr; terminate_layer &rArr; fsm_sdata &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[2c2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_info
<LI><a href="#[2c3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_notice
<LI><a href="#[f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lcp_close
</UL>
<BR>[Called By]<UL><LI><a href="#[2bd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LcpSendEchoRequest
</UL>

<P><STRONG><a name="[2bd]"></a>LcpSendEchoRequest</STRONG> (Thumb, 114 bytes, Stack size 32 bytes, .\build\lwip_lcp.o(i.LcpSendEchoRequest))
<BR><BR>[Stack]<UL><LI>Max Depth = 744 + Unknown Stack Size
<LI>Call Chain = LcpSendEchoRequest &rArr; LcpLinkFailure &rArr; lcp_close &rArr; fsm_close &rArr; terminate_layer &rArr; fsm_sdata &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[2c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fsm_sdata
<LI><a href="#[2c1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LcpLinkFailure
</UL>
<BR>[Called By]<UL><LI><a href="#[2bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LcpEchoCheck
</UL>

<P><STRONG><a name="[e5]"></a>lcp_ackci</STRONG> (Thumb, 580 bytes, Stack size 32 bytes, .\build\lwip_lcp.o(i.lcp_ackci))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = lcp_ackci
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lwip_lcp.o(.constdata)
</UL>
<P><STRONG><a name="[e4]"></a>lcp_addci</STRONG> (Thumb, 378 bytes, Stack size 32 bytes, .\build\lwip_lcp.o(i.lcp_addci))
<BR><BR>[Stack]<UL><LI>Max Depth = 520<LI>Call Chain = lcp_addci &rArr; ppp_error &rArr; ppp_logit &rArr; ppp_vslprintf &rArr; ppp_slprintf &rArr;  ppp_vslprintf (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[463]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_error
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lwip_lcp.o(.constdata)
</UL>
<P><STRONG><a name="[e3]"></a>lcp_cilen</STRONG> (Thumb, 172 bytes, Stack size 8 bytes, .\build\lwip_lcp.o(i.lcp_cilen))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = lcp_cilen
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lwip_lcp.o(.constdata)
</UL>
<P><STRONG><a name="[68]"></a>lcp_delayed_up</STRONG> (Thumb, 30 bytes, Stack size 16 bytes, .\build\lwip_lcp.o(i.lcp_delayed_up))
<BR><BR>[Stack]<UL><LI>Max Depth = 664 + Unknown Stack Size
<LI>Call Chain = lcp_delayed_up &rArr; fsm_lowerup &rArr; fsm_sconfreq &rArr; sys_timeout &rArr; sys_now &rArr; us_ticker_read &rArr; us_ticker_init &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[4c5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fsm_lowerup
</UL>
<BR>[Address Reference Count : 4]<UL><LI> lwip_lcp.o(i.lcp_close)
<LI> lwip_lcp.o(i.lcp_input)
<LI> lwip_lcp.o(i.lcp_lowerdown)
<LI> lwip_lcp.o(i.lcp_lowerup)
</UL>
<P><STRONG><a name="[ea]"></a>lcp_down</STRONG> (Thumb, 90 bytes, Stack size 24 bytes, .\build\lwip_lcp.o(i.lcp_down))
<BR><BR>[Stack]<UL><LI>Max Depth = 568 + Unknown Stack Size
<LI>Call Chain = lcp_down &rArr; lcp_echo_lowerdown &rArr; sys_untimeout &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[525]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;link_down
<LI><a href="#[524]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lcp_echo_lowerdown
<LI><a href="#[526]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_send_config
<LI><a href="#[527]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_recv_config
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lwip_lcp.o(.constdata)
</UL>
<P><STRONG><a name="[524]"></a>lcp_echo_lowerdown</STRONG> (Thumb, 34 bytes, Stack size 16 bytes, .\build\lwip_lcp.o(i.lcp_echo_lowerdown))
<BR><BR>[Stack]<UL><LI>Max Depth = 544 + Unknown Stack Size
<LI>Call Chain = lcp_echo_lowerdown &rArr; sys_untimeout &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[2bf]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_untimeout
</UL>
<BR>[Called By]<UL><LI><a href="#[ea]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lcp_down
</UL>

<P><STRONG><a name="[528]"></a>lcp_echo_lowerup</STRONG> (Thumb, 38 bytes, Stack size 16 bytes, .\build\lwip_lcp.o(i.lcp_echo_lowerup))
<BR><BR>[Stack]<UL><LI>Max Depth = 776 + Unknown Stack Size
<LI>Call Chain = lcp_echo_lowerup &rArr; LcpEchoCheck &rArr; LcpSendEchoRequest &rArr; LcpLinkFailure &rArr; lcp_close &rArr; fsm_close &rArr; terminate_layer &rArr; fsm_sdata &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[2bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LcpEchoCheck
</UL>
<BR>[Called By]<UL><LI><a href="#[e9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lcp_up
</UL>

<P><STRONG><a name="[ed]"></a>lcp_extcode</STRONG> (Thumb, 146 bytes, Stack size 40 bytes, .\build\lwip_lcp.o(i.lcp_extcode))
<BR><BR>[Stack]<UL><LI>Max Depth = 672 + Unknown Stack Size
<LI>Call Chain = lcp_extcode &rArr; fsm_sdata &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[2c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fsm_sdata
<LI><a href="#[529]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lcp_rprotrej
<LI><a href="#[52a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lcp_received_echo_reply
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lwip_lcp.o(.constdata)
</UL>
<P><STRONG><a name="[ec]"></a>lcp_finished</STRONG> (Thumb, 14 bytes, Stack size 16 bytes, .\build\lwip_lcp.o(i.lcp_finished))
<BR><BR>[Stack]<UL><LI>Max Depth = 576 + Unknown Stack Size
<LI>Call Chain = lcp_finished &rArr; link_terminated &rArr; lcp_lowerdown &rArr; fsm_lowerdown &rArr; sys_untimeout &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[52b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;link_terminated
</UL>
<BR>[Called By]<UL><LI><a href="#[f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lcp_close
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lwip_lcp.o(.constdata)
</UL>
<P><STRONG><a name="[ee]"></a>lcp_init</STRONG> (Thumb, 194 bytes, Stack size 24 bytes, .\build\lwip_lcp.o(i.lcp_init))
<BR><BR>[Stack]<UL><LI>Max Depth = 28<LI>Call Chain = lcp_init &rArr; __aeabi_memclr4
</UL>
<BR>[Calls]<UL><LI><a href="#[50b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fsm_init
<LI><a href="#[23c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memclr4
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lwip_lcp.o(.constdata)
</UL>
<P><STRONG><a name="[ef]"></a>lcp_input</STRONG> (Thumb, 58 bytes, Stack size 24 bytes, .\build\lwip_lcp.o(i.lcp_input))
<BR><BR>[Stack]<UL><LI>Max Depth = 752 + Unknown Stack Size
<LI>Call Chain = lcp_input &rArr; fsm_input &rArr; fsm_rconfreq &rArr; fsm_sconfreq &rArr; sys_timeout &rArr; sys_now &rArr; us_ticker_read &rArr; us_ticker_init &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[2bf]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_untimeout
<LI><a href="#[4c5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fsm_lowerup
<LI><a href="#[4bd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fsm_input
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lwip_lcp.o(.constdata)
</UL>
<P><STRONG><a name="[e6]"></a>lcp_nakci</STRONG> (Thumb, 1210 bytes, Stack size 136 bytes, .\build\lwip_lcp.o(i.lcp_nakci))
<BR><BR>[Stack]<UL><LI>Max Depth = 832 + Unknown Stack Size
<LI>Call Chain = lcp_nakci &rArr; lcp_close &rArr; fsm_close &rArr; terminate_layer &rArr; fsm_sdata &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[2c3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_notice
<LI><a href="#[f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lcp_close
<LI><a href="#[52c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;magic
<LI><a href="#[23c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memclr4
<LI><a href="#[247]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy4
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lwip_lcp.o(.constdata)
</UL>
<P><STRONG><a name="[f0]"></a>lcp_protrej</STRONG> (Thumb, 20 bytes, Stack size 8 bytes, .\build\lwip_lcp.o(i.lcp_protrej))
<BR><BR>[Stack]<UL><LI>Max Depth = 672 + Unknown Stack Size
<LI>Call Chain = lcp_protrej &rArr; fsm_protreject &rArr; terminate_layer &rArr; fsm_sdata &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[463]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_error
<LI><a href="#[4c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fsm_protreject
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lwip_lcp.o(.constdata)
</UL>
<P><STRONG><a name="[52a]"></a>lcp_received_echo_reply</STRONG> (Thumb, 100 bytes, Stack size 32 bytes, .\build\lwip_lcp.o(i.lcp_received_echo_reply))
<BR><BR>[Stack]<UL><LI>Max Depth = 520<LI>Call Chain = lcp_received_echo_reply &rArr; ppp_warn &rArr; ppp_logit &rArr; ppp_vslprintf &rArr; ppp_slprintf &rArr;  ppp_vslprintf (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[2be]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_warn
<LI><a href="#[52d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_dbglog
</UL>
<BR>[Called By]<UL><LI><a href="#[ed]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lcp_extcode
</UL>

<P><STRONG><a name="[e7]"></a>lcp_rejci</STRONG> (Thumb, 598 bytes, Stack size 80 bytes, .\build\lwip_lcp.o(i.lcp_rejci))
<BR><BR>[Stack]<UL><LI>Max Depth = 88<LI>Call Chain = lcp_rejci &rArr; __aeabi_memcpy4
</UL>
<BR>[Calls]<UL><LI><a href="#[247]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy4
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lwip_lcp.o(.constdata)
</UL>
<P><STRONG><a name="[e8]"></a>lcp_reqci</STRONG> (Thumb, 1210 bytes, Stack size 96 bytes, .\build\lwip_lcp.o(i.lcp_reqci))
<BR><BR>[Stack]<UL><LI>Max Depth = 672 + Unknown Stack Size
<LI>Call Chain = lcp_reqci &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[46a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_alloc
<LI><a href="#[46b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_free
<LI><a href="#[52d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_dbglog
<LI><a href="#[52c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;magic
<LI><a href="#[23c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memclr4
<LI><a href="#[249]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lwip_lcp.o(.constdata)
</UL>
<P><STRONG><a name="[e2]"></a>lcp_resetci</STRONG> (Thumb, 142 bytes, Stack size 24 bytes, .\build\lwip_lcp.o(i.lcp_resetci))
<BR><BR>[Stack]<UL><LI>Max Depth = 300<LI>Call Chain = lcp_resetci &rArr; magic &rArr; magic_random_bytes &rArr; md5_finish &rArr; md5_update &rArr; md5_process
</UL>
<BR>[Calls]<UL><LI><a href="#[52c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;magic
<LI><a href="#[247]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy4
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lwip_lcp.o(.constdata)
</UL>
<P><STRONG><a name="[529]"></a>lcp_rprotrej</STRONG> (Thumb, 94 bytes, Stack size 32 bytes, .\build\lwip_lcp.o(i.lcp_rprotrej))
<BR><BR>[Stack]<UL><LI>Max Depth = 520<LI>Call Chain = lcp_rprotrej &rArr; ppp_warn &rArr; ppp_logit &rArr; ppp_vslprintf &rArr; ppp_slprintf &rArr;  ppp_vslprintf (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[2be]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_warn
<LI><a href="#[52d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_dbglog
</UL>
<BR>[Called By]<UL><LI><a href="#[ed]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lcp_extcode
</UL>

<P><STRONG><a name="[eb]"></a>lcp_starting</STRONG> (Thumb, 14 bytes, Stack size 16 bytes, .\build\lwip_lcp.o(i.lcp_starting))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = lcp_starting
</UL>
<BR>[Calls]<UL><LI><a href="#[52f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;link_required
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lwip_lcp.o(.constdata)
</UL>
<P><STRONG><a name="[e9]"></a>lcp_up</STRONG> (Thumb, 262 bytes, Stack size 40 bytes, .\build\lwip_lcp.o(i.lcp_up))
<BR><BR>[Stack]<UL><LI>Max Depth = 816 + Unknown Stack Size
<LI>Call Chain = lcp_up &rArr; lcp_echo_lowerup &rArr; LcpEchoCheck &rArr; LcpSendEchoRequest &rArr; LcpLinkFailure &rArr; lcp_close &rArr; fsm_close &rArr; terminate_layer &rArr; fsm_sdata &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[531]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;link_established
<LI><a href="#[528]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lcp_echo_lowerup
<LI><a href="#[526]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_send_config
<LI><a href="#[527]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_recv_config
<LI><a href="#[530]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netif_set_mtu
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lwip_lcp.o(.constdata)
</UL>
<P><STRONG><a name="[566]"></a>magic_churnrand</STRONG> (Thumb, 88 bytes, Stack size 112 bytes, .\build\lwip_magic.o(i.magic_churnrand))
<BR><BR>[Stack]<UL><LI>Max Depth = 688 + Unknown Stack Size
<LI>Call Chain = magic_churnrand &rArr; sys_jiffies &rArr; us_ticker_read &rArr; us_ticker_init &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[47c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_get_random
<LI><a href="#[468]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;md5_update
<LI><a href="#[467]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;md5_starts
<LI><a href="#[469]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;md5_finish
<LI><a href="#[567]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_jiffies
</UL>
<BR>[Called By]<UL><LI><a href="#[569]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;magic_randomize
<LI><a href="#[568]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;magic_init
</UL>

<P><STRONG><a name="[592]"></a>md5_process</STRONG> (Thumb, 2220 bytes, Stack size 84 bytes, .\build\lwip_md5.o(i.md5_process))
<BR><BR>[Stack]<UL><LI>Max Depth = 84<LI>Call Chain = md5_process
</UL>
<BR>[Called By]<UL><LI><a href="#[468]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;md5_update
</UL>

<P><STRONG><a name="[594]"></a>plug_holes</STRONG> (Thumb, 108 bytes, Stack size 12 bytes, .\build\lwip_mem.o(i.plug_holes))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = plug_holes
</UL>
<BR>[Called By]<UL><LI><a href="#[593]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mem_free
</UL>

<P><STRONG><a name="[495]"></a>do_memp_free_pool</STRONG> (Thumb, 36 bytes, Stack size 24 bytes, .\build\lwip_memp.o(i.do_memp_free_pool))
<BR><BR>[Stack]<UL><LI>Max Depth = 488 + Unknown Stack Size
<LI>Call Chain = do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[497]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_unprotect
<LI><a href="#[496]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_protect
</UL>
<BR>[Called By]<UL><LI><a href="#[4e7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memp_free
<LI><a href="#[598]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memp_free_pool
</UL>

<P><STRONG><a name="[498]"></a>do_memp_malloc_pool</STRONG> (Thumb, 42 bytes, Stack size 16 bytes, .\build\lwip_memp.o(i.do_memp_malloc_pool))
<BR><BR>[Stack]<UL><LI>Max Depth = 480 + Unknown Stack Size
<LI>Call Chain = do_memp_malloc_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[497]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_unprotect
<LI><a href="#[496]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_protect
</UL>
<BR>[Called By]<UL><LI><a href="#[4e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memp_malloc
<LI><a href="#[59a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memp_malloc_pool
</UL>

<P><STRONG><a name="[5a5]"></a>netif_issue_reports</STRONG> (Thumb, 34 bytes, Stack size 16 bytes, .\build\lwip_netif.o(i.netif_issue_reports))
<BR><BR>[Stack]<UL><LI>Max Depth = 144<LI>Call Chain = netif_issue_reports &rArr; igmp_report_groups &rArr; igmp_delaying_member &rArr; igmp_start_timer &rArr; lwip_get_random &rArr; randLIB_get_32bit &rArr; randLIB_get_64bit &rArr; rol
</UL>
<BR>[Calls]<UL><LI><a href="#[4e9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;igmp_report_groups
</UL>
<BR>[Called By]<UL><LI><a href="#[590]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netif_set_up
<LI><a href="#[5ab]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netif_set_link_up
<LI><a href="#[5a6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netif_set_ipaddr
</UL>

<P><STRONG><a name="[624]"></a>pbuf_header_impl</STRONG> (Thumb, 134 bytes, Stack size 20 bytes, .\build\lwip_pbuf.o(i.pbuf_header_impl))
<BR><BR>[Stack]<UL><LI>Max Depth = 20<LI>Call Chain = pbuf_header_impl
</UL>
<BR>[Called By]<UL><LI><a href="#[4d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_header
<LI><a href="#[4fd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_header_force
</UL>

<P><STRONG><a name="[626]"></a>pbuf_skip_const</STRONG> (Thumb, 34 bytes, Stack size 12 bytes, .\build\lwip_pbuf.o(i.pbuf_skip_const))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = pbuf_skip_const
</UL>
<BR>[Called By]<UL><LI><a href="#[486]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_try_get_at
<LI><a href="#[625]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_skip
</UL>

<P><STRONG><a name="[a0]"></a>ppp_do_connect</STRONG> (Thumb, 26 bytes, Stack size 16 bytes, .\build\lwip_ppp.o(i.ppp_do_connect))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = ppp_do_connect
</UL>
<BR>[Calls]<UL><LI><a href="#[523]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;new_phase
</UL>
<BR>[Called By]<UL><LI><a href="#[62d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_connect
</UL>
<BR>[Address Reference Count : 2]<UL><LI> lwip_ppp.o(i.ppp_close)
<LI> lwip_ppp.o(i.ppp_connect)
</UL>
<P><STRONG><a name="[a5]"></a>ppp_netif_init_cb</STRONG> (Thumb, 28 bytes, Stack size 0 bytes, .\build\lwip_ppp.o(i.ppp_netif_init_cb))
<BR>[Address Reference Count : 1]<UL><LI> lwip_ppp.o(i.ppp_new)
</UL>
<P><STRONG><a name="[636]"></a>ppp_netif_output</STRONG> (Thumb, 74 bytes, Stack size 32 bytes, .\build\lwip_ppp.o(i.ppp_netif_output))
<BR><BR>[Stack]<UL><LI>Max Depth = 568 + Unknown Stack Size
<LI>Call Chain = ppp_netif_output &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[46b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_free
</UL>
<BR>[Called By]<UL><LI><a href="#[a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_netif_output_ip4
</UL>

<P><STRONG><a name="[a4]"></a>ppp_netif_output_ip4</STRONG> (Thumb, 20 bytes, Stack size 16 bytes, .\build\lwip_ppp.o(i.ppp_netif_output_ip4))
<BR><BR>[Stack]<UL><LI>Max Depth = 584 + Unknown Stack Size
<LI>Call Chain = ppp_netif_output_ip4 &rArr; ppp_netif_output &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[636]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_netif_output
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lwip_ppp.o(i.ppp_netif_init_cb)
</UL>
<P><STRONG><a name="[f5]"></a>pppos_connect</STRONG> (Thumb, 66 bytes, Stack size 24 bytes, .\build\lwip_pppos.o(i.pppos_connect))
<BR><BR>[Stack]<UL><LI>Max Depth = 704 + Unknown Stack Size
<LI>Call Chain = pppos_connect &rArr; ppp_start &rArr; lcp_open &rArr; fsm_open &rArr; fsm_lowerup &rArr; fsm_sconfreq &rArr; sys_timeout &rArr; sys_now &rArr; us_ticker_read &rArr; us_ticker_init &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[497]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_unprotect
<LI><a href="#[496]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_protect
<LI><a href="#[639]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pppos_input_free_current_packet
<LI><a href="#[638]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_start
<LI><a href="#[23c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memclr4
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lwip_pppos.o(.constdata)
</UL>
<P><STRONG><a name="[f7]"></a>pppos_destroy</STRONG> (Thumb, 26 bytes, Stack size 16 bytes, .\build\lwip_pppos.o(i.pppos_destroy))
<BR><BR>[Stack]<UL><LI>Max Depth = 560 + Unknown Stack Size
<LI>Call Chain = pppos_destroy &rArr; pppos_input_free_current_packet &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[598]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memp_free_pool
<LI><a href="#[639]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pppos_input_free_current_packet
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lwip_pppos.o(.constdata)
</UL>
<P><STRONG><a name="[f6]"></a>pppos_disconnect</STRONG> (Thumb, 40 bytes, Stack size 24 bytes, .\build\lwip_pppos.o(i.pppos_disconnect))
<BR><BR>[Stack]<UL><LI>Max Depth = 488 + Unknown Stack Size
<LI>Call Chain = pppos_disconnect &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[497]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_unprotect
<LI><a href="#[496]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_protect
<LI><a href="#[631]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_link_end
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lwip_pppos.o(.constdata)
</UL>
<P><STRONG><a name="[a6]"></a>pppos_input_callback</STRONG> (Thumb, 44 bytes, Stack size 16 bytes, .\build\lwip_pppos.o(i.pppos_input_callback))
<BR><BR>[Stack]<UL><LI>Max Depth = 1216 + Unknown Stack Size
<LI>Call Chain = pppos_input_callback &rArr; ppp_input &rArr; ip4_input &rArr; tcp_input &rArr; tcp_listen_input &rArr; tcp_alloc &rArr; tcp_kill_prio &rArr; tcp_abort &rArr; tcp_abandon &rArr; tcp_pcb_remove &rArr; tcp_output &rArr; tcp_output_segment &rArr; ip4_output_if &rArr; ip4_output_if_opt &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[4d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_header
<LI><a href="#[46b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_free
<LI><a href="#[62f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_input
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lwip_pppos.o(i.pppos_input)
</UL>
<P><STRONG><a name="[63a]"></a>pppos_input_drop</STRONG> (Thumb, 12 bytes, Stack size 8 bytes, .\build\lwip_pppos.o(i.pppos_input_drop))
<BR><BR>[Stack]<UL><LI>Max Depth = 552 + Unknown Stack Size
<LI>Call Chain = pppos_input_drop &rArr; pppos_input_free_current_packet &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[639]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pppos_input_free_current_packet
</UL>
<BR>[Called By]<UL><LI><a href="#[416]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pppos_input
</UL>

<P><STRONG><a name="[639]"></a>pppos_input_free_current_packet</STRONG> (Thumb, 42 bytes, Stack size 8 bytes, .\build\lwip_pppos.o(i.pppos_input_free_current_packet))
<BR><BR>[Stack]<UL><LI>Max Depth = 544 + Unknown Stack Size
<LI>Call Chain = pppos_input_free_current_packet &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[46b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_free
</UL>
<BR>[Called By]<UL><LI><a href="#[63a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pppos_input_drop
<LI><a href="#[f7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pppos_destroy
<LI><a href="#[f5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pppos_connect
</UL>

<P><STRONG><a name="[f9]"></a>pppos_netif_output</STRONG> (Thumb, 266 bytes, Stack size 56 bytes, .\build\lwip_pppos.o(i.pppos_netif_output))
<BR><BR>[Stack]<UL><LI>Max Depth = 672 + Unknown Stack Size
<LI>Call Chain = pppos_netif_output &rArr; pppos_output_last &rArr; sys_now &rArr; us_ticker_read &rArr; us_ticker_init &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[46a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_alloc
<LI><a href="#[63c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pppos_output_last
<LI><a href="#[63b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pppos_output_append
<LI><a href="#[542]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_now
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lwip_pppos.o(.constdata)
</UL>
<P><STRONG><a name="[63b]"></a>pppos_output_append</STRONG> (Thumb, 170 bytes, Stack size 40 bytes, .\build\lwip_pppos.o(i.pppos_output_append))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = pppos_output_append
</UL>
<BR>[Called By]<UL><LI><a href="#[f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pppos_write
<LI><a href="#[63c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pppos_output_last
<LI><a href="#[f9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pppos_netif_output
</UL>

<P><STRONG><a name="[63c]"></a>pppos_output_last</STRONG> (Thumb, 164 bytes, Stack size 40 bytes, .\build\lwip_pppos.o(i.pppos_output_last))
<BR><BR>[Stack]<UL><LI>Max Depth = 616 + Unknown Stack Size
<LI>Call Chain = pppos_output_last &rArr; sys_now &rArr; us_ticker_read &rArr; us_ticker_init &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[46b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_free
<LI><a href="#[63b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pppos_output_append
<LI><a href="#[542]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_now
</UL>
<BR>[Called By]<UL><LI><a href="#[f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pppos_write
<LI><a href="#[f9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pppos_netif_output
</UL>

<P><STRONG><a name="[fb]"></a>pppos_recv_config</STRONG> (Thumb, 58 bytes, Stack size 40 bytes, .\build\lwip_pppos.o(i.pppos_recv_config))
<BR><BR>[Stack]<UL><LI>Max Depth = 504 + Unknown Stack Size
<LI>Call Chain = pppos_recv_config &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[497]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_unprotect
<LI><a href="#[496]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_protect
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lwip_pppos.o(.constdata)
</UL>
<P><STRONG><a name="[fa]"></a>pppos_send_config</STRONG> (Thumb, 56 bytes, Stack size 20 bytes, .\build\lwip_pppos.o(i.pppos_send_config))
<BR><BR>[Stack]<UL><LI>Max Depth = 20<LI>Call Chain = pppos_send_config
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lwip_pppos.o(.constdata)
</UL>
<P><STRONG><a name="[f8]"></a>pppos_write</STRONG> (Thumb, 156 bytes, Stack size 48 bytes, .\build\lwip_pppos.o(i.pppos_write))
<BR><BR>[Stack]<UL><LI>Max Depth = 664 + Unknown Stack Size
<LI>Call Chain = pppos_write &rArr; pppos_output_last &rArr; sys_now &rArr; us_ticker_read &rArr; us_ticker_init &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[46a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_alloc
<LI><a href="#[46b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_free
<LI><a href="#[63c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pppos_output_last
<LI><a href="#[63b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pppos_output_append
<LI><a href="#[542]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_now
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lwip_pppos.o(.constdata)
</UL>
<P><STRONG><a name="[45c]"></a>add_dns_addr_to_dns_list_index</STRONG> (Thumb, 26 bytes, Stack size 16 bytes, .\build\lwip_stack.o(i.add_dns_addr_to_dns_list_index))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = add_dns_addr_to_dns_list_index
</UL>
<BR>[Calls]<UL><LI><a href="#[45d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dns_setserver
</UL>
<BR>[Called By]<UL><LI><a href="#[459]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;add_dns_addr
</UL>

<P><STRONG><a name="[475]"></a>all_zeros</STRONG> (Thumb, 26 bytes, Stack size 0 bytes, .\build\lwip_stack.o(i.all_zeros))
<BR><BR>[Called By]<UL><LI><a href="#[474]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;convert_mbed_addr_to_lwip
</UL>

<P><STRONG><a name="[57f]"></a>convert_lwip_addr_to_mbed</STRONG> (Thumb, 16 bytes, Stack size 0 bytes, .\build\lwip_stack.o(i.convert_lwip_addr_to_mbed))
<BR><BR>[Called By]<UL><LI><a href="#[107]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_socket_recvfrom
<LI><a href="#[103]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_socket_accept
<LI><a href="#[fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_gethostbyname
</UL>

<P><STRONG><a name="[474]"></a>convert_mbed_addr_to_lwip</STRONG> (Thumb, 54 bytes, Stack size 16 bytes, .\build\lwip_stack.o(i.convert_mbed_addr_to_lwip))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = convert_mbed_addr_to_lwip
</UL>
<BR>[Calls]<UL><LI><a href="#[475]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;all_zeros
</UL>
<BR>[Called By]<UL><LI><a href="#[106]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_socket_sendto
<LI><a href="#[102]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_socket_connect
<LI><a href="#[100]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_socket_bind
<LI><a href="#[109]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_setsockopt
<LI><a href="#[fd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_add_dns_server
</UL>

<P><STRONG><a name="[4b7]"></a>find_multicast_member</STRONG> (Thumb, 92 bytes, Stack size 24 bytes, .\build\lwip_stack.o(i.find_multicast_member))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = find_multicast_member &rArr; memcmp
</UL>
<BR>[Calls]<UL><LI><a href="#[4b8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;next_registered_multicast_member
<LI><a href="#[323]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memcmp
</UL>
<BR>[Called By]<UL><LI><a href="#[109]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_setsockopt
</UL>

<P><STRONG><a name="[45b]"></a>get_ip_addr_type</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, .\build\lwip_stack.o(i.get_ip_addr_type))
<BR><BR>[Called By]<UL><LI><a href="#[459]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;add_dns_addr
</UL>

<P><STRONG><a name="[fd]"></a>mbed_lwip_add_dns_server</STRONG> (Thumb, 64 bytes, Stack size 40 bytes, .\build\lwip_stack.o(i.mbed_lwip_add_dns_server))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = mbed_lwip_add_dns_server &rArr; convert_mbed_addr_to_lwip
</UL>
<BR>[Calls]<UL><LI><a href="#[45d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dns_setserver
<LI><a href="#[379]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dns_getserver
<LI><a href="#[474]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;convert_mbed_addr_to_lwip
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lwip_stack.o(.constdata)
</UL>
<P><STRONG><a name="[56f]"></a>mbed_lwip_arena_alloc</STRONG> (Thumb, 70 bytes, Stack size 16 bytes, .\build\lwip_stack.o(i.mbed_lwip_arena_alloc))
<BR><BR>[Stack]<UL><LI>Max Depth = 480 + Unknown Stack Size
<LI>Call Chain = mbed_lwip_arena_alloc &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[497]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_unprotect
<LI><a href="#[496]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_protect
<LI><a href="#[23c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memclr4
</UL>
<BR>[Called By]<UL><LI><a href="#[fe]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_socket_open
<LI><a href="#[103]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_socket_accept
</UL>

<P><STRONG><a name="[570]"></a>mbed_lwip_arena_dealloc</STRONG> (Thumb, 74 bytes, Stack size 24 bytes, .\build\lwip_stack.o(i.mbed_lwip_arena_dealloc))
<BR><BR>[Stack]<UL><LI>Max Depth = 992 + Unknown Stack Size
<LI>Call Chain = mbed_lwip_arena_dealloc &rArr; mbed_lwip_setsockopt &rArr; igmp_leavegroup &rArr; igmp_leavegroup_netif &rArr; igmp_send &rArr; igmp_ip_output_if &rArr; ip4_output_if_opt &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[4b8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;next_registered_multicast_member
<LI><a href="#[109]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_setsockopt
<LI><a href="#[220]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;free
</UL>
<BR>[Called By]<UL><LI><a href="#[fe]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_socket_open
<LI><a href="#[ff]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_socket_close
<LI><a href="#[103]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_socket_accept
</UL>

<P><STRONG><a name="[571]"></a>mbed_lwip_core_init</STRONG> (Thumb, 96 bytes, Stack size 24 bytes, .\build\lwip_stack.o(i.mbed_lwip_core_init))
<BR><BR>[Stack]<UL><LI>Max Depth = 752 + Unknown Stack Size
<LI>Call Chain = mbed_lwip_core_init &rArr; tcpip_init &rArr; lwip_init &rArr; ppp_init &rArr; magic_init &rArr; magic_churnrand &rArr; sys_jiffies &rArr; us_ticker_read &rArr; us_ticker_init &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[47c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_get_random
<LI><a href="#[57b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_sem_new
<LI><a href="#[553]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_sem_wait
<LI><a href="#[57c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcpip_init
<LI><a href="#[54e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_init_tcp_isn
<LI><a href="#[563]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_seed_random
</UL>
<BR>[Called By]<UL><LI><a href="#[392]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_bringup_2
</UL>

<P><STRONG><a name="[578]"></a>mbed_lwip_err_remap</STRONG> (Thumb, 98 bytes, Stack size 0 bytes, .\build\lwip_stack.o(i.mbed_lwip_err_remap))
<BR><BR>[Called By]<UL><LI><a href="#[392]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_bringup_2
<LI><a href="#[106]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_socket_sendto
<LI><a href="#[104]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_socket_send
<LI><a href="#[107]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_socket_recvfrom
<LI><a href="#[105]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_socket_recv
<LI><a href="#[101]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_socket_listen
<LI><a href="#[102]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_socket_connect
<LI><a href="#[ff]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_socket_close
<LI><a href="#[100]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_socket_bind
<LI><a href="#[103]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_socket_accept
<LI><a href="#[109]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_setsockopt
</UL>

<P><STRONG><a name="[57d]"></a>mbed_lwip_get_ipv4_addr</STRONG> (Thumb, 32 bytes, Stack size 0 bytes, .\build\lwip_stack.o(i.mbed_lwip_get_ipv4_addr))
<BR><BR>[Called By]<UL><LI><a href="#[45a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_get_ip_addr
</UL>

<P><STRONG><a name="[fc]"></a>mbed_lwip_gethostbyname</STRONG> (Thumb, 56 bytes, Stack size 32 bytes, .\build\lwip_stack.o(i.mbed_lwip_gethostbyname))
<BR><BR>[Stack]<UL><LI>Max Depth = 688 + Unknown Stack Size
<LI>Call Chain = mbed_lwip_gethostbyname &rArr; netconn_gethostbyname &rArr; sys_arch_sem_wait &rArr; us_ticker_read &rArr; us_ticker_init &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[57e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netconn_gethostbyname
<LI><a href="#[57f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;convert_lwip_addr_to_mbed
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lwip_stack.o(.constdata)
</UL>
<P><STRONG><a name="[583]"></a>mbed_lwip_is_local_addr</STRONG> (Thumb, 52 bytes, Stack size 0 bytes, .\build\lwip_stack.o(i.mbed_lwip_is_local_addr))
<BR><BR>[Called By]<UL><LI><a href="#[100]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_socket_bind
</UL>

<P><STRONG><a name="[71]"></a>mbed_lwip_netif_link_irq</STRONG> (Thumb, 62 bytes, Stack size 16 bytes, .\build\lwip_stack.o(i.mbed_lwip_netif_link_irq))
<BR><BR>[Stack]<UL><LI>Max Depth = 536 + Unknown Stack Size
<LI>Call Chain = mbed_lwip_netif_link_irq &rArr; sys_sem_signal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[37c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_sem_signal
<LI><a href="#[580]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netif_set_down
<LI><a href="#[57a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_set_dhcp
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lwip_stack.o(i.mbed_lwip_bringup_2)
</UL>
<P><STRONG><a name="[72]"></a>mbed_lwip_netif_status_irq</STRONG> (Thumb, 126 bytes, Stack size 16 bytes, .\build\lwip_stack.o(i.mbed_lwip_netif_status_irq))
<BR><BR>[Stack]<UL><LI>Max Depth = 536 + Unknown Stack Size
<LI>Call Chain = mbed_lwip_netif_status_irq &rArr; sys_sem_signal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[37c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_sem_signal
<LI><a href="#[45a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_get_ip_addr
<LI><a href="#[459]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;add_dns_addr
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lwip_stack.o(i.mbed_lwip_bringup_2)
</UL>
<P><STRONG><a name="[109]"></a>mbed_lwip_setsockopt</STRONG> (Thumb, 498 bytes, Stack size 48 bytes, .\build\lwip_stack.o(i.mbed_lwip_setsockopt))
<BR><BR>[Stack]<UL><LI>Max Depth = 968 + Unknown Stack Size
<LI>Call Chain = mbed_lwip_setsockopt &rArr; igmp_leavegroup &rArr; igmp_leavegroup_netif &rArr; igmp_send &rArr; igmp_ip_output_if &rArr; ip4_output_if_opt &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[4e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;igmp_leavegroup
<LI><a href="#[4e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;igmp_joingroup
<LI><a href="#[497]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_unprotect
<LI><a href="#[496]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_protect
<LI><a href="#[578]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_err_remap
<LI><a href="#[4b7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;find_multicast_member
<LI><a href="#[474]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;convert_mbed_addr_to_lwip
<LI><a href="#[249]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
<LI><a href="#[21d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;malloc
</UL>
<BR>[Called By]<UL><LI><a href="#[570]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_arena_dealloc
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lwip_stack.o(.constdata)
</UL>
<P><STRONG><a name="[103]"></a>mbed_lwip_socket_accept</STRONG> (Thumb, 132 bytes, Stack size 40 bytes, .\build\lwip_stack.o(i.mbed_lwip_socket_accept))
<BR><BR>[Stack]<UL><LI>Max Depth = 1032 + Unknown Stack Size
<LI>Call Chain = mbed_lwip_socket_accept &rArr; mbed_lwip_arena_dealloc &rArr; mbed_lwip_setsockopt &rArr; igmp_leavegroup &rArr; igmp_leavegroup_netif &rArr; igmp_send &rArr; igmp_ip_output_if &rArr; ip4_output_if_opt &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[582]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netconn_getaddr
<LI><a href="#[581]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netconn_accept
<LI><a href="#[578]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_err_remap
<LI><a href="#[570]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_arena_dealloc
<LI><a href="#[56f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_arena_alloc
<LI><a href="#[57f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;convert_lwip_addr_to_mbed
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lwip_stack.o(.constdata)
</UL>
<P><STRONG><a name="[108]"></a>mbed_lwip_socket_attach</STRONG> (Thumb, 12 bytes, Stack size 8 bytes, .\build\lwip_stack.o(i.mbed_lwip_socket_attach))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = mbed_lwip_socket_attach
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lwip_stack.o(.constdata)
</UL>
<P><STRONG><a name="[100]"></a>mbed_lwip_socket_bind</STRONG> (Thumb, 118 bytes, Stack size 48 bytes, .\build\lwip_stack.o(i.mbed_lwip_socket_bind))
<BR><BR>[Stack]<UL><LI>Max Depth = 584 + Unknown Stack Size
<LI>Call Chain = mbed_lwip_socket_bind &rArr; netconn_bind &rArr; netconn_apimsg &rArr; tcpip_send_msg_wait_sem &rArr; sys_mutex_unlock &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[584]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netconn_bind
<LI><a href="#[583]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_is_local_addr
<LI><a href="#[578]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_err_remap
<LI><a href="#[474]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;convert_mbed_addr_to_lwip
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lwip_stack.o(.constdata)
</UL>
<P><STRONG><a name="[74]"></a>mbed_lwip_socket_callback</STRONG> (Thumb, 112 bytes, Stack size 24 bytes, .\build\lwip_stack.o(i.mbed_lwip_socket_callback))
<BR><BR>[Stack]<UL><LI>Max Depth = 488 + Unknown Stack Size
<LI>Call Chain = mbed_lwip_socket_callback &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[497]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_unprotect
<LI><a href="#[496]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_protect
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lwip_stack.o(i.mbed_lwip_socket_open)
</UL>
<P><STRONG><a name="[ff]"></a>mbed_lwip_socket_close</STRONG> (Thumb, 40 bytes, Stack size 24 bytes, .\build\lwip_stack.o(i.mbed_lwip_socket_close))
<BR><BR>[Stack]<UL><LI>Max Depth = 1016 + Unknown Stack Size
<LI>Call Chain = mbed_lwip_socket_close &rArr; mbed_lwip_arena_dealloc &rArr; mbed_lwip_setsockopt &rArr; igmp_leavegroup &rArr; igmp_leavegroup_netif &rArr; igmp_send &rArr; igmp_ip_output_if &rArr; ip4_output_if_opt &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[585]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netbuf_delete
<LI><a href="#[586]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netconn_delete
<LI><a href="#[578]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_err_remap
<LI><a href="#[570]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_arena_dealloc
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lwip_stack.o(.constdata)
</UL>
<P><STRONG><a name="[102]"></a>mbed_lwip_socket_connect</STRONG> (Thumb, 94 bytes, Stack size 48 bytes, .\build\lwip_stack.o(i.mbed_lwip_socket_connect))
<BR><BR>[Stack]<UL><LI>Max Depth = 584 + Unknown Stack Size
<LI>Call Chain = mbed_lwip_socket_connect &rArr; netconn_connect &rArr; netconn_apimsg &rArr; tcpip_send_msg_wait_sem &rArr; sys_mutex_unlock &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[587]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netconn_connect
<LI><a href="#[578]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_err_remap
<LI><a href="#[474]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;convert_mbed_addr_to_lwip
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lwip_stack.o(.constdata)
</UL>
<P><STRONG><a name="[101]"></a>mbed_lwip_socket_listen</STRONG> (Thumb, 44 bytes, Stack size 24 bytes, .\build\lwip_stack.o(i.mbed_lwip_socket_listen))
<BR><BR>[Stack]<UL><LI>Max Depth = 560 + Unknown Stack Size
<LI>Call Chain = mbed_lwip_socket_listen &rArr; netconn_listen_with_backlog &rArr; netconn_apimsg &rArr; tcpip_send_msg_wait_sem &rArr; sys_mutex_unlock &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[588]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netconn_listen_with_backlog
<LI><a href="#[578]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_err_remap
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lwip_stack.o(.constdata)
</UL>
<P><STRONG><a name="[fe]"></a>mbed_lwip_socket_open</STRONG> (Thumb, 90 bytes, Stack size 24 bytes, .\build\lwip_stack.o(i.mbed_lwip_socket_open))
<BR><BR>[Stack]<UL><LI>Max Depth = 1016 + Unknown Stack Size
<LI>Call Chain = mbed_lwip_socket_open &rArr; mbed_lwip_arena_dealloc &rArr; mbed_lwip_setsockopt &rArr; igmp_leavegroup &rArr; igmp_leavegroup_netif &rArr; igmp_send &rArr; igmp_ip_output_if &rArr; ip4_output_if_opt &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[589]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netconn_new_with_proto_and_callback
<LI><a href="#[570]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_arena_dealloc
<LI><a href="#[56f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_arena_alloc
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lwip_stack.o(.constdata)
</UL>
<P><STRONG><a name="[105]"></a>mbed_lwip_socket_recv</STRONG> (Thumb, 102 bytes, Stack size 32 bytes, .\build\lwip_stack.o(i.mbed_lwip_socket_recv))
<BR><BR>[Stack]<UL><LI>Max Depth = 696 + Unknown Stack Size
<LI>Call Chain = mbed_lwip_socket_recv &rArr; netconn_recv &rArr; netconn_recv_data &rArr; sys_arch_mbox_fetch &rArr; us_ticker_read &rArr; us_ticker_init &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[48d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_copy_partial
<LI><a href="#[585]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netbuf_delete
<LI><a href="#[58a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netconn_recv
<LI><a href="#[578]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_err_remap
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lwip_stack.o(.constdata)
</UL>
<P><STRONG><a name="[107]"></a>mbed_lwip_socket_recvfrom</STRONG> (Thumb, 84 bytes, Stack size 40 bytes, .\build\lwip_stack.o(i.mbed_lwip_socket_recvfrom))
<BR><BR>[Stack]<UL><LI>Max Depth = 704 + Unknown Stack Size
<LI>Call Chain = mbed_lwip_socket_recvfrom &rArr; netconn_recv &rArr; netconn_recv_data &rArr; sys_arch_mbox_fetch &rArr; us_ticker_read &rArr; us_ticker_init &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[48d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_copy_partial
<LI><a href="#[585]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netbuf_delete
<LI><a href="#[58a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netconn_recv
<LI><a href="#[578]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_err_remap
<LI><a href="#[57f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;convert_lwip_addr_to_mbed
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lwip_stack.o(.constdata)
</UL>
<P><STRONG><a name="[104]"></a>mbed_lwip_socket_send</STRONG> (Thumb, 54 bytes, Stack size 40 bytes, .\build\lwip_stack.o(i.mbed_lwip_socket_send))
<BR><BR>[Stack]<UL><LI>Max Depth = 592 + Unknown Stack Size
<LI>Call Chain = mbed_lwip_socket_send &rArr; netconn_write_partly &rArr; netconn_apimsg &rArr; tcpip_send_msg_wait_sem &rArr; sys_mutex_unlock &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[58b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netconn_write_partly
<LI><a href="#[578]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_err_remap
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lwip_stack.o(.constdata)
</UL>
<P><STRONG><a name="[106]"></a>mbed_lwip_socket_sendto</STRONG> (Thumb, 108 bytes, Stack size 56 bytes, .\build\lwip_stack.o(i.mbed_lwip_socket_sendto))
<BR><BR>[Stack]<UL><LI>Max Depth = 648 + Unknown Stack Size
<LI>Call Chain = mbed_lwip_socket_sendto &rArr; netbuf_ref &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[585]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netbuf_delete
<LI><a href="#[58f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netconn_sendto
<LI><a href="#[58d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netbuf_ref
<LI><a href="#[58c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netbuf_new
<LI><a href="#[58e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netbuf_free
<LI><a href="#[578]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_err_remap
<LI><a href="#[474]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;convert_mbed_addr_to_lwip
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lwip_stack.o(.constdata)
</UL>
<P><STRONG><a name="[73]"></a>mbed_lwip_tcpip_init_irq</STRONG> (Thumb, 12 bytes, Stack size 8 bytes, .\build\lwip_stack.o(i.mbed_lwip_tcpip_init_irq))
<BR><BR>[Stack]<UL><LI>Max Depth = 528 + Unknown Stack Size
<LI>Call Chain = mbed_lwip_tcpip_init_irq &rArr; sys_sem_signal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[37c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_sem_signal
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lwip_stack.o(i.mbed_lwip_core_init)
</UL>
<P><STRONG><a name="[57a]"></a>mbed_set_dhcp</STRONG> (Thumb, 14 bytes, Stack size 8 bytes, .\build\lwip_stack.o(i.mbed_set_dhcp))
<BR><BR>[Stack]<UL><LI>Max Depth = 160<LI>Call Chain = mbed_set_dhcp &rArr; netif_set_up &rArr; netif_issue_reports &rArr; igmp_report_groups &rArr; igmp_delaying_member &rArr; igmp_start_timer &rArr; lwip_get_random &rArr; randLIB_get_32bit &rArr; randLIB_get_64bit &rArr; rol
</UL>
<BR>[Calls]<UL><LI><a href="#[590]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netif_set_up
</UL>
<BR>[Called By]<UL><LI><a href="#[392]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_bringup_2
<LI><a href="#[71]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_netif_link_irq
</UL>

<P><STRONG><a name="[4b8]"></a>next_registered_multicast_member</STRONG> (Thumb, 22 bytes, Stack size 0 bytes, .\build\lwip_stack.o(i.next_registered_multicast_member))
<BR><BR>[Called By]<UL><LI><a href="#[570]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_lwip_arena_dealloc
<LI><a href="#[4b7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;find_multicast_member
</UL>

<P><STRONG><a name="[bc]"></a>tcp_accept_null</STRONG> (Thumb, 20 bytes, Stack size 16 bytes, .\build\lwip_tcp.o(i.tcp_accept_null))
<BR><BR>[Stack]<UL><LI>Max Depth = 1032 + Unknown Stack Size
<LI>Call Chain = tcp_accept_null &rArr; tcp_abort &rArr; tcp_abandon &rArr; tcp_pcb_remove &rArr; tcp_output &rArr; tcp_output_segment &rArr; ip4_output_if &rArr; ip4_output_if_opt &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[558]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_abort
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lwip_tcp.o(i.tcp_listen_with_backlog_and_err)
</UL>
<P><STRONG><a name="[69d]"></a>tcp_close_shutdown</STRONG> (Thumb, 328 bytes, Stack size 24 bytes, .\build\lwip_tcp.o(i.tcp_close_shutdown))
<BR><BR>[Stack]<UL><LI>Max Depth = 984 + Unknown Stack Size
<LI>Call Chain = tcp_close_shutdown &rArr; tcp_pcb_remove &rArr; tcp_output &rArr; tcp_output_segment &rArr; ip4_output_if &rArr; ip4_output_if_opt &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[4e7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memp_free
<LI><a href="#[69f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_trigger_input_pcb_close
<LI><a href="#[69c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_timer_needed
<LI><a href="#[696]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_rst
<LI><a href="#[694]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_pcb_remove
<LI><a href="#[69e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_pcb_purge
<LI><a href="#[6a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_listen_closed
<LI><a href="#[6a1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_close_shutdown_fin
</UL>
<BR>[Called By]<UL><LI><a href="#[557]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_shutdown
<LI><a href="#[556]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_close
</UL>

<P><STRONG><a name="[6a1]"></a>tcp_close_shutdown_fin</STRONG> (Thumb, 100 bytes, Stack size 16 bytes, .\build\lwip_tcp.o(i.tcp_close_shutdown_fin))
<BR><BR>[Stack]<UL><LI>Max Depth = 960 + Unknown Stack Size
<LI>Call Chain = tcp_close_shutdown_fin &rArr; tcp_output &rArr; tcp_output_segment &rArr; ip4_output_if &rArr; ip4_output_if_opt &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[562]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_output
<LI><a href="#[6a2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_send_fin
</UL>
<BR>[Called By]<UL><LI><a href="#[6a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_fasttmr
<LI><a href="#[69d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_close_shutdown
</UL>

<P><STRONG><a name="[69a]"></a>tcp_kill_prio</STRONG> (Thumb, 78 bytes, Stack size 24 bytes, .\build\lwip_tcp.o(i.tcp_kill_prio))
<BR><BR>[Stack]<UL><LI>Max Depth = 1040 + Unknown Stack Size
<LI>Call Chain = tcp_kill_prio &rArr; tcp_abort &rArr; tcp_abandon &rArr; tcp_pcb_remove &rArr; tcp_output &rArr; tcp_output_segment &rArr; ip4_output_if &rArr; ip4_output_if_opt &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[558]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_abort
</UL>
<BR>[Called By]<UL><LI><a href="#[697]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_alloc
</UL>

<P><STRONG><a name="[699]"></a>tcp_kill_state</STRONG> (Thumb, 64 bytes, Stack size 24 bytes, .\build\lwip_tcp.o(i.tcp_kill_state))
<BR><BR>[Stack]<UL><LI>Max Depth = 1032 + Unknown Stack Size
<LI>Call Chain = tcp_kill_state &rArr; tcp_abandon &rArr; tcp_pcb_remove &rArr; tcp_output &rArr; tcp_output_segment &rArr; ip4_output_if &rArr; ip4_output_if_opt &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[693]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_abandon
</UL>
<BR>[Called By]<UL><LI><a href="#[697]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_alloc
</UL>

<P><STRONG><a name="[698]"></a>tcp_kill_timewait</STRONG> (Thumb, 50 bytes, Stack size 16 bytes, .\build\lwip_tcp.o(i.tcp_kill_timewait))
<BR><BR>[Stack]<UL><LI>Max Depth = 1032 + Unknown Stack Size
<LI>Call Chain = tcp_kill_timewait &rArr; tcp_abort &rArr; tcp_abandon &rArr; tcp_pcb_remove &rArr; tcp_output &rArr; tcp_output_segment &rArr; ip4_output_if &rArr; ip4_output_if_opt &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[558]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_abort
</UL>
<BR>[Called By]<UL><LI><a href="#[697]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_alloc
</UL>

<P><STRONG><a name="[6a0]"></a>tcp_listen_closed</STRONG> (Thumb, 30 bytes, Stack size 16 bytes, .\build\lwip_tcp.o(i.tcp_listen_closed))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = tcp_listen_closed
</UL>
<BR>[Calls]<UL><LI><a href="#[6b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_remove_listener
</UL>
<BR>[Called By]<UL><LI><a href="#[69d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_close_shutdown
</UL>

<P><STRONG><a name="[6b2]"></a>tcp_netif_ip_addr_changed_pcblist</STRONG> (Thumb, 42 bytes, Stack size 24 bytes, .\build\lwip_tcp.o(i.tcp_netif_ip_addr_changed_pcblist))
<BR><BR>[Stack]<UL><LI>Max Depth = 1040 + Unknown Stack Size
<LI>Call Chain = tcp_netif_ip_addr_changed_pcblist &rArr; tcp_abort &rArr; tcp_abandon &rArr; tcp_pcb_remove &rArr; tcp_output &rArr; tcp_output_segment &rArr; ip4_output_if &rArr; ip4_output_if_opt &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[558]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_abort
</UL>
<BR>[Called By]<UL><LI><a href="#[5a9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_netif_ip_addr_changed
</UL>

<P><STRONG><a name="[69b]"></a>tcp_new_port</STRONG> (Thumb, 96 bytes, Stack size 12 bytes, .\build\lwip_tcp.o(i.tcp_new_port))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = tcp_new_port
</UL>
<BR>[Called By]<UL><LI><a href="#[55a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_connect
<LI><a href="#[54f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_bind
</UL>

<P><STRONG><a name="[6b0]"></a>tcp_remove_listener</STRONG> (Thumb, 24 bytes, Stack size 0 bytes, .\build\lwip_tcp.o(i.tcp_remove_listener))
<BR><BR>[Called By]<UL><LI><a href="#[6a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_listen_closed
</UL>

<P><STRONG><a name="[6b4]"></a>tcp_getoptbyte</STRONG> (Thumb, 70 bytes, Stack size 0 bytes, .\build\lwip_tcp_in.o(i.tcp_getoptbyte))
<BR><BR>[Called By]<UL><LI><a href="#[6b1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_parseopt
</UL>

<P><STRONG><a name="[6ab]"></a>tcp_listen_input</STRONG> (Thumb, 296 bytes, Stack size 32 bytes, .\build\lwip_tcp_in.o(i.tcp_listen_input))
<BR><BR>[Stack]<UL><LI>Max Depth = 1088 + Unknown Stack Size
<LI>Call Chain = tcp_listen_input &rArr; tcp_alloc &rArr; tcp_kill_prio &rArr; tcp_abort &rArr; tcp_abandon &rArr; tcp_pcb_remove &rArr; tcp_output &rArr; tcp_output_segment &rArr; ip4_output_if &rArr; ip4_output_if_opt &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[562]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_output
<LI><a href="#[6b1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_parseopt
<LI><a href="#[69c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_timer_needed
<LI><a href="#[696]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_rst
<LI><a href="#[6a5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_enqueue_flags
<LI><a href="#[6a3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_next_iss
<LI><a href="#[6a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_eff_send_mss_impl
<LI><a href="#[697]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_alloc
<LI><a href="#[693]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_abandon
</UL>
<BR>[Called By]<UL><LI><a href="#[4fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_input
</UL>

<P><STRONG><a name="[6b1]"></a>tcp_parseopt</STRONG> (Thumb, 148 bytes, Stack size 24 bytes, .\build\lwip_tcp_in.o(i.tcp_parseopt))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = tcp_parseopt
</UL>
<BR>[Calls]<UL><LI><a href="#[6b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_getoptbyte
</UL>
<BR>[Called By]<UL><LI><a href="#[6ad]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_process
<LI><a href="#[6ab]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_listen_input
</UL>

<P><STRONG><a name="[6ad]"></a>tcp_process</STRONG> (Thumb, 1418 bytes, Stack size 32 bytes, .\build\lwip_tcp_in.o(i.tcp_process))
<BR><BR>[Stack]<UL><LI>Max Depth = 1048 + Unknown Stack Size
<LI>Call Chain = tcp_process &rArr; tcp_abort &rArr; tcp_abandon &rArr; tcp_pcb_remove &rArr; tcp_output &rArr; tcp_output_segment &rArr; ip4_output_if &rArr; ip4_output_if_opt &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[558]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_abort
<LI><a href="#[6b7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_rexmit
<LI><a href="#[6b6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_receive
<LI><a href="#[6b1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_parseopt
<LI><a href="#[69c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_timer_needed
<LI><a href="#[696]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_rst
<LI><a href="#[6b5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_rexmit_rto
<LI><a href="#[6a7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_seg_free
<LI><a href="#[69e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_pcb_purge
<LI><a href="#[6a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_eff_send_mss_impl
</UL>
<BR>[Called By]<UL><LI><a href="#[4fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_input
</UL>

<P><STRONG><a name="[6b6]"></a>tcp_receive</STRONG> (Thumb, 1444 bytes, Stack size 40 bytes, .\build\lwip_tcp_in.o(i.tcp_receive))
<BR><BR>[Stack]<UL><LI>Max Depth = 944 + Unknown Stack Size
<LI>Call Chain = tcp_receive &rArr; tcp_send_empty_ack &rArr; ip4_output_if &rArr; ip4_output_if_opt &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[48e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_htons
<LI><a href="#[490]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_htonl
<LI><a href="#[46e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_realloc
<LI><a href="#[4d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_header
<LI><a href="#[500]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_clen
<LI><a href="#[6ac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_send_empty_ack
<LI><a href="#[6b8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_rexmit_fast
<LI><a href="#[6b9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_update_rcv_ann_wnd
<LI><a href="#[6a7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_seg_free
</UL>
<BR>[Called By]<UL><LI><a href="#[6ad]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_process
</UL>

<P><STRONG><a name="[6aa]"></a>tcp_timewait_input</STRONG> (Thumb, 134 bytes, Stack size 16 bytes, .\build\lwip_tcp_in.o(i.tcp_timewait_input))
<BR><BR>[Stack]<UL><LI>Max Depth = 960 + Unknown Stack Size
<LI>Call Chain = tcp_timewait_input &rArr; tcp_output &rArr; tcp_output_segment &rArr; ip4_output_if &rArr; ip4_output_if_opt &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[562]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_output
<LI><a href="#[696]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_rst
</UL>
<BR>[Called By]<UL><LI><a href="#[4fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_input
</UL>

<P><STRONG><a name="[6a6]"></a>tcp_create_segment</STRONG> (Thumb, 192 bytes, Stack size 40 bytes, .\build\lwip_tcp_out.o(i.tcp_create_segment))
<BR><BR>[Stack]<UL><LI>Max Depth = 584 + Unknown Stack Size
<LI>Call Chain = tcp_create_segment &rArr; tcp_seg_free &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[48e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_htons
<LI><a href="#[490]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_htonl
<LI><a href="#[4d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_header
<LI><a href="#[46b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_free
<LI><a href="#[4e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memp_malloc
<LI><a href="#[6a7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_seg_free
</UL>
<BR>[Called By]<UL><LI><a href="#[561]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_write
<LI><a href="#[6a5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_enqueue_flags
</UL>

<P><STRONG><a name="[6af]"></a>tcp_output_alloc_header</STRONG> (Thumb, 120 bytes, Stack size 32 bytes, .\build\lwip_tcp_out.o(i.tcp_output_alloc_header))
<BR><BR>[Stack]<UL><LI>Max Depth = 608 + Unknown Stack Size
<LI>Call Chain = tcp_output_alloc_header &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[48e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_htons
<LI><a href="#[490]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_htonl
<LI><a href="#[46a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_alloc
</UL>
<BR>[Called By]<UL><LI><a href="#[6ac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_send_empty_ack
<LI><a href="#[6bb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_zero_window_probe
<LI><a href="#[6ae]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_keepalive
</UL>

<P><STRONG><a name="[6b3]"></a>tcp_output_segment</STRONG> (Thumb, 214 bytes, Stack size 48 bytes, .\build\lwip_tcp_out.o(i.tcp_output_segment))
<BR><BR>[Stack]<UL><LI>Max Depth = 904 + Unknown Stack Size
<LI>Call Chain = tcp_output_segment &rArr; ip4_output_if &rArr; ip4_output_if_opt &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[48e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_htons
<LI><a href="#[490]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_htonl
<LI><a href="#[505]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip_chksum_pseudo
<LI><a href="#[4d7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip4_output_if
<LI><a href="#[6a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_eff_send_mss_impl
</UL>
<BR>[Called By]<UL><LI><a href="#[562]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_output
</UL>

<P><STRONG><a name="[6bc]"></a>tcp_write_checks</STRONG> (Thumb, 98 bytes, Stack size 0 bytes, .\build\lwip_tcp_out.o(i.tcp_write_checks))
<BR><BR>[Called By]<UL><LI><a href="#[561]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_write
</UL>

<P><STRONG><a name="[be]"></a>tcpip_thread</STRONG> (Thumb, 124 bytes, Stack size 8 bytes, .\build\lwip_tcpip.o(i.tcpip_thread))
<BR><BR>[Stack]<UL><LI>Max Depth = 632 + Unknown Stack Size
<LI>Call Chain = tcpip_thread &rArr; sys_timeouts_mbox_fetch &rArr; sys_check_timeouts &rArr; sys_now &rArr; us_ticker_read &rArr; us_ticker_init &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[552]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_mutex_unlock
<LI><a href="#[554]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_mutex_lock
<LI><a href="#[4e7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memp_free
<LI><a href="#[691]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_timeouts_mbox_fetch
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lwip_tcpip.o(i.tcpip_init)
</UL>
<P><STRONG><a name="[61]"></a>cyclic_timer</STRONG> (Thumb, 22 bytes, Stack size 16 bytes, .\build\lwip_timeouts.o(i.cyclic_timer))
<BR><BR>[Stack]<UL><LI>Max Depth = 624 + Unknown Stack Size
<LI>Call Chain = cyclic_timer &rArr; sys_timeout &rArr; sys_now &rArr; us_ticker_read &rArr; us_ticker_init &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[2c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_timeout
</UL>
<BR>[Address Reference Count : 2]<UL><LI> lwip_timeouts.o(i.sys_timeouts_init)
<LI> lwip_timeouts.o(i.cyclic_timer)
</UL>
<P><STRONG><a name="[68e]"></a>sys_check_timeouts</STRONG> (Thumb, 112 bytes, Stack size 32 bytes, .\build\lwip_timeouts.o(i.sys_check_timeouts))
<BR><BR>[Stack]<UL><LI>Max Depth = 608 + Unknown Stack Size
<LI>Call Chain = sys_check_timeouts &rArr; sys_now &rArr; us_ticker_read &rArr; us_ticker_init &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[552]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_mutex_unlock
<LI><a href="#[554]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_mutex_lock
<LI><a href="#[4e7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memp_free
<LI><a href="#[542]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_now
</UL>
<BR>[Called By]<UL><LI><a href="#[691]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_timeouts_mbox_fetch
</UL>

<P><STRONG><a name="[692]"></a>sys_timeouts_sleeptime</STRONG> (Thumb, 48 bytes, Stack size 8 bytes, .\build\lwip_timeouts.o(i.sys_timeouts_sleeptime))
<BR><BR>[Stack]<UL><LI>Max Depth = 584 + Unknown Stack Size
<LI>Call Chain = sys_timeouts_sleeptime &rArr; sys_now &rArr; us_ticker_read &rArr; us_ticker_init &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[542]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_now
</UL>
<BR>[Called By]<UL><LI><a href="#[691]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_timeouts_mbox_fetch
</UL>

<P><STRONG><a name="[bd]"></a>tcpip_tcp_timer</STRONG> (Thumb, 40 bytes, Stack size 8 bytes, .\build\lwip_timeouts.o(i.tcpip_tcp_timer))
<BR><BR>[Stack]<UL><LI>Max Depth = 1072 + Unknown Stack Size
<LI>Call Chain = tcpip_tcp_timer &rArr; tcp_tmr &rArr; tcp_fasttmr &rArr; tcp_process_refused_data &rArr; tcp_recv_null &rArr; tcp_close &rArr; tcp_close_shutdown &rArr; tcp_pcb_remove &rArr; tcp_output &rArr; tcp_output_segment &rArr; ip4_output_if &rArr; ip4_output_if_opt &rArr; ip4_output_if_opt_src &rArr; ip4_frag &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[2c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_timeout
<LI><a href="#[10a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_tmr
</UL>
<BR>[Address Reference Count : 2]<UL><LI> lwip_timeouts.o(i.tcp_timer_needed)
<LI> lwip_timeouts.o(i.tcpip_tcp_timer)
</UL>
<P><STRONG><a name="[6c0]"></a>udp_input_local_match</STRONG> (Thumb, 66 bytes, Stack size 12 bytes, .\build\lwip_udp.o(i.udp_input_local_match))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = udp_input_local_match
</UL>
<BR>[Called By]<UL><LI><a href="#[4fb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_input
</UL>

<P><STRONG><a name="[6bf]"></a>udp_new_port</STRONG> (Thumb, 80 bytes, Stack size 8 bytes, .\build\lwip_udp.o(i.udp_new_port))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = udp_new_port
</UL>
<BR>[Called By]<UL><LI><a href="#[47d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_bind
</UL>

<P><STRONG><a name="[633]"></a>ppp_log_write</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, .\build\lwip_utils.o(i.ppp_log_write))
<BR><BR>[Called By]<UL><LI><a href="#[62e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_logit
</UL>

<P><STRONG><a name="[62e]"></a>ppp_logit</STRONG> (Thumb, 34 bytes, Stack size 280 bytes, .\build\lwip_utils.o(i.ppp_logit))
<BR><BR>[Stack]<UL><LI>Max Depth = 464<LI>Call Chain = ppp_logit &rArr; ppp_vslprintf &rArr; ppp_slprintf &rArr;  ppp_vslprintf (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[632]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_vslprintf
<LI><a href="#[633]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_log_write
</UL>
<BR>[Called By]<UL><LI><a href="#[2c2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_info
<LI><a href="#[464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_fatal
<LI><a href="#[2be]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_warn
<LI><a href="#[2c3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_notice
<LI><a href="#[463]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_error
<LI><a href="#[52d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_dbglog
</UL>

<P><STRONG><a name="[43d]"></a>mbed_cpy_nvic</STRONG> (Thumb, 34 bytes, Stack size 0 bytes, .\build\mbed_boot.o(i.mbed_cpy_nvic))
<BR><BR>[Called By]<UL><LI><a href="#[1de]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_entry
</UL>

<P><STRONG><a name="[4cd]"></a>are_interrupts_enabled</STRONG> (Thumb, 16 bytes, Stack size 0 bytes, .\build\mbed_critical_section_api.o(i.are_interrupts_enabled))
<BR><BR>[Called By]<UL><LI><a href="#[477]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hal_critical_section_exit
<LI><a href="#[476]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hal_critical_section_enter
</UL>

<P><STRONG><a name="[444]"></a>_gpio_init_in</STRONG> (Thumb, 38 bytes, Stack size 16 bytes, .\build\mbed_gpio.o(i._gpio_init_in))
<BR><BR>[Stack]<UL><LI>Max Depth = 616 + Unknown Stack Size
<LI>Call Chain = _gpio_init_in &rArr; gpio_dir &rArr; gpio_mode &rArr; pin_mode &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[446]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;gpio_dir
<LI><a href="#[447]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;gpio_mode
<LI><a href="#[445]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;gpio_init
</UL>
<BR>[Called By]<UL><LI><a href="#[415]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;gpio_init_in_ex
</UL>

<P><STRONG><a name="[448]"></a>_gpio_init_out</STRONG> (Thumb, 52 bytes, Stack size 24 bytes, .\build\mbed_gpio.o(i._gpio_init_out))
<BR><BR>[Stack]<UL><LI>Max Depth = 624 + Unknown Stack Size
<LI>Call Chain = _gpio_init_out &rArr; gpio_dir &rArr; gpio_mode &rArr; pin_mode &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[449]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;gpio_write
<LI><a href="#[446]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;gpio_dir
<LI><a href="#[447]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;gpio_mode
<LI><a href="#[445]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;gpio_init
</UL>
<BR>[Called By]<UL><LI><a href="#[4ca]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;gpio_init_out_ex
</UL>

<P><STRONG><a name="[2e0]"></a>get_console(int)</STRONG> (Thumb, 38 bytes, Stack size 16 bytes, .\build\mbed_retarget.o(i._Z11get_consolei))
<BR><BR>[Stack]<UL><LI>Max Depth = 256<LI>Call Chain = get_console(int) &rArr; default_console() &rArr; DirectSerial::DirectSerial(PinName, PinName, int) &rArr; serial_init &rArr; uart_init &rArr; serial_baud &rArr; serial_leuart_baud &rArr;  mbed_assert_internal (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[2e3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;default_console()
<LI><a href="#[2e2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::mbed_target_override_console(int)
<LI><a href="#[2e1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::mbed_override_console(int)
</UL>
<BR>[Called By]<UL><LI><a href="#[321]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;get_fhc(int)
</UL>

<P><STRONG><a name="[2e4]"></a>convert_crlf(int)</STRONG> (Thumb, 24 bytes, Stack size 8 bytes, .\build\mbed_retarget.o(i._Z12convert_crlfi))
<BR><BR>[Stack]<UL><LI>Max Depth = 296<LI>Call Chain = convert_crlf(int) &rArr; isatty &rArr; get_fhc(int) &rArr; get_console(int) &rArr; default_console() &rArr; DirectSerial::DirectSerial(PinName, PinName, int) &rArr; serial_init &rArr; uart_init &rArr; serial_baud &rArr; serial_leuart_baud &rArr;  mbed_assert_internal (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[2e5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;isatty
</UL>
<BR>[Called By]<UL><LI><a href="#[26a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_sys_write
</UL>

<P><STRONG><a name="[2ea]"></a>singleton_lock()</STRONG> (Thumb, 16 bytes, Stack size 8 bytes, .\build\mbed_retarget.o(i._Z14singleton_lockv))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = singleton_lock() &rArr; osMutexAcquire
</UL>
<BR>[Calls]<UL><LI><a href="#[2eb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osMutexAcquire
</UL>
<BR>[Called By]<UL><LI><a href="#[2f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__cxa_guard_acquire
<LI><a href="#[6cd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SingletonPtr&lang;rtos::Mutex&rang;::get()
</UL>

<P><STRONG><a name="[2f7]"></a>unbind_from_fd(int, mbed::FileHandle*)</STRONG> (Thumb, 40 bytes, Stack size 16 bytes, .\build\mbed_retarget.o(i._Z14unbind_from_fdiPN4mbed10FileHandleE))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = unbind_from_fd(int, mbed::FileHandle*) &rArr; __aeabi_errno_addr &rArr; __user_perthread_libspace &rArr; os_kernel_is_active &rArr; osKernelGetState &rArr; svcRtxKernelGetState
</UL>
<BR>[Calls]<UL><LI><a href="#[218]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_errno_addr
</UL>
<BR>[Called By]<UL><LI><a href="#[3e5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::fdopen(mbed::FileHandle*, const char*)
</UL>

<P><STRONG><a name="[2e3]"></a>default_console()</STRONG> (Thumb, 54 bytes, Stack size 8 bytes, .\build\mbed_retarget.o(i._Z15default_consolev))
<BR><BR>[Stack]<UL><LI>Max Depth = 240<LI>Call Chain = default_console() &rArr; DirectSerial::DirectSerial(PinName, PinName, int) &rArr; serial_init &rArr; uart_init &rArr; serial_baud &rArr; serial_leuart_baud &rArr;  mbed_assert_internal (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[2fa]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_atexit
<LI><a href="#[2fb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__cxa_guard_release
<LI><a href="#[2f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__cxa_guard_acquire
<LI><a href="#[2f9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DirectSerial::DirectSerial(PinName, PinName, int)
</UL>
<BR>[Called By]<UL><LI><a href="#[2e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;get_console(int)
</UL>

<P><STRONG><a name="[30a]"></a>singleton_unlock()</STRONG> (Thumb, 12 bytes, Stack size 8 bytes, .\build\mbed_retarget.o(i._Z16singleton_unlockv))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = singleton_unlock() &rArr; osMutexRelease
</UL>
<BR>[Calls]<UL><LI><a href="#[30b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osMutexRelease
</UL>
<BR>[Called By]<UL><LI><a href="#[2fb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__cxa_guard_release
<LI><a href="#[2f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__cxa_guard_acquire
<LI><a href="#[6cd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SingletonPtr&lang;rtos::Mutex&rang;::get()
</UL>

<P><STRONG><a name="[318]"></a>handle_open_errors(int, unsigned)</STRONG> (Thumb, 26 bytes, Stack size 16 bytes, .\build\mbed_retarget.o(i._Z18handle_open_errorsij))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = handle_open_errors(int, unsigned) &rArr; __aeabi_errno_addr &rArr; __user_perthread_libspace &rArr; os_kernel_is_active &rArr; osKernelGetState &rArr; svcRtxKernelGetState
</UL>
<BR>[Calls]<UL><LI><a href="#[218]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_errno_addr
</UL>
<BR>[Called By]<UL><LI><a href="#[44c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;open
</UL>

<P><STRONG><a name="[319]"></a>reserve_filehandle()</STRONG> (Thumb, 96 bytes, Stack size 16 bytes, .\build\mbed_retarget.o(i._Z18reserve_filehandlev))
<BR><BR>[Stack]<UL><LI>Max Depth = 608 + Unknown Stack Size
<LI>Call Chain = reserve_filehandle() &rArr; SingletonPtr&lang;rtos::Mutex&rang;::operator -&rang;() &rArr; SingletonPtr&lang;rtos::Mutex&rang;::get() &rArr; rtos::Mutex::Mutex() &rArr; rtos::Mutex::constructor(const char*) &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[2e9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Mutex::unlock()
<LI><a href="#[2e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Mutex::lock(unsigned)
<LI><a href="#[31a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SingletonPtr&lang;rtos::Mutex&rang;::operator -&rang;()
<LI><a href="#[218]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_errno_addr
</UL>
<BR>[Called By]<UL><LI><a href="#[44c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;open
<LI><a href="#[362]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::bind_to_fd(mbed::FileHandle*)
</UL>

<P><STRONG><a name="[321]"></a>get_fhc(int)</STRONG> (Thumb, 44 bytes, Stack size 16 bytes, .\build\mbed_retarget.o(i._Z7get_fhci))
<BR><BR>[Stack]<UL><LI>Max Depth = 272<LI>Call Chain = get_fhc(int) &rArr; get_console(int) &rArr; default_console() &rArr; DirectSerial::DirectSerial(PinName, PinName, int) &rArr; serial_init &rArr; uart_init &rArr; serial_baud &rArr; serial_leuart_baud &rArr;  mbed_assert_internal (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[2e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;get_console(int)
</UL>
<BR>[Called By]<UL><LI><a href="#[44e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;write
<LI><a href="#[44d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lseek
<LI><a href="#[2e5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;isatty
<LI><a href="#[44b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;close
<LI><a href="#[242]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_sys_open
<LI><a href="#[265]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_sys_flen
</UL>

<P><STRONG><a name="[f]"></a>default_idle_hook()</STRONG> (Thumb, 64 bytes, Stack size 16 bytes, .\build\mbed_rtx_idle.o(i._Z17default_idle_hookv))
<BR><BR>[Stack]<UL><LI>Max Depth = 288<LI>Call Chain = default_idle_hook() &rArr; svcRtxKernelResume &rArr; KernelUnblock &rArr; OS_Tick_Enable &rArr; rtos::internal::SysTimer::SysTimer() &rArr; mbed::TimerEvent::TimerEvent__sub_object(const ticker_data_t*) &rArr; ticker_set_handler &rArr; initialize &rArr;  mbed_assert_internal (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[311]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;core_util_critical_section_exit
<LI><a href="#[30c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;core_util_critical_section_enter
<LI><a href="#[30d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxKernelSuspend
<LI><a href="#[310]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxKernelResume
<LI><a href="#[30e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sleep_manager_sleep_auto
<LI><a href="#[2cb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::internal::SysTimer::schedule_tick(unsigned)
<LI><a href="#[30f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::internal::SysTimer::update_tick()
<LI><a href="#[2cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::internal::SysTimer::cancel_tick()
</UL>
<BR>[Address Reference Count : 1]<UL><LI> mbed_rtx_idle.o(.data)
</UL>
<P><STRONG><a name="[472]"></a>compute_tick</STRONG> (Thumb, 178 bytes, Stack size 40 bytes, .\build\mbed_ticker_api.o(i.compute_tick))
<BR><BR>[Stack]<UL><LI>Max Depth = 88<LI>Call Chain = compute_tick &rArr; __aeabi_uldivmod
</UL>
<BR>[Calls]<UL><LI><a href="#[3e1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_uldivmod
</UL>
<BR>[Called By]<UL><LI><a href="#[4f2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;schedule_interrupt
</UL>

<P><STRONG><a name="[4ef]"></a>initialize</STRONG> (Thumb, 240 bytes, Stack size 48 bytes, .\build\mbed_ticker_api.o(i.initialize))
<BR><BR>[Stack]<UL><LI>Max Depth = 184 + In Cycle
<LI>Call Chain = initialize &rArr;  mbed_assert_internal (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[33a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_assert_internal
<LI><a href="#[4f1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;update_present_time
<LI><a href="#[4f2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;schedule_interrupt
<LI><a href="#[4f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_llsl
<LI><a href="#[3e1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_uldivmod
</UL>
<BR>[Called By]<UL><LI><a href="#[353]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ticker_set_handler
<LI><a href="#[3e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ticker_read_us
</UL>

<P><STRONG><a name="[4f2]"></a>schedule_interrupt</STRONG> (Thumb, 152 bytes, Stack size 40 bytes, .\build\mbed_ticker_api.o(i.schedule_interrupt))
<BR><BR>[Stack]<UL><LI>Max Depth = 136<LI>Call Chain = schedule_interrupt &rArr; update_present_time &rArr; __aeabi_uldivmod
</UL>
<BR>[Calls]<UL><LI><a href="#[649]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_ticker_match_interval_passed
<LI><a href="#[4f1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;update_present_time
<LI><a href="#[472]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;compute_tick
</UL>
<BR>[Called By]<UL><LI><a href="#[e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ticker_irq_handler
<LI><a href="#[351]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ticker_remove_event
<LI><a href="#[34f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ticker_insert_event_us
<LI><a href="#[4ef]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;initialize
</UL>

<P><STRONG><a name="[6be]"></a>set_handler</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, .\build\mbed_ticker_api.o(i.set_handler))
<BR><BR>[Called By]<UL><LI><a href="#[353]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ticker_set_handler
</UL>

<P><STRONG><a name="[4f1]"></a>update_present_time</STRONG> (Thumb, 320 bytes, Stack size 48 bytes, .\build\mbed_ticker_api.o(i.update_present_time))
<BR><BR>[Stack]<UL><LI>Max Depth = 96<LI>Call Chain = update_present_time &rArr; __aeabi_uldivmod
</UL>
<BR>[Calls]<UL><LI><a href="#[3e1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_uldivmod
</UL>
<BR>[Called By]<UL><LI><a href="#[e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ticker_irq_handler
<LI><a href="#[3e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ticker_read_us
<LI><a href="#[34f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ticker_insert_event_us
<LI><a href="#[4f2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;schedule_interrupt
<LI><a href="#[4ef]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;initialize
</UL>

<P><STRONG><a name="[2e7]"></a>dns_scan_byte(const unsigned char**)</STRONG> (Thumb, 12 bytes, Stack size 0 bytes, .\build\nsapi_dns.o(i._Z13dns_scan_bytePPKh))
<BR><BR>[Called By]<UL><LI><a href="#[312]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dns_scan_response(const unsigned char**, nsapi_addr*, unsigned)
<LI><a href="#[2e6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dns_scan_word(const unsigned char**)
</UL>

<P><STRONG><a name="[2e6]"></a>dns_scan_word(const unsigned char**)</STRONG> (Thumb, 26 bytes, Stack size 16 bytes, .\build\nsapi_dns.o(i._Z13dns_scan_wordPPKh))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = dns_scan_word(const unsigned char**)
</UL>
<BR>[Calls]<UL><LI><a href="#[2e7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dns_scan_byte(const unsigned char**)
</UL>
<BR>[Called By]<UL><LI><a href="#[312]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dns_scan_response(const unsigned char**, nsapi_addr*, unsigned)
</UL>

<P><STRONG><a name="[2fd]"></a>dns_append_byte(unsigned char**, unsigned char)</STRONG> (Thumb, 10 bytes, Stack size 0 bytes, .\build\nsapi_dns.o(i._Z15dns_append_bytePPhh))
<BR><BR>[Called By]<UL><LI><a href="#[31b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dns_append_question(unsigned char**, const char*, nsapi_version)
<LI><a href="#[2fe]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dns_append_word(unsigned char**, unsigned short)
<LI><a href="#[2fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dns_append_name(unsigned char**, const char*, unsigned char)
</UL>

<P><STRONG><a name="[2fc]"></a>dns_append_name(unsigned char**, const char*, unsigned char)</STRONG> (Thumb, 34 bytes, Stack size 16 bytes, .\build\nsapi_dns.o(i._Z15dns_append_namePPhPKch))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = dns_append_name(unsigned char**, const char*, unsigned char)
</UL>
<BR>[Calls]<UL><LI><a href="#[2fd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dns_append_byte(unsigned char**, unsigned char)
<LI><a href="#[249]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Called By]<UL><LI><a href="#[31b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dns_append_question(unsigned char**, const char*, nsapi_version)
</UL>

<P><STRONG><a name="[2fe]"></a>dns_append_word(unsigned char**, unsigned short)</STRONG> (Thumb, 26 bytes, Stack size 16 bytes, .\build\nsapi_dns.o(i._Z15dns_append_wordPPht))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = dns_append_word(unsigned char**, unsigned short)
</UL>
<BR>[Calls]<UL><LI><a href="#[2fd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dns_append_byte(unsigned char**, unsigned char)
</UL>
<BR>[Called By]<UL><LI><a href="#[31b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dns_append_question(unsigned char**, const char*, nsapi_version)
</UL>

<P><STRONG><a name="[312]"></a>dns_scan_response(const unsigned char**, nsapi_addr*, unsigned)</STRONG> (Thumb, 376 bytes, Stack size 80 bytes, .\build\nsapi_dns.o(i._Z17dns_scan_responsePPKhP10nsapi_addrj))
<BR><BR>[Stack]<UL><LI>Max Depth = 96<LI>Call Chain = dns_scan_response(const unsigned char**, nsapi_addr*, unsigned) &rArr; dns_scan_word(const unsigned char**)
</UL>
<BR>[Calls]<UL><LI><a href="#[2e6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dns_scan_word(const unsigned char**)
<LI><a href="#[2e7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dns_scan_byte(const unsigned char**)
</UL>
<BR>[Called By]<UL><LI><a href="#[303]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;nsapi_dns_query_multiple(NetworkStack*, const char*, nsapi_addr*, unsigned, nsapi_version)
</UL>

<P><STRONG><a name="[31b]"></a>dns_append_question(unsigned char**, const char*, nsapi_version)</STRONG> (Thumb, 148 bytes, Stack size 24 bytes, .\build\nsapi_dns.o(i._Z19dns_append_questionPPhPKc13nsapi_version))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = dns_append_question(unsigned char**, const char*, nsapi_version) &rArr; dns_append_word(unsigned char**, unsigned short)
</UL>
<BR>[Calls]<UL><LI><a href="#[2fe]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dns_append_word(unsigned char**, unsigned short)
<LI><a href="#[2fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dns_append_name(unsigned char**, const char*, unsigned char)
<LI><a href="#[2fd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dns_append_byte(unsigned char**, unsigned char)
<LI><a href="#[31c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;strcspn
</UL>
<BR>[Called By]<UL><LI><a href="#[303]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;nsapi_dns_query_multiple(NetworkStack*, const char*, nsapi_addr*, unsigned, nsapi_version)
</UL>

<P><STRONG><a name="[303]"></a>nsapi_dns_query_multiple(NetworkStack*, const char*, nsapi_addr*, unsigned, nsapi_version)</STRONG> (Thumb, 308 bytes, Stack size 272 bytes, .\build\nsapi_dns.o(i._Z24nsapi_dns_query_multipleP12NetworkStackPKcP10nsapi_addrj13nsapi_version))
<BR><BR>[Stack]<UL><LI>Max Depth = 856 + Unknown Stack Size
<LI>Call Chain = nsapi_dns_query_multiple(NetworkStack*, const char*, nsapi_addr*, unsigned, nsapi_version) &rArr; UDPSocket::UDPSocket() &rArr; Socket::Socket__sub_object() &rArr; rtos::Mutex::Mutex() &rArr; rtos::Mutex::constructor(const char*) &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[2f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SocketAddress::SocketAddress(nsapi_addr, unsigned short)
<LI><a href="#[13c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;UDPSocket::~UDPSocket()
<LI><a href="#[31e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;UDPSocket::UDPSocket()
<LI><a href="#[320]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;UDPSocket::recvfrom(SocketAddress*, void*, unsigned)
<LI><a href="#[31f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;UDPSocket::sendto(const SocketAddress&, const void*, unsigned)
<LI><a href="#[2f6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Socket::close()
<LI><a href="#[2ef]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Socket::open(NetworkStack*)
<LI><a href="#[2f2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Socket::set_timeout(int)
<LI><a href="#[31b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dns_append_question(unsigned char**, const char*, nsapi_version)
<LI><a href="#[312]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dns_scan_response(const unsigned char**, nsapi_addr*, unsigned)
<LI><a href="#[249]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
<LI><a href="#[31d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;strlen
<LI><a href="#[220]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;free
<LI><a href="#[21d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;malloc
</UL>
<BR>[Called By]<UL><LI><a href="#[302]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;nsapi_dns_query(NetworkStack*, const char*, SocketAddress*, nsapi_version)
</UL>

<P><STRONG><a name="[a3]"></a>mbed::ppp_output(ppp_pcb_s*, unsigned char*, unsigned, void*)</STRONG> (Thumb, 94 bytes, Stack size 40 bytes, .\build\ppp_lwip.o(i._ZN4mbed10ppp_outputEP9ppp_pcb_sPhjPv))
<BR><BR>[Stack]<UL><LI>Max Depth = 584 + Unknown Stack Size
<LI>Call Chain = mbed::ppp_output(ppp_pcb_s*, unsigned char*, unsigned, void*) &rArr; mbed::poll(mbed::pollfh*, unsigned, int) &rArr; mbed::Timer::~Timer() &rArr; sleep_manager_unlock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[363]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::poll(mbed::pollfh*, unsigned, int)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> ppp_lwip.o(i.ppp_lwip_if_init)
</UL>
<P><STRONG><a name="[a2]"></a>mbed::ppp_link_status(ppp_pcb_s*, int, void*)</STRONG> (Thumb, 170 bytes, Stack size 24 bytes, .\build\ppp_lwip.o(i._ZN4mbed15ppp_link_statusEP9ppp_pcb_siPv))
<BR><BR>[Stack]<UL><LI>Max Depth = 584 + Unknown Stack Size
<LI>Call Chain = mbed::ppp_link_status(ppp_pcb_s*, int, void*) &rArr; mbed::Callback&lang;void(nsapi_event, int)&rang;::operator ()(nsapi_event, int) const &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[37a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void(nsapi_event, int)&rang;::operator bool() const
<LI><a href="#[37b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void(nsapi_event, int)&rang;::operator ()(nsapi_event, int) const
<LI><a href="#[379]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dns_getserver
<LI><a href="#[37c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_sem_signal
</UL>
<BR>[Address Reference Count : 1]<UL><LI> ppp_lwip.o(i.ppp_lwip_if_init)
</UL>
<P><STRONG><a name="[3a5]"></a>mbed::handle_modem_hangup()</STRONG> (Thumb, 24 bytes, Stack size 8 bytes, .\build\ppp_lwip.o(i._ZN4mbed19handle_modem_hangupEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 720 + Unknown Stack Size
<LI>Call Chain = mbed::handle_modem_hangup() &rArr; ppp_close &rArr; lcp_close &rArr; fsm_close &rArr; terminate_layer &rArr; fsm_sdata &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[3a6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_close
</UL>
<BR>[Called By]<UL><LI><a href="#[55]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::ppp_input()
</UL>

<P><STRONG><a name="[3a8]"></a>mbed::prepare_event_queue()</STRONG> (Thumb, 246 bytes, Stack size 56 bytes, .\build\ppp_lwip.o(i._ZN4mbed19prepare_event_queueEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 696 + Unknown Stack Size
<LI>Call Chain = mbed::prepare_event_queue() &rArr; events::EventQueue::EventQueue(unsigned, unsigned char*) &rArr; equeue_create &rArr; equeue_create_inplace &rArr; equeue_tick &rArr; equeue_tick_init() &rArr; mbed::Ticker::attach_us(mbed::Callback&lang;void()&rang;, unsigned long long) &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[367]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;operator new(unsigned)
<LI><a href="#[37e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;operator delete (void*)
<LI><a href="#[53]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void()&rang;::~Callback()
<LI><a href="#[282]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void()&rang;::Callback(void(*)())
<LI><a href="#[361]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Mutex::Mutex()
<LI><a href="#[3ac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;T3()&rang; mbed::callback&lang;events::EventQueue, events::EventQueue, void&rang;(T2*, T3(T1::*)())
<LI><a href="#[3ae]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;events::EventQueue::~EventQueue()
<LI><a href="#[3a9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;events::EventQueue::EventQueue(unsigned, unsigned char*)
<LI><a href="#[3aa]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Semaphore::Semaphore(int)
<LI><a href="#[3ad]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Thread::start(mbed::Callback&lang;void()&rang;)
<LI><a href="#[3ab]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Thread::constructor(osPriority_t, unsigned, unsigned char*, const char*)
</UL>
<BR>[Called By]<UL><LI><a href="#[572]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ppp_lwip_if_init
</UL>

<P><STRONG><a name="[55]"></a>mbed::ppp_input()</STRONG> (Thumb, 118 bytes, Stack size 32 bytes, .\build\ppp_lwip.o(i._ZN4mbed9ppp_inputEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 752 + Unknown Stack Size
<LI>Call Chain = mbed::ppp_input() &rArr; mbed::handle_modem_hangup() &rArr; ppp_close &rArr; lcp_close &rArr; fsm_close &rArr; terminate_layer &rArr; fsm_sdata &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; do_memp_free_pool &rArr; sys_arch_unprotect &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[363]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::poll(mbed::pollfh*, unsigned, int)
<LI><a href="#[416]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pppos_input
<LI><a href="#[3a5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::handle_modem_hangup()
</UL>
<BR>[Address Reference Count : 1]<UL><LI> ppp_lwip.o(i._ZN4mbed9stream_cbEv)
</UL>
<P><STRONG><a name="[a1]"></a>mbed::stream_cb()</STRONG> (Thumb, 74 bytes, Stack size 32 bytes, .\build\ppp_lwip.o(i._ZN4mbed9stream_cbEv))
<BR><BR>[Stack]<UL><LI>Max Depth = 656 + Unknown Stack Size
<LI>Call Chain = mbed::stream_cb() &rArr; int events::EventQueue::call&lang;mbed::Callback&lang;void()&rang;&rang;(T1) &rArr; equeue_post &rArr; equeue_tick &rArr; equeue_tick_init() &rArr; mbed::Ticker::attach_us(mbed::Callback&lang;void()&rang;, unsigned long long) &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[53]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void()&rang;::~Callback()
<LI><a href="#[40e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;int events::EventQueue::call&lang;mbed::Callback&lang;void()&rang;&rang;(T1)
<LI><a href="#[417]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;T1()&rang; mbed::callback&lang;void&rang;(T1(*)())
</UL>
<BR>[Address Reference Count : 1]<UL><LI> ppp_lwip.o(i.ppp_lwip_connect)
</UL>
<P><STRONG><a name="[1d6]"></a>__sti___12_ppp_lwip_cpp_b3a13e7c</STRONG> (Thumb, 64 bytes, Stack size 16 bytes, .\build\ppp_lwip.o(i.__sti___12_ppp_lwip_cpp_b3a13e7c))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = __sti___12_ppp_lwip_cpp_b3a13e7c
</UL>
<BR>[Calls]<UL><LI><a href="#[2fa]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_atexit
</UL>
<BR>[Address Reference Count : 1]<UL><LI> ppp_lwip.o(.init_array)
</UL>
<P><STRONG><a name="[641]"></a>rol</STRONG> (Thumb, 50 bytes, Stack size 32 bytes, .\build\randlib.o(i.rol))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = rol
</UL>
<BR>[Calls]<UL><LI><a href="#[644]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_llsr
<LI><a href="#[4f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_llsl
</UL>
<BR>[Called By]<UL><LI><a href="#[640]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;randLIB_get_64bit
</UL>

<P><STRONG><a name="[63f]"></a>splitmix64</STRONG> (Thumb, 94 bytes, Stack size 20 bytes, .\build\randlib.o(i.splitmix64))
<BR><BR>[Stack]<UL><LI>Max Depth = 20<LI>Call Chain = splitmix64
</UL>
<BR>[Called By]<UL><LI><a href="#[63e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;randLIB_add_seed
</UL>

<P><STRONG><a name="[2cf]"></a>RTC_IntClear</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, .\build\rtc_api.o(i.RTC_IntClear))
<BR><BR>[Called By]<UL><LI><a href="#[53e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtc_get_full
<LI><a href="#[38]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RTC_IRQHandler
</UL>

<P><STRONG><a name="[646]"></a>RTC_IntEnable</STRONG> (Thumb, 12 bytes, Stack size 0 bytes, .\build\rtc_api.o(i.RTC_IntEnable))
<BR><BR>[Called By]<UL><LI><a href="#[53c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtc_init_real
<LI><a href="#[53a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtc_enable_comp0
</UL>

<P><STRONG><a name="[29e]"></a>EventFlagsCheck</STRONG> (Thumb, 86 bytes, Stack size 24 bytes, .\build\rtx_evflags.o(i.EventFlagsCheck))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = EventFlagsCheck
</UL>
<BR>[Calls]<UL><LI><a href="#[2a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__asm___13_rtx_evflags_c_736f7bde__atomic_chk32_any
<LI><a href="#[29f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__asm___13_rtx_evflags_c_736f7bde__atomic_chk32_all
</UL>
<BR>[Called By]<UL><LI><a href="#[511]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;isrRtxEventFlagsWait
<LI><a href="#[86]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxEventFlagsWait
<LI><a href="#[85]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxEventFlagsSet
<LI><a href="#[b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxEventFlagsPostProcess
</UL>

<P><STRONG><a name="[2a1]"></a>EventFlagsClear</STRONG> (Thumb, 22 bytes, Stack size 16 bytes, .\build\rtx_evflags.o(i.EventFlagsClear))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = EventFlagsClear
</UL>
<BR>[Calls]<UL><LI><a href="#[2a2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__asm___13_rtx_evflags_c_736f7bde__atomic_clr32
</UL>
<BR>[Called By]<UL><LI><a href="#[82]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxEventFlagsClear
</UL>

<P><STRONG><a name="[2a3]"></a>EventFlagsSet</STRONG> (Thumb, 22 bytes, Stack size 16 bytes, .\build\rtx_evflags.o(i.EventFlagsSet))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = EventFlagsSet
</UL>
<BR>[Calls]<UL><LI><a href="#[2a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__asm___13_rtx_evflags_c_736f7bde__atomic_set32
</UL>
<BR>[Called By]<UL><LI><a href="#[41b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osEventFlagsSet
<LI><a href="#[85]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxEventFlagsSet
</UL>

<P><STRONG><a name="[5b5]"></a>__get_BASEPRI</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, .\build\rtx_evflags.o(i.__get_BASEPRI))
<BR><BR>[Called By]<UL><LI><a href="#[41d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osEventFlagsWait
<LI><a href="#[41b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osEventFlagsSet
<LI><a href="#[419]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osEventFlagsNew
<LI><a href="#[421]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osEventFlagsDelete
<LI><a href="#[5b1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osEventFlagsClear
</UL>

<P><STRONG><a name="[5b3]"></a>__get_IPSR</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, .\build\rtx_evflags.o(i.__get_IPSR))
<BR><BR>[Called By]<UL><LI><a href="#[41d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osEventFlagsWait
<LI><a href="#[41b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osEventFlagsSet
<LI><a href="#[419]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osEventFlagsNew
<LI><a href="#[421]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osEventFlagsDelete
<LI><a href="#[5b1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osEventFlagsClear
</UL>

<P><STRONG><a name="[5b4]"></a>__get_PRIMASK</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, .\build\rtx_evflags.o(i.__get_PRIMASK))
<BR><BR>[Called By]<UL><LI><a href="#[41d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osEventFlagsWait
<LI><a href="#[41b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osEventFlagsSet
<LI><a href="#[419]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osEventFlagsNew
<LI><a href="#[421]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osEventFlagsDelete
<LI><a href="#[5b1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osEventFlagsClear
</UL>

<P><STRONG><a name="[511]"></a>isrRtxEventFlagsWait</STRONG> (Thumb, 118 bytes, Stack size 32 bytes, .\build\rtx_evflags.o(i.isrRtxEventFlagsWait))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = isrRtxEventFlagsWait &rArr; EventFlagsCheck
</UL>
<BR>[Calls]<UL><LI><a href="#[29e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EventFlagsCheck
<LI><a href="#[514]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxEventFlagsWaitNotCompleted
<LI><a href="#[513]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxEventFlagsWaitCompleted
<LI><a href="#[512]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxEventFlagsError
</UL>
<BR>[Called By]<UL><LI><a href="#[41d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osEventFlagsWait
</UL>

<P><STRONG><a name="[2b0]"></a>KernelBlock</STRONG> (Thumb, 60 bytes, Stack size 8 bytes, .\build\rtx_kernel.o(i.KernelBlock))
<BR><BR>[Stack]<UL><LI>Max Depth = 184<LI>Call Chain = KernelBlock &rArr; OS_Tick_Disable &rArr; rtos::internal::SysTimer::cancel_tick() &rArr; mbed::TimerEvent::remove() &rArr; ticker_remove_event &rArr; schedule_interrupt &rArr; update_present_time &rArr; __aeabi_uldivmod
</UL>
<BR>[Calls]<UL><LI><a href="#[2b1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OS_Tick_Disable
</UL>
<BR>[Called By]<UL><LI><a href="#[30d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxKernelSuspend
</UL>

<P><STRONG><a name="[2b2]"></a>KernelUnblock</STRONG> (Thumb, 52 bytes, Stack size 8 bytes, .\build\rtx_kernel.o(i.KernelUnblock))
<BR><BR>[Stack]<UL><LI>Max Depth = 248<LI>Call Chain = KernelUnblock &rArr; OS_Tick_Enable &rArr; rtos::internal::SysTimer::SysTimer() &rArr; mbed::TimerEvent::TimerEvent__sub_object(const ticker_data_t*) &rArr; ticker_set_handler &rArr; initialize &rArr;  mbed_assert_internal (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[2b3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OS_Tick_Enable
</UL>
<BR>[Called By]<UL><LI><a href="#[310]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxKernelResume
</UL>

<P><STRONG><a name="[5be]"></a>__get_BASEPRI</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, .\build\rtx_kernel.o(i.__get_BASEPRI))
<BR><BR>[Called By]<UL><LI><a href="#[5c5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osKernelRestoreLock
<LI><a href="#[5c3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osKernelLock
<LI><a href="#[591]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osKernelStart
<LI><a href="#[44a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osKernelInitialize
<LI><a href="#[5bb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osKernelGetState
</UL>

<P><STRONG><a name="[5c0]"></a>__get_CONTROL</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, .\build\rtx_kernel.o(i.__get_CONTROL))
<BR><BR>[Called By]<UL><LI><a href="#[591]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osKernelStart
<LI><a href="#[44a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osKernelInitialize
<LI><a href="#[5bb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osKernelGetState
</UL>

<P><STRONG><a name="[5bc]"></a>__get_IPSR</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, .\build\rtx_kernel.o(i.__get_IPSR))
<BR><BR>[Called By]<UL><LI><a href="#[5c5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osKernelRestoreLock
<LI><a href="#[5c3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osKernelLock
<LI><a href="#[591]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osKernelStart
<LI><a href="#[44a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osKernelInitialize
<LI><a href="#[5bb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osKernelGetState
</UL>

<P><STRONG><a name="[5bd]"></a>__get_PRIMASK</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, .\build\rtx_kernel.o(i.__get_PRIMASK))
<BR><BR>[Called By]<UL><LI><a href="#[5c5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osKernelRestoreLock
<LI><a href="#[5c3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osKernelLock
<LI><a href="#[591]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osKernelStart
<LI><a href="#[44a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osKernelInitialize
<LI><a href="#[5bb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osKernelGetState
</UL>

<P><STRONG><a name="[441]"></a>os_kernel_is_active</STRONG> (Thumb, 32 bytes, Stack size 8 bytes, .\build\rtx_lib.o(i.os_kernel_is_active))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = os_kernel_is_active &rArr; osKernelGetState &rArr; svcRtxKernelGetState
</UL>
<BR>[Calls]<UL><LI><a href="#[5bb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osKernelGetState
</UL>
<BR>[Called By]<UL><LI><a href="#[1db]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_mutex_release
<LI><a href="#[1da]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_mutex_acquire
<LI><a href="#[219]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__user_perthread_libspace
</UL>

<P><STRONG><a name="[2c5]"></a>MessageQueueGet</STRONG> (Thumb, 54 bytes, Stack size 24 bytes, .\build\rtx_msgqueue.o(i.MessageQueueGet))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = MessageQueueGet
</UL>
<BR>[Calls]<UL><LI><a href="#[2c6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__asm___14_rtx_msgqueue_c_3fd3b50e__atomic_dec32_nz
<LI><a href="#[2c7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__asm___14_rtx_msgqueue_c_3fd3b50e__atomic_wr8
</UL>
<BR>[Called By]<UL><LI><a href="#[8c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxMessageQueueGet
<LI><a href="#[515]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;isrRtxMessageQueueGet
</UL>

<P><STRONG><a name="[2c8]"></a>MessageQueuePut</STRONG> (Thumb, 76 bytes, Stack size 24 bytes, .\build\rtx_msgqueue.o(i.MessageQueuePut))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = MessageQueuePut
</UL>
<BR>[Calls]<UL><LI><a href="#[2c9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__asm___14_rtx_msgqueue_c_3fd3b50e__atomic_inc32
</UL>
<BR>[Called By]<UL><LI><a href="#[8e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxMessageQueuePut
<LI><a href="#[8c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxMessageQueueGet
<LI><a href="#[b7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxMessageQueuePostProcess
</UL>

<P><STRONG><a name="[5eb]"></a>MessageQueueRemove</STRONG> (Thumb, 34 bytes, Stack size 0 bytes, .\build\rtx_msgqueue.o(i.MessageQueueRemove))
<BR><BR>[Called By]<UL><LI><a href="#[8c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxMessageQueueGet
<LI><a href="#[b7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxMessageQueuePostProcess
</UL>

<P><STRONG><a name="[5cc]"></a>__get_BASEPRI</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, .\build\rtx_msgqueue.o(i.__get_BASEPRI))
<BR><BR>[Called By]<UL><LI><a href="#[5cf]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osMessageQueuePut
<LI><a href="#[5cd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osMessageQueueNew
<LI><a href="#[5c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osMessageQueueGet
</UL>

<P><STRONG><a name="[5ca]"></a>__get_IPSR</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, .\build\rtx_msgqueue.o(i.__get_IPSR))
<BR><BR>[Called By]<UL><LI><a href="#[5cf]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osMessageQueuePut
<LI><a href="#[5cd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osMessageQueueNew
<LI><a href="#[5c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osMessageQueueGet
</UL>

<P><STRONG><a name="[5cb]"></a>__get_PRIMASK</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, .\build\rtx_msgqueue.o(i.__get_PRIMASK))
<BR><BR>[Called By]<UL><LI><a href="#[5cf]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osMessageQueuePut
<LI><a href="#[5cd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osMessageQueueNew
<LI><a href="#[5c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osMessageQueueGet
</UL>

<P><STRONG><a name="[515]"></a>isrRtxMessageQueueGet</STRONG> (Thumb, 144 bytes, Stack size 32 bytes, .\build\rtx_msgqueue.o(i.isrRtxMessageQueueGet))
<BR><BR>[Stack]<UL><LI>Max Depth = 64<LI>Call Chain = isrRtxMessageQueueGet &rArr; osRtxPostProcess &rArr; isr_queue_put
</UL>
<BR>[Calls]<UL><LI><a href="#[518]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxPostProcess
<LI><a href="#[2c5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MessageQueueGet
<LI><a href="#[517]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxMessageQueueRetrieved
<LI><a href="#[519]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxMessageQueueNotRetrieved
<LI><a href="#[516]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxMessageQueueError
<LI><a href="#[249]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Called By]<UL><LI><a href="#[5c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osMessageQueueGet
</UL>

<P><STRONG><a name="[51a]"></a>isrRtxMessageQueuePut</STRONG> (Thumb, 158 bytes, Stack size 32 bytes, .\build\rtx_msgqueue.o(i.isrRtxMessageQueuePut))
<BR><BR>[Stack]<UL><LI>Max Depth = 64<LI>Call Chain = isrRtxMessageQueuePut &rArr; osRtxPostProcess &rArr; isr_queue_put
</UL>
<BR>[Calls]<UL><LI><a href="#[518]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxPostProcess
<LI><a href="#[51b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxMemoryPoolAlloc
<LI><a href="#[51c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxMessageQueueNotInserted
<LI><a href="#[51d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxMessageQueueInsertPending
<LI><a href="#[516]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EvrRtxMessageQueueError
<LI><a href="#[249]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Called By]<UL><LI><a href="#[5cf]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osMessageQueuePut
</UL>

<P><STRONG><a name="[5d4]"></a>__get_BASEPRI</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, .\build\rtx_mutex.o(i.__get_BASEPRI))
<BR><BR>[Called By]<UL><LI><a href="#[30b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osMutexRelease
<LI><a href="#[423]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osMutexNew
<LI><a href="#[2eb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osMutexAcquire
<LI><a href="#[424]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osMutexDelete
</UL>

<P><STRONG><a name="[5d2]"></a>__get_IPSR</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, .\build\rtx_mutex.o(i.__get_IPSR))
<BR><BR>[Called By]<UL><LI><a href="#[30b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osMutexRelease
<LI><a href="#[423]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osMutexNew
<LI><a href="#[2eb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osMutexAcquire
<LI><a href="#[424]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osMutexDelete
</UL>

<P><STRONG><a name="[5d3]"></a>__get_PRIMASK</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, .\build\rtx_mutex.o(i.__get_PRIMASK))
<BR><BR>[Called By]<UL><LI><a href="#[30b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osMutexRelease
<LI><a href="#[423]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osMutexNew
<LI><a href="#[2eb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osMutexAcquire
<LI><a href="#[424]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osMutexDelete
</UL>

<P><STRONG><a name="[2d0]"></a>SemaphoreTokenDecrement</STRONG> (Thumb, 24 bytes, Stack size 16 bytes, .\build\rtx_semaphore.o(i.SemaphoreTokenDecrement))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = SemaphoreTokenDecrement
</UL>
<BR>[Calls]<UL><LI><a href="#[2d1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__asm___15_rtx_semaphore_c_eca73427__atomic_dec16_nz
</UL>
<BR>[Called By]<UL><LI><a href="#[42f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osSemaphoreAcquire
<LI><a href="#[94]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxSemaphoreAcquire
<LI><a href="#[b8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxSemaphorePostProcess
</UL>

<P><STRONG><a name="[2d2]"></a>SemaphoreTokenIncrement</STRONG> (Thumb, 30 bytes, Stack size 16 bytes, .\build\rtx_semaphore.o(i.SemaphoreTokenIncrement))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = SemaphoreTokenIncrement
</UL>
<BR>[Calls]<UL><LI><a href="#[2d3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__asm___15_rtx_semaphore_c_eca73427__atomic_inc16_lt
</UL>
<BR>[Called By]<UL><LI><a href="#[431]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osSemaphoreRelease
<LI><a href="#[98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxSemaphoreRelease
</UL>

<P><STRONG><a name="[614]"></a>__get_BASEPRI</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, .\build\rtx_semaphore.o(i.__get_BASEPRI))
<BR><BR>[Called By]<UL><LI><a href="#[42e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osSemaphoreNew
<LI><a href="#[430]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osSemaphoreGetCount
<LI><a href="#[42f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osSemaphoreAcquire
<LI><a href="#[431]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osSemaphoreRelease
<LI><a href="#[432]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osSemaphoreDelete
</UL>

<P><STRONG><a name="[612]"></a>__get_IPSR</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, .\build\rtx_semaphore.o(i.__get_IPSR))
<BR><BR>[Called By]<UL><LI><a href="#[42e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osSemaphoreNew
<LI><a href="#[430]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osSemaphoreGetCount
<LI><a href="#[42f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osSemaphoreAcquire
<LI><a href="#[431]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osSemaphoreRelease
<LI><a href="#[432]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osSemaphoreDelete
</UL>

<P><STRONG><a name="[613]"></a>__get_PRIMASK</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, .\build\rtx_semaphore.o(i.__get_PRIMASK))
<BR><BR>[Called By]<UL><LI><a href="#[42e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osSemaphoreNew
<LI><a href="#[430]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osSemaphoreGetCount
<LI><a href="#[42f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osSemaphoreAcquire
<LI><a href="#[431]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osSemaphoreRelease
<LI><a href="#[432]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osSemaphoreDelete
</UL>

<P><STRONG><a name="[51e]"></a>isr_queue_get</STRONG> (Thumb, 44 bytes, Stack size 16 bytes, .\build\rtx_system.o(i.isr_queue_get))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = isr_queue_get
</UL>
<BR>[Calls]<UL><LI><a href="#[51f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__asm___12_rtx_system_c_024f2f18__atomic_dec16_nz
<LI><a href="#[520]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__asm___12_rtx_system_c_024f2f18__atomic_inc16_lim
</UL>
<BR>[Called By]<UL><LI><a href="#[215]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxPendSV_Handler
</UL>

<P><STRONG><a name="[521]"></a>isr_queue_put</STRONG> (Thumb, 56 bytes, Stack size 24 bytes, .\build\rtx_system.o(i.isr_queue_put))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = isr_queue_put
</UL>
<BR>[Calls]<UL><LI><a href="#[520]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__asm___12_rtx_system_c_024f2f18__atomic_inc16_lim
<LI><a href="#[522]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__asm___12_rtx_system_c_024f2f18__atomic_inc16_lt
</UL>
<BR>[Called By]<UL><LI><a href="#[518]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxPostProcess
</UL>

<P><STRONG><a name="[2d8]"></a>ThreadFlagsCheck</STRONG> (Thumb, 86 bytes, Stack size 24 bytes, .\build\rtx_thread.o(i.ThreadFlagsCheck))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = ThreadFlagsCheck
</UL>
<BR>[Calls]<UL><LI><a href="#[2da]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__asm___12_rtx_thread_c_add96be5__atomic_chk32_any
<LI><a href="#[2d9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__asm___12_rtx_thread_c_add96be5__atomic_chk32_all
</UL>
<BR>[Called By]<UL><LI><a href="#[ba]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadPostProcess
</UL>

<P><STRONG><a name="[61f]"></a>__get_BASEPRI</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, .\build\rtx_thread.o(i.__get_BASEPRI))
<BR><BR>[Called By]<UL><LI><a href="#[2a6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osThreadGetId
<LI><a href="#[5d9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osThreadGetName
<LI><a href="#[427]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osThreadYield
<LI><a href="#[428]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osThreadTerminate
<LI><a href="#[61b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osThreadContextNew
</UL>

<P><STRONG><a name="[61d]"></a>__get_IPSR</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, .\build\rtx_thread.o(i.__get_IPSR))
<BR><BR>[Called By]<UL><LI><a href="#[2a6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osThreadGetId
<LI><a href="#[5d9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osThreadGetName
<LI><a href="#[427]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osThreadYield
<LI><a href="#[428]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osThreadTerminate
<LI><a href="#[61b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osThreadContextNew
</UL>

<P><STRONG><a name="[61e]"></a>__get_PRIMASK</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, .\build\rtx_thread.o(i.__get_PRIMASK))
<BR><BR>[Called By]<UL><LI><a href="#[2a6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osThreadGetId
<LI><a href="#[5d9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osThreadGetName
<LI><a href="#[427]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osThreadYield
<LI><a href="#[428]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osThreadTerminate
<LI><a href="#[61b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osThreadContextNew
</UL>

<P><STRONG><a name="[600]"></a>osRtxKernelGetState</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, .\build\rtx_thread.o(i.osRtxKernelGetState))
<BR><BR>[Called By]<UL><LI><a href="#[60a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadWaitEnter
<LI><a href="#[5f2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadDispatch
<LI><a href="#[9e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxThreadYield
<LI><a href="#[9d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxThreadTerminate
<LI><a href="#[9a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxThreadExit
</UL>

<P><STRONG><a name="[604]"></a>osRtxThreadFree</STRONG> (Thumb, 92 bytes, Stack size 8 bytes, .\build\rtx_thread.o(i.osRtxThreadFree))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = osRtxThreadFree &rArr; osRtxMemoryFree
</UL>
<BR>[Calls]<UL><LI><a href="#[5e6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxMemoryPoolFree
<LI><a href="#[5df]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxMemoryFree
</UL>
<BR>[Called By]<UL><LI><a href="#[9d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxThreadTerminate
<LI><a href="#[9a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxThreadExit
</UL>

<P><STRONG><a name="[601]"></a>osRtxThreadGetRunning</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, .\build\rtx_thread.o(i.osRtxThreadGetRunning))
<BR><BR>[Called By]<UL><LI><a href="#[60a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadWaitEnter
<LI><a href="#[5f2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadDispatch
<LI><a href="#[608]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxThreadStackCheck
<LI><a href="#[9e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxThreadYield
<LI><a href="#[9b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxThreadGetId
<LI><a href="#[9a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxThreadExit
</UL>

<P><STRONG><a name="[68b]"></a>osRtxThreadSetRunning</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, .\build\rtx_thread.o(i.osRtxThreadSetRunning))
<BR><BR>[Called By]<UL><LI><a href="#[9d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxThreadTerminate
<LI><a href="#[9a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;svcRtxThreadExit
</UL>

<P><STRONG><a name="[610]"></a>TimerInsert</STRONG> (Thumb, 58 bytes, Stack size 12 bytes, .\build\rtx_timer.o(i.TimerInsert))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = TimerInsert
</UL>
<BR>[Called By]<UL><LI><a href="#[93]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxTimerTick
</UL>

<P><STRONG><a name="[60f]"></a>TimerUnlink</STRONG> (Thumb, 18 bytes, Stack size 0 bytes, .\build\rtx_timer.o(i.TimerUnlink))
<BR><BR>[Called By]<UL><LI><a href="#[93]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;osRtxTimerTick
</UL>

<P><STRONG><a name="[534]"></a>LEUART_IntClear</STRONG> (Thumb, 4 bytes, Stack size 0 bytes, .\build\serial_api.o(i.LEUART_IntClear))
<BR><BR>[Called By]<UL><LI><a href="#[65a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_tx_abort_asynch_intern
<LI><a href="#[659]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_rx_abort_asynch_intern
<LI><a href="#[b2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;leuart1_irq
<LI><a href="#[b1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;leuart0_irq
<LI><a href="#[65b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_rx_irq_handler_asynch
</UL>

<P><STRONG><a name="[667]"></a>LEUART_IntDisable</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, .\build\serial_api.o(i.LEUART_IntDisable))
<BR><BR>[Called By]<UL><LI><a href="#[65a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_tx_abort_asynch_intern
<LI><a href="#[659]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_rx_abort_asynch_intern
<LI><a href="#[65d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_tx_irq_handler_asynch
</UL>

<P><STRONG><a name="[66d]"></a>LEUART_IntEnable</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, .\build\serial_api.o(i.LEUART_IntEnable))
<BR><BR>[Called By]<UL><LI><a href="#[65d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_tx_irq_handler_asynch
</UL>

<P><STRONG><a name="[532]"></a>LEUART_IntGetEnabled</STRONG> (Thumb, 10 bytes, Stack size 0 bytes, .\build\serial_api.o(i.LEUART_IntGetEnabled))
<BR><BR>[Called By]<UL><LI><a href="#[b2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;leuart1_irq
<LI><a href="#[b1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;leuart0_irq
<LI><a href="#[65b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_rx_irq_handler_asynch
<LI><a href="#[33b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_irq_handler_asynch
</UL>

<P><STRONG><a name="[66b]"></a>LEUART_RxDataGet</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, .\build\serial_api.o(i.LEUART_RxDataGet))
<BR><BR>[Called By]<UL><LI><a href="#[65b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_rx_irq_handler_asynch
</UL>

<P><STRONG><a name="[65c]"></a>LEUART_StatusGet</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, .\build\serial_api.o(i.LEUART_StatusGet))
<BR><BR>[Called By]<UL><LI><a href="#[65d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_tx_irq_handler_asynch
<LI><a href="#[65b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_rx_irq_handler_asynch
<LI><a href="#[33b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_irq_handler_asynch
</UL>

<P><STRONG><a name="[669]"></a>USART_IntClear</STRONG> (Thumb, 4 bytes, Stack size 0 bytes, .\build\serial_api.o(i.USART_IntClear))
<BR><BR>[Called By]<UL><LI><a href="#[b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;usart2_tx_irq
<LI><a href="#[ae]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;usart1_tx_irq
<LI><a href="#[ac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;usart0_tx_irq
<LI><a href="#[aa]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;uart1_tx_irq
<LI><a href="#[a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;uart0_tx_irq
<LI><a href="#[65a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_tx_abort_asynch_intern
<LI><a href="#[659]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_rx_abort_asynch_intern
<LI><a href="#[65b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_rx_irq_handler_asynch
</UL>

<P><STRONG><a name="[668]"></a>USART_IntDisable</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, .\build\serial_api.o(i.USART_IntDisable))
<BR><BR>[Called By]<UL><LI><a href="#[65a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_tx_abort_asynch_intern
<LI><a href="#[659]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_rx_abort_asynch_intern
<LI><a href="#[65d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_tx_irq_handler_asynch
</UL>

<P><STRONG><a name="[66e]"></a>USART_IntEnable</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, .\build\serial_api.o(i.USART_IntEnable))
<BR><BR>[Called By]<UL><LI><a href="#[65d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_tx_irq_handler_asynch
</UL>

<P><STRONG><a name="[658]"></a>USART_IntGetEnabled</STRONG> (Thumb, 10 bytes, Stack size 0 bytes, .\build\serial_api.o(i.USART_IntGetEnabled))
<BR><BR>[Called By]<UL><LI><a href="#[65b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_rx_irq_handler_asynch
<LI><a href="#[33b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_irq_handler_asynch
</UL>

<P><STRONG><a name="[66c]"></a>USART_RxDataGet</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, .\build\serial_api.o(i.USART_RxDataGet))
<BR><BR>[Called By]<UL><LI><a href="#[65b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_rx_irq_handler_asynch
</UL>

<P><STRONG><a name="[65e]"></a>USART_StatusGet</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, .\build\serial_api.o(i.USART_StatusGet))
<BR><BR>[Called By]<UL><LI><a href="#[65d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_tx_irq_handler_asynch
<LI><a href="#[65b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_rx_irq_handler_asynch
<LI><a href="#[33b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_irq_handler_asynch
</UL>

<P><STRONG><a name="[65f]"></a>__NVIC_ClearPendingIRQ</STRONG> (Thumb, 22 bytes, Stack size 0 bytes, .\build\serial_api.o(i.__NVIC_ClearPendingIRQ))
<BR><BR>[Called By]<UL><LI><a href="#[342]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_irq_set
</UL>

<P><STRONG><a name="[662]"></a>__NVIC_DisableIRQ</STRONG> (Thumb, 54 bytes, Stack size 0 bytes, .\build\serial_api.o(i.__NVIC_DisableIRQ))
<BR><BR>[Called By]<UL><LI><a href="#[342]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_irq_set
</UL>

<P><STRONG><a name="[660]"></a>__NVIC_EnableIRQ</STRONG> (Thumb, 26 bytes, Stack size 0 bytes, .\build\serial_api.o(i.__NVIC_EnableIRQ))
<BR><BR>[Called By]<UL><LI><a href="#[342]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_irq_set
</UL>

<P><STRONG><a name="[661]"></a>__NVIC_SetPriority</STRONG> (Thumb, 32 bytes, Stack size 8 bytes, .\build\serial_api.o(i.__NVIC_SetPriority))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = __NVIC_SetPriority
</UL>
<BR>[Called By]<UL><LI><a href="#[654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_preinit
<LI><a href="#[342]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_irq_set
</UL>

<P><STRONG><a name="[663]"></a>__NVIC_SetVector</STRONG> (Thumb, 14 bytes, Stack size 0 bytes, .\build\serial_api.o(i.__NVIC_SetVector))
<BR><BR>[Called By]<UL><LI><a href="#[654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_preinit
</UL>

<P><STRONG><a name="[b1]"></a>leuart0_irq</STRONG> (Thumb, 52 bytes, Stack size 8 bytes, .\build\serial_api.o(i.leuart0_irq))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = leuart0_irq &rArr; uart_irq
</UL>
<BR>[Calls]<UL><LI><a href="#[533]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;uart_irq
<LI><a href="#[532]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LEUART_IntGetEnabled
<LI><a href="#[534]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LEUART_IntClear
</UL>
<BR>[Address Reference Count : 1]<UL><LI> serial_api.o(i.serial_preinit)
</UL>
<P><STRONG><a name="[b2]"></a>leuart1_irq</STRONG> (Thumb, 52 bytes, Stack size 8 bytes, .\build\serial_api.o(i.leuart1_irq))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = leuart1_irq &rArr; uart_irq
</UL>
<BR>[Calls]<UL><LI><a href="#[533]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;uart_irq
<LI><a href="#[532]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LEUART_IntGetEnabled
<LI><a href="#[534]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LEUART_IntClear
</UL>
<BR>[Address Reference Count : 1]<UL><LI> serial_api.o(i.serial_preinit)
</UL>
<P><STRONG><a name="[64b]"></a>serial_enable</STRONG> (Thumb, 80 bytes, Stack size 16 bytes, .\build\serial_api.o(i.serial_enable))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = serial_enable &rArr; LEUART_Enable
</UL>
<BR>[Calls]<UL><LI><a href="#[2b8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LEUART_Enable
<LI><a href="#[64c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;USART_Enable
<LI><a href="#[64d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_get_index
</UL>
<BR>[Called By]<UL><LI><a href="#[327]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_init
</UL>

<P><STRONG><a name="[64e]"></a>serial_enable_pins</STRONG> (Thumb, 96 bytes, Stack size 16 bytes, .\build\serial_api.o(i.serial_enable_pins))
<BR><BR>[Stack]<UL><LI>Max Depth = 16 + In Cycle
<LI>Call Chain = serial_enable_pins &rArr;  pin_mode (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[4cb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pin_mode
</UL>
<BR>[Called By]<UL><LI><a href="#[327]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_init
</UL>

<P><STRONG><a name="[655]"></a>serial_get_clock</STRONG> (Thumb, 86 bytes, Stack size 0 bytes, .\build\serial_api.o(i.serial_get_clock))
<BR><BR>[Called By]<UL><LI><a href="#[327]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_init
<LI><a href="#[64a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_leuart_baud
</UL>

<P><STRONG><a name="[64d]"></a>serial_get_index</STRONG> (Thumb, 12 bytes, Stack size 8 bytes, .\build\serial_api.o(i.serial_get_index))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = serial_get_index
</UL>
<BR>[Calls]<UL><LI><a href="#[64f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_pointer_get_index
</UL>
<BR>[Called By]<UL><LI><a href="#[64b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_enable
<LI><a href="#[34b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_irq_handler
</UL>

<P><STRONG><a name="[650]"></a>serial_get_rx_irq_index</STRONG> (Thumb, 108 bytes, Stack size 8 bytes, .\build\serial_api.o(i.serial_get_rx_irq_index))
<BR><BR>[Stack]<UL><LI>Max Depth = 536 + Unknown Stack Size
<LI>Call Chain = serial_get_rx_irq_index &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[33a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_assert_internal
</UL>
<BR>[Called By]<UL><LI><a href="#[342]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_irq_set
</UL>

<P><STRONG><a name="[651]"></a>serial_get_tx_irq_index</STRONG> (Thumb, 108 bytes, Stack size 8 bytes, .\build\serial_api.o(i.serial_get_tx_irq_index))
<BR><BR>[Stack]<UL><LI>Max Depth = 536 + Unknown Stack Size
<LI>Call Chain = serial_get_tx_irq_index &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[33a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_assert_internal
</UL>
<BR>[Called By]<UL><LI><a href="#[342]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_irq_set
</UL>

<P><STRONG><a name="[64a]"></a>serial_leuart_baud</STRONG> (Thumb, 178 bytes, Stack size 24 bytes, .\build\serial_api.o(i.serial_leuart_baud))
<BR><BR>[Stack]<UL><LI>Max Depth = 120 + In Cycle
<LI>Call Chain = serial_leuart_baud &rArr;  mbed_assert_internal (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[33a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed_assert_internal
<LI><a href="#[292]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CMU_ClockSelectSet
<LI><a href="#[283]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CMU_ClockDivSet
<LI><a href="#[2b6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LEUART_BaudrateSet
<LI><a href="#[655]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_get_clock
</UL>
<BR>[Called By]<UL><LI><a href="#[328]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_baud
</UL>

<P><STRONG><a name="[64f]"></a>serial_pointer_get_index</STRONG> (Thumb, 106 bytes, Stack size 0 bytes, .\build\serial_api.o(i.serial_pointer_get_index))
<BR><BR>[Called By]<UL><LI><a href="#[533]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;uart_irq
<LI><a href="#[64d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_get_index
</UL>

<P><STRONG><a name="[659]"></a>serial_rx_abort_asynch_intern</STRONG> (Thumb, 186 bytes, Stack size 16 bytes, .\build\serial_api.o(i.serial_rx_abort_asynch_intern))
<BR><BR>[Stack]<UL><LI>Max Depth = 488 + Unknown Stack Size
<LI>Call Chain = serial_rx_abort_asynch_intern &rArr; serial_unblock_sleep &rArr; sleep_manager_unlock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[666]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dma_channel_free
<LI><a href="#[665]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DMA_ChannelEnable
<LI><a href="#[66a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_unblock_sleep
<LI><a href="#[668]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;USART_IntDisable
<LI><a href="#[669]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;USART_IntClear
<LI><a href="#[667]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LEUART_IntDisable
<LI><a href="#[534]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LEUART_IntClear
</UL>
<BR>[Called By]<UL><LI><a href="#[65b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_rx_irq_handler_asynch
<LI><a href="#[33b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_irq_handler_asynch
</UL>

<P><STRONG><a name="[657]"></a>serial_set_route</STRONG> (Thumb, 176 bytes, Stack size 0 bytes, .\build\serial_api.o(i.serial_set_route))
<BR><BR>[Called By]<UL><LI><a href="#[327]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_init
</UL>

<P><STRONG><a name="[65a]"></a>serial_tx_abort_asynch_intern</STRONG> (Thumb, 132 bytes, Stack size 16 bytes, .\build\serial_api.o(i.serial_tx_abort_asynch_intern))
<BR><BR>[Stack]<UL><LI>Max Depth = 488 + Unknown Stack Size
<LI>Call Chain = serial_tx_abort_asynch_intern &rArr; serial_unblock_sleep &rArr; sleep_manager_unlock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[666]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dma_channel_free
<LI><a href="#[665]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DMA_ChannelEnable
<LI><a href="#[66a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_unblock_sleep
<LI><a href="#[668]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;USART_IntDisable
<LI><a href="#[669]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;USART_IntClear
<LI><a href="#[667]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LEUART_IntDisable
<LI><a href="#[534]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LEUART_IntClear
</UL>
<BR>[Called By]<UL><LI><a href="#[65d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_tx_irq_handler_asynch
<LI><a href="#[33b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_irq_handler_asynch
</UL>

<P><STRONG><a name="[66a]"></a>serial_unblock_sleep</STRONG> (Thumb, 48 bytes, Stack size 8 bytes, .\build\serial_api.o(i.serial_unblock_sleep))
<BR><BR>[Stack]<UL><LI>Max Depth = 472 + Unknown Stack Size
<LI>Call Chain = serial_unblock_sleep &rArr; sleep_manager_unlock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[2b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LEUART_BaudrateGet
<LI><a href="#[33e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sleep_manager_unlock_deep_sleep_internal
</UL>
<BR>[Called By]<UL><LI><a href="#[65a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_tx_abort_asynch_intern
<LI><a href="#[659]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_rx_abort_asynch_intern
</UL>

<P><STRONG><a name="[a7]"></a>uart0_rx_irq</STRONG> (Thumb, 12 bytes, Stack size 8 bytes, .\build\serial_api.o(i.uart0_rx_irq))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = uart0_rx_irq &rArr; uart_irq
</UL>
<BR>[Calls]<UL><LI><a href="#[533]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;uart_irq
</UL>
<BR>[Address Reference Count : 1]<UL><LI> serial_api.o(i.serial_preinit)
</UL>
<P><STRONG><a name="[a8]"></a>uart0_tx_irq</STRONG> (Thumb, 20 bytes, Stack size 8 bytes, .\build\serial_api.o(i.uart0_tx_irq))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = uart0_tx_irq &rArr; uart_irq
</UL>
<BR>[Calls]<UL><LI><a href="#[533]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;uart_irq
<LI><a href="#[669]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;USART_IntClear
</UL>
<BR>[Address Reference Count : 1]<UL><LI> serial_api.o(i.serial_preinit)
</UL>
<P><STRONG><a name="[a9]"></a>uart1_rx_irq</STRONG> (Thumb, 12 bytes, Stack size 8 bytes, .\build\serial_api.o(i.uart1_rx_irq))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = uart1_rx_irq &rArr; uart_irq
</UL>
<BR>[Calls]<UL><LI><a href="#[533]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;uart_irq
</UL>
<BR>[Address Reference Count : 1]<UL><LI> serial_api.o(i.serial_preinit)
</UL>
<P><STRONG><a name="[aa]"></a>uart1_tx_irq</STRONG> (Thumb, 20 bytes, Stack size 8 bytes, .\build\serial_api.o(i.uart1_tx_irq))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = uart1_tx_irq &rArr; uart_irq
</UL>
<BR>[Calls]<UL><LI><a href="#[533]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;uart_irq
<LI><a href="#[669]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;USART_IntClear
</UL>
<BR>[Address Reference Count : 1]<UL><LI> serial_api.o(i.serial_preinit)
</UL>
<P><STRONG><a name="[656]"></a>uart_init</STRONG> (Thumb, 276 bytes, Stack size 48 bytes, .\build\serial_api.o(i.uart_init))
<BR><BR>[Stack]<UL><LI>Max Depth = 184<LI>Call Chain = uart_init &rArr; serial_baud &rArr; serial_leuart_baud &rArr;  mbed_assert_internal (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[2b9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LEUART_Init
<LI><a href="#[2dc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;USART_InitAsync
<LI><a href="#[328]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_baud
<LI><a href="#[247]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy4
</UL>
<BR>[Called By]<UL><LI><a href="#[327]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_init
</UL>

<P><STRONG><a name="[533]"></a>uart_irq</STRONG> (Thumb, 38 bytes, Stack size 16 bytes, .\build\serial_api.o(i.uart_irq))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = uart_irq
</UL>
<BR>[Calls]<UL><LI><a href="#[64f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;serial_pointer_get_index
</UL>
<BR>[Called By]<UL><LI><a href="#[b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;usart2_tx_irq
<LI><a href="#[af]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;usart2_rx_irq
<LI><a href="#[ae]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;usart1_tx_irq
<LI><a href="#[ad]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;usart1_rx_irq
<LI><a href="#[ac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;usart0_tx_irq
<LI><a href="#[ab]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;usart0_rx_irq
<LI><a href="#[aa]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;uart1_tx_irq
<LI><a href="#[a9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;uart1_rx_irq
<LI><a href="#[a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;uart0_tx_irq
<LI><a href="#[a7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;uart0_rx_irq
<LI><a href="#[b2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;leuart1_irq
<LI><a href="#[b1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;leuart0_irq
</UL>

<P><STRONG><a name="[ab]"></a>usart0_rx_irq</STRONG> (Thumb, 12 bytes, Stack size 8 bytes, .\build\serial_api.o(i.usart0_rx_irq))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = usart0_rx_irq &rArr; uart_irq
</UL>
<BR>[Calls]<UL><LI><a href="#[533]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;uart_irq
</UL>
<BR>[Address Reference Count : 1]<UL><LI> serial_api.o(i.serial_preinit)
</UL>
<P><STRONG><a name="[ac]"></a>usart0_tx_irq</STRONG> (Thumb, 20 bytes, Stack size 8 bytes, .\build\serial_api.o(i.usart0_tx_irq))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = usart0_tx_irq &rArr; uart_irq
</UL>
<BR>[Calls]<UL><LI><a href="#[533]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;uart_irq
<LI><a href="#[669]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;USART_IntClear
</UL>
<BR>[Address Reference Count : 1]<UL><LI> serial_api.o(i.serial_preinit)
</UL>
<P><STRONG><a name="[ad]"></a>usart1_rx_irq</STRONG> (Thumb, 12 bytes, Stack size 8 bytes, .\build\serial_api.o(i.usart1_rx_irq))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = usart1_rx_irq &rArr; uart_irq
</UL>
<BR>[Calls]<UL><LI><a href="#[533]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;uart_irq
</UL>
<BR>[Address Reference Count : 1]<UL><LI> serial_api.o(i.serial_preinit)
</UL>
<P><STRONG><a name="[ae]"></a>usart1_tx_irq</STRONG> (Thumb, 20 bytes, Stack size 8 bytes, .\build\serial_api.o(i.usart1_tx_irq))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = usart1_tx_irq &rArr; uart_irq
</UL>
<BR>[Calls]<UL><LI><a href="#[533]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;uart_irq
<LI><a href="#[669]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;USART_IntClear
</UL>
<BR>[Address Reference Count : 1]<UL><LI> serial_api.o(i.serial_preinit)
</UL>
<P><STRONG><a name="[af]"></a>usart2_rx_irq</STRONG> (Thumb, 12 bytes, Stack size 8 bytes, .\build\serial_api.o(i.usart2_rx_irq))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = usart2_rx_irq &rArr; uart_irq
</UL>
<BR>[Calls]<UL><LI><a href="#[533]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;uart_irq
</UL>
<BR>[Address Reference Count : 1]<UL><LI> serial_api.o(i.serial_preinit)
</UL>
<P><STRONG><a name="[b0]"></a>usart2_tx_irq</STRONG> (Thumb, 20 bytes, Stack size 8 bytes, .\build\serial_api.o(i.usart2_tx_irq))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = usart2_tx_irq &rArr; uart_irq
</UL>
<BR>[Calls]<UL><LI><a href="#[533]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;uart_irq
<LI><a href="#[669]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;USART_IntClear
</UL>
<BR>[Address Reference Count : 1]<UL><LI> serial_api.o(i.serial_preinit)
</UL>
<P><STRONG><a name="[51]"></a>&lang;Func4&rang;</STRONG> (Thumb, 14 bytes, Stack size 8 bytes, .\build\serialbase.o(i.<Func4>))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = &lang;Func4&rang; &rArr; mbed::Callback&lang;void()&rang;::Callback(void(*)())
</UL>
<BR>[Calls]<UL><LI><a href="#[282]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void()&rang;::Callback(void(*)())
</UL>
<BR>[Address Reference Count : 1]<UL><LI> serialbase.o(i._ZN4mbed10SerialBaseC1E7PinNameS1_i)
</UL>
<P><STRONG><a name="[32b]"></a>ipv4_is_valid(const char*)</STRONG> (Thumb, 56 bytes, Stack size 0 bytes, .\build\socketaddress.o(i._Z13ipv4_is_validPKc))
<BR><BR>[Called By]<UL><LI><a href="#[329]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SocketAddress::set_ip_address(const char*)
</UL>

<P><STRONG><a name="[32c]"></a>ipv6_is_valid(const char*)</STRONG> (Thumb, 82 bytes, Stack size 0 bytes, .\build\socketaddress.o(i._Z13ipv6_is_validPKc))
<BR><BR>[Called By]<UL><LI><a href="#[329]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SocketAddress::set_ip_address(const char*)
</UL>

<P><STRONG><a name="[2ff]"></a>ipv4_to_address(char*, const unsigned char*)</STRONG> (Thumb, 28 bytes, Stack size 24 bytes, .\build\socketaddress.o(i._Z15ipv4_to_addressPcPKh))
<BR><BR>[Stack]<UL><LI>Max Depth = 160 + Unknown Stack Size
<LI>Call Chain = ipv4_to_address(char*, const unsigned char*) &rArr; __2sprintf &rArr; _printf_char_common &rArr; __printf
</UL>
<BR>[Calls]<UL><LI><a href="#[225]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__2sprintf
</UL>
<BR>[Called By]<UL><LI><a href="#[334]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SocketAddress::get_ip_address() const
</UL>

<P><STRONG><a name="[300]"></a>ipv6_scan_chunk(unsigned short*, const char*)</STRONG> (Thumb, 76 bytes, Stack size 32 bytes, .\build\socketaddress.o(i._Z15ipv6_scan_chunkPtPKc))
<BR><BR>[Stack]<UL><LI>Max Depth = 256<LI>Call Chain = ipv6_scan_chunk(unsigned short*, const char*) &rArr; __0sscanf &rArr; __vfscanf_char &rArr; __vfscanf &rArr; _scanf_int
</UL>
<BR>[Calls]<UL><LI><a href="#[231]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__0sscanf
</UL>
<BR>[Called By]<UL><LI><a href="#[314]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ipv6_from_address(unsigned char*, const char*)
</UL>

<P><STRONG><a name="[301]"></a>ipv6_to_address(char*, const unsigned char*)</STRONG> (Thumb, 56 bytes, Stack size 16 bytes, .\build\socketaddress.o(i._Z15ipv6_to_addressPcPKh))
<BR><BR>[Stack]<UL><LI>Max Depth = 152 + Unknown Stack Size
<LI>Call Chain = ipv6_to_address(char*, const unsigned char*) &rArr; __2sprintf &rArr; _printf_char_common &rArr; __printf
</UL>
<BR>[Calls]<UL><LI><a href="#[225]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__2sprintf
</UL>
<BR>[Called By]<UL><LI><a href="#[334]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SocketAddress::get_ip_address() const
</UL>

<P><STRONG><a name="[313]"></a>ipv4_from_address(unsigned char*, const char*)</STRONG> (Thumb, 68 bytes, Stack size 32 bytes, .\build\socketaddress.o(i._Z17ipv4_from_addressPhPKc))
<BR><BR>[Stack]<UL><LI>Max Depth = 256<LI>Call Chain = ipv4_from_address(unsigned char*, const char*) &rArr; __0sscanf &rArr; __vfscanf_char &rArr; __vfscanf &rArr; _scanf_int
</UL>
<BR>[Calls]<UL><LI><a href="#[231]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__0sscanf
</UL>
<BR>[Called By]<UL><LI><a href="#[329]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SocketAddress::set_ip_address(const char*)
</UL>

<P><STRONG><a name="[314]"></a>ipv6_from_address(unsigned char*, const char*)</STRONG> (Thumb, 122 bytes, Stack size 40 bytes, .\build\socketaddress.o(i._Z17ipv6_from_addressPhPKc))
<BR><BR>[Stack]<UL><LI>Max Depth = 296<LI>Call Chain = ipv6_from_address(unsigned char*, const char*) &rArr; ipv6_scan_chunk(unsigned short*, const char*) &rArr; __0sscanf &rArr; __vfscanf_char &rArr; __vfscanf &rArr; _scanf_int
</UL>
<BR>[Calls]<UL><LI><a href="#[300]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ipv6_scan_chunk(unsigned short*, const char*)
<LI><a href="#[23c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memclr4
<LI><a href="#[315]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memmove
</UL>
<BR>[Called By]<UL><LI><a href="#[329]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SocketAddress::set_ip_address(const char*)
</UL>

<P><STRONG><a name="[1d7]"></a>__sti___7_SPI_cpp_ab1f1164</STRONG> (Thumb, 46 bytes, Stack size 16 bytes, .\build\spi.o(i.__sti___7_SPI_cpp_ab1f1164))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = __sti___7_SPI_cpp_ab1f1164 &rArr; __aeabi_vec_ctor_nocookie_nodtor
</UL>
<BR>[Calls]<UL><LI><a href="#[2fa]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_atexit
<LI><a href="#[34a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_vec_ctor_nocookie_nodtor
</UL>
<BR>[Address Reference Count : 1]<UL><LI> spi.o(.init_array)
</UL>
<P><STRONG><a name="[6c9]"></a>TIMER_CompareSet</STRONG> (Thumb, 16 bytes, Stack size 0 bytes, .\build\us_ticker.o(i.TIMER_CompareSet))
<BR><BR>[Called By]<UL><LI><a href="#[119]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;us_ticker_set_interrupt
</UL>

<P><STRONG><a name="[6c4]"></a>TIMER_IntClear</STRONG> (Thumb, 4 bytes, Stack size 0 bytes, .\build\us_ticker.o(i.TIMER_IntClear))
<BR><BR>[Called By]<UL><LI><a href="#[119]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;us_ticker_set_interrupt
<LI><a href="#[118]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;us_ticker_clear_interrupt
<LI><a href="#[bf]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;us_ticker_irq_handler_internal
</UL>

<P><STRONG><a name="[6c5]"></a>TIMER_IntDisable</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, .\build\us_ticker.o(i.TIMER_IntDisable))
<BR><BR>[Called By]<UL><LI><a href="#[119]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;us_ticker_set_interrupt
<LI><a href="#[117]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;us_ticker_disable_interrupt
</UL>

<P><STRONG><a name="[6c6]"></a>TIMER_IntEnable</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, .\build\us_ticker.o(i.TIMER_IntEnable))
<BR><BR>[Called By]<UL><LI><a href="#[119]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;us_ticker_set_interrupt
<LI><a href="#[115]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;us_ticker_init
</UL>

<P><STRONG><a name="[6c7]"></a>TIMER_IntGet</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, .\build\us_ticker.o(i.TIMER_IntGet))
<BR><BR>[Called By]<UL><LI><a href="#[116]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;us_ticker_read
<LI><a href="#[bf]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;us_ticker_irq_handler_internal
</UL>

<P><STRONG><a name="[1d8]"></a>__sti___8_main_cpp_led0</STRONG> (Thumb, 488 bytes, Stack size 32 bytes, .\build\main.o(i.__sti___8_main_cpp_led0))
<BR><BR>[Stack]<UL><LI>Max Depth = 880 + Unknown Stack Size
<LI>Call Chain = __sti___8_main_cpp_led0 &rArr; mbed::Serial::Serial(PinName, PinName, const char*, int) &rArr; mbed::Stream::Stream__sub_object(const char*) &rArr; mbed::fdopen(mbed::FileHandle*, const char*) &rArr; fdopen &rArr; fopen &rArr; _freopen_locked &rArr; _sys_open &rArr; open &rArr; mbed::FilePath::FilePath(const char*) &rArr; mbed::FileBase::lookup(const char*, unsigned) &rArr; SingletonPtr&lang;rtos::Mutex&rang;::operator -&rang;() &rArr; SingletonPtr&lang;rtos::Mutex&rang;::get() &rArr; rtos::Mutex::Mutex() &rArr; rtos::Mutex::constructor(const char*) &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[2fa]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_atexit
<LI><a href="#[282]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Callback&lang;void()&rang;::Callback(void(*)())
<LI><a href="#[335]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::DigitalOut::DigitalOut(PinName)
<LI><a href="#[412]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::DigitalIn::DigitalIn(PinName)
<LI><a href="#[361]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Mutex::Mutex()
<LI><a href="#[3aa]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Semaphore::Semaphore(int)
<LI><a href="#[3ab]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtos::Thread::constructor(osPriority_t, unsigned, unsigned char*, const char*)
<LI><a href="#[3d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::EasyCellularConnection::EasyCellularConnection(bool)
<LI><a href="#[3e2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::Serial::Serial(PinName, PinName, const char*, int)
<LI><a href="#[414]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mbed::DigitalIn::DigitalIn(PinName, PinMode)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> main.o(.init_array)
</UL>
<P><STRONG><a name="[21b]"></a>Heap1_SizeAdjust</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(h1_alloc_mt.o)(.text))
<BR><BR>[Called By]<UL><LI><a href="#[21a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_malloc_internal
</UL>

<P><STRONG><a name="[241]"></a>_freopen_locked</STRONG> (Thumb, 174 bytes, Stack size 32 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(fopen_locked.o)(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 736 + Unknown Stack Size
<LI>Call Chain = _freopen_locked &rArr; _sys_open &rArr; open &rArr; mbed::FilePath::FilePath(const char*) &rArr; mbed::FileBase::lookup(const char*, unsigned) &rArr; SingletonPtr&lang;rtos::Mutex&rang;::operator -&rang;() &rArr; SingletonPtr&lang;rtos::Mutex&rang;::get() &rArr; rtos::Mutex::Mutex() &rArr; rtos::Mutex::constructor(const char*) &rArr; mbed_assert_internal &rArr; mbed_die &rArr; wait_ms &rArr; wait_us &rArr; sleep_manager_lock_deep_sleep_internal &rArr; error &rArr; exit &rArr;  mbed_die (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[242]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_sys_open
<LI><a href="#[1db]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_mutex_release
<LI><a href="#[1da]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_mutex_acquire
<LI><a href="#[23f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_fseek
<LI><a href="#[239]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_fclose_internal
</UL>
<BR>[Called By]<UL><LI><a href="#[244]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fopen
<LI><a href="#[243]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;freopen
</UL>

<P><STRONG><a name="[254]"></a>_fp_digits</STRONG> (Thumb, 432 bytes, Stack size 96 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(_printf_fp_dec.o)(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 220<LI>Call Chain = _fp_digits &rArr; _btod_etento &rArr; _btod_emul &rArr; _e2e
</UL>
<BR>[Calls]<UL><LI><a href="#[258]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_btod_emul
<LI><a href="#[257]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_btod_ediv
<LI><a href="#[256]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_btod_d2e
<LI><a href="#[255]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_btod_etento
<LI><a href="#[259]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_ll_udiv10
</UL>
<BR>[Called By]<UL><LI><a href="#[25a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_fp_dec_real
</UL>

<P><STRONG><a name="[4a]"></a>_printf_input_char</STRONG> (Thumb, 10 bytes, Stack size 0 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(_printf_char_common.o)(.text))
<BR>[Address Reference Count : 1]<UL><LI> _printf_char_common.o(.text)
</UL>
<P><STRONG><a name="[4b]"></a>_scanf_char_input</STRONG> (Thumb, 12 bytes, Stack size 0 bytes, C:\Keil_v5\ARM\ARMCC\Bin\..\lib\armlib\c_w.l(scanf_char.o)(.text))
<BR>[Address Reference Count : 1]<UL><LI> scanf_char.o(.text)
</UL><P>
<H3>
Undefined Global Symbols
</H3><HR></body></html>
